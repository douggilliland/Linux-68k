/	KERMIT FOR DEC 12-BIT MACHINES

/	LAST EDIT:	06-SEP-1990	11:00:00	CJL

	XLIST	OFF
	IFNDEF	OFF	<OFF=	1>	/TURN LISTING OFF
	IFNDEF	ON	<ON=	0>	/TURN LISTING ON
	XLIST	ON;	IFZERO	1	<








***	 **** *********** *********    ***      *** *** *********** *****   ****
***	****  *********** **********   ****    **** *** *********** *****  ******
***   ****    ***	  ***	 ****  ****    **** ***	    ***	      *** ***  ***
***  ****     ***	  ***     ***  *****  ***** ***     ***       *** **   ****
*** ****      ***	  ***     ***  *****  ***** ***     ***       *** **    ***
*******       ***	  ***    ****  ************ ***     ***       ***       **
******	      **********  **********   *** **** *** ***	    *** ***** ***      **
*******	      **********  *********    *** **** *** ***	    *** ***** ***     **
*** ****      ***	  *** ****     ***  **  *** ***     ***       ***    **
***  ****     ***	  ***  ****    ***  **  *** ***     ***       ***   **
***   ****    ***	  ***   ****   ***      *** ***     ***       ***  **
***    ****   *********** ***	 ****  ***	*** ***	    ***       *** *********
***	 **** *********** ***	  **** ***	*** ***	    ***	      *** *********
					>	XLIST	ON



















/	COPYRIGHT (C) 1989, 1990 BY THE TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF
/	NEW YORK.



/	PERMISSION IS  GRANTED  TO  ANY  INDIVIDUAL OR INSTITUTION TO COPY OR USE THIS
/	DOCUMENT AND THE  PROGRAM(S) DESCRIBED IN IT, EXCEPT FOR EXPLICITLY COMMERCIAL
/	PURPOSES.
/	EDIT HISTORY.							/014 CJL

/	052	06-SEP-1990	BUG FIX.			CHARLES LASNER (CJL)

/		SENDING A FILE WHICH  EXACTLY  FILLS  THE LAST DATA PACKET AT THE
/		END OF THE FILE WILL  CAUSE  THE  PACKET  TO  BE SENT TWICE.  THE
/		ROUTINE DIDN'T CHECK FOR AN EMPTY OUTPUT BUFFER AT EOF.

/	051	29-AUG-1990	BUG FIX.			CJL

/		PDP-8/A NOT IDENTIFIED CORRECTLY  IN  CPUID ROUTINE.  THE UPDATED
/		PC IS WHAT IS LOADED  INTO  THE  AC  WHEN 7016 IS EXECUTED ON THE
/		KK-8/A CPU.  THE ROUTINE WAS  CHECKING FOR THE NON-UPDATED VALUE.
/		ALSO  NEW  DOCUMENTATION FOR PRE-CLEARING MEMORY FOR  BENEFIT  OF
/		ENCODED BINARY FILES.
/	050	06-SEP-1989	DECMATE I SUPPORT, ETC.		CJL

/		THIS EDIT IMPLEMENTS DECMATE  I  SUPPORT USING THE DP278-A OR -B.
/		A NEW CONDITIONAL 'PORT' SELECTS  WHICH  PORT  IS TO BE USED.  IF
/		KERMIT-12 IS RUN ON DECMATE I  (WHILE  NOT  CONFIGURED FOR SERIAL
/		PRINTER  PORT  COMMUNICATIONS;    SEE  EDIT  048.)   THEN  REMOTE
/		COMMUNICATIONS TAKES PLACE ON THE PORT SELECTED AT  ASSEMBLY TIME
/		('PORT=0' OR 'PORT=1').    ADDED  BAUD  RATE PARAMETER 'BRATE' TO
/		SELECT REMOTE COMMUNICATIONS BAUD  RATE  FROM THE STANDARD TABLE;
/		DEFAULTS TO 1200 BAUD ('BRATE=7').
 
/	049	30-AUG-1989	REMOTE FLOW CONTROL, ETC.	CJL

/		THIS  EDIT  IMPLEMENTS FLOW CONTROL SUPPORT (IF FLOW  CONTROL  IS
/		ENABLED) FOR THE REMOTE LINE WHILE SENDING PACKETS TO  THE REMOTE
/		KERMIT REGARDLESS  OF  STATE.    PREVIOUSLY,  FLOW  CONTROL  ONLY
/		APPLIED TO CONNECT  MODE.  LOCAL FLOW CONTROL (TOWARDS THE REMOTE
/		KERMIT) IS UNNECESSARY AS  LOCAL  BUFFERS  FOR  REMOTE  INPUT ARE
/		ALWAYS AVAILABLE.  CERTAIN ROUTINE  CHANGES  MADE  FOR BENEFIT OF
/		DECMATE I SUPPORT IN A SUBSEQUENT EDIT.

/	048	24-AUG-1989	DECMATE II, ETC. SUPPORT.	CJL

/		ONCE-ONLY CODE ADDED  TO  IMPLEMENT DECMATE II, ETC.  REMOTE LINE
/		SUPPORT  ON  SERIAL  COMMUNICATIONS   PORT.    SELECTED  PORT  IS
/		INDICATED ON OPENING BANNER IF OPERATING ON DECMATE.

/	THIS EDIT PROVIDES BASIC SUPPORT  OF  THE DECMATE II COMMUNICATIONS PORT AS AN
/	AUTOMATIC FEATURE OF THE STANDARD RELEASE  OF  K12MIT.  AUTOMATIC DETECTION OF
/	DECMATE II, ETC.  HARDWARE IS PERFORMED  UNLESS  THE  PDP-8-TYPE  REMOTE  LINE
/	SUPPORT IS ASSEMBLED FOR THE SERIAL PRINTER AS  THE  REMOTE  LINE ('SPRINT' IS
/	SET OR EQUIVALENT).

/	THIS  EDIT INCORPORATES ALL OF THE  INFORMATION  TAKEN  FROM  VARIOUS  SOURCES
/	REGARDING DECMATE PORT INITIALIZATION, ETC.  EVERY  ATTEMPT  HAS  BEEN MADE TO
/	COMPLETELY  SET ALL APPROPRIATE REGISTERS, ETC.  FOR  DECMATE  II,  III,  III+
/	OPERATION.  NO SUPPORT EXISTS FOR THE DECMATE III  BUILT-IN  MODEM  OPTION, AS
/	EXPLICIT  DOCUMENTATION  IS NOT AVAILABLE (SOME OF THE INITIALIZATION CODE  IS
/	APPARENTLY USED TO DISABLE THE MODEM).  THESE ROUTINES ARE ONLY  KNOWN TO WORK
/	ON  THE DECMATE II, AS THE III (ESPECIALLY WITH OPTIONAL MODEM) AND  THE  III+
/	HAVEN'T BEEN  AVAILABLE  TO  THE  AUTHOR FOR TESTING.  THE INITIALIZATION CODE
/	WILL BE UPDATED  LATER  TO  INCLUDE  PANEL  REQUESTS,  ETC.    TO  CORRECT ANY
/	PROBLEMS, ETC.  DECMATE-SPECIFIC  FEATURES  (SUCH  AS  SETUP COMMANDS) WILL BE
/	ADDED LATER AND ENABLED FROM THESE ROUTINES.

/	THIS EDIT INCORPORATES  NON-INTERRUPT  ROUTINES  WHICH HAVE BEEN TESTED AT THE
/	MAXIMUM COMMUNICATIONS SPEED OF  THE  DECMATE  II  (19200  BAUD).    THEY WILL
/	SUFFICE FOR ALL KERMIT IMPROVEMENTS  SHORT  OF  SLIDING  WINDOWS AT WHICH TIME
/	INTERRUPT-DRIVEN I/O WILL BE REQUIRED.   (INTERRUPT-DRIVEN  I/O  IS ILLEGAL ON
/	CERTAIN OS/8 SYSTEMS WHERE INTERRUPTS ARE HARMFUL  TO THE SYSTEM OR NON-SYSTEM
/	HANDLERS.) 
/	047	21-AUG-1989	CODE CLEANUP.			CJL

/		STREAM-LINED CONNECT MODE ROUTINES FOR MINIMUM USE OF IOTS.  THIS
/		IS  IN  PREPARATION  FOR  EVENTUAL DECMATE II OPERATION,  AND  TO
/		MINIMIZE  K12PCH  PATCH  FILE SIZE.  CERTAIN NON-CONNECT ROUTINES
/		MOVED TO FACILIATE CONNECT ROUTINE REORGANIZATION. 

/	046	15-AUG-1989	CODE CLEANUP.			CJL

/		ADDED NEW (NON-CONNECT) MODE COMMUNICATIONS ROUTINES FOR EVENTUAL
/		DECMATE USE.  ELIMINATION OF 'IREM' AND 'IREMW' ROUTINES IN FAVOR
/		OF 'COMIN'.   ELIMINATION  OF 'OREM' IN FAVOR OF 'COMOUT'.  ADDED
/		STATUS UPDATE ROUTINE ('UPSTATUS')  FOR EVENTUAL DECMATE II, ETC.
/		USAGE.  ELIMINATED PDP-8, DECMATE  I,  DECMATE  II  CONDITIONALS.
/		REORGANIZED  SERIAL  LINE  CONDITIONALS  AND ADDED  NEW  'SPRINT'
/		PARAMETER FOR SERIAL PRINTER  PORT  USAGE AS COMMUNICATIONS PORT.
/		ADDED ONCE-ONLY CODE ADDED TO  AUTOMATICALLY  RECOGNIZE DECMATE I
/		AND II OPERATION UNLESS ASSEMBLED FOR  REMOTE  COMMUNICATIONS  ON
/		SERIAL  PRINTER  PORT  ('SPRINT'  SET).   UPDATED  K12PCH.PAL  TO
/		CORRESPOND   TO  NEW  DEFINITIONS.    DEFINED  EVENTUALLY  NEEDED
/		COMMUNICATIONS PORT  INSTRUCTIONS FOR DECMATE II;  ACTUAL DECMATE
/		II OPERATION WILL  BE  DEFINED  IN A SUBSEQUENT EDIT.  DOCUMENTED
/		NEW LOADING AND SAVING  INSTRUCTIONS  FOR  K12MIT  TO  ALLOW  FOR
/		ONCE-ONLY CODE IN 10000-11777 WITHOUT  SWAPPING  THE CODE OUT FOR
/		THE USR.  THIS ELIMINATES OVERHEAD  WHEN  LOADING  K12MIT, BUT IS
/		DIFFERENT  FROM  THE FORMER INSTRUCTIONS WHICH ASSUMED  NO  OTHER
/		USAGE OF 10000-11777 OTHER THAN THE (LOCKED-IN) USR.

/	THIS EDIT  PROVIDES THE FRAMEWORK FOR AUTOMATIC DETECTION OF PROGRAM EXECUTION
/	OF K12MIT ON  ANY  MEMBER  OF  THE  DECMATE  FAMILY  (I, II, III, III+).  WHEN
/	6120-TYPE CPU DETECTION OCCURS,  THE  DECMATE I OR II-TYPE COMMUNICATIONS PORT
/	INITIALIZE CODE IS AUTOMATICALLY SELECTED  AS  NECESSARY UNLESS THE PDP-8-TYPE
/	ROUTINES ARE ASSEMBLED (WITH 'SPRINT' SET  OR  EQUIVALENT USER SETTINGS, ETC.)
/	FOR THE VT-78-TYPE PRINTER PORT (32/33), IN  WHICH  CASE THE COMMUNICATIONS IS
/	DONE VIA THE PRINTER PORT ON THE DECMATE (WHICH IS ALMOST PDP-8 COMPATIBLE AND
/	IS ACCOMODATED AS SUCH).

/	SUBSEQUENT EDITS SHOULD PROVIDE FOR A DECMATE I PARAMETER TO CONTROL  THE PORT
/	SELECTION,  AS  THERE  ARE  AT  LEAST  TWO VARIANT OPTIONS BOARDS (DP-278A AND
/	DP-278B) EACH CONSISTING OF TWO PORTS.
/	045	12-AUG-1989	BUG FIX.  			CJL

/		FINISH,  GET,  AND  RECEIVE  COMMANDS   FAIL  TO  ABORT  PROPERLY
/		(ESPECIALLY AFTER THE SEND COMMAND HAS BEEN USED), AS THE CURRENT
/		OPERATING MODE ('KMODE') IS NEVER PROPERLY SET,  OR  IS SET AFTER
/		SEVERAL PACKETS HAVE BEEN SENT.  EACH COMMAND  NOW  SETS  ITS OWN
/		OPERATING MODE BEFORE INITIATING ANY PACKETS.

/	044	11-AUG-1989	CODE CLEANUP.			CJL

/		CHANGED  'CCMSG'  TO  'ABMSG'  WITH  CLEARER  MESSAGE.    CHANGED
/		'CCFLAG'  TO  'ABFLAG' FOR CONSISTENCY.  CHANGED ABORT  CHARACTER
/		FROM <^C> TO CHOICE OF <^X> OR <^Z> FOR  CONSISTENCY.  ELIMINATED
/		'ITTY'  AND  'ITTYW'  ROUTINES  BY  USING  'CTLCTST'  AND 'INPUT'
/		ROUTINES ALREADY  AVAILABLE  A/O EDIT 043.  ELIMINATED 'TCHAR' IN
/		FAVOR OF 'INCHAR' AVAILABLE A/O EDIT 043.

/	043	07-AUG-1989	CODE CLEANUP, ETC.		CJL

/		REWRITE OF  CONSOLE SUPPORT ROUTINES INCLUDING FORCED-ECHO OUTPUT
/		AND COLUMN COUNT FOR <HT> SIMULATION IN PREPARATION FOR IMPENDING
/		USER-INTERFACE  REWRITE.     'SCRIBE',  'LININP',  AND  'ESCPRNT'
/		ROUTINES NOW CALL  "P7ECHO" ROUTINE TO ENSURE PRINTING OF CRUCIAL
/		MESSAGES.

/	042	13-JUN-1989	CODE CLEANUP.			CJL

/		FIXED VARIOUS NAK-RELATED BUGS AND SEND-INIT PROBLEMS AS IN  K278
/		(SOME  OF  THE K278 STUFF IS DEFICIENT!).  CALCULATION OF  PROPER
/		SEQUENCE  NUMBER  FOR NAK CORRECTED OVER FORMER (K08MIT AND K278)
/		VERSIONS.  ADDED ERROR MESSAGE FOR FULL-DISK PROBLEM.

/	041	12-MAY-1989	BUG FIX.			CJL

/		VARIOUS  VERSIONS  (DECMATE)  WON'T  FUNCTION REMOTELY WHILE KL-8
/		VERSIONS WORK  FINE.    ADDED  REMOTE LINE READ IOT TO INITIALIZE
/		REMOTE  LINE  AT   STARTUP  TIME  FOR  VERSIONS  REQUIRING  THIS.
/		CORRESPONDING CHANGES IN PATCH FILE MADE FOR REMOTE LINE READ IOT
/		IN TWO PLACES.
/	040	07-MAR-1989	COSMETIC CLEANUP.		CJL

/		CLEANUP OF EDIT HISTORY AND OTHER COMMENTS.

/	039	21-MAY-1988	CODE CLEANUP.			CJL

/		ADDED VARIABLE 'INIECHO' TO  ALLOW  DEFAULT CONNECT-MODE STATE TO
/		BE HALF-DUPLEX ("SET LOCAL-ECHO ON").    MODIFIED  INPUT  SERVICE
/		ERROR ADDRESSES TO SIMPLIFY ERROR TABLES.

/	038	19-MAY-1988	CODE CLEANUP.			CJL

/		ELIMINATED  TRAILER FILES DURING ASSEMBLY BY  CREATING  VARIABLES
/		'GENMSG' AND 'UMSG.' THIS ALLOWS THE HEADER  FILE  (PARAM.PA)  TO
/		CONTAIN THE LOCAL MESSAGE TEXT WITHOUT SUBSEQUENT OVERLAY  (WHICH
/		WAS WHY THERE FORMERLY WAS A TRAILER FILE CAPABILITY).    OVERLAY
/		BY  K12PCH.BN  WILL  DEFAULT TO CREATION OF A DUMMY USER  MESSAGE
/		(WITHIN K12PCH) ENCOURAGING LOCAL  CUSTOMIZATION.  K12MIT.BN WILL
/		CONTAIN A NULL MESSAGE BY DEFAULT UNLESS CUSTOMIZED IN PARAM.PA.

/	037	21-JAN-1988	BUG FIX.			CJL

/		RESET OS/8 DEVICE CONTROL WORD  TABLE TO DELETE TENTATIVE FILE IN
/		CASE OF PRIOR INPUT SERVICE ERROR.

/	036	20-JAN-1988	BUG FIX.			CJL

/		RESET 'OFFLG' WHEN DOING INPUT SERVICE IN CASE PRIOR ERRORS LEAVE
/		THE FLAG SET.

/	035	14-JAN-1988	USR RESIDENT CODING.		CJL

/		CALLS TO USR NOW USE 10200 INSTEAD  OF  17700.   NO SWAP OVERHEAD
/		WHEN OPENING OR CLOSING FILES.

/	034	13-JAN-1988	CODE CLEANUP.			CJL

/		ALL  EIGHT-BIT  ORIENTED  CONSOLE  CODE ELIMINATED;  NOW  IGNORES
/		PARITY (JUST SEVEN BITS).

/	033	12-JAN-1988	CODE CLEANUP.			CJL

/		'TTYOUT' AND 'OTTY' ROUTINES ELIMINATED;  NOW USES 'P7CH' FOR ALL
/		CONSOLE OUTPUT (EXCEPT FOR CONNECT MODE).

/	032	12-JAN-1988	CODE CLEANUP.			CJL

/		VARIOUS  ROUTINES REWRITTEN TO ELIMINATE DEPENDENCIES ON CPU TYPE
/		BEYOND THE CLASSIC PDP-8.
/	031	11-JAN-1988	CODE CLEANUP.			CJL

/		ELIMINATED 'RTDISP'  AND  CHANGED CALLING CONVENTION FOR DISPATCH
/		ROUTINE.  ALL  CALLERS  NOW  LOCAL  OR VIA LOCAL POINTERS.  ADDED
/		SEVERAL  CONDITIONAL  PARAMETERS  AND    LABELS  FOR  BENEFIT  OF
/		K12PCH.PAL.

/	030	05-JAN-1988	CODE CLEANUP.			CJL

/		CHANGED LOWER/UPPER CASE CONDITIONAL ASSEMBLY PARAMETERS AND MORE
/		EFFICIENT CODE.

/	029	21-DEC-1987	CODE CLEANUP.			CJL

/		CHANGED CALLING CONVENTIONS FOR 'SCRIBE' AND SIMILAR ROUTINES AND
/		REWROTE 'COMMAND' ROUTINE.

/	028	15-DEC-1987	CODE CLEANUP.			CJL

/		COMPLETE REWRITE OF FILE LOOKUP ROUTINE.   'LUKUP' NOW USES FIELD
/		ONE  BUFFER  AND  ITS OWN AUTO-INDEX REGISTER CONSERVING  PROGRAM
/		SPACE.

/	027	05-DEC-1987	CODE CLEANUP.			CJL

/		CHANGED  DISPATCH  ('DISPA0') ROUTINE TO USE 'SRCHTABLE' ROUTINE.
/		ALL CALLS  MADE COMPATIBLE.  ELIMINATED 'SCANC' CODE.  ELIMINATED
/		CODE WITHIN 'DPARS'  ROUTINE.    'LUKUP' ROUTINE NOW DOES ITS OWN
/		DISK I/O.  ELIMINATED 'BLKIN' ROUTINE.

/	026	27-NOV-1987	NEW CONNECT MODE CODE.		CJL

/		TOTAL  REWRITE  OF ALL CONNECT MODE CONSOLE AND REMOTE INPUT  AND
/		OUTPUT  TERMINAL  ROUTINES.  CONNECT IS NOW FULLY BUFFERED IN ALL
/		DIRECTIONS.   IF  FLOW  CONTROL  IS  OBEYED, ANY BAUD RATE CAN BE
/		ACCOMODATED BOTH LOCALLY  AND  REMOTE  (UP  TO  9600 BAUD TESTED,
/		SHOULD WORK TO AT  LEAST  19200 BAUD BY INSPECTION).  TESTED WITH
/		FAST VT-100 EMULATOR CONSOLE TO  PROVE  ESCAPE  SEQUENCES ARE NOT
/		DROPPED WHEN LOCAL TERMINAL IS FASTER  THAN REMOTE LINE.  LIMITED
/		USE OF SUBROUTINES TO IMPROVE HIGH BAUD  RATE  OPERATION.   ADDED
/		TABLE-DRIVEN ERROR EXIT ROUTINE FOR SEND ROUTINES.

/	THIS EDIT PROVIDES  FULLY  BUFFERED  INPUT/OUTPUT  ROUTINES FOR BOTH LOCAL AND
/	REMOTE PORTS.  NO  INTERRUPTS  ARE  USED  FOR  MAXIMUM COMPATIBILITY WITH OS/8
/	DEVICES (SOME OF WHICH ARE  INTOLERANT OF INTERRUPTS, SUCH AS TD-8/E).  REMOTE
/	FLOW CONTROL (IF ENABLED) WILL SIGNAL BUFFER FILLING VIA <DC3> WHEN THE BUFFER
/	IS 3/4 FULL.  WHEN THE BUFFER  REACHES 1/4 FULL, THE REMOTE WILL BE SENT <DC1>
/	TO ALLOW FURTHER OUTPUT.  REMOTE FLOW CONTROL IS SUPPORTED IN BOTH DIRECTIONS;
/	LOCAL FLOW CONTROL IS FROM THE KEYBOARD ONLY.

/	WHILE THE CONSOLE OUTPUT IS PAUSED BY <DC3>, THE  BUFFER WILL FILL WITH OUTPUT
/	CHARACTERS.  WHEN THE USER RELEASES THE CONSOLE WITH <DC1>,  THE  BUFFER  WILL
/	RAPIDLY  EMPTY  (ASSUMING THE CONSOLE IS FASTER THAN THE REMOTE LINE).    THIS
/	ALLOWS THE USER TO PAUSE THE CONSOLE WITHOUT BACKING UP THE REMOTE  LINE UP TO
/	THE LIMITS OF BOTH LOCAL OUTPUT AND REMOTE INPUT BUFFERS.
/	025	24-NOV-1987	NEW FEATURES AND CODE CLEANUP.	CJL

/		PROPER  INTERRUPT  SETUP  FOR  <^C> AND <^P>, ECHO  STATE.    ALL
/		MESSAGES  IN  NEW  FORMAT,  (SOME NEW ONES HAVE BETTER  CONTENT).
/		ELIMINATED  'PRI6B' AND 'REM6B' ROUTINES.  NEW AND IMPROVED INPUT
/		SERVICE ERROR  CODE  MOVED  TO  PROPER  PAGE.    REWROTE  CONNECT
/		ROUTINES TO ALLOW  NON-INTERRUPT BUFFERED I/O LATER.  CREATED NEW
/		VARIABLE 'ESCHAR' AND PARAMETER  'ESCAPE'  TO  SET DEFAULT ESCAPE
/		CHARACTER.  ESCAPE CHARACTER CAN BE CHANGED IN MEMORY AND WILL BE
/		USED  CORRECTLY  BY ALL ROUTINES.   ADDED  'ESCPRNT'  ROUTINE  TO
/		HANDLE  ALL  CASES  (INCLUDING NON-CONTROL CHARACTERS).   DEFAULT
/		ESCAPE  PARAMETER  VALUE  COMPATIBLE  WITH K08V2, BUT IS  A  USER
/		PARAMETER,  CONFIGURED  AS  OTHER PARAMETERS DEFINED IN EDIT 017.
/		CREATED  ESCAPE FUNCTION TABLE FOR EXPANSION LATER.  NOW SUPPORTS
/		ESCAPE C(LOSE)  IN  UPPER  OR LOWER CASE, ESCAPE ESCAPE (SEND ONE
/		ESCAPE CHARACTER).   ALL  BAD  ESCAPE  COMMANDS  WILL ISSUE <BEL>
/		CHARACTER TO WARN USER  THAT COMMAND IS ILLEGAL AND OTHERWISE WAS
/		IGNORED.  CREATED NEW VARIABLE  'ECHOFLAG' TO ALLOW LOCAL ECHO IN
/		CONNECT MODE.

/	024	19-NOV-1987	NEW FEATURES.			CJL

/		NEW  STARTUP MESSAGES AND HELP METHOD  VIA  COMMAND.    CPU  TYPE
/		IDENTIFICATION TO ALLOW FUTURE VERSIONS TO CHECK  FOR  QUIRKS AND
/		MODEL DEPENDENCIES.  THE DEFAULT PROMPT REFLECTS THE  ACTUAL  CPU
/		TYPE (THUS "KERMIT-12>" ON PDP-12).  VERSION, REVISION, AND  DATE
/		NOW EQUATED SYMBOLS.

/	023	18-NOV-1987	NEW CONSOLE I/O PACKAGE.	CJL

/		NEW  CONSOLE  I/O  ROUTINES  WITH  DC1/DC3  SUPPORT  FOR  CONSOLE
/		TERMINAL MESSAGES NOT ASSOCIATED WITH ANY REMOTE ACTIVITY (NOT TO
/		BE USED DURING CONNECT MODE).  USES FIELD ONE FOR MESSAGE TEXT TO
/		ALLOW FOR MORE PROGRAM  SPACE.    THE  MESSAGES  ARE NOW GIVEN IN
/		UPPER/LOWER SIXBIT FORMAT.  SUPPORT  FOR <^P> RESTART AND <^O> TO
/		FLIP  ECHO.  UPPER-CASE CAN BE  FORCED  BY  CHANGING  A  VARIABLE
/		('UPONLY').

/	022	17-NOV-1987	BUG FIX.			CJL

/		EXTRA-LONG INIT PACKETS CORRUPTING PROGRAM;  NOW  CHECKS  FOR AND
/		IGNORES EXTRA CAPABILITIES BEYOND 'CAPAS' BYTE.
/	021	17-NOV-1987	CODE CLEANUP.			CJL

/		REWROTE  TENTATIVE OUTPUT FILE LENGTH CODE FOR MORE  CONSISTENCY.
/		RENAMED "FINISH" COMMAND CORRECTLY (FORMERLY "BYE").

/	FORMER  CODE  REGARDING  THE  TENTATIVE  FILE  MAXIMUM  LENGTH WAS  ACCEPTABLY
/	ORGANIZED  FOR  ORIGINAL  PS/8, OS/8 CONVENTIONS.  WITH THE EVOLUTION  OF  THE
/	OPERATING  SYSTEM  INTO  OS/78  (VERSIONS  1-4) AND OS/278 (VERSIONS 1-2), THE
/	ENTER OPERATION HAS BEEN CHANGED WITH DANGEROUS CONSEQUENCES.

/	THE  ORIGINAL DEFINITION OF THE LENGTH RETURNED BY ENTER IS THE ACTUAL  LENGTH
/	OF  THE LARGEST EMPTY (IN TWO'S COMPLEMENT FORM).  IF RECORD 7777 IS  PART  OF
/	THE  ACTUAL  LARGEST  EMPTY (FULL SIZE DEVICE AND THE LARGEST EMPTY IS LAST ON
/	THE  DEVICE),  THEN  THE  LENGTH RETURNED IS ONE LESS (THIS IS A LONG STANDING
/	BUG).  SINCE THERE IS NO STRAIGHT-FORWARD WAY TO DETERMINE THIS, THE LENGTH IS
/	ASSUMED TO BE CORRECT.

/	TESTS WITH THE  DECUS  VERSION  OF  OS/278 (DM-101) REVEAL A DANGEROUS CHANGE:
/	THE LENGTH RETURNED IS TWO LARGER THAN ACTUALLY EXISTS!

/	TO COUNTERACT THIS, EDIT  010  INSERTED  A  DECREMENT  OF  TWO INTO THE LENGTH
/	BEFORE PASSING IT BACK TO  THE  KERMIT FILE WRITING ROUTINE.  THE FILE WRITING
/	ROUTINE THEN ADDS ONE TO THE LENGTH TO CREATE A "DANGER COUNT", I.E., IN TWO'S
/	COMPLEMENT  NOTATION,  THIS IS THE AMOUNT THAT  WILL  INDICATE  FILE  OVERFLOW
/	SHOULD IT REACH ZERO.

/	THIS HAS NOW BEEN REORGANIZED TO ALLOW THE  ENTER  ROUTINE  TO  SET THE DANGER
/	COUNT  DIRECTLY.  OS/8 USERS MUST ALLOW FOR THE  EXTRA  ROOM  (WHICH  MUST  BE
/	PRESENT  BUT  WILL NOT BE USED), SINCE NO CHECK FOR  SYSTEM  VERSION  WILL  BE
/	PERFORMED.

/	020	16-NOV-1987	NEW ROUTINES AND CODE CLEANUP.	CJL

/		REWROTE  ENTIRE  OUTPUT  FILE    PACK   ROUTINE.    NOW  SUPPORTS
/		ASCII/BINARY  INTERNAL FILE MODE FOR  LATER  USE.    USES  OUTPUT
/		BUFFER IN FIELD ONE (SAME DEFINITIONS  AS  INPUT BUFFER) TO ALLOW
/		MORE PROGRAM SPACE.  END OF FILE  CONVENTION  IN  ASCII  MODE NOW
/		INCLUDES  ENSURING  <^Z>  CHARACTER  PACKED  INTO FILE (OR  NOT).
/		REWROTE  ENTIRE  OUTPUT  FILE  CLOSE  ROUTINE  TO  IMPLEMENT <^Z>
/		SCHEME.  ELIMINATED SEPARATE OUTPUT FILE INITIALIZE ROUTINE;  USE
/		SPECIAL ROUTINE CALL INSTEAD.  FIXED PACKET WRITE BUG.

/	019	15-NOV-1987	NEW ROUTINES AND CODE CLEANUP.	CJL

/		FIXED UNPACK <^Z> BUG.  REWROTE ENTIRE INPUT FILE UNPACK ROUTINE.
/		NOW SUPPORTS ASCII/BINARY INTERNAL FILE MODE FOR LATER USE.  USES
/		INPUT BUFFER IN FIELD ONE TO ALLOW  MORE  PROGRAM  SPACE.  BUFFER
/		FIELD DEFINED VIA SYMBOLS TO ALLOW CHANGES IN THE FUTURE.  END OF
/		FILE CONVENTION IN ASCII MODE NOW INCLUDES SENDING <^Z> CHARACTER
/		OR  NOT.  ELIMINATED SEPARATE INPUT FILE INITIALIZE ROUTINE;  USE
/		SPECIAL ROUTINE CALL INSTEAD.

/	018	09-NOV-1987	BUG FIX AND CODE CLEANUP.	CJL

/		FIXED RECEIVE BUG; NOW ALLOW DEV: ON RECEIVE.
/	017	05-NOV-1987	NEW FEATURES.			CJL

/		CONDITIONAL ASSEMBLY  PARAMETERS  ADDED  FOR MACHINE TYPE (PDP-8,
/		DECMATE I, DECMATE  II/III/III+),  REMOTE LINE AND LOCAL TERMINAL
/		INTERFACE DEFINITIONS.

/	016	05-NOV-1987	CODE CLEANUP.			CJL

/		OPTIMIZATION OF CODE, LITERALS, CONSTANTS.

/	015	04-NOV-1987	BUG FIX.			CJL

/		INPUT SERVICE ROUTINE ERROR  DOES JMP INSTEAD OF JMS WHEN CALLING
/		COMMON ERROR HANDLER.

/	014	02-NOV-1987	SOURCE FILE CLEANUP.		CJL

/		SOURCE FILE COSMETICALLY CLEANED UP  AND  RENAMED  TO  K12MIT.PAL
/		WHICH CONFORMS WITH CUCCA NAMING CONVENTION.    NO  ACTUAL BINARY
/		CODE CHANGES BEYOND K08V2.  THIS EDIT  HISTORY  ADDED.    ENTRIES
/		PRIOR TO 014 TRANSCRIBED BY CJL.

/	SINCE THE PDP-12 (AND OTHER 12-BIT DEC MACHINES)  IS  THE INTENDED ENVIRONMENT
/	FOR THIS PROGRAM, IT IS NOW KNOWN AS KERMIT-12.

/	ASSEMBLING  THE  SOURCE FILE PRODUCES BINARY IDENTICAL TO K08V2.PA  CONFIRMING
/	THAT SOURCE CLEANUP DOESN'T DAMAGE THE CODING (K08V2 IS NOW OBSOLETE).

/	013	01-OCT-1987	CHANGE TO VERSION 2.0.		R. SCHLERF (RICH)

/		CHANGED  'RKIOT'/'RTIOT'    TO   43/44  REMOTE  LINE  IOT  (LOCAL
/		PREFERENCE).  CHANGED  'ESCAPE'  CHARACTER  TO  ^]  ('CONX1') FOR
/		GENERIC CONFORMITY.  ADDED  VERSION/COMMAND BANNER AT STARTUP FOR
/		MINI-HELP.    INCORPORATED  K278  CHANGES  003-006,  009-010  (NO
/		INTERRUPTS).  DELETED 'ERRMSG.' NOW USES  'STXERR'  AT 'CLOOP9'+2
/		FOR PROGRAM SPACE.  TO CONFORM TO  GENERIC KERMIT, "BACK ON PDP8"
/		MESSAGE  DELETED AND REPLACED WITH BEEP <^G>.   MESSAGE  "SENDING
/		FILE  XXXXXX.XX  CREATED  ON  DD-MM-YY"  REDUCED TO "SENDING FILE
/		XXXXXX.XX"  TO CONFORM TO GENERIC KERMIT.  PARITY BIT IS  IGNORED
/		ON BOTH REMOTE AND TTY LINES.  OUTPUT PARITY IS SET TO SPACE.

/	PROGRAM RENAMED TO K08V2.PA AND MADE AVAILABLE TO CUCCA BY:

/	RICHARD SCHLERF (RICH)
/	AMERICAN CYANAMID COMPANY
/	MEDICAL RESEARCH DIVISION
/	LEDERLE LABORATORIES
/	BUILDING 190 ROOM 115H
/	PEARL RIVER, NEW YORK  10965
/	(914) 732-2186 (09:00 TO 16:00)

/	SINCE  PRIMARY APPLICATION OF K08V2 IS FOR PDP-8 USAGE, THE MODIFICATIONS  NOT
/	SPECIFIC TO DECMATE II/III FROM K278 WERE MOVED TO THE K08MIT VERSION.  FUTURE
/	VERSIONS WILL  INCORPORATE  THE  DECMATE  FEATURES AND THUS OBSOLETE ALL OTHER
/	VERSIONS AT THAT TIME.
/	012	04-JUN-1986	PROGRAM FIX.			SEPP STADELMANN (SSTA)

/		RE-INITIALIZE VIA 'V30ST' AS ROM SETUP CLEARS COMPOSETABLE, ETC.

/	04-JUN-1986 VERSION RELEASED  TO  CUCCA  BY  MARTYN HEMMINGS (DEC GERMANY) AND
/	SEPP STADELMANN (DEC SWITZERLAND) OF:

/	DIGITAL EQUIPMENT CORPORATION (DEC)
/	146 MAIN STREET
/	MAYNARD, MASS  01754
/	(617) 897-5111

/	CUCCA RENAMED FILES (KERMIT.PA AND KERCOM.PA) TO K278.PA AND K278COM.PA (WHICH
/	DOESN'T REALLY CONFORM TO THE NAMING CONVENTION).

/	CUCCA VERSION OF K278.PA FOUND TO BE DEFECTIVE.  FILE REPAIRED BY:

/	CHARLES LASNER (CJL)
/	CLA SYSTEMS
/	72-55 METROPOLITAN AVENUE
/	MIDDLE VILLAGE, NEW YORK  11379-2107
/	(718) 894-6499

/	REPAIRED FILE (K278.PA) NOW AVAILABLE AT CUCCA.

/	PROGRAM IS NOW  THE DECMATE II/III (III-PLUS) KERMIT ONLY.  HOOKS WERE LEFT IN
/	FOR PDP-8 VERSION, BUT  NOT  IMPLEMENTED.    K278  DOES  WORK  WITH ADDITIONAL
/	IMPLEMENTATIONS OF KERMIT, BUT RECEIVE  COMMAND DOES NOT WORK.  PROGRAM YIELDS
/	RECOVERABLE SYSTEM ERROR/HALT WHEN EXITING TO  FLOPPY-BASED DECMATE II SYSTEM.
/	CONNECT MODE IS VT200 8-BIT WHICH CONFUSES EVEN/ODD PARITY SYSTEMS.  K278 DOES
/	NOT SUPPORT SETUP KEY OF DECMATE, BUT IMPLEMENTS SETUP COMMAND.

/	011	04-JUN-1986	NEW FEATURES.			SSTA

/		'PRQ3' CODE CONDITIONALS.  ROM SETUP COMMAND IMPLEMENTED FOR DMII/III.
/		AUTOMATIC UPPERCASE SELECT ON RETURN FROM CONNECT.

/	010	13-MAR-1986	BUG FIX.			MARTYN HEMMINGS (MART)

/		FULL DISK HANDLED WELL.

/	009	13-MAR-1986	BUG FIX.			MART

/		CLEAN UP BREAK AND GET.
/	008	12-MAR-1986	BUG FIX.			MART

/		CLEAR  INPUT  CHARACTERS  FROM  COMMUNICATIONS PORT WHEN IN  IDLE
/		LOOP.

/	007	11-MAR-1986	NEW FEATURES AND BUG FIX.	MARTYN HEMMINGS AND
/								SSEP STADELMANN
/								(MART+SSTA)

/		INTERRUPT DRIVEN AND BUG FIX.

/	006	10-MAR-1986	NEW FEATURE.			MART+SSTA

/		DEVICE PARSE ON GET.

/	005	10-MAR-1986	BUG FIX.			MART+SSTA

/		NO DATE IN FILE WITH <^Z> INTACT.

/	004	10-MAR-1986	NEW FEATURES AND BUG FIX.	MART+SSTA

/		MAXIMUM  RECEIVE  BUFFER  FIXUP  ('RTERMI'),  15  SECOND TIME-OUT
/		DURING CONNECT.

/	003	10-MAR-1986	BUG FIX.			SSTA

/		TWO PAGE HANDLER FIX.

/	K08MIT.PAL  COPIED  TO  DEC  ENGINEERING NETWORK (NODE LSMVAX::) ULTIMATELY TO
/	EUROPE (NODE VIRGIN::) WHERE PROGRAM BECAME KERMIT.PAL AND KERCOM.PAL.

/	KERMIT.PAL  AND KERCOM.PAL ARE TWO SOURCE FILES ASSEMBLED TOGETHER TO  PRODUCE
/	THE RUNNING KERMIT-8.  *THEY ARE FOR THE DECMATE II/III/III-PLUS ONLY.*

/	002	18-JUL-1985	ORIGINAL RELEASE.		RANDY HIPPE

/	18-JUL-1985 VERSION RELEASED TO CUCCA BY JERRY SANDS AND RANDY HIPPE OF:

/	BUREAU OF ENGRAVING, INC.
/	3311 BROADWAY N.E.
/	MINNEAPOLIS, MN  55413
/	(612) 623-0900 X218

/	CUCCA  RENAMED  FILE  (KER8.PAL)  TO  K08MIT.PAL  WHICH  CONFORMS  TO   NAMING
/	CONVENTION OF KERMIT FILES.

/	K08MIT SUPPORTS CONNECT, BYE (REALLY FIN), EXIT, SEND, GET, RECEIVE ONLY.

/	PROGRAM PRONE  TO  GETTING  "CONFUSED" AND OUTPUTS FILE DATE ATTRIBUTE BOTH AS
/	'CAPAS' BYTE FEATURE  AND  ASCII  TEXT INSERTED INTO CONTENTS OF FILE AHEAD OF
/	FILE DATA.  COMMAND PROCESSOR ACCEPTS UPPER-CASE COMPLETE COMMANDS ONLY.  <^C>
/	ABORT FEATURE TAKES VERY LONG TIME TO ACT (IF AT ALL!).  MANY KERMITS WILL NOT
/	WORK WITH K08MIT;  HOWEVER, K08MIT WAS TESTED SUCCESSFULLY WITH KERMIT-20.

/	001	30-JUL-1984	FIRST VERSION (KER8.PAL).	JERRY SANDS
/	HARDWARE HINTS AND KINKS.


/	KERMIT-12 REQUIRES THE FOLLOWING STANDARD OS/8 FAMILY CONFIGURATION:

/	PDP-8 FAMILY MEMBER WITH AT LEAST 8K MEMORY.

/	OS/8 SYSTEM DEVICE (WITH OS/8 FAMILY OPERATING SYSTEM RESIDENT).

/	KL8-COMPATIBLE CONSOLE INTERFACE.

/	7/8-BIT ASCII EXTERNAL CONSOLE TERMINAL DEVICE (TTY:).

/	KL8-COMPATIBLE REMOTE INTERFACE TO OTHER KERMIT.

/	NOTE:  ASSEMBLY  PARAMETERS  OF  KERMIT-12  ALLOW FOR LOCAL KERMIT CONTROLLING
/	TERMINALS TO BE OTHER  THAN  THE  PRIMARY  OS/8  CONSOLE  DEVICE.   THE ACTUAL
/	HARDWARE MUST STILL CONFORM TO  THE  SAME REQUIREMENTS (THE DEVICE CODES WOULD
/	THEN BE USER-SPECIFIED AND DIFFER FROM  THE  STANDARD  03/04)  AS THE STANDARD
/	CONSOLE INTERFACE AND TERMINAL.

/	SPECIAL DECMATE CONSIDERATIONS:

/	DECMATE  USAGE IS USUALLY OBTAINED BY  ASSEMBLING  FOR  THE  STANDARD  CONSOLE
/	DEVICE  (03/04),  AS  THE  BUILT-IN  FIRMWARE/SLUSHWARE  OF  THE  DECMATES  IS
/	SUFFICIENTLY COMPATIBLE WITH THE PDP-8 HARDWARE FOR KERMIT-12'S  REQUIREMENTS.
/	(THE ONLY OTHER ACCEPTABLE CONSOLE DEVICE ON THE DECMATE IS THE PRINTER PORT.)

/	DECMATE  REMOTE  COMMUNICATIONS  PORTS  ARE    *RADICALLY*    DIFFERENT   FROM
/	KL8-COMPATIBLE PORTS.  THESE ARE HANDLED AUTOMATICALLY BY ONCE-ONLY CODE WHICH
/	DETECTS  THE  USAGE  OF  KERMIT-12  ON  THE    SPECIFIC  DECMATE  SYSTEM,  AND
/	SELF-CONFIGURATION AS APPROPRIATE.  THERE IS ONE EXCEPTION  TO THIS, NAMELY IF
/	THE COMMUNICATIONS PORT CODE IS ASSEMBLED FOR THE PRINTER  PORT  (32/33), THEN
/	THE PRINTER PORT, *NOT* THE COMMUNICATIONS PORT WILL BE USED.    THE  STANDARD
/	ASSEMBLY  OF  KERMIT-12 IS FOR A PDP-8 WITH DEVICE 40/41 COMMUNICATIONS  PORT.
/	THIS DESIGNATED VERSION WILL SELF-CONFIGURE WHEN EXECUTED ON A DECMATE.
/	CONFIGURATION RESTRICTIONS:

/	WHEN  INTERRUPTS  ARE SUPPORTED AGAIN, DEVICES SUCH AS THE TD-8/E WON'T  WORK.
/	THE  NON-INTERRUPT  VERSION  SHOULD WORK TO 19200 BAUD ON THE PDP-8/E CPU,  SO
/	THIS  SHOULD NOT BE A PROBLEM.  INTERRUPT-DRIVEN VERSIONS OF KERMIT-12 MUST BE
/	RUN ONLY  ON  SYSTEMS  WHERE  *ALL*  INTENDED  DEVICES CAN HAVE THEIR HANDLERS
/	INTERRUPTED BY THE CONSOLE AND REMOTE LINE INTERRUPT HANDLERS.  WHEN IN DOUBT,
/	THE NON-INTERRUPT VERSION MUST BE USED (CURRENTLY THE ONLY VERSION).

/	IF FLOW CONTROL IS  DISABLED  (DUE  TO  XON/XOFF  BEING  UNAVAILABLE) THEN THE
/	CONSOLE BAUD RATE MUST MEET  OR  EXCEED  THE  REMOTE LINE RATE.  THE USER MUST
/	TAKE MINIMAL CARE NOT TO OVERLOAD  THE  INTERNAL BUFFERS OF KERMIT-12, AS THIS
/	WILL YIELD THE ERROR MESSAGE:  KEYBOARD INPUT ERROR!

/	THIS IS NOT LIKELY TO OCCUR UNLESS  ONE  "PLAYS"  WITH  A  KEYBOARD  WHICH CAN
/	GENERATE NUMEROUS ESCAPE SEQUENCES AS THE BUFFERS ARE  QUITE  ADEQUATE FOR ALL
/	REASONABLE TERMINAL APPLICATIONS.  SIMILARLY, IF THE REMOTE LINE DOES NOT OBEY
/	XON/XOFF  PROTOCOL  (WHILE  KERMIT-12  HAS  IT  ENABLED), THEN INTERNAL BUFFER
/	OVERFLOW WILL YIELD THE ERROR MESSAGE:  REMOTE LINE INPUT ERROR!

/	THESE ERRORS ARE EXTREMELY UNLIKELY AND CAN ONLY BE CREATED BY  MISUSE OF FLOW
/	CONTROL (THE ONLY EXCEPTION TO THIS IS THE ATTEMPT TO USE KERMIT-12  WITH  THE
/	CONSOLE  BAUD  RATE  SLOWER  THAN  THE REMOTE LINE BAUD RATE WITH FLOW CONTROL
/	DISABLED).  IF FLOW CONTROL IS ENABLED AND OBEYED THEN THE BUFFERING OF REMOTE
/	LINE INPUT  WILL  OCCUR  WHILE SHORT PAUSES OCCUR ON THE CONSOLE (ASSUMING THE
/	USER FREEZES/UNFREEZES THE  DISPLAY OFTEN AND THE CONSOLE DISPLAY BAUD RATE IS
/	FASTER THAN THE REMOTE LINE BAUD RATE) WITH PRACTICALLY NO REMOTE LINE DELAY.

/	FLOW CONTROL IS NOT  YET  SUPPORTED  DURING KERMIT TRANSFERS.  SINCE KERMIT-12
/	DOES  NOT SUPPORT SLIDING WINDOWS,  KERMIT-12  WILL  NEVER  GENERATE  OUTGOING
/	XON/XOFF SEQUENCES.  FUTURE REVISIONS WILL  SUPPORT INCOMING XON/XOFF FROM THE
/	REMOTE KERMIT.  XON/XOFF PROTOCOL DURING CONNECT  MODE IS COMPLETELY AVAILABLE
/	AT THE USER'S OPTION.

/	CONSOLE TERMINALS ARE REQUIRED TO SUPPORT "GLASS TTY:"  FEATURES,  I.E.    THE
/	PRINTING ASCII CHARACTER SET (LOWER-CASE DESIRABLE) AND THE CONTROL CHARACTERS
/	<CR>, <LF>, AND <BEL> (THE LAST FOR VARIOUS AUDIBLE REPORTS  ONLY).  TERMINALS
/	LACKING LOWER-CASE  SUPPORT  SHOULD "FOLD" LOWER-CASE CHARACTERS TO UPPER-CASE
/	AUTOMATICALLY.  TERMINALS  SUCH  AS  THE VT05 CAN HAVE THE KEYBOARD LOWER-CASE
/	ENABLED, AS KERMIT-12 SUPPORTS  OPTIONAL  OUTPUT FOLDING.  THE UPPER-CASE ONLY
/	OPTION SHOULD BE ENABLED FOR  TERMINALS WHICH IGNORE LOWER-CASE INPUT FROM THE
/	HOST,  AS KERMIT-12 GENERATES NUMEROUS LOWER-CASE  MESSAGE  CHARACTERS  (WHICH
/	BECOME UPPER-CASE IF THIS OPTION IS SET).   THE <BS> CHARACTER IS REQUIRED FOR
/	VISUAL  RUBOUT  (<BS>  <SPACE>  <BS>)  ONLY.   FUTURE  VERSIONS  WILL  SUPPORT
/	HARD-COPY BACKSPACE TO REMOVE THIS REQUIREMENT.  ALL TERMINAL  FEATURES  (SUCH
/	AS ACTUAL VT-100 FUNCTIONALITY) ARE FREELY PASSED TO THE HOST  DURING  CONNECT
/	MODE;  THE ONLY CHARACTER ACTUALLY RESERVED IS THE ESCAPE CHARACTER WHICH WILL
/	BE  TREATED  AS  A SEVEN-BIT CHARACTER ONLY.  IF THE USER PRESSES  THE  ESCAPE
/	CHARACTER TWICE,  THEN  THE  SEVEN-BIT REPRESENTATION OF THE CHARACTER IS SENT
/	ONCE;  THERE  IS  NO  WAY  TO SEND THE ESCAPE CHARACTER WITH THE HIGH-BIT SET.
/	SINCE THE ESCAPE CHARACTER  ITSELF  CAN  BE SET TO ALMOST ANY SEVEN-BIT VALUE,
/	THIS SHOULD NOT BE A SERIOUS LIMITATION.  TERMINALS THAT DON'T "BEEP" WHEN THE
/	<BEL> CHARACTER IS SENT SHOULD NOT  OUTPUT  A  PRINTABLE RENDITION OF THE <^G>
/	CHARACTER, AS THIS WOULD DISRUPT THE TERMINAL OUTPUT AND INTERNAL COLUMN COUNT
/	DURING VARIOUS MESSAGE SEQUENCES, ETC.
/	KL-8/E INTERFACES SHOULD BE SETUP WITH THE FOLLOWING STANDARD SETTINGS:

/	1 STOP BIT ABOVE 110 BAUD WITH 8 BITS DATA.

/	FUNCTIONAL  BAUD RATES INCLUDE 110, 150, 300, 600,  1200,  2400,  4800,  9600,
/	19200, 38400 AND 76800.  2400 BAUD REQUIRES A  REVISION  "B"  OR  BETTER M8650
/	MODULE  (IF  ONE  USES  DEC'S  DOCUMENTATION  OF AVAILABLE SPLIT-LUG OPTIONS).
/	ACTUAL  BAUD  RATES  UP TO APPROXIMATELY 100 KBAUD SHOULD WORK WHEN  KERMIT-12
/	BECOMES  INTERRUPT-DRIVEN.    RATES  OTHER THAN 110 BAUD REQUIRE A 19.6608 MHZ
/	BAUD-RATE OSCILLATOR.

/	THE BAUD  RATES STATED ABOVE ARE ACTUALLY AVAILABLE ON THE KL-8/E, BUT REQUIRE
/	A SINGLE SOLDER  JUMPER  TO  IMPLEMENT  THE  PROPER BAUD RATE ABOVE 2400 BAUD.
/	CHANGING BAUD-RATE GENERATOR CRYSTALS  WILL  PRODUCE OTHER RATES AS NECESSARY.
/	(SEND INQUIRIES  TO CLA SYSTEMS FOR INFORMATION REGARDING KL-8/E MODIFICATIONS
/	INCLUDING UPGRADED BAUD-RATE  OSCILLATORS,  ETC.) KERMIT-12 HAS BEEN TESTED TO
/	9600 BAUD AND SHOULD WORK TO 19200 BAUD (AS OF THE CURRENT VERSION).


/	KL8-J/A INTERFACES SHOULD BE SETUP WITH THE FOLLOWING STANDARD SETTINGS:

/	1 STOP BIT ABOVE 110 BAUD WITH 8 BITS DATA NO PARITY.

/	FUTURE  VERSIONS  OF KERMIT-12 WILL SUPPORT VARIOUS SOFTWARE-GENERATED  PARITY
/	OPTIONS.  THE FRAMING AND OVERRUN ERRORS CAN BE ENABLED AND WILL EVENTUALLY BE
/	SUPPORTED (BUT THE PARITY GENERATOR SHOULD BE DISABLED TO PREVENT  INTERACTION
/	WITH THE SOFTWARE USE OF PARITY GENERATION/DETECTION).

/	ALL BAUD RATES ARE SUPPORTABLE:

/	110, 150, 300, 600, 1200, 2400, 4800, 9600, 19200.

/	19200 BAUD IS ACHIEVED BY CUTTING JUMPER "W2" AND ADDING JUMPER  "W5" AND THEN
/	SETTING THE BOARD FOR WHAT IS NORMALLY 9600 BAUD.  A WESTERN DIGITAL TR-1602-B
/	OR  EQUIVALENT  UART  IS  REQUIRED TO SUPPORT 19200 BAUD;  MOST OF THE  RECENT
/	PRODUCTION  DEC M8655 BOARDS USE THE SMC COMM 2017 UART WHICH MEETS OR EXCEEDS
/	THIS REQUIREMENT.   EARLY  M8655 BOARDS USE GI UARTS IN CERAMIC PACKAGES WHICH
/	*CANNOT* BE USED AT 19200 BAUD (MANY ARE FLAKY AT 9600 BAUD!).

/	RECEIVE BAUD RATE SHOULD  BE IDENTICAL TO TRANSMIT BAUD RATE.  (DO NOT SET THE
/	RECEIVE=150 BAUD SWITCH!)
/	OTHER INTERFACES:

/	DKC-8/A (8/A OPTION BOARD #1)  INTERFACES  SHOULD  BE SETUP AS PER THE KL8-J/A
/	SPECIFICATIONS INCLUDING THE REQUIREMENTS OF THE UART.  SOME DEC DOCUMENTATION
/	INDICATED A PROHIBITION ON THE USE OF  19200 BAUD, BUT THIS IS OBVIATED BY THE
/	USE OF THE SAME UARTS AS IN THE KL8-J/A.

/	EARLIER DEVICES SUCH AS PT08, DP-12, KL-8/F OR DC02 (CHANNEL ZERO ONLY) SHOULD
/	WORK CORRECTLY AS FACTORY WIRED (MOST OF THESE DEVICES  DO NOT SUPPORT OPTIONS
/	KERMIT-12  WOULD  REQUIRE  TO  BE  DISABLED  ANYWAY.    THESE  INCLUDE  PARITY
/	GENERATION,  FRAMING  ERROR  DETECTION,  ETC.).  TO UTILIZE THESE DEVICES, THE
/	ASSEMBLY PARAMETERS  FOR  USER DEVICES AND THEIR RESPECTIVE DEVICE CODE VALUES
/	SHOULD BE GIVEN  DURING  ASSEMBLY  (SEE ASSEMBLY INSTRUCTIONS).  PROPER DEVICE
/	CODE VALUES MUST BE  OBTAINED  FOR  THE  SELECTED INTERFACE, AS THERE ARE MANY
/	ACTUAL POSSIBILITIES.  (DP-12 DEVICES  ARE  GENERALLY DEVICE 40/41;  PT08/DC02
/	INTERFACES ARE GENERALLY DEVICE 11/12, ETC.)
/	ASSEMBLY INSTRUCTIONS.

/	KERMIT-12 CAN BE ASSEMBLED BY EITHER OF TWO METHODS:


/	P?S/8 METHOD:

/	ASSUMING THE EXTENDED-LENGTH FILE KERM12 IS  THE  SOURCE  FILE,  THE FOLLOWING
/	COMMAND WILL PRODUCE A FULLY ORNAMENTED LISTING:

/	.PAL KB1,KB2,KB3,KB4<KERM12(ACEJLMNPQSX8)

/	OPTION SWITCH BREAKDOWN:

/	/A	ALL SYMBOLS IN SYMBOL PRINTOUT.

/	/C	OPTIMIZE  CORE  DURING ASSEMBLY FOR MORE SYMBOLS,  LESS  BUFFERS.
/		THIS OPTION SHOULD BE DELETED IF MORE THAN  8K  IS  AVAILABLE FOR
/		ASSEMBLY.

/	/E	FORGET LITERAL BOUNDARIES WHEN LEAVING THE CURRENT PAGE.

/	/J	*DO NOT* TERMINATE TEXT STRINGS WITH EXTRA ZERO WORD.

/	/L	PERFORM SECOND-PASS LISTING.

/	/M	CHAIN TO MAP FOR BITMAP OUTPUT AT END OF ASSEMBLY.

/	/N	ENABLE NEATNESS ADORNMENTS TO LISTING OUTPUT.

/	/P	ENABLE PRINTER-ORIENTED (WIDE MODE) LISTING OUTPUT.

/	/Q	ENABLE LITERALS ONLY, GENERATED LINKS ARE ERRORS.

/	/S	ENABLE SYMBOL TABLE PRINTOUT.

/	/X	ENABLE CROSS-REFERENCE OUTPUT AT END OF ASSEMBLY.

/	/8	ENABLE FULL SYMBOL TABLE INCLUDING LINC MODE CROSS ASSEMBLY.

/	THE NUMBER OF BINARY FILES REQUIRED (KB1, KB2, KB3, ETC.) IS  TO BE DETERMINED
/	AT ASSEMBLY TIME, AS KERMIT-12 WILL TEND TO GROW LARGER AS FEATURES ARE ADDED.

/	P?S/8 PAL IS THE PREFERRED METHOD  OF ASSEMBLING K12MIT DURING DEVELOPMENT DUE
/	TO SUPERIOR ERROR DIAGNOSTICS AND OVERALL SPEED.   K12MIT COULD GROW TO A SIZE
/	BEYOND THE CAPABILITIES OF OS/8 CREF.  THIS  LIMITATION  CANNOT  APPLY  TO THE
/	P?S/8 DEVELOPMENT ENVIRONMENT.

/	P?S/8 PAL CAN PRODUCE A LISTING OF K12MIT, BUT THE BINARY FILES CREATED BY THE
/	ASSEMBLY  MUST BE TRANSFERRED TO AN OS/8 ENVIRONMENT FOR USE, SINCE K12MIT (AS
/	SPECIFICALLY WRITTEN) IS FOR THE OS/8 FAMILY OF SYSTEMS ONLY.

/	NOTE:  P?S/8 IS *NOT* A DEC PRODUCT;  IT IS SOLD COMMERCIALLY AND IS AVAILABLE
/	FREE  OF  CHARGE (EXCEPT FOR MEDIA HANDLING CHARGES, ETC.) *ONLY* TO QUALIFIED
/	INSTITUTIONS.  CONTACT CJL FOR ADDITIONAL INFORMATION ON ACQUIRING P?S/8.
/	OS/8 FAMILY OF SYSTEMS METHOD:

/	K12MIT.PA CAN BE ASSEMBLED WITH PAL8 VERSION B0 WHICH IS AVAILABLE FROM  DECUS
/	AS PART OF THE OS/278 RELEASE.  PAL8 VERSION B0 WILL RUN ON  ANY  OS/8  FAMILY
/	SYSTEM,  AS  IT  HAS  NO  HARDWARE  DEPENDENCIES  BEYOND  THE  ORIGINAL  PDP-8
/	REQUIREMENT (NO BSW OR IAC ROTATE OR CAF OR R3L INSTRUCTIONS AS WAS INTENDED).
/	THIS ALSO APPLIES TO CREF  VERSION B0 WHICH IS REQUIRED WHEN A CROSS-REFERENCE
/	IS REQUESTED.  PAL8 VERSION B0  AND  CREF  VERSION B0 ARE AVAILABLE AS PART OF
/	THE KERMIT-12 DISTRIBUTION AS K12PL8.ENC AND K12CRF.ENC RESPECTIVELY.  SEE THE
/	DOCUMENTATION OF K12DEC FOR INFORMATION ON PRODUCING PAL8.SV  AND CREF.SV FROM
/	THESE ENCODED FILES.

/	ASSUMING CCL IS ENABLED, THE FOLLOWING COMMAND WILL PRODUCE A BINARY AND FULLY
/	ORNAMENTED LISTING:

/	.PAL DEV:K12MIT.BN,DEV:K12MIT.LS,DEV:KSCR.TM<DEV:PARAM.PA,DEV:K12MIT.PA(CEFMW)

/	DEV:  IS THE APPLICABLE DEVICE WHERE THE FILES RESIDE.    STANDARD  EXTENSIONS
/	ARE  ASSUMED  (.BN  FOR  BINARY, .LS FOR LISTING, .PA FOR PAL  SOURCE).    THE
/	KSCR.TM  TEMPORARY  OUTPUT FILE SPECIFICATION IS OPTIONAL, BUT IS DEFAULTED TO
/	SYS:CREFLS.TM IF  NOT  EXPLICITLY GIVEN.  MANY SYSTEM DEVICES ARE TOO SMALL TO
/	SUPPORT THIS TEMPORARY  FILE,  THUS  THE  FILE  MAY  BE  DIRECTED  TO  ANOTHER
/	AVAILABLE DEVICE WITH SUFFICIENT SPACE.

/	THE PARAM.PA FILE IS OPTIONAL AND USED TO PASS SHORT USER PARAMETERS, ETC.  TO
/	THE ASSEMBLY.

/	OPTION SWITCH BREAKDOWN:

/	/C	CHAIN TO CREF.SV TO PRODUCE A CROSS-REFERENCED LISTING FILE.

/	/E	GENERATED LINKS ARE ERRORS.

/	/F	*DO NOT* TERMINATE TEXT STRINGS WITH EXTRA ZERO WORD.

/	/M	USE MAMMOTH SYMBOL TABLE OPTION FOR CREF.

/	/W	FORGET LITERAL BOUNDARIES WHEN LEAVING THE CURRENT PAGE.

/	LOADING INSTRUCTIONS:

/	.LOAD DEV:K12CLR,K12MIT.BN	THIS LOADS THE BINARY CLEAR AND KERMIT
/	.SAVE DEV K12MIT.SV=1		THIS SAVES THE CORE IMAGE

/	THE  JOB STATUS WORD (=1) INDICATED THAT K12MIT.SV LOADS INTO 10000-11777, BUT
/	SHOULD NOT BE SAVED/RESTORED  WHEN  THE  USR  IS  LOADED  OVER  THIS  AREA  OR
/	DISMISSED (THE USR IS ACTUALLY  NEVER  DISMISSED  IN NORMAL K12MIT OPERATION).
/	OTHER BITS MAY BE SET AT  THE  USER'S  OPTION,  BUT  ARE UNNECESSARY;  THE BIT
/	INDICATED SERVES ONLY TO REDUCE SYSTEM OVERHEAD  REGARDING  THE DISPOSITION OF
/	10000-11777.  THE  BINARY  FILE  K12CLR.BN  (CREATED  BY ASSEMBLING K12CLR.PA)
/	LOADS ZEROES INTO ALL  OF  MEMORY  TO  CREATE A "CLEAN" CORE IMAGE FILE, WHICH
/	MAKES THE ENCODED BINARY FILE SMALLER DUE TO REPEAT COMPRESSION.
/	PASSING SHORT PARAMETER FILES.

/	WHEN INSERTING A SHORT USER MODIFICATION FILE IN THE INPUT STREAM  (PARAM.PAL)
/	THE FOLLOWING SHOULD BE NOTED:

/	ALWAYS  PUT  THE  SHORT  PARAMETER  FILE  (CONTAINING EQUATED SYMBOLS SUCH  AS
/	USER=1, ETC.) IN FRONT OF K12MIT.PAL.

/	IF TTY:  IS USED FOR DIRECT TYPE-IN OF THESE  PARAMETERS, THE INFORMATION NEED
/	ONLY BE TYPED ENDING WITH <^Z> DURING PASS 1.  SUBSEQUENT  PASSES  REQUIRE THE
/	ENDING <^Z> ONLY.  IF THIS METHOD IS USED, A LISTING WITHOUT  THE  USER  INPUT
/	WHICH  DID THE CUSTOMIZING OF KERMIT-12 CAN BE CREATED.  NOTE:  IF  BINARY  IS
/	GENERATED BY THE CONTENTS OF THE PARAMETER FILE (SUCH AS USE OF THE LOCAL TEXT
/	MESSAGE,  ETC.),  THE  INFORMATION MUST BE TYPED IN DURING PASS 2.  THE PASS 3
/	LISTING MAY  CONTAIN  THE INFORMATION IF SO DESIRED, REQUIRING A REPETITION OF
/	THE INPUT.   PASS  1  INPUT  OF  THE INFORMATION IS EFFECTIVELY IGNORED, AS NO
/	DEFINITIONS ARE CREATED ('LCLMSG' IS DEFINED ELSEWHERE, ETC.).

/	EXPERIENCED PDP-8 USERS NEW TO PAL8 VERSION B0 TAKE SPECIAL NOTICE:

/	DUE TO HARDWARE LIMITATIONS OF THE DECMATES, THE KEYBOARD FLAG WILL BE CLEARED
/	DURING PDP-8 PAL8 B0 OPERATION.  THE KL8E TTY:  HANDLER WILL NO LONGER BE ABLE
/	TO BUFFER <^Z> DURING THE ASSEMBLY;  YOU MUST  WAIT UNTIL THE HANDLER ACCESSES
/	THE KEYBOARD ON EACH PASS *THEN* PRESS <^Z> TO CONTINUE THE ASSEMBLY.


/	CREATING A CUSTOM MESSAGE FROM THE PARAMETER FILE.

/	IF  SO  DESIRED,  A CUSTOM LOCAL HEADER MESSAGE MAY BE ADDED BY INSERTING  THE
/	FOLLOWING INTO THE PARAMETER FILE:

/	BUFFLD=	10		/THESE PROBABLY
/	FILBUFF=2000		/WON'T CHANGE!

/	GENMSG=	0		/DON'T GENERATE STANDARD (NULL) MESSAGE
/	UMSG=	0		/DON'T GENERATE STANDARD (DUMMY) USER MESSAGE

/	FIELD	BUFFLD%10	/FIELD FOR TEXT MESSAGE

/	*FILBUFFER		/LOCAL MESSAGE LOADS THERE

/LCLMSG,TEXT	"%^I^NSERT ^L^OCAL ^M^ESSAGE ^H^ERE!%"

/	ZBLOCK	LCLMSG+40-.	/ZERO REST OF MESSAGE AREA

/	TEXT IS IN  UPPER/LOWER-CASE  SIXBIT  WITH  '^'  MEANING SHIFT CASE (INITIALLY
/	LOWER-CASE) AND '%' MEANING <CR>, <LF>.
/	OTHER METHODS:

/	KERMIT-12  *CANNOT*  BE ASSEMBLED  BY  PAL10  (LAST  KNOWN  VERSION  OF  PDP-8
/	CROSS-ASSEMBLER FOR TOPS10 (142)) BECAUSE IT LACKS CERTAIN FEATURES:

/	DOES NOT SUPPORT 'RELOC' PSEUDO-OP.

/	DOES NOT SUPPORT PAGE ZERO  REDEFINE  (CAUSES  "Z" ERROR ON SOURCE FILES WHICH
/	DON'T HAVE ERRORS WHEN ASSEMBLED BY EITHER P?S/8 PAL OR OS/8 PAL8).

/	INCORRECTLY HANDLES 'ZBLOCK' PSEUDO-OP (LEADS TO  "Q"  ERROR  ON  SOURCE FILES
/	WHICH DON'T HAVE ERRORS WHEN ASSEMBLED BY EITHER P?S/8 PAL OR OS/8 PAL8).

/	DOES NOT SUPPORT LITERAL "FORGETTING" (P?S/8 PAL OPTION /E OR OS/8 PAL8 OPTION
/	/W) WHICH IS REQUIRED FOR DEFINING OVERLAY AREAS, ETC.

/	DOES NOT SUPPORT TEXT WITHOUT ZERO WORD FILL (P?S/8 PAL OPTION /J OR OS/8 PAL8
/	OPTION /F FULFILLS THIS REQUIREMENT) WHICH IS REQUIRED FOR TEXT MESSAGES.


/	P?S/8 PAL IS AN IMPROPER SUPERSET OF PAL10.  PAL10 SUPPORTS MACRO-8 MODE AS AN
/	OPTION AND AUTOMATIC FIELD DUMP BITMAPS;  ALL OTHER KNOWN PAL10 FEATURES EXIST
/	IN  P?S/8  PAL  INCLUDING  THE  SUPPORT  OF  THE  AUTOMATIC FIELD DUMP  BITMAP
/	PSEUDO-OPS ('ENBITS' AND 'NOBITS').

/	OS/8  PAL8 (VERSION B0) IS A SUBSET OF P?S/8 PAL WHICH HAS  SEVERAL  SYNTACTIC
/	QUIRKS (WHICH  ARE AVOIDABLE, BUT NONETHELESS ARE INCOMPATIBLE WITH BOTH P?S/8
/	PAL  AND  PAL10    IN  CERTAIN  MINOR  WAYS);    REGARDLESS,  PAL8  LACKS  THE
/	COMPATIBILITY PROBLEMS OF PAL10.

/	MAINTAINING SOURCE COMPATIBILITY.

/	KERMIT-12 SOURCE FILE CONVENTIONS DEMAND THE USE OF THE COMMON SUBSET OF P?S/8
/	PAL AND OS/8 PAL8 (VERSION  B0).    CERTAIN  FORMS  OF  STATEMENTS  SHOULD  BE
/	AVOIDED:

/	TAD			/NOT LEGAL IN PAL8
/	0+TAD			/NOT LEGAL IN PAL10, AND POSSIBLY WRONG IN PAL8
/	TAD	(3)+1		/GENERATES SAME AS "TAD (3+1)" IN PAL8
/	-A!-B			/UNARY OPERATOR HANDLED WRONG IN PAL8
/	I+N			/NOT LEGAL IN PAL8
/	N+I			/NOT LEGAL IN PAL8
/	I I			/NOT LEGAL IN PAL8

/	THIS  REQUIREMENT IS EASILY MET BY  KERMIT-12  AS  MOST  OF  THESE  CASES  ARE
/	ESOTERIC QUIRKS AND NOT NEEDED FOR THIS ASSEMBLY.

/	THE RESTRICTIONS OF PAL10 (EVEN THOUGH IT  HAS  OTHER DESIRABLE FEATURES, MOST
/	OF WHICH IT SHARES WITH P?S/8 PAL) ARE  TOO SEVERE TO ALLOW USABLE ASSEMBLY OF
/	THIS  PROGRAM.    BETTER  CROSS-ASSEMBLERS  MAY  EXIST  ELSEWHERE  WHICH   ARE
/	SOURCE-COMPATIBLE WITH KERMIT-12.
/	USE OF P?S/8 LANGUAGE EXTENSIONS.

/	P?S/8 OFFERS SEVERAL USEFUL FEATURES OVER PAL8 (AND PAL10) WHICH MAY BE USEFUL
/	FOR  ASSEMBLY  DEVELOPMENT OF KERMIT-12.  THESE INCLUDE LANGUAGE ELEMENTS SUCH
/	AS "TAD (3)+1" HANDLED CORRECTLY, OR PSEUDO-OPS SUCH AS "PAUSE EXPR" WHERE THE
/	VALUE OF 'EXPR'  WILL  BE  DISPLAYED ON THE SYSTEM CONSOLE DURING THE ASSEMBLY
/	WHEN THAT POINT IN  THE  ASSEMBLY  IS  REACHED.   TO ACCESS THESE FEATURES AND
/	STILL  PROVIDE COMPATIBILITY WITH PAL8  (VERSION  B0),  THE  FOLLOWING  CODING
/	TECHNIQUE IS SUGGESTED:


/	IFNDEF	PQS	<PQS=0>	/WILL BE 0 ON PAL8, PAL10


/	IFZERO	PQS	<	/DO PAL8, ETC. STUFF HERE

/	FOO=	(TABLE)		/DEFINE POINTER TO ADDRESS OF TABLE

/	TAD	FOO-1		/GET (POINTER TO ADDRESS OF TABLE)-1
/	DCA	XR1		/SETUP AUTO-INDEX REGISTER

/	WISH WE HAD PAUSE AND ERROR PSEUDO-OPS IN PAL8.

/			>	/END OF PAL8, ETC. VARIANT


/	IFNZRO	PQS	<	/DO P?S/8 PAL STUFF HERE

/	TAD	(TABLE)-1	/GET (POINTER TO ADDRESS OF TABLE)-1
/	DCA	XR1		/SETUP AUTO-INDEX REGISTER

/	IFNDEF	PASS	<PASS=0>/DEFINE PASS VARIABLE

/	PASS=	PASS+1		/BUMP EVERY ASSEMBLER PASS

/	PAUSE	PASS		/DISPLAY PASS NUMBER

/	IFNZRO	.&4000	<

/	ERROR	1234		/DISPLAY ERROR MESSAGE IF THERE ARE PROBLEMS

/			>

/			>	/END OF P?S/8 PAL VARIANT


/	THIS ALLOWS TEMPORARY DEVELOPMENT FEATURES OR  PERMANENT ELEMENTS WHICH MAY BE
/	MORE ELEGANTLY EXPRESSED IN P?S/8 PAL VARIANT  CODING, WHILE THE PAL8 (VERSION
/	B0) VERSION CAN STILL BE USED (VIA DIRECT  OCTAL,  MULTIPLE EQUATE STATEMENTS,
/	CONDITIONAL FLUSH AS IN THE ABOVE EXAMPLE, ETC.   AS  NECESSARY)  FOR STANDARD
/	ASSEMBLY OF KERMIT-12.
/	ASSEMBLY PARAMETERS.

/	SEVERAL  PARAMETERS  MUST  BE  CHANGED  WITHIN  K12MIT.PA  (OR  PASSED TO  THE
/	ASSEMBLER VIA A SHORT FILE INSERTED INTO THE ASSEMBLY STREAM BEFORE  THE  MAIN
/	FILE):

/	SETTING  KEY= [RECEIVE IOT CODE FOR  CONSOLE  KEYBOARD]  DEFINES  THE  CONSOLE
/	KEYBOARD IOT CODE (DEFAULT IS 03).

/	SETTING  TTY=  [TRANSMIT  IOT CODE FOR CONSOLE  OUTPUT]  CHANGES  THE  CONSOLE
/	PRINTER IOT CODE (DEFAULT IS 04).

/	THE FOLLOWING DEFINITIONS ARE  ESSENTIALLY  FOR  KL8-TYPE DEVICES ONLY, AS THE
/	CODE DEMANDS KL8 HARDWARE COMPATIBILITY.    MODELS  OTHER  THAN PDP-8 (SUCH AS
/	DECMATE) GENERALLY EITHER PLACE RESTRICTIONS ON  AVAILABLE  INTERFACES  (OTHER
/	SOFTWARE DESIGNATES A SERIAL INTERFACE AS A  LOGICAL  PRINTER  PORT;  DECMATES
/	SUPPORT A FIRMWARE "PRINT SCREEN" KEY WHICH ENFORCES  THIS.),  OR  DON'T ALLOW
/	USABLE PLUG-IN OPTIONS.

/	IGNORING BUILT-IN DECMATE SUPPORT, THE FOLLOWING PARAMETERS ARE ACTIVE:

/	SETTING DEV30=	1 	CREATES DEVICE 30/31 REMOTE LINE IOTS.

/	SETTING DEV40=	1 	CREATES DEVICE 40/41 REMOTE LINE IOTS.

/	SETTING LEDERLE=1 	CREATES DEVICE 43/44  REMOTE  LINE  IOTS (AND A CUSTOM
/				HEADER).

/	SETTING ORIGNAL=1	CREATES  DEVICE  33/34  REMOTE   LINE  IOTS  (ORIGINAL
/				SETTINGS).

/	SETTING SPRINT= 1	CREATES DEVICE 32/33 REMOTE LINE  IOTS (SERIAL PRINTER
/				PORT).

/	SETTING USER=	1	CREATES DEVICE XX/XY REMOTE LINE IOTS.

/	IF NONE OF THESE ARE SET, THEN DEV40=1 APPLIES BY DEFAULT.



/	SETTING USER=	1	REQUIRES THE USER TO DEFINE TWO ADDITIONAL VALUES:

/		XX=	[RECEIVE IOT DEVICE CODE] (DEFAULT IS 40).

/		XY=	[TRANSMIT IOT DEVICE CODE] (DEFAULT IS 41).
/	SETTING SPRINT= 1	INHIBITS THE BUILT-IN CHECK FOR DECMATE  OPERATION AND
/				USES    THE    SERIAL  PRINTER  PORT  FOUND  ON    ALL
/				WPS-8-CONFIGURED    PDP-8/E,  PDP-8/A  CONFIGURATIONS,
/				VT-78,  AND  ALL DECMATES (VT-278,  DECMATE  II,  III,
/				III+) FOR REMOTE COMMUNICATIONS.

/	THE  USE OF THE SERIAL PRINTER PORT FOR REMOTE COMMUNICATIONS PURPOSES MAY  BE
/	PROBLEMATIC DUE TO CONSIDERATIONS SUCH AS THE RS-232 CONNECTION TO THE PRINTER
/	IS A  MODEM  (DCE), RATHER THAN A TERMINAL (DTE) (DECMATE II, ETC.  REQUIRES A
/	GENDER CHANGER.), OR  THE SOFTWARE DESIGNATION OF THE PORT AS BEING ALLEDGEDLY
/	*ONLY* FOR A PRINTER,  SUCH AS WHEN CERTAIN SYSTEMS SUPPORT THE "PRINT SCREEN"
/	KEY AS A SCREEN DUMP  TO  THE  SERIAL PRINTER PORT, ETC.  THESE ISSUES ARE NOT
/	RELEVANT TO KERMIT-12 OPERATION, AS THE "PRINT SCREEN" KEY IS NOT SUPPORTED BY
/	KERMIT-12 IN THIS CONFIGURATION AS SUCH (FUTURE  VERSIONS  COULD  REDEFINE THE
/	"PRINT SCREEN" KEY TO SUCH FUNCTIONS AS DUMP SCREEN TO A FILE, ETC.).

/	SETTING BRATE= NN	SETS THE DEFAULT BAUD RATE (FOR  SYSTEMS  THAT SUPPORT
/				THIS  FEATURE)  FROM  A  TABLE  OF  VALUES  (0-15)  AS
/				FOLLOWS:

/				NN		BAUD RATE

/				00		50
/				01		75
/				02		110
/				03		134.5
/				04		150
/				05		300
/				06		600
/				07		1200
/				08		1800
/				09		2000
/				10		2400
/				11		3600
/				12		4800
/				13		7200
/				14		9600
/				15		19200

/	SETTING ESCAPE=	NNNN	SETS THE DEFAULT ESCAPE CHARACTER TO NNNN.

/	SETTING FLOW=	1	ENABLES FLOW-CONTROL BY DEFAULT.
/	SETTING FLOW=	0	DISABLES FLOW-CONTROL BY DEFAULT.

/	SETTING FMODE=	0177	SETS THE DEFAULT FILE MODE TO ASCII.
/	SETTING FMODE=	4377	SETS THE DEFAULT FILE MODE TO BINARY.
/	SETTING GENMSG=	0	CAUSES  NO  BINARY TO BE GENERATED WHERE  'LCLMSG'  IS
/				DEFINED.  THIS ALLOWS THE PARAMETER FILE (PARAM.PA) OR
/				SUBSEQUENT  OVERLAY  BY  K12PCH.BN TO DEFINE THE LOCAL
/				HEADER MESSAGE.    THIS  PARAMETER  SHOULD  NOT BE SET
/				UNLESS ONE OF  THESE  METHODS IS USED, ELSE THE HEADER
/				MESSAGE  WILL BE UNDEFINED.    (NOTE:    IF  K12PCH.BN
/				GENERATES  A HEADER MESSAGE, THEN  THIS  PARAMETER  IS
/				UNIMPORTANT,  AS  K12PCH.BN  OVERLAYS  THE  BINARY  OF
/				K12MIT.)
/	SETTING GENMSG=	1	CAUSES A HEADER MESSAGE TO BE GENERATED.  THE CONTENTS
/				OF  THE  MESSAGE  ARE CREATED BY SETTING LEDERLE=1  OR
/				UMSG=1.   IF EITHER IS ZERO, A DEFAULT (NULL)  MESSAGE
/				WILL BE GENERATED.

/	SETTING ICLOSE=	1	ENSURES  A  <^Z>  AT  <EOF>  OF  ASCII  INPUT FILES BY
/				DEFAULT.
/	SETTING ICLOSE=	0	CLOSES ASCII INPUT FILES AS RECEIVED BY DEFAULT.

/	SETTING INIECHO=0	CAUSES A  FULL-DUPLEX CONNECT MODE STATE WITH NO LOCAL
/				CHARACTER ECHOING BY DEFAULT.
/	SETTING INIECHO=1	CAUSES A HALF-DUPLEX  CONNECT  MODE  STATE  WITH LOCAL
/				ECHO OF ALL CONSOLE CHARACTERS BY DEFAULT.

/	SETTING LOWER=	0	ALLOWS LOWER-CASE CONSOLE OUTPUT BY DEFAULT.
/	SETTING LOWER=	-40	FOLDS  LOWER-CASE  CONSOLE  OUTPUT  TO  UPPER-CASE  BY
/				DEFAULT.

/	SETTING OCLOSE=	0	PREVENTS DEFAULT SENDING OF <^Z>  AT  <EOF>  OF  ASCII
/				FILES.
/	SETTING OCLOSE= 1	CAUSES  <^Z> TO BE SENT AT <EOF>  OF  ASCII  FILES  BY
/				DEFAULT.

/	SETTING PORT=	0	CAUSES THE DP-278 PORT 0 TO BE USED  IF  KERMIT-12  IS
/				RUN ON A DECMATE 1 (ASSUMING SPRINT=0).
/	SETTING PORT=	1	CAUSES  THE DP-278 PORT 1 TO BE USED IF  KERMIT-12  IS
/				RUN ON A DECMATE 1 (ASSUMING SPRINT=0).

/	SETTING RETCNT=	NNNN	SETS THE PACKET RETRY COUNT TO NNNN BY DEFAULT.
/	SETTING UMSG=	0	PREVENTS THE  LOCAL  USER  HEADER  MESSAGE  FROM BEING
/				GENERATED.
/	SETTING UMSG=	1	CAUSES THE LOCAL  USER HEADER MESSAGE TO BE GENERATED.
/				THE PARAMETER GENMSG=1 IS  REQUIRED  TO  BE  SET.  THE
/				SOURCE MUST BE MODIFIED LOCALLY  TO CHANGE THE MESSAGE
/				TEXT FROM "INSERT LOCAL USER MESSAGE  HERE!,"  AS THIS
/				IS THE DEFAULT CONTENTS.
/	KERMIT-12 FOR THE FAMILY OF 12-BIT DEC MACHINES.

/	BRIEF USAGE DESCRIPTION.

/	KERMIT-12 IS AN IMPLEMENTATION OF THE KERMIT PROTOCOL FOR THE FAMILY OF 12-BIT
/	DEC (AND COMPATIBLE) MACHINES GENERALLY KNOWN AS PDP-8 OR DECMATE.

/	AS OF THE CURRENT IMPLEMENTATION, THE FOLLOWING COMMANDS ARE EFFECTIVE:

/	1.	CONNECT (TO REMOTE SYSTEM AS TERMINAL).

/	2.	SEND FILESPEC (TO REMOTE RECEIVER OR SERVER).

/	3.	RECEIVE FILESPEC (FROM REMOTE SENDER).

/	4.	GET FILESPEC (FROM REMOTE SERVER).

/	5.	FINISH (SERVING).

/	6.	SETUP (ON DECMATE II/III/III-PLUS ONLY). **** NOT IMPLEMENTED ****

/	7.	EXIT (TO OPERATING SYSTEM).

/	8.	HELP (DISPLAYS HELP MESSAGE).

/	FILESPEC  MAY  BE  ANY LOCAL (OS/8) FILE-STRUCTURED DEVICE:FILENAME.EXTENSION,
/	WHERE THE  FILENAME  AND  EXTENSION WILL BE TRUNCATED TO 6 ALPHANUMERICS AND 2
/	ALPHANUMERICS RESPECTIVELY, AS  NECESSARY (THIS IS REFERRED TO AS 6.2 FILENAME
/	FORMAT).  THE DEVICE:    FIELD  IS  OPTIONAL;   ALL COMMANDS USING THE DEVICE:
/	FIELD FOR LOCAL DEVICE SPECIFICATION  WILL  USE  THIS  DEVICE AS THE SOURCE OR
/	DESTINATION AS NECESSARY FOR THE LOCAL  FILES.    IF  THE  DEVICE:    FIELD IS
/	OMITTED, THE DEFAULT DEVICE DSK:  WILL BE USED.  THE ACTUAL DEVICE USED MAY BE
/	SELECTED BEFORE INVOKING KERMIT-12 BY USING THE OS/8 ASSIGN COMMAND:

/	.ASSIGN DEV DSK

/	WHERE DEV IS ANY AVAILABLE FILE-STRUCTURED DEVICE.

/	KERMIT-12 USES AN UNUSUAL SCHEME FOR ITS PROMPT:    THE  ACTUAL DEFAULT PROMPT
/	TEXT  IS  PARTIALLY  TAKEN  FROM  THE  ACTUAL MACHINE KERMIT-12  IS  CURRENTLY
/	EXECUTING  ON.    FOR  EXAMPLE, IF KERMIT-12 HAS DETERMINED THE  CPU  TYPE  AS
/	PDP-8/E, THE PROMPT WILL BE:

/	KERMIT-8/E>

/	THIS  ALLOWS KERMIT-12 USERS (WITH DIFFERENT CPU-TYPE MACHINES) TO DISTINGUISH
/	MESSAGES ORIGINATING  FROM  THE  RESPECTIVE  SYSTEMS.    FUTURE  VERSIONS WILL
/	SUPPORT USER PROMPT STRINGS TO ALLOW MORE DISTINCTIVE SYSTEM MESSAGES.

/	THE HELP OR CONNECT COMMANDS MAY BE USED TO DETERMINE THE CURRENT CONNECT MODE
/	ESCAPE CHARACTER.
/	COMMAND RESTRICTIONS.

/	THE  SEND  COMMAND  ALLOWS   DEVICE:FILENAME.EXTENSION  (6.2)  WITH  WILD-CARD
/	SUBSTITUTION.  A * MAY  BE  GIVEN  FOR  AN  ENTIRE  FIELD  (EITHER FILENAME OR
/	EXTENSION OR BOTH) ONLY.  A  ?    WILL  MATCH  ANY SINGLE CHARACTER WHICH MUST
/	EXIST IN THE ACTUAL FILENAME OR EXTENSION,  UNLESS  RIGHT-MOST  IN  THE FIELD.
/	ALL  MATCHING FILES WILL BE SENT.  NO  OUTBOUND  FILENAME  (AS-NAME)  FACILITY
/	EXISTS AT THIS TIME.

/	THE  RECEIVE  COMMAND  ALLOWS  OPTIONAL  DEVICE:   ONLY.   *THE  FILENAME  AND
/	EXTENSION  ARE  NOT  ALLOWED*.  NAMES OF RECEIVED FILES WILL  BE  MODIFIED  IF
/	NECESSARY  TO  CONFORM  TO  THE  6.2  FORMAT.   *IMPLEMENTATION RESTRICTION* :
/	CERTAIN REMOTE  FILENAMES  CONTAINING  NON-ALPHANUMERIC  CHARACTERS  MAY CAUSE
/	KERMIT-12 TO HASTILY ABORT THE TRANSMISSION AND RETURN TO COMMAND LEVEL.

/	THE GET COMMAND  ALLOWS  OPTIONAL  DEVICE:    TO  DETERMINE DESTINATION OF THE
/	INCOMING FILES.  THE  OUTBOUND  FILESPEC  MUST  CONFORM  TO  LOCAL CONVENTIONS
/	(FILENAME AND EXTENSION ARE NOT  LIMITED  TO  6.2  FORMAT;  THE DEVICE:  FIELD
/	WILL NOT BE SENT TO THE  REMOTE  KERMIT  UNLESS  IT  IS  ILLEGAL  WITHIN  OS/8
/	SPECIFICATIONS, SUCH AS TOO MANY DEVICE LETTERS.    IN  THIS CASE, THE DEFAULT
/	DEVICE DSK:  APPLIES, AND THE ENTIRE "DEVICE"  FIELD  IS  SENT  ALONG WITH ANY
/	FILENAME  AND EXTENSION).  CERTAIN REMOTE SYSTEMS ARE INCOMPATIBLE  WITH  THIS
/	IMPLEMENTATION,  AS  IMBEDDED  SPACES  OR  NON-ALPHANUMERIC CHARACTERS ARE NOT
/	ALLOWED, EVEN  THOUGH  THEY  MAY  BE REQUIRED ON THE REMOTE SYSTEM.  WILD-CARD
/	CHARACTERS ARE ALLOWED, BUT ONLY AS SPECIFIED IN THE SEND COMMAND ABOVE.

/	<^X>  OR  <^Z>  CAN BE USED TO ABORT KERMIT TRANSMISSIONS (EVENTUALLY) BUT  IS
/	NORMALLY  A  SLOW  PROCESS,  SINCE  THE CHECKING IS DONE BY A SOFTWARE TIMEOUT
/	SCHEME.   AT  THE  PRESENT  TIME,  THERE  IS  NO DISTINCTION BETWEEN THESE THO
/	CHARACTERS, SO IT  IS NOT POSSIBLE TO ABORT A SINGLE FILE; THE ENTIRE BATCH OF
/	FILES INVOLVED IN THE TRANSFER IS ABORTED.

/	DECMATE II/III/III-PLUS CONSIDERATIONS:

/	FUNCTION KEYS SEND <ESC>  SEQUENCES SPECIFIED BY SLUSHWARE/FIRMWARE.  ALL SOFT
/	FUNCTION KEYS ARE THEREFORE INEFFECTIVE  (EXCEPT  FOR HOLD SCREEN WHICH ALWAYS
/	WORKS).

/	CONNECT MODE RUNS IN 8-BIT MODE.

/	THE COMPOSE KEY IS ENABLED FOR USE WITH A LOADED COMPOSE TABLE.

/	ANY VALID DECMATE II/III/III-PLUS CHARACTER SET  IS  ALLOWED  WHILE IN CONNECT
/	MODE  (MCS  TCS  LINE,  ETC.).    ALL   <ESC>  SEQUENCES  ARE  PASSED  TO  THE
/	SLUSHWARE/FIRMWARE UNMODIFIED.

/	KEYBOARD UPPER-CASE LOCK WILL ALWAYS BE AUTOMATICALLY APPLIED UPON RETURN FROM
/	CONNECT MODE.
/	DEFINITIONS.							/017 CJL

	*200					/FOR DEFINITIONS	/047 CJL

/	REMOTE LINE PARAMETERS; SET ONLY ONE AS NECESSARY.		/046 CJL

	IFNDEF	DEV30	<DEV30=	0>		/USE DEVICE 30/31 VALUES
	IFNDEF	DEV40	<DEV40=	0>		/USE DEVICE 40/41 VALUES
	IFNDEF	LEDERLE	<LEDERLE=0>		/USE LEDERLE LABS VALUES
	IFNDEF	ORIGNAL	<ORIGNAL=0>		/USE ORIGINAL VALUES
	IFNDEF	SPRINT	<SPRINT=0>		/USE DEVICE 32/33 VALUES
	IFNDEF	USER	<USER=	0>		/USE USER-DEFINED VALUES

	REMOTE=	DEV30+DEV40+LEDERLE+ORIGNAL	/SET REMOTE LINE IOT CODE
	REMOTE=	REMOTE+SPRINT+USER		/SET REMOTE LINE IOT CODE

	IFZERO	REMOTE	<DEV40=	1>		/DEFAULT TO DEVICE 40/41 VERSION

/	DEV30 PARAMETERS.

	IFNZRO	DEV30			<

	IFNDEF	REC	<REC=	30>		/DEVICE 30 INPUT
	IFNDEF	SEN	<SEN=	31>		/DEVICE 31 OUTPUT

					>

/	DEV40 PARAMETERS (DEFAULT).

	IFNZRO	DEV40			<

	IFNDEF	REC	<REC=	40>		/DEVICE 40 INPUT
	IFNDEF	SEN	<SEN=	41>		/DEVICE 41 OUTPUT

					>

/	LEDERLE PARAMETERS.						/038 CJL

	IFNZRO	LEDERLE			<

	IFNDEF	REC	<REC=	43>		/DEVICE 43 INPUT
	IFNDEF	SEN	<SEN=	44>		/DEVICE 44 OUTPUT
	IFNDEF	GENMSG	<GENMSG=1>		/GENERATE LOCAL HEADER MESSAGE
	IFNDEF	UMSG	<UMSG=	0>		/DON'T GENERATE USER MESSAGE

					>

/	ORIGNAL PARAMETERS.

	IFNZRO	ORIGNAL			<

	IFNDEF	REC	<REC=	33>		/DEVICE 33 INPUT
	IFNDEF	SEN	<SEN=	34>		/DEVICE 34 OUTPUT

					>
/	SPRINT PARAMETERS.						/046 CJL

	IFNZRO	SPRINT			<

	IFNDEF	REC	<REC=	32>		/DEVICE 32 INPUT
	IFNDEF	SEN	<SEN=	33>		/DEVICE 33 OUTPUT

					>

/	USER PARAMETERS.

	IFNZRO	USER			<

	IFNDEF	XX	<XX=	40>		/DEFAULT TO DEVICE 40
	IFNDEF	XY	<XY=	41>		/DEFAULT TO DEVICE 41
	IFNDEF	REC	<REC=	XX>		/DEVICE XX INPUT
	IFNDEF	SEN	<SEN=	XY>		/DEVICE XY OUTPUT
	IFNDEF	GENMSG	<GENMSG=1>		/GENERATE LOCAL HEADER MESSAGE
	IFNDEF	UMSG	<UMSG=	1>		/GENERATE USER MESSAGE

					>

/	REMOTE LINE IOT DEFINITIONS.

/	RECEIVE DEFINITIONS.

	RKRBIOT=REC^10+6006			/READ REMOTE, CLEAR FLAG
	RKSFIOT=REC^10+6001			/SKIP ON REMOTE INPUT FLAG

/	TRANSMIT DEFINITIONS.

	RSBIOT=	SEN^10+6003			/SET BAUD RATE FROM AC[8-11]
	RTLSIOT=SEN^10+6006			/TRANSMIT CHARACTER, CLEAR FLAG
	RTSFIOT=SEN^10+6001			/SKIP ON TRANSMIT FLAG

/	CONSOLE TTY: DEFINITIONS.					/017 CJL

/	KEYBOARD DEFINITIONS.						/017 CJL

	IFNDEF	KEY	<KEY=	03>	/KEYBOARD DEVICE CODE

	KCCIOT=	KEY^10+6002		/CLEAR CONSOLE KEYBOARD FLAG, AC
	KRBIOT=	KEY^10+6006		/READ CONSOLE KEYBOARD BUFFER, CLEAR FLAG
	KRSIOT=	KEY^10+6004		/READ CONSOLE KEYBOARD BUFFER STATIC
	KSFIOT=	KEY^10+6001		/SKIP ON CONSOLE KEYBOARD FLAG

/	TELEPRINTER DEFINITIONS.					/017 CJL

	IFNDEF	TTY	<TTY=	04>	/TELEPRINTER DEVICE CODE

	TLSIOT=	TTY^10+6006		/PRINT CHARACTER, CLEAR FLAG
	TSFIOT=	TTY^10+6001		/SKIP ON TELEPRINTER FLAG
/	DEFAULT ESCAPE CHARACTER DEFINITION.				/025 CJL

	IFNDEF	ESCAPE	<ESCAPE="]&37>	/DEFAULT IS CONTROL-]

/	DEFAULT LOWER-CASE ENABLE DEFINITION.				/030 CJL

	IFNDEF	LOWER	<LOWER=	0/-40>	/LOWER-CASE IS ALLOWED AS IS
					/CHANGE TO -40 IF LOWER-CASE
					/SHOULD BE FOLDED TO UPPER-CASE

/	DEFAULT RETRY COUNT DEFINITION.					/031 CJL

	IFNDEF	RETCNT	<RETCNT=5>	/DEFAULT IS FIVE RETRIES

/	DEFAULT FILE MODE DEFINITION.					/031 CJL

	IFNDEF	FMODE	<FMODE=	0177>	/DEFAULT IS ASCII FILE MODE
					/4377 IS BINARY FILE MODE

/	DEFAULT FLOW-CONTROL MODE DEFINITION.				/031 CJL

	IFNDEF	FLOW	<FLOW=	1>	/DEFAULT IS FLOW-CONTROL ENABLED

/	DEFAULT ASCII INPUT FILE <^Z> DISPOSITION.			/031 CJL

	IFNDEF	ICLOSE	<ICLOSE=1>	/ENSURE <^Z> AT ASCII <EOF>

/	DEFAULT ASCII OUTPUT FILE <^Z> DISPOSITION.			/031 CJL

	IFNDEF	OCLOSE	<OCLOSE=0>	/<^Z> NOT SENT AT ASCII <EOF>

/	DEFAULT LOCAL MESSAGE GENERATION DEFINITIONS.			/038 CJL

	IFNDEF	GENMSG	<GENMSG=1>	/DEFAULT IS TO GENERATE A MESSAGE
	IFNDEF	UMSG	<UMSG=	0>	/DEFAULT IS NO DUMMY USER MESSAGE
	IFNDEF	LEDERLE	<LEDERLE=0>	/DEFAULT IS NO LEDERLE MESSAGE

/	THE NULL MESSAGE WILL BE GENERATED BY DEFAULT.

/	ECHO DEFINITION.						/039 CJL

	IFNDEF	INIECHO	<INIECHO=0>	/DEFAULT IS NO LOCAL ECHO

/	DEFAULT DECMATE I PORT DEFINITION.				/050 CJL

	IFNDEF	PORT	<PORT=	0>	/DEFAULT IS PORT ZERO 

/	DEFAULT BAUD RATE DEFINITION.					/050 CJL

	IFNDEF	BRATE	<BRATE=	7>	/DEFAULT IS 1200 BAUD
/	STATE DEFINITIONS.

	STDAT=	"D&137			/DATA
	STACK=	"Y&137			/ACK
	STNAK=	"N&137			/NAK
	STSIN=	"S&137			/SEND-INIT
	STBRK=	"B&137			/BREAK LINK
	STFIL=	"F&137			/FILENAME HEADER
	STEOF=	"Z&137			/END OF FILE OR REPLY
	STERR=	"E&137			/ERROR PACKET
	STATT=	"A&137			/FILE ATTRIBUTES
	STRIN=	"R&137			/RECEIVE-INIT
	STEOT=	"B&137			/BREAK TRANSMISSION
	STGEN=	"G&137			/KERMIT GENERIC COMMAND

/	DEFAULT INIT PARAMETERS.

	DEFCK=	"1&177			/DEFAULT 1 CHARACTER CHECKSUM	/014 CJL
	DEFEOL=	15+40			/CR IS DEFAULT <EOL>
	DEFQCTL= "#&177			/"#" IS DEFAULT QCTL

/	BUFFER DEFINITIONS.						/014 CJL

	DECIMAL				/MAKE IT EASIER			/014 CJL

	DEFMAXL=94			/DEFAULT MAXIMUM PACKET SIZE

	LINSIZ=	32			/KEYBOARD LINE BUFFER SIZE

	OCTAL				/BACK TO NORMAL			/014 CJL

	BUFSIZE=200			/128 CHARACTER RING BUFFERS	/026 CJL
					/FOR NO-INTERRUPT CONNECT MODE
/	CONTROL CHARACTER DEFINITIONS.					/023 CJL

	CNTRLA=	"A&37			/<^A> DEFAULT MARK CHARACTER	/023 CJL
	CNTRLB=	"B&37			/<^B>				/046 CJL
	CNTRLC=	"C&37			/<^C> PROGRAM EXIT CHARACTER	/023 CJL
	CNTRLD=	"D&37			/<^D>				/046 CJL
	CNTRLE=	"E&37			/<^E>				/046 CJL
	CNTRLF=	"F&37			/<^F>				/046 CJL
	CNTRLG=	"G&37			/<^G> BELL CHARACTER		/023 CJL
	CNTRLH=	"H&37			/<^H> BACKSPACE CHARACTER	/023 CJL
	CNTRLI=	"I&37			/<^I> HORIZONTAL TAB CHARACTER	/043 CJL
	CNTRLJ=	"J&37			/<^J> LINEFEED CHARACTER	/023 CJL
	CNTRLK=	"K&37			/<^K> VERTICAL TAB CHARACTER	/046 CJL
	CNTRLL=	"L&37			/<^L> FORM FEED CHARACTER	/046 CJL
	CNTRLM=	"M&37			/<^M> CARRIAGE RETURN CHARACTER	/023 CJL
	CNTRLN=	"N&37			/<^N>				/046 CJL
	CNTRLO=	"O&37			/<^O> ECHO FLIP CHARACTER	/023 CJL
	CNTRLP=	"P&37			/<^P> PROGRAM RESTART CHARACTER	/023 CJL
	CNTRLQ=	"Q&37			/<^Q> OUTPUT RESUME CHARACTER	/023 CJL
	CNTRLR=	"R&37			/<^R>				/046 CJL
	CNTRLS=	"S&37			/<^S> OUTPUT WAIT CHARACTER	/023 CJL
	CNTRLT=	"T&37			/<^T>				/046 CJL
	CNTRLU=	"U&37			/<^U>				/046 CJL
	CNTRLV=	"V&37			/<^V>				/046 CJL
	CNTRLW=	"W&37			/<^W>				/046 CJL
	CNTRLX=	"X&37			/<^X> FILE ABORT CHARACTER	/044 CJL
	CNTRLY=	"Y&37			/<^Y>				/046 CJL
	CNTRLZ= "Z&37			/<^Z> ABORT AND <EOF> CHARACTER /044 CJL
	DELETE=	177			/<DEL> DELETE OR <RO> CHARACTER	/034 CJL
	LOWERC=	"C&177+40		/LOWER-CASE C (CLOSE CHARACTER)	/025 CJL
	UPPERC=	"C&177			/UPPER-CASE C (CLOSE CHARACTER)	/025 CJL

/	I/O AND FIELD DEFINITIONS.					/019 CJL

	BUFFLD=	10			/I/O BUFFER FIELD		/019 CJL
	DIRFLD=	10			/DIRECTORY LOOKUP BUFFER FIELD	/028 CJL
	DMIFLD=	10			/DECMATE ONCE-ONLY CODE FIELD	/046 CJL
	MSGFLD=	10			/TEXT MESSAGE FIELD		/023 CJL
	PAGCNT=	2			/I/O BUFFER SIZE IN PAGES	/019 CJL
	PRGFLD=	00			/PROGRAM FIELD			/019 CJL
	USRFLD=	10			/USR FIELD			/020 CJL

/	OS/8 MONITOR DEFINITIONS.					/014 CJL

	SBOOT=	7600			/MONITOR EXIT LOCATION IS 07600	/014 CJL
	USR=	7700			/NON-LOCKED USR ENTRY POINT	/035 CJL
/	USER SERVICE ROUTINE AND HANDLER DEFINITIONS.			/020 CJL

	CLOSE=	4			/CLOSE TENTATIVE OUTPUT FILE	/020 CJL
	ENTER=	3			/ENTER TENTATIVE OUTPUT FILE	/020 CJL
	FETCH=	1			/FETCH HANDLER			/020 CJL
	INQUIRE=12			/INQUIRE ABOUT HANDLER		/020 CJL
	LOOKUP=	2			/LOOKUP FILE			/020 CJL
	RESET=	13			/RESET DEVICE CONTROL WORD TABLE/037 CJL
	USRIN=	10			/LOCK USR IN CORE		/020 CJL
	WRITE=	4000			/I/O CALL WRITE BIT		/020 CJL

/	INSTRUCTION DEFINITIONS.

	CLCL=	6136			/CLEAR CLOCK FLAG (8/A, ETC.)	/046 CJL
	CLSK=	6131			/SKIP ON, CLEAR CLOCK FLAG	/046 CJL
	CLSK8A=	6137			/SKIP ON CLOCK FLAG (8/A, ETC.)	/046 CJL
	COM=	0017			/COMPLEMENT AC
	DCAC=	DCA	.		/CURRENT PAGE DCA INSTRUCTION	/047 CJL
	IAAC=	6171			/"A" REGISTER TO AC
	IACA=	6167			/AC TO "A" REGISTER
	ISZC=	ISZ	.		/CURRENT PAGE ISZ INSTRUCTION	/050 CJL
	JMPC=	JMP	.		/CURRENT PAGE JMP INSTRUCTION	/047 CJL
	JMPIC=	JMP I	.		/CURRENT PAGE JMP I INSTRUCTION	/047 CJL
	JMSC=	JMS	.		/CURRENT PAGE JMS INSTRUCTION	/047 CJL
	JMSIC=	JMS I	.		/CURRENT PAGE JMS I INSTRUCTION	/047 CJL
	LINC=	6141			/GOTO LINC MODE
	PDP=	0002			/GOTO PDP-8 MODE
	PRQ3=	6236			/TYPE THREE PANEL REQUEST	/046 CJL
	TADC=	TAD	.		/CURRENT PAGE TAD INSTRUCTION	/047 CJL
	R3L=	7014			/ROTATE AC (NOT LINK) LEFT 3	/046 CJL

/	NUMERIC LOAD DEFINITIONS.					/014 CJL

	NL0000=	CLA			/LOAD AC WITH 0000		/046 CJL
	NL0001=	CLA IAC			/LOAD AC WITH 0001		/014 CJL
	NL0002=	CLA CLL CML RTL		/LOAD AC WITH 0002		/014 CJL
	NL0003=	CLA STL IAC RAL		/LOAD AC WITH 0003 (8/I ON UP)	/046 CJL
	NL0004=	CLA CLL IAC RTL		/LOAD AC WITH 0004 (8/I ON UP)	/046 CJL
	NL0006=	CLA STL IAC RTL		/LOAD AC WITH 0006 (8/I ON UP)	/046 CJL
	NL0010=	CLA IAC RAL RAR		/LOAD AC WITH 0010 (6120)	/024 CJL
	NL0100=	CLA IAC BSW		/LOAD AC WITH 0100 (8/E ON UP)	/024 CJL
	NL3776=	CLA CLL CMA RAR RAL	/LOAD AC WITH 3776 (8/I OR 8/L)	/024 CJL
	NL3777=	CLA CLL CMA RAR		/LOAD AC WITH 3777		/046 CJL
	NL4000=	CLA CLL CML RAR		/LOAD AC WITH 4000		/014 CJL
	NL5777=	CLA CLL CMA RTR		/LOAD AC WITH 5777		/046 CJL
	NL6000=	CLA STL IAC RTR		/LOAD AC WITH 6000 (8/I ON UP)	/046 CJL
	NL7775=	CLA CLL CMA RTL		/LOAD AC WITH 7775		/014 CJL
	NL7776=	CLA CLL CMA RAL		/LOAD AC WITH 7776		/014 CJL
	NL7777=	CLA CMA			/LOAD AC WITH 7777		/014 CJL
/	DECMATE I COMMUNICATIONS PORT DEFINITIONS.			/050 CJL

	IPORT0=	30		/COMMUNICATIONS PORT 0 INPUT DEVICE CODE

	RKFL0=	IPORT0^10+6000	/SET COMMUNICATIONS PORT 0 INPUT FLAG
	RKSF0=	IPORT0^10+6001	/SKIP ON, CLEAR COMMUNICATIONS PORT 0 INPUT FLAG
	RKCC0=	IPORT0^10+6002	/CLEAR AC
	RKIE0=	IPORT0^10+6005	/PORT 0 INPUT INTERRUPT ENABLE PER AC[11]
	RKRB0=	IPORT0^10+6006	/READ COMMUNICATIONS PORT 0 INTO AC

	OPORT0=	31		/COMMUNICATIONS PORT 0 OUTPUT DEVICE CODE

	RTFL0=	OPORT0^10+6000	/SET COMMUNICATIONS PORT 0 OUTPUT FLAG
	RTSF0=	OPORT0^10+6001	/SKIP ON, CLEAR COMMUNICATIONS PORT 0 OUTPUT FLAG
	RTCF0=	OPORT0^10+6002	/NOP
	RTIE0=	OPORT0^10+6005	/PORT 0 OUTPUT INTERRUPT ENABLE PER AC[11]
	RTLS0=	OPORT0^10+6006	/WRITE COMMUNICATIONS PORT 0 FROM AC

	IPORT1=	34		/COMMUNICATIONS PORT 1 INPUT DEVICE CODE

	RKFL1=	IPORT1^10+6000	/SET COMMUNICATIONS PORT 1 INPUT FLAG
	RKSF1=	IPORT1^10+6001	/SKIP ON, CLEAR COMMUNICATIONS PORT 1 INPUT FLAG
	RKCC1=	IPORT1^10+6002	/CLEAR AC
	RKIE1=	IPORT1^10+6005	/PORT 1 INPUT INTERRUPT ENABLE PER AC[11]
	RKRB1=	IPORT1^10+6006	/READ COMMUNICATIONS PORT 1 INTO AC

	OPORT1=	35		/COMMUNICATIONS PORT 1 OUTPUT DEVICE CODE

	RTFL1=	OPORT1^10+6000	/SET COMMUNICATIONS PORT 1 OUTPUT FLAG
	RTSF1=	OPORT1^10+6001	/SKIP ON, CLEAR COMMUNICATIONS PORT 1 OUTPUT FLAG
	RTCF1=	OPORT1^10+6002	/NOP
	RTIE1=	OPORT1^10+6005	/PORT 1 OUTPUT INTERRUPT ENABLE PER AC[11]
	RTLS1=	OPORT1^10+6006	/WRITE COMMUNICATIONS PORT 1 FROM AC

	PCON=	36		/PORT STATUS AND CONTROL DEVICE CODE

	SMFL=	PCON^10+6000	/SET MODEM CHANGE FLAG
	MFSK=	PCON^10+6001	/SKIP ON, CLEAR MODEM CHANGE FLAG
	WCON0=	PCON^10+6002	/WRITE COMMUNICATIONS PORT 0 CONTROL REGISTER
	PSR=	PCON^10+6003	/READ PORT STATUS REGISTER
	PMR=	PCON^10+6004	/READ PORT MODEM REGISTER
	MFIE=	PCON^10+6005	/LOAD MODEM CHANGE INTERRUPT ENABLE PER AC[11]
	WCON1=	PCON^10+6006	/WRITE COMMUNICATIONS PORT 1 CONTROL REGISTER
	RACD=	PCON^10+6007	/RESET ACTIVE COMMUNICATIONS PORT PER AC[0]
/	DECMATE II, ETC. COMMUNICATIONS PORT DEFINITIONS.		/046 CJL

	PORTIN=	30		/COMMUNICATIONS PORT INPUT DEVICE CODE

	IFL=	PORTIN^10+6000	/SET COMMUNICATIONS PORT INPUT/OUTPUT FLAG
	ISF=	PORTIN^10+6001	/SKIP ON, CLEAR COMMUNICATIONS PORT INPUT/OUTPUT FLAG
	ICF=	PORTIN^10+6002	/NOP (CLEAR THE AC?)
	INOP1=	PORTIN^10+6003	/(NOP?)
	IRS=	PORTIN^10+6004	/READ COMMUNICATIONS PORT RECEIVE BUFFER
	IIE=	PORTIN^10+6005	/COMMUNICATIONS PORT I/O INTERRUPT ENABLE PER AC[11]
	IRB=	PORTIN^10+6006	/READ COMMUNICATIONS PORT RECEIVE BUFFER
	INOP2=	PORTIN^10+6007	/(NOP?)

	PORTOUT=31		/COMMUNICATIONS PORT OUTPUT DEVICE CODE

	DUMBFL=	PORTOUT^10+6000	/SET COMMUNICATIONS PORT DUMMY FLAG
	DUMBSF=	PORTOUT^10+6001	/SKIP ON, CLEAR COMMUNICATIONS PORT DUMMY FLAG
	DUMBCF=	PORTOUT^10+6002	/NOP (CLEAR THE AC?)
 	ONOP1=	PORTOUT^10+6003	/(NOP?)
	OPC=	PORTOUT^10+6004	/LOAD COMMUNICATIONS PORT TRANSMIT BUFFER
	DUMBIE=	PORTOUT^10+6005	/COMMUNICATIONS PORT DUMMY INTERRUPT ENABLE PER AC[11]
	OLS=	PORTOUT^10+6006	/LOAD COMMUNICATIONS PORT TRANSMIT BUFFER
	ONOP2=	PORTOUT^10+6007	/(NOP?)

	PORTCON=36		/COMMUNICATIONS PORT CONTROL DEVICE CODE

	MFL=	PORTCON^10+6000	/SET MODEM CHANGE FLAG
	MSF=	PORTCON^10+6001	/SKIP ON, CLEAR MODEM CHANGE FLAG
	MLC=	PORTCON^10+6002	/LOAD MODEM CONTROL REGISTER
	MSB=	PORTCON^10+6003	/LOAD BAUD RATE REGISTER
	MRS=	PORTCON^10+6004	/READ MODEM STATUS REGISTER
	MIE=	PORTCON^10+6005	/MODEM CHANGE INTERRUPT ENABLE PER AC[11]
	MPSCC=	PORTCON^10+6006	/ACCESS MULTIPROTOCOL SERIAL COMMUNICATIONS CONTROLLER
	MPRESET=PORTCON^10+6007 /RESET MULTIPROTOCOL SERIAL COMMUNICATIONS CONTROLLER
/	MISCELLANEOUS DEFINITIONS.					/014 CJL

/	STATIC DATE CALCULATIONS.					/024 CJL

/	THESE EQUATIONS CAUSE PRINTABLE  TEXT OF THE DATE PARTICULARS, WHICH ARE GIVEN
/	IN OS/8 INTERNAL FORMAT.  PROGRAM MAINTAINENCE REQUIRES THE UPDATE OF VERSION,
/	REVISION, REVDATE, AND REVDGRP.  REVDATE  AND  REVDGRP SHOULD BE OBTAINED FROM
/	THE SYSTEM WHEN RELEASING A NEW VERSION  AFTER  FIRST  CORRECTLY  INVOKING THE
/	SYSTEM DATE COMMAND.

/	VERSION=[ANY NUMBER IN THE RANGE 00-143 (DECIMAL 00-99)]

/	REVISIO=[ANY SIX-BIT ALPHA (A-Z); DO NOT FORGET &77]

/	REVDATE=[THE CONTENTS OF 17666 (DATE WORD)]

/	REVDGRP=[THE CONTENTS OF 07777 (ONLY BITS[3-4] ARE USED)]



	IFNDEF	REVDATE	<REVDATE=4464>	/REVISION DATE (LOCATION 17666)

	IFNDEF	REVDGRP	<REVDGRP=0400>	/REVISION 8 YEAR DATE GROUP (LOCATION 07777)

	IFNDEF	REVISIO	<REVISIO="G&77>	/REVISION OF KERMIT-12

	IFNDEF	VERSION	<VERSION=12>	/VERSION OF KERMIT-12


	DAY=	REVDATE&370%10		/REVISION DAY

	DGROUP=	REVDGRP&600%20		/REVISION DATE GROUP (WHICH 8 YEARS)

	MONTH=	REVDATE&7400%400	/REVISION MONTH

	YEAR=	REVDATE&7+DGROUP+106	/REVISION YEAR (SINCE 1900)
	FIELD	PRGFLD%10	/STARTING FIELD				/038 CJL

	*0			/START AT THE BEGINNING			/014 CJL

INTPC,	.-.			/PC FROM INTERRUPT (IF ANY)		/014 CJL
	JMP I	INTPC		/RETURN WITH INTERRUPTS OFF		/014 CJL

ABFLAG,	.-.			/FILE ABORT FLAG			/044 CJL
TABLEJU,.-.			/MATCHING VALUE FOR SRCHTABLE ROUTINE	/025 CJL

	IFNZRO	.-4	<ERROR	.>					/014 CJL
ODT,	ZBLOCK	7-.		/RESERVED FOR OS/8 ODT			/014 CJL
RATE,	BRATE			/BAUD RATE				/050 CJL

	*10			/GET TO AUTO-INDEX AREA			/014 CJL

XR0,	.-.			/AUTO-INDEX ZERO			/014 CJL
XR1,	.-.			/AUTO-INDEX ONE				/014 CJL
DIRXR,	PORT			/DIRECTORY LOOKUP DEDICATED AUTO-INDEX	/028 CJL
				/INITIALIZED FOR DECMATE I ONCE-ONLY	/050 CJL

/	THE REMAINING LOCATIONS THROUGH  000017  MUST  BE USED DIRECTLY ONLY, SO AS TO
/	NOT CAUSE INADVERTANT AUTO-INDEXING.

/	COLUMN COUNTER FOR CONSOLE ROUTINES (NEVER USED INDIRECTLY).	/043 CJL

COLUMN,	.-.			/CONSOLE OUTPUT COLUMN COUNTER		/043 CJL

/	CONSOLE TERMINAL ECHO SWITCH (NEVER USED INDIRECTLY).		/020 CJL

ECHOSW,	0			/0=ECHO, 4000=DON'T ECHO		/020 CJL

/	LATEST (NON-CONNECT MODE) CHARACTER (NEVER USED INDIRECTLY).	/043 CJL

INCHAR,	.-.			/LATEST INPUT CHARACTER FROM CONSOLE	/043 CJL

/	CURRENT KERMIT MODE (NEVER USED INDIRECTLY).			/025 CJL

KMODE,	.-.			/CURRENT MODE OF KERMIT			/025 CJL

/	KERMIT MODE FLAG VALUES.					/014 CJL

/	MLINE=	1		/KERMIT IS ON-LINE
	MSEND=	2		/KERMIT IS IN SEND MODE
	MREC=	3		/KERMIT IS IN RECEIVE MODE

/	LATEST CHARACTER SENT TO OUTPUT FILE (NEVER USED INDIRECTLY).	/020 CJL

LATEST,	.-.			/LATEST CHARACTER SENT TO OUTPUT FILE	/020 CJL
	*20			/GET PAST AUTO-INDEX AREA

INFLAG,	.-.			/DECMATE INPUT AVAILABLE FLAG		/046 CJL
OUTFLAG,.-.			/DECMATE OUTPUT AVAILABLE FLAG		/046 CJL
TEMP,	0
RCHAR,	0			/REMOTE LINE CURRENT INPUT CHAR
SCAN1,	0			/
SCAN2,	0			/
KEYDSP,	0			/DISPATCH ADDRESS FOR KEYWORD MATCH
BININP,	0			/BINARY REGISTER FOR DECIMAL INPUT
PTABLE,	0			/
LPTR,	0			/HOLDS LINE POINTER
STATE,	0			/CURRENT STATE
RETRY,	-RETCNT			/PACKET ERROR RETRY COUNTER		/031 CJL
RTRYC,	0			/USE THIS FOR ACTUAL COUNTER

/	CURRENT PACKET I/O DATA.					/014 CJL

PAKPTR,	0			/POINTER TO OUTPUT PACKET POINTER
PAKCKS,	0			/HOLDS CURRENT OUTPUT PACKET CHECKSUM TOTAL
CURSEQ,	0			/CURRENT SEQ NUMBER
QFLAG,	0			/NON-ZERO WHEN NO CONTROL QUOTING

/	RECEIVE "INIT" REGISTERS.					/014 CJL

RMAXL,	DEFMAXL+40		/MAX LENGTH FOR DATA PACKET (DEFAULT)
RTIME,	0			/TIME-OUT VALUE
RNPAD,	0			/NUMBER OF PADDING CHARS
RPADC,	0			/CHAR USED FOR PADDING
REOL,	DEFEOL			/TERMINATOR CHAR USED FOR END OF PACKET
RQCTL,	DEFQCTL			/CONTROL CHAR PREFIX CHAR
RQBIN,	0			/PARITY CHAR PREFIX CHAR (CHARS GT 177)
RCHKT,	DEFCK			/CHECKSUM TYPE  (DEFAULT TYPE 1)
RREPT,	0			/PREFIX CHAR FOR REPEATED CHARS
RCAPAS,	0			/EXTRA CAPABILITY BIT MASK

/	ZBLOCK	4		/RESERVED FOR EXTRA CAPABILITIES	/022 CJL

	INITEND=.		/END OF INIT REGISTERS			/022 CJL

HNDADR,	0			/FILE DEVICE HANDLER ADDRESS
FORCEP,	0			/FLAG FOR FORCED OUTPUT OF PACKET WHEN THERE IS
				/  NO DATA (JUST SOH, LEN, SEQ, AND CHECKSUM)
PRSERR,	0			/HOLDS PARSE POSITION FOR REPORTING ERRORS
PACK6P,	0			/POINTER TO STORAGE OF 6 BIT CHARS
PACK6F,	0			/FLAG FOR WHICH BYTE TO STORE
GET6P,	0			/POINTER USED IN THE GET6 ROUTINE
GET6F,	0			/FLAG USED IN THE GET6 ROUTINE
MOVE4,	0			/COUNTER FOR "MOVE"
INIFLG,	0			/INIT DONE FLAG
MQ,	.-.			/"MQ" TEMPORARY REGISTER		/032 CJL
/	FILE NAME PARSE REGISTERS.					/014 CJL

FNPTR,	0			/POINTER TO WHERE TO PUT A PARSED FILE NAME
WILDF,	0			/WILD CARD IN FILE NAME FLAG

/	FILE INFORMATION.						/014 CJL

FSBLK,	0			/FILE START BLOCK
FLEN,	0			/FILE LENGTH
DEVNUM,	0			/PARSED DEVICE NUMBER HERE
OFFLG,	0			/OUTPUT FILE OPEN FLAG
ODNAME,	0			/POINTER TO USER SPECIFIED DEVICE FOR OUTPUT
ODNUMB,	0			/OUTPUT DEVICE NUMBER

/	PARITY VARIABLES.						/014 CJL

/MARK,	0200			/SET BIT [8] FOR COMMAND INPUTS 	/A013
/PARITY,0			/PARITY MASK (0=SPACE, 200=MARK)	/AM013

/	INTERNAL FILE MODE FLAG.					/019 CJL

FILMODE,FMODE			/ASCII=0177, BINARY=4377		/019 CJL

/	UPPER-CASE ONLY FLAG.						/023 CJL

UPONLY,	LOWER			/0=UPPER/LOWER CASE, -40=UPPER-CASE ONLY/030 CJL

/	<^C> DISPATCH ADDRESS.						/023 CJL

UCADDRE,SBOOT			/<^C> ADDRESS SHOULD BE SET AS NECESSARY/023 CJL

/	<^P> DISPATCH ADDRESS.						/023 CJL

UPADDRE,CHKCLR			/<^P> ADDRESS SHOULD BE SET AS NECESSARY/023 CJL

/	ESCAPE CHARACTER FOR CONNECT MODE.				/025 CJL

ESCHAR,	ESCAPE			/ESCAPE CHARACTER FOR CONNECT MODE	/025 CJL

/	FLOW CONTROL FLAG.						/026 CJL

FLOWFLA,-FLOW			/0=NO FLOW CONTROL, 7777=FLOW CONTROL	/049 CJL
				/VIA <^S>/<^Q>

/	KEYBOARD INPUT ERROR FLAG.					/026 CJL

KEYERRO,.-.			/0=NO ERROR, NON-ZERO=BAD CHARACTER	/026 CJL
				/OR BUFFER OVERRUN
/	REMOTE LINE INPUT ERROR FLAG.					/026 CJL

RINERRO,.-.			/0=NO ERROR, NON-ZERO=BAD CHARACTER	/026 CJL
				/OR BUFFER OVERRUN

/	REMOTE LINE OUTPUT FLOW CONTROL WAIT FLAG.			/026 CJL

REMWAIT,.-.			/0=DON'T WAIT, 4000=WAIT FOR <^Q>	/026 CJL

/	REMOTE INPUT WAIT FLAG.						/026 CJL

/	FLAG STATES:

/	VALUE			ACTION

/	0000			BUFFER IS LESS THAN  3/4  FULL.   INPUT FREELY ALLOWED
/				WITHOUT FLOW CONTROL RESTRICTIONS.   IF BUFFER BECOMES
/				3/4 FULL AND FLOW CONTROL IS  IN  EFFECT  THEN  CHANGE
/				STATE TO 0001.

/	0001			BUFFER IS NOW 3/4 FULL.  OUTPUT  <^S>  TO  REMOTE  AND
/				THEN CHANGE STATE TO 4000.

/	4000			WAITING FOR BUFFER TO EMPTY TO LESS THAN 1/4 FULL.  IF
/				FLOW  CONTROL  IS BEING OBEYED, THEN BUFFER SHOULD NOW
/				BE EMPTYING.

/	7777			BUFFER  IS  NOW  LESS  THAN 1/4 FULL.  OUTPUT <^Q>  TO
/				REMOTE AND THEN CHANGE STATE TO 0000.

RINWAIT,.-.			/REMOTE INPUT WAIT FLAG			/026 CJL

/	REMOTE LINE OUTPUT BUFFER POINTERS.				/026 CJL

REMINSE,.-.			/REMOTE OUTPUT INSERTION POINTER	/026 CJL
REMREMO,.-.			/REMOTE OUTPUT REMOVAL POINTER		/026 CJL
/	POINTER FOR THE PACKET INPUT AND OUTPUT ROUTINES

	SPACK=	JMS I	.	/SEND A PACKET TO REMOTE
		SPACK0		/PUT IN A POINTER

	FPACK=	JMS I	.	/FORMAT PACKET
		FPACK0		/PUT IN THE POINTER

	RPACK=	JMS I	.	/RECEIVE A PACKET FROM REMOTE
		ILINK		/PUT IN A POINTER

/	POINTERS FOR OUTPUT ROUTINES

	PRI8B=	JMS I	.	/PRINT 8 BIT STRING ON TTY
		PRI8B0		/PUT IN THE POINTER

	REM8B=	JMS I	.	/SEND 8 BIT STRING DOWN REMOTE LINE
		REM8B0		/PUT IN THE POINTER

/	MISC.

	PACK6=	JMS I	.	/DEFINE CALL TO ROUTINE
		PACK60		/POINTER TO ROUTINE

	GET6=	JMS I	.	/DEFINE THE INSTRUCTION
		GET60		/PUT IN THE POINTER

	MOVE=	JMS I	.	/DEFINE CALL TO MOVE ROUTINE
		MOVE0		/POINTER

	CLEAR=	JMS I	.	/DEFINE CALL FOR "CLEAR" ROUTINE
		CLEAR0		/POINTER
	PAGE			/START ON NEW PAGE			/A014 CJL

/	KERMIT-12 PROGRAM STARTS HERE.					/A014 CJL

CLOOP,	JMP I	(INITIALIZE)	/**** INITIALIZED **** CLA CLL		/024 CJL
	JMS I	[CRESET]	/RESET CONSOLE ROUTINE STUFF
	DCA	ABFLAG		/CLEAR ABORT FLAG			/044 CJL
	DCA	REMWAIT		/CLEAR REMOTE FLOW CONTROL WAIT		/049 CJL
CLDMZAP,JMS	DMINIT		/INITIALIZE DECMATE PORT		/048 CJL

/	THE  PREVIOUS  INSTRUCTION  IS  FOR  DECMATE  OPERATION  ONLY.    THE  DEFAULT
/	INSTRUCTION IS FOR KL8 INTERFACES ONLY.

	*CLDMZAP		/OVERLAY DECMATE CODE			/048 CJL

CLDMZAP,NOP			/DON'T INITIALIZE DECMATE PORT		/048 CJL
	TAD	RATE		/GET BAUD RATE
SETBAUD,MSB			/SET REMOTE BAUD RATE			/050 CJL

/	THE PREVIOUS INSTRUCTION IS FOR DECMATE II OPERATION ONLY.	/050 CJL

	*SETBAUD		/OVERLAY DECMATE II CODE		/050 CJL

SETBAUD,NOP			/NOT APPLICABLE ON DECMATE I		/050 CJL

/	THE  PREVIOUS  INSTRUCTION  IS  FOR DECMATE I OPERATION  ONLY.    THE  DEFAULT
/	INSTRUCTION IS FOR KL8 INTERFACES ONLY.

	*SETBAUD		/OVERLAY DECMATE I CODE			/050 CJL

SETBAUD,RSBIOT			/SET REMOTE BAUD RATE			/050 CJL
	JMS I	[SCRIBE]	/DO A					/025 CJL
	CRLF			/<CR>, <LF>				/025 CJL
	JMS I	[SCRIBE]	/GIVE THEM THE				/025 CJL
	PRMTMSG			/PROMPT MESSAGE				/025 CJL
	JMS I	(LININP)	/GET INPUT LINE FROM USER
	TAD	(CMDTBL)	/GET ADDRESS OF PARSE TABLE		/M014 CJL
	DCA	PTABLE		/STORE FOR PARSER
	TAD	(LINBUF)	/GET INPUT LINE BUFFER ADDRESS		/M014 CJL

CLOOP1,	JMS I	(KEYPRS)	/PARSE OFF A KEYWORD
	JMP	CLOOP9		/NO MATCH ON KEYWORD
	JMP	CLOOP		/END OF LINE DETECTED
	DCA	LPTR		/STORE POINTER TO NEXT POS ON LINE
	JMS I	KEYDSP		/DISPATCH TO SERVICE
	JMP	CLOOP7		/ERROR RETURN FROM SERVICE DISPATCH
	TAD	LPTR		/RE-GET COMMAND LINE POINTER
	JMP	CLOOP1		/CONTINUE LINE PARSE

CLOOP7,	SNA			/SKIP IF A RETURNING MESSAGE PASSED	/029 CJL
	JMP	CLOOP		/JUST GO BACK TO COMMAND LOOP		/029 CJL
	DCA	RETARG		/STORE IN-LINE				/029 CJL
	JMS I	[SCRIBE]	/CALL MESSAGE PRINT ROUTINE
RETARG,	.-.			/WILL BE PASSED MESSAGE ADDRESS
	JMP	CLOOP		/KEEP GOING
CLOOP9,	JMS I	[SCRIBE]	/COMPLAIN OF				/025 CJL
	CMERMSG			/BAD COMMAND				/025 CJL
	JMP	CLOOP		/GO AGAIN

/	ROUTINE TO FORMAT A PACKET OF DATA
/	CALL:	FPACK
/		DATA ADDRESS (DATA MUST ALREADY BE CONTROL/QUOTED AND MUST
/			      NOT BE LONGER THAN THE LARGEST PACKET)
/		PACKET TYPE

FPACK0,	0
	CLA CLL			/INSURE CLEAR AC
	TAD I	FPACK0		/GET THE DATA ADDRESS
	DCA	FP1		/STORE IN SOURCE POINTER
	ISZ	FPACK0		/BUMP ARGUMENT POINTER
	TAD I	FPACK0		/NOW GET TYPE
	DCA I	(RSTYP)		/STORE
	ISZ	FPACK0		/BUMP ARGUMENT POINTER
	TAD	(RSDTA		/GET ADDRESS OF DATA BUFFER
	DCA	FP2		/STORE IN DESTINATION POINTER

 	TAD	(40+3		/SET FOR LENGTH COUNTER
	DCA I	(RSLEN)		/STORE IN PACKET
	DCA	FP3		/INIT CHECKSUM
	TAD	CURSEQ		/GET CURRENT SEQ NUMBER
	AND	[77]		/MODULO 64				/014/016 CJL
	TAD	[40]		/TAKE CHAR(SEQUENCE NUMBER)		/014/016 CJL
	DCA I	(RSSEQ)		/PUT INTO PACKET
FPACK2,	TAD I	FP1		/GET A CHAR FROM SOURCE
	SPA			/SKIP IF NOT END
	JMP	FPACK3		/END
	TAD	FP3		/COMBINE WITH CHECKSUM
	DCA	FP3		/AND RETURN
	TAD I	FP1		/GET CHAR BACK AGAIN
	DCA I	FP2		/NOW PUT INTO DESTINATION
	ISZ I	(RSLEN)		/BUMP THE LENGTH
	ISZ	FP1		/BUMP THE SOURCE POINTER
	ISZ	FP2		/BUMP THE DESTINATION POINTER
	JMP	FPACK2		/LOOP
FPACK3,	CLA CLL			/CLEAR THE AC
	TAD	FP3		/GET CALCULATED CHECKSUM
	TAD I	(RSLEN)		/INCLUDE THE LENGTH
	TAD I	(RSSEQ)		/AND THE SEQUENCE
	TAD I	(RSTYP)		/AND THE TYPE
	JMS I	[CKSUM]		/GET IT CORRECT
	DCA I	FP2		/STORE WITH PACKET
	ISZ	FP2		/BUMP PACKET POINTER
	TAD	REOL		/GET ANY END OF LINE TO INCLUDE
	TAD	[-40]		/MAKE IT A REAL CHARACTER		/014/016 CJL
	SNA			/SKIP IF EOL CHAR REQUIRED
	JMP	FPACK4		/NO EOL CHAR
	DCA I	FP2		/STORE EOL CHAR WITH PACKET
	ISZ	FP2		/BUMP POINTER
FPACK4,	NL7777			/SET -1					/032 CJL
	DCA I	FP2		/PACKET NOW COMPLETE
	TAD	RETRY		/SET UP RE-TRY COUNTER
	DCA	RTRYC
	ISZ	CURSEQ		/BUMP SEQUENCE NUMBER FOR NEXT TIME
	NOP			/PROTECT ISZ
	JMP I	FPACK0		/RETURN

FP1,	0			/POINTER TO SOURCE DATA
FP2,	0			/POINTER TO PACKET BUFFER
FP3,	0			/RUNNING CHECKSUM

/	DECMATE INITIALIZE ROUTINE.				/048 CJL

DMINIT,	.-.			/DECMATE PORT INITIALIZE ROUTINE/048 CJL
DMI01,	TAD	DM234/(234)	/GET SCD ENABLE VALUE		/050 CJL
DMI02,	WCON0			/WRITE CONTROL REGISTER 0 (1)	/050 CJL
DMI03,	NL0000			/INDICATE PORT 0 (1)		/050 CJL
DMI04,	RACD			/RESET THE ACTIVE PORT		/050 CJL
DMI05,	ISZ	DMWASTE		/WASTE				/050 CJL
DMI06,	JMP	DMI05		/SOME TIME			/050 CJL
DMI07,	ISZ	DMWASTE		/WASTE				/050 CJL
DMI08,	JMP	DMI07		/SOME TIME			/050 CJL
DMI09,	RTFL0			/SET PORT 0 (1) OUTPUT FLAG	/050 CJL
DMI10,	TAD	DM2516/(2516)	/SETUP FOR 8 BITS, NO PARITY	/050 CJL
DMI11,	JMS	DMSEND		/SEND TO MODE REGISTER 1	/050 CJL
DMI12,	TAD	RATE		/GET BAUD RATE			/050 CJL
DMI13,	TAD	DM2460/(2460)	/ADD ON CLOCK ENABLE VALUES	/050 CJL
DMI14,	JMS	DMSEND		/SEND TO MODE REGISTER 2	/050 CJL
DMI15,	TAD	DM3425/(3425)	/GET ENABLE AND RESET VALUE	/050 CJL
DMI16,	JMS	DMSEND		/SEND TO COMMAND REGISTER	/050 CJL
DMI17,	RKRB0			/DO A DUMMY READ ON PORT 0 (1)	/050 CJL
/	THE  PREVIOUS  INSTRUCTIONS  ARE  FOR  DECMATE	I OPERATION ONLY.  THE DEFAULT
/	INSTRUCTIONS ARE FOR DECMATE II, ETC.  INTERFACES ONLY.

	*DMI01			/OVERLAY DECMATE I CODE		/050 CJL

DMI01,	ISZ	DMWASTE		/WASTE				/048 CJL
DMI02,	JMP	DMI01		/SOME TIME			/048 CJL
DMI03,	ISZ	DMWASTE		/WASTE				/048 CJL
DMI04,	JMP	DMI03		/SOME TIME			/048 CJL
DMI05,	ISF			/SKIP ON AND CLEAR PORT FLAG	/048 CJL
DM50,	50/NOP			/JUST IN CASE			/048 CJL
DMI07,	IRB			/READ THE PORT BUFFER		/048 CJL
DMI08,	CLA			/CLEAN UP			/048 CJL
DMI09,	TAD	DM50/(50)	/GET OUTPUT INTERRUPT VALUE	/048 CJL
DMI10,	MPSCC			/CLEAR OUTPUT INTERRUPT		/048 CJL
DMI11,	TAD	(60-50)		/GET ERROR RESET VALUE		/048 CJL
DMI12,	MPSCC			/CLEAR OVERRUN ERRORS		/048 CJL
DMI13,	TAD	(70-60)		/SET END OF INTERRUPT VALUE	/048 CJL
DMI14,	MPSCC			/CLEAR THE INTERRUPT		/048 CJL
DMI15,	DCA	OUTFLAG		/INDICATE OUTPUT IS AVAILABLE	/048 CJL
DMI16,	DCA	INFLAG		/CLEAR INPUT AVAILABLE FLAG	/048 CJL
DMI17,	JMP I	DMINIT		/RETURN				/048 CJL

/	DECMATE I INITIALIZE CODE CONTINUES HERE.		/050 CJL

DMISET,	RTFL0			/SET PORT 0 (1) OUTPUT FLAG	/050 CJL
	CLA			/CLEAN UP			/050 CJL
	JMP I	DMINIT		/RETURN				/050 CJL

DMSEND,	.-.			/DECMATE I SEND ROUTINE		/050 CJL
DMISKP,	RTSF0			/SKIP ON PORT 0 (1) OUTPUT FLAG	/050 CJL
	JMP	DMISKP		/WAIT FOR IT			/050 CJL
DMIOUT,	RTLS0			/SEND TO PORT 0 (1) REGISTER	/050 CJL
	CLA			/CLEAN UP			/050 CJL
	JMP I	DMSEND		/RETURN				/050 CJL

DMWASTE,.-.			/TIMER TEMPORARY		/050 CJL
DM234,	234			/CONSTANT 0234			/050 CJL
DM2460,	2460			/CONSTANT 2460			/050 CJL
DM2516,	2516			/CONSTANT 2516			/050 CJL
DM3425,	3425			/CONSTANT 3425			/050 CJL

	PAGE
/	ROUTINE TO SEND THE FORMATTED PACKET			/027 CJL
/	ARGUMENTS:  CALL+1 NON-ZERO = AWAIT RESPONSE
/			       ZERO = DO NOT AWAIT RESPONSE
/		    CALL + 2 DISPATCH TABLE-2			/027 CJL

SPACK0,	0
	REM8B;	RSBUF		/SEND PACKET JUST COMPLETED
	TAD I	SPACK0		/DO WE GET A RESPONSE?
	ISZ	SPACK0		/BUMP POINTER PAST ARGUMENT
	SNA CLA			/SKIP IF YES
	JMP I	SPACK0		/ALL DONE HERE
	RPACK			/GET PACKET BACK FROM REMOTE
	TAD I	SPACK0		/DID WE WANT A DISPATCH?
	ISZ	SPACK0		/BUMP PAST ARGUMENT
	SNA			/SKIP IF YES
	JMP I	SPACK0		/EXIT IF NO
	DCA	SPACARG		/STORE IN-LINE				/031 CJL
	JMS	DISPATCH	/CALL DISPATCH ROUTINE			/031 CJL
SPACARG,.-.			/WILL BE DISPATCH TABLE-2		/031 CJL
	JMP I	SPACK0		/NOT FOUND, GOTTA RETURN

/	CONSOLE RESET ROUTINE.						/024 CJL

CRESET,	.-.			/CONSOLE RESET ROUTINE
	CLA CLL			/CLEAN UP
	DCA	ECHOSW		/ENABLE OUTPUT ECHO
	TAD	(UPCPRT)	/ALLOW THEM TO
	DCA	UCADDRESS	/RESTART VIA <^C>
	TAD	[CLOOP]		/ALLOW THEM TO
	DCA	UPADDRESS	/RESTART VIA <^P>
	JMP I	CRESET		/RETURN

/	ALTERNATE CONSOLE RESET ROUTINE.				/025 CJL

CREST2,	.-.			/ALTERNATE CONSOLE RESET ROUTINE
	JMS	CRESET		/CLEAR AC AND ENABLE OUTPUT ECHO
	TAD	(KCCZAP)	/RENDER <^C>
	DCA	UCADDRESS	/TOTALLY HARMLESS
	TAD	(CHKCLR)	/MAKE <^P> PRINT "^P"
	DCA	UPADDRESS	/AND THEN GO AWAY
	JMP I	CREST2		/RETURN
/	ROUTINE TO CLEAR WORDS OF MEMORY
/	ENTER WITH:	AC = MINUS NUMBER OF WORDS TO CLEAR
/		    	MQ = ADDRESS OF WHERE TO START THE CLEAR

CLEAR0,	0
	DCA	CLEAR5		/STORE COUNT OF WORDS
	TAD	MQ		/GET ADDRESS TO CLEAR			/032 CJL
	DCA	CLEAR6		/STORE IN POINTER
	DCA I	CLEAR6		/ZERO A WORD
	ISZ	CLEAR6		/BUMP POINTER
	ISZ	CLEAR5		/BUMP COUNTER
	JMP	.-3		/LOOP
	JMP I	CLEAR0		/DONE

CLEAR5,	0			/TEMP FOR "CLEAR" ROUTINE
CLEAR6,	0			/TEMP FOR "CLEAR" ROUTINE

/	ROUTINE TO DISPATCH TO ROUTINE BASED ON VALUE OF "RRTYP".	/027 CJL

/	CALLING SEQUENCE:

/	CLA			/AC MUST BE CLEAR
/	JMS	DISPATCH	/CALL ROUTINE
/	ADDRESS-2		/DISPATCH TABLE ADDRESS-2
/	NO MATCH RETURN		/RETURNS HERE WITH CLEAR AC IF NO MATCH

/	CALL  WILL DISPATCH TO THE CORRESPONDING ROUTINE ON A MATCH IN  THE  SPECIFIED
/	TABLE (WHICH ENDS WITH ZERO) WITH A CLEAR AC.

DISPATC,.-.			/MATCH "RRTYP" AND DISPATCH ROUTINE
	CLA			/JUST IN CASE				/031 CJL
	TAD I	DISPATCH	/GET PASSED ARGUMENT
	ISZ	DISPATCH	/BUMP PAST THE ARGUMENT
	DCA	DISPA2		/SAVE PASSED ARGUMENT IN-LINE
	TAD I	(RRTYP)		/GET VALUE OF "RRTYP"
	CIA			/INVERT FOR TESTING
	JMS I	[SRCHTABLE]	/CALL TABLE SEARCH ROUTINE
DISPA2,	.-.			/WILL BE TABLE ADDRESS-2
	SNA CLA			/SKIP IF MATCH FOUND
	JMP I	DISPATCH	/RETURN ON NO MATCH
	JMP I	TABLEJUMP	/DISPATCH TO MATCHING ADDRESS
/	ROUTINE TO PUT CHARS INTO A BUFFER TO GET READY TO FORMAT A PACKET.
/	ENTER WITH CHAR IN THE AC; IF THE CHAR NEEDS CONTROL QUOTING, IT WILL BE ADDED
/	EXIT + 2 IF EVERYTHING IS OK
/	EXIT + 1 IF BUFFER IS FULL

OPBUF,	0			/PUT CHARACTERS INTO BUFFER FOR PACKET ROUTINE
	JMS I	(OPRE)		/CHECK FOR PREFIX
	JMP	OPBUF1		/NO PREFIX
	DCA	OP1		/SAVE CONVERTED CHAR
	TAD	RQCTL		/GET QUOTE CHAR TO USE
	DCA I	OP2		/PUT RETURNED PREFIX INTO BUFFER
	ISZ	OP2		/BUMP POINTER
	TAD	OP1		/GET BACK CONVERTED CHAR
OPBUF1,	DCA I	OP2		/PUT INTO BUFFER
	ISZ	OP2		/BUMP POINTER
	NL7777			/SET -1					/032 CJL
	DCA I	OP2		/ALWAYS TERMINATE BUFFER
	TAD	RMAXL		/GET MAX BUFFER LENGTH
	TAD	(-40+HOLDBF-4	/
	CIA
	TAD	OP2		/COMPARE WITH WHAT WE HAVE
	SPA CLA			/SKIP IF NO ROOM
	JMP	OPBUF2		/HAVE ROOM
	JMS	INIOPB		/RESET BUFFER
	JMP I	OPBUF		/TAKE RETURN + 1

OPBUF2,	ISZ	OPBUF		/BUMP RETURN FOR BUFFER NOT FULL
	JMP I	OPBUF		/DONE

OP1,	0			/TEMP LOCATION
OP2,	HOLDBF			/POINTER FOR HOLD BUFFER

/	ROUTINE TO RE-SET THE HOLD BUFFER.

INIOPB,	0
	TAD	(HOLDBF		/RE-SET BUFFER POINTER
	DCA	OP2
	JMP I	INIOPB

/	ROUTINE TO CALCULATE A 1 BYTE CHECKSUM.

CKSUM,	0
	DCA	CKSUM1		/STORE TEMP
	TAD	CKSUM1		/GET BACK
	RTR;RTR;RTR		/GET TWO HIGHEST INTO TWO LOWEST	/032 CJL
	AND	(3		/KEEP ONLY BITS 0-1
	TAD	CKSUM1		/GET ORIGINAL
	AND	[77]		/KEEP ONLY BITS 0-5			/016 CJL
	TAD	[40]		/MAKE A CHAR(CHECKSUM)
	JMP I	CKSUM		/DONE, RETURN IN AC

CKSUM1,	0			/TEMP FOR "CKSUM"
	PAGE
/	ROUTINE TO INPUT CHARS FROM REMOTE UNTIL A "SOH" CHAR IS FOUND.

GETSOH,	0
	JMS	COMIN		/GET A CHARACTER FROM THE REMOTE LINE	/046 CJL
	JMP I	GETSOH		/TIME-OUT
	AND	[177]		/IGNORE PARITY BIT			/034 CJL
	TAD	(-CNTRLA)	/COMPARE WITH "SOH"			/034 CJL
	SZA CLA			/SKIP IF SAME
	JMP	GETSOH+1	/LOOP TILL WE GET ONE
	ISZ	GETSOH		/BUMP FOR GOOD RETURN
	JMP I	GETSOH		/GOT ONE, DONE


/	ROUTINE TO GET A CHAR FROM THE REMOTE LINE AND UPDATE CHECKSUM.

GETIR,	0
	JMS	COMIN		/GET A CHARACTER FROM THE REMOTE LINE	/046 CJL
	JMP I	GETIR		/TIME-OUT RETURN
	DCA	GETIR1		/STORE TEMP
	TAD	GETIR1		/GET CHAR BACK
	TAD I	(ILINK9)	/ADD CHECKSUM
	DCA I	(ILINK9)	/RETURN UPDATED CHECKSUM
	TAD	GETIR1		/RE-GET CURRENT INPUT CHAR
	TAD	[-15]		/CHECK FOR A RETURN
	SNA CLA			/SKIP IF NOT A RETURN
	JMP I	GETIR		/WAS A RETURN, TAKE EXIT + 1
	TAD	GETIR1		/RE-GET CHAR FOR RETURN
	ISZ	GETIR		/BUMP FOR GOOD RETURN
	JMP I	GETIR		/AND RETURN IN THE AC

GETIR1,	0			/TEMP LOCAL TO "GETIR"
/	REMOTE COMMUNICATIONS ROUTINES FOR NON-CONNECT USAGE.		/046 CJL

/	REMOTE INPUT ROUTINE.						/046 CJL

COMIN,	.-.			/REMOTE INPUT ROUTINE			/046 CJL
	CLA			/CLEAN UP				/046 CJL
	TAD	[-15]		/SETUP THE				/049 CJL
	DCA	TIMEOUT		/TIME-OUT FACTOR			/046 CJL
INLUP,	TAD	INFLAG		/IS INPUT AVAILABLE?			/046 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE  II USE ONLY.  THE DEFAULT INSTRUCTION IS
/	FOR KL8 INTERFACES.

	*INLUP			/OVERLAY DECMATE II CODE		/049 CJL

INLUP,	SKP			/WE'RE NOT A DECMATE II			/049 CJL
	SNA CLA			/SKIP IF INPUT AVAILABLE (ON DECMATE II)/049 CJL
INSKIP,	JMP	NOTYET		/JUMP IF NOT				/049 CJL
INLUP1,	DCA	INFLAG		/CLEAR INPUT AVAILABILITY FLAG		/049 CJL
INREAD,	IRB			/GET THE CHARACTER			/049 CJL

/	THE ABOVE INSTRUCTIONS ARE FOR DECMATE II  USE ONLY.  THE DEFAULT INSTRUCTIONS
/	ARE FOR KL8 INTERFACES.

	*INSKIP			/OVERLAY DECMATE II CODE		/049 CJL

INSKIP,	RKSFIOT			/INPUT FLAG UP?				/049 CJL
INLUP1,	JMP	NOTYET		/NO, CHECK FOR ABORT, ETC.		/049 CJL
INREAD,	RKRBIOT			/YES, READ IN THE CHARACTER		/049 CJL
	AND	[177]		/JUST SEVEN-BIT				/046 CJL
	DCA	RCHAR		/SAVE THE CHARACTER			/046 CJL
	TAD	RCHAR		/GET IT BACK				/046 CJL
	ISZ	COMIN		/BUMP TO GOOD RETURN			/046 CJL
	JMP I	COMIN		/RETURN					/046 CJL

/	COMES HERE IF INPUT NOT AVAILABLE.

NOTYET,	JMS I	(CTLCTST)	/CHECK FOR <^C>, ETC.			/044 CJL
	TAD	[-CNTRLZ]	/COMPARE POSSIBLE CHARACTER TO <^Z>	/044 CJL
	SZA			/SKIP IF IT ALREADY MATCHES		/044 CJL
	TAD	[-CNTRLX+CNTRLZ]/ELSE COMPARE TO <^X>			/044 CJL
	SNA CLA			/SKIP IF NEITHER ABORT CHARACTER	/049 CJL
	ISZ	ABFLAG		/SET ABORT FLAG				/049 CJL
	SKP			/SKIP IF NOT TOO MANY TIMES		/049 CJL
	JMP	.-2		/ENSURE FLAG SETTING			/049 CJL
INSTATU,JMS	UPSTATUS	/UPDATE THE PORT STATUS			/049 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE  II USE ONLY.  THE DEFAULT INSTRUCTION IS
/	FOR KL8 INTERFACES.

	*INSTATUS		/OVERLAY DECMATE II CODE		/049 CJL

INSTATU,NOP			/WE'RE NOT A DECMATE II			/049 CJL
	ISZ	WASTIME		/WASTE SOME TIME			/046 CJL
	JMP	INLUP		/KEEP TRYING				/046 CJL
	ISZ	TIMEOUT		/WAITING TOO LONG?			/046 CJL
	JMP	INLUP		/NO, KEEP TRYING			/046 CJL
	JMP I	COMIN		/YES, TAKE ERROR RETURN			/046 CJL

/	FLOW-CONTROL STATUS ROUTINE.					/049 CJL

GETFLOW,.-.			/GET FLOW-CONTROL STATUS
GETFL1,	JMS	UPSTATUS	/UPDATE THE CURRENT STATUS

/	THE ABOVE INSTRUCTION IS FOR DECMATE II USE ONLY.   THE DEFAULT INSTRUCTION IS
/	FOR KL8 INTERFACES.

	*GETFL1			/OVERLAY DECMATE II CODE

GETFL1,	NOP			/WE'RE NOT A DECMATE II
	JMS I	(RINGET)	/GET REMOTE CHARACTER (IF ANY)
	CLA			/THROW IT AWAY
	TAD	REMWAIT		/GET REMOTE FLOW STATUS
	JMP I	GETFLOW		/RETURN

/	REMOTE OUTPUT ROUTINE.						/046 CJL

COMOUT,	.-.			/REMOTE OUTPUT ROUTINE			/046 CJL
	DCA	OUTEMP		/SAVE PASSED VALUE			/046 CJL
CMRESET,TAD	[-15]		/SETUP THE				/049 CJL
	DCA	OTIME		/TIME-OUT COUNTER			/049 CJL
COMWAIT,JMS	GETFLOW		/GET REMOTE WAIT STATUS			/049 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE USE ONLY.  THE DEFAULT INSTRUCTION IS FOR
/	KL8 INTERFACES.

	*COMWAIT		/OVERLAY DECMATE CODE			/049 CJL

COMWAIT,NL7777			/SETUP FOR FLOW CONTROL FLAG LOAD	/049 CJL
	AND	FLOWFLAG	/SHOULD WE WAIT FOR REMOTE FLOW CONTROL?/049 CJL
	SNA CLA			/SKIP IF SO				/049 CJL
	JMP	NOWAIT		/JUMP IF NOT				/049 CJL
FLOWAIT,JMS	GETFLOW		/GET REMOTE WAIT STATUS			/049 CJL
	SZA CLA			/SKIP IF NOT WAITING			/049 CJL
	JMP	FLOWAIT		/JUMP IF STILL WAITING			/049 CJL
NOWAIT,	TAD	OUTFLAG		/CHECK IF OUTPUT IS AVAILABLE		/049 CJL
CMOUT1,	SNA CLA			/SKIP IF SO				/049 CJL
CMOUT2,	JMP	OWAIT		/JUMP IF NOT				/049 CJL
DM1AND,	DCA	OUTFLAG		/CLEAR OUTPUT AVAILABILITY FLAG		/049 CJL
CMOUT3,	TAD	OUTEMP		/GET THE PASSED VALUE			/049 CJL
CMOUT4,	OLS			/OUTPUT IT				/049 CJL

/	THE ABOVE INSTRUCTIONS ARE FOR DECMATE II  USE ONLY.  THE DEFAULT INSTRUCTIONS
/	ARE FOR KL8 INTERFACES.

	*NOWAIT			/OVERLAY DECMATE II CODE		/049 CJL

NOWAIT,	RTSFIOT			/OUTPUT FLAG UP?			/049 CJL
CMOUT1,	JMP	OWAIT		/NO, WAIT FOR IT THERE			/049 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE I USE  ONLY.   THE DEFAULT INSTRUCTION IS
/	FOR KL8 INTERFACES.

	*CMOUT1			/OVERLAY DECMATE I CODE			/049 CJL

CMOUT1,	JMP	COMWAIT		/NO, WAIT FOR IT			/049 CJL
CMOUT2,	TAD	OUTEMP		/YES, GET PASSED VALUE			/049 CJL
DM1AND,	AND	[377]		/ENSURE EIGHT BITS (FOR DECMATE I)	/049 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE I USE ONLY.    THE DEFAULT INSTRUCTION IS
/	FOR KL8 INTERFACES.

	*DM1AND			/OVERLAY DECMATE I CODE			/049 CJL

DM1AND,	SKP			/WE'RE NOT A DECMATE I			/049 CJL
CMOUT3,	TAD	[400]		/FORCE OUTPUT WRITE FOR DECMATE I	/049 CJL
CMOUT4,	RTLSIOT			/OUTPUT THE CHARACTER			/049 CJL
	CLA			/CLEAN UP				/049 CJL
	JMP I	COMOUT		/RETURN					/049 CJL

/	COMES HERE IF OUTPUT NOT READY.					/049 CJL

OWAIT,	ISZ	OWASTE		/WASTE SOME TIME			/049 CJL
	JMP	COMWAIT		/KEEP TRYING				/049 CJL
	ISZ	OTIME		/WAITING TOO LONG?			/049 CJL
	JMP	COMWAIT		/NO, KEEP TRYING			/049 CJL
	JMS I	(DMINIT)	/YES, RESET EVERYTHING			/049 CJL
	JMP	CMRESET		/TRY, TRY AGAIN				/049 CJL
/	DECMATE II, ETC. STATUS UPDATE ROUTINE.				/046 CJL

UPSTATU,.-.			/UPDATE THE STATUS ROUTINE		/046 CJL
	ISF			/COMMUNICATIONS PORT FLAG UP?		/046 CJL
	JMP I	UPSTATUS	/NO, RETURN				/046 CJL
	NL4000			/SETUP READ OF REGISTER ZERO		/046 CJL
	MPSCC			/TELL THE MPSCC CHIP			/046 CJL
	CLA			/CLEAN UP				/046 CJL
	MPSCC			/READ REGISTER ZERO NOW			/046 CJL
	AND	(5)		/JUST INPUT AND OUTPUT BITS		/046 CJL
	CLL RAR			/MOVE INPUT TO LINK			/046 CJL
	SNA CLA			/SKIP IF OUTPUT INTERRUPT		/046 CJL
	JMP	INCHK		/JUMP IF NOT				/046 CJL
	TAD	(050)		/GET OUTPUT CLEAR VALUE			/046 CJL
	MPSCC			/CLEAR THE OUTPUT INTERRUPT		/046 CJL
	DCA	OUTFLAG		/INDICATE OUTPUT AVAILABLE NOW		/046 CJL
INCHK,	CLA RAL			/GET RECEIVE STATUS			/046 CJL
	SZA			/SKIP IF INPUT NOT AVAILABLE RIGHT NOW	/046 CJL
	DCA	INFLAG		/INDICATE NEW INPUT STATUS		/046 CJL
	CLA			/CLEAN UP EITHER WAY			/046 CJL
	TAD	(070)		/GET END OF INTERRUPT VALUE		/046 CJL
	MPSCC			/CLEAR THE INTERRUPT			/046 CJL
	CLA			/CLEAN UP				/046 CJL
	JMP I	UPSTATUS	/RETURN					/046 CJL

	AND377=	AND	[377]	/INSTRUCTION CONSTANT			/049 CJL
	OUTEMP=	COMIN		/OUTPUT ROUTINE TEMPORARY		/049 CJL
	TIMEOUT=GETFLOW		/TIME-OUT TEMPORARY			/049 CJL
	WASTIME=COMOUT		/TIME-OUT TEMPORARY			/049 CJL

OTIME,	.-.			/TIME-OUT TEMPORARY			/049 CJL
OWASTE,	.-.			/TIME-OUT TEMPORARY			/049 CJL

	PAGE

/	HOLD BUFFER FOR CHAR OUTPUT

	DECIMAL

HOLDBF,	ZBLOCK	92

	OCTAL
/	ROUTINE TO CHECK FOR CONTROL PREFIX.
/	ENTER WITH CHAR TO CHECK IN THE AC.
/	EXIT + 1 WITH CHAR IN THE AC IF NO PREFIX QUOTING.
/	EXIT + 2 WITH PROPER CHAR IN THE AC AND QUOTING IS REQUIRED.

OPRE,	0			/CHECK FOR CONTROL PREFIX ROUTINE
	DCA	PRETEMP		/SAVE THE CHARACTER			/032 CJL
	TAD	QFLAG		/CHECK FOR IN CTRL QUOTE MODE
	SZA CLA			/SKIP IF YES
	JMP	OPRE1		/NO QUOTE PREFIX
	TAD	PRETEMP		/GET THE CHARACTER			/032 CJL
	AND	[7740]		/QUICK CHECK FOR <40			/014/016 CJL
	SNA CLA			/SKIP IF NOT CONTROL
	JMP	OPRE2		/PREFIX QUOTE
	TAD	PRETEMP		/GET THE CHARACTER			/032 CJL
	TAD	(-177		/CHECK FOR "DELETE"
	SNA CLA			/SKIP IF NOT
	JMP	OPRE2		/PREFIX QUOTE
	TAD	PRETEMP		/GET THE CHARACTER			/032 CJL
	CIA			/NEGATE FOR COMPARE
	TAD	RQCTL		/SEE IF SAME AS QUOTE CHAR
	SZA CLA			/SKIP IF PREFIX QUOTE
	JMP	OPRE1		/NO PREFIX QUOTE
	TAD	RQCTL		/PREFIX WITH PREFIX
	JMP	OPRE3		/PREFIX WITH THE PREFIX

OPRE1,	TAD	PRETEMP		/GET THE CHARACTER			/032 CJL
	JMP I	OPRE		/DONE

OPRE2,	TAD	PRETEMP		/GET THE CHARACTER			/032 CJL
	TAD	[100]		/MAKE IT PRINTABLE			/016 CJL
	AND	[177]		/IN CASE IT WAS 177			/014/016 CJL

OPRE3,	ISZ	OPRE		/BUMP FOR PREFIX RETURN
	JMP I	OPRE		/DONE

PRETEMP,.-.			/PREFIX TEMPORARY			/032 CJL

	PAGE								/014 CJL
/	ROUTINE TO SCAN A TEXT LINE FOR KEYWORD DELIMITERS.

/	THIS  ROUTINE EXPECTS THE AC TO POINT TO A TEXT LINE TO  SCAN  AND  FINDS  THE
/	FIRST NON-SPACE, NON-END OF LINE CHAR IN THE LINE AND SETS "SCAN1" TO POINT TO
/	IT.  NEXT WE FIND THE LAST CHAR IN THE LINE THAT IS A  NON-SPACE,  NON-END  OF
/	LINE  AND  STORE  A  POINTER  TO  IT  IN "SCAN2".  KEYWORDS ARE DELIMITED BY A
/	BEGINNING OF  LINE  OR SPACE AT THE BEGINNING AND AN END OF LINE OR A SPACE AT
/	THE END.

/	ENTER:	AC = POINTER TO COMMAND LINE

/	EXIT: (SUCCESS)	SCAN1 = POINTER TO FIRST CHAR OF KEYWORD.
/			SCAN2 = POINTER TO LAST CHAR OF KEYWORD.
/			RETURN = RETURN + 2 (NO WORDS LEFT IN LINE).

/	EXIT: (FAIL)	RETURN = RETURN + 1.

SCNEL,	0			/SCAN ROUTINE
	JMS I	[NOSP]		/FIND FIRST NON-SPACE
	JMP I	SCNEL		/END OF LINE RETURN
	DCA	SCAN1		/RETURN SCAN LINE POINTER
	TAD	SCAN1		/RE-GET SCAN LINE POINTER
	JMS I	[SP]		/FIND FIRST SPACE OR EOL
	NOP			/RETURN HERE ON EOL
	TAD	(-1		/BACK UP TO PREVIOUS CHAR
	DCA	SCAN2		/SET END ELEMENT POINTER
	ISZ	SCNEL		/TAKE SUCCESS RETURN
	JMP I	SCNEL		/DONE


/	ROUTINE TO SCAN THRU A TEXT LINE LOOKING FOR THE NEXT SPACE.
/	ENTER ROUTINE WITH THE LINE POINTER IN THE AC.

/	EXIT:	RETURN + 2 WITH AC = POINTER TO SPACE.
/		RETURN + 1 WITH AC = POINTER TO END OF LINE.

SP,	0			/CHECK FOR A <SPACE> ROUTINE
	DCA	SCANTP		/USE A TEMP POINTER
	SKP			/SKIP INTO LOOP BELOW
SP1,	ISZ	SCANTP		/BUMP LINE POINTER
	TAD I	SCANTP		/GET A CHAR
	SPA			/SKIP IF NOT END OF LINE
	JMP	SP3		/GOT AN END OF LINE
	TAD	[-" !200]	/COMPARE WITH <SP>			/034 CJL
	SZA CLA			/SKIP IF IS A SPACE
	JMP	SP1		/LOOP TILL SPACE OR EOL
	ISZ	SP		/BUMP RETURN FOR SPACE FOUND

SP3,	CLA CLL			/INSURE A CLEAR AC
	TAD	SCANTP		/GET POINTER VALUE
	JMP I	SP		/RETURN IN AC
/	ROUTINE TO SCAN THRU A TEXT LINE FOR THE FIRST NON-SPACE.
/	ENTER ROUTINE WITH POINTER TO THE LINE IN THE AC.

/	EXIT:	RETURN + 2 WITH AC = POINTER TO NON-SPACE.
/		RETURN + 1 WITH AC = POINTER TO END OF LINE.

NOSP,	0			/FIND A NON-<SPACE> ROUTINE
	DCA	SCANTP		/USE A TEMP POINTER
	SKP			/SKIP INTO LOOP BELOW
NOSP1,	ISZ	SCANTP		/BUMP THE LINE POINTER
	TAD I	SCANTP		/GET A CHAR FROM THE LINE
	SPA			/SKIP IF NOT EOL
	JMP	NOSP3		/EXIT IF EOL
	TAD	[-" !200]	/COMPARE WITH <SP>			/034 CJL
	SNA CLA			/SKIP IF NOT SPACE
	JMP	NOSP1		/LOOP TILL SPACE OR EOL
	ISZ	NOSP		/BUMP RETURN FOR SPACE FOUND
NOSP3,	CLA CLL			/INSURE CLEAR AC
	TAD	SCANTP		/GET POINTER
	JMP I	NOSP		/RETURN IN AC



/	ROUTINE TO FIND AN END CHAR IN A STRING.
/	ENTER ROUTINE WITH POINTER TO THE STRING IN THE AC.
/	EXIT WITH THE POINTER TO THE FIRST MINUS CHAR IN THE AC.

FNDEND,	0			/FIND END CHAR ROUTINE
	DCA	SCANTP		/PUT POINTER IN SCANTP
FEND1,	TAD I	SCANTP		/GET A CHAR FROM THE STRING
	SPA CLA			/SKIP IF NOT END
	JMP	FEND2		/EXIT IF END OF STRING
	ISZ	SCANTP		/BUMP THE POINTER
	JMP	FEND1		/LOOP TILL NON-END OF STRING

FEND2,	TAD	SCANTP		/GET POINTER TO NON-END OF STRING
	JMP I	FNDEND		/EXIT WITH POINTER IN AC

SCANTP,	0			/USED IN THE SCAN ROUTINES "SP", "NOSP", "FNDNUL"
/	ROUTINE TO LOOKUP THE KEY WORD POINTED TO BY THE AC IN THE	/014 CJL
/	TABLE POINTED TO BY PTABLE.

/	RETURN + 1 IF NO MATCH IS FOUND WITH AC = ENTRY VALUE.
/	RETURN + 2 IF NO KEYWORD IS FOUND (EOL DETECTED).
/	RETURN + 3 IF MATCH IS FOUND WITH THE NEXT PARSE POSITION IN THE LINE IN
/	THE AC AND THE DISPATCH ADDRESS FROM THE TABLE IN "KEYDSP".

KEYPRS,	.-.			/KEYWORD PARSE ROUTINE
	DCA	LOOK3		/SAVE IN CASE OF FAIL
	TAD	LOOK3		/RE-GET
/	AND	(137)		/MAKE CHARACTER UPPER-CASE, NO PARITY	/MD013
	JMS	SCNEL		/TRY TO SCAN OFF A KEYWORD
	JMP	KP45		/END OF LINE ENCOUNTERED
	TAD	PTABLE		/GET ADDRESS OF TABLE
	DCA	LOOK2		/STORE IN LOCAL POINTER

KP10,	TAD	SCAN1		/GET ADDRESS OF SCAN ELEMENT
	DCA	LOOK1		/INTO LOCAL POINTER

KP20,	TAD I	LOOK1		/GET A CHARACTER FROM THE SCAN ELEMENT
	CIA			/NEGATE FOR COMPARE
	TAD I	LOOK2		/GET A CHAR FROM THE TABLE ELEMENT
	SZA CLA			/SKIP IF MATCH
	JMP	KP90		/NO MATCH, SET TO LOOK AT NEXT TABLE ENTRY
	TAD	LOOK1		/CHECK IF ALL ENTERED CHARS MATCH
	CIA			/NEGATE TO COMPARE
	TAD	SCAN2		/HAVE WE MATCHED TO THE TERMINATOR?
	SNA CLA			/SKIP IF NO
	JMP	KP40		/YES, GOT ENOUGH TO MATCH
	ISZ	LOOK1		/MORE TO MATCH, BUMP SCAN ELEMENT POINTER
	ISZ	LOOK2		/BUMP TABLE ELEMENT POINTER
	JMP	KP20		/CONTINUE MATCH LOOP

KP40,	TAD	LOOK2		/GET CURRENT TABLE POINTER
	JMS	FNDEND		/FIND A NULL MARK
	IAC			/BUMP BY 1
	DCA	LOOK1		/STORE IN A POINTER
	TAD I	LOOK1		/GET DISPATCH ADDRESS
	DCA	KEYDSP		/PUT INTO DISPATCH ADDRESS
	ISZ	KEYPRS		/BUMP RETURN
	ISZ	KEYPRS		/BUMP AGAIN
	CLA CLL IAC		/AC = 1
	TAD	SCAN2		/GET POINTER TO END OF CURRENT KEY
	JMP I	KEYPRS		/RETURN

/	END OF LINE ENCOUNTERED ON PARSE.

KP45,	ISZ	KEYPRS		/BUMP RETURN ONCE FOR EOL

/	NO MATCHES IN THE TABLE HERE.

KP50,	TAD	LOOK3		/GET ORIGINAL AC
	JMP I	KEYPRS		/RETURN
/	FAILURE ON CURRENT TABLE ENTRY, SET FOR NEXT ENTRY (IF	THERE IS ONE)  AND TRY
/	AGAIN.

KP90,	TAD	LOOK2		/GET TABLE POINTER
	JMS	FNDEND		/FIND NEXT TABLE ENTRY
	IAC;IAC			/NEXT ENTRY IS 2 PAST THE NULL
	DCA	LOOK2		/RE-SET LOCAL TABLE POINTER
	TAD I	LOOK2		/CHECK END OF TABLE
	SNA CLA			/SKIP IF NOT END OF THE TABLE
	JMP	KP50		/TAKE NOT FOUND EXIT
	JMP	KP10		/TRY MATCH ON THIS ENTRY

LOOK1,	.-.			/TEMPORARY FOR KEYPRS			/014 CJL
LOOK2,	.-.			/TEMPORARY FOR KEYPRS			/014 CJL
LOOK3,	.-.			/TEMPORARY FOR KEYPRS			/014 CJL

/	ROUTINE TO MOVE WORDS OF MEMORY.				/014 CJL

/	CALLING SEQUENCE:

/	TAD	(DESTINATION)	/GET DESTINATION ADDRESS
/	DCA	MQ		/INTO MQ				/032 CJL
/	TAD	(-COUNT)	/GET -NUMBER OF WORDS TO MOVE
/	DCA	MOVE4		/SETUP MOVE COUNTER
/	TAD	(SOURCE)	/GET SOURCE ADDRESS
/	JMS I	(MOVE0)		/CALL MOVE ROUTINE
/	RETURN			/RETURNS HERE

MOVE0,	.-.			/MOVE ROUTINE				/014 CJL
	DCA	MOVE5		/STORE SOURCE ADDRESS IN LOCAL POINTER
	TAD	MQ		/GET DESTINATION ADDRESS		/032 CJL
	DCA	MOVE6		/STORE IN LOCAL POINTER
MOVE1,	TAD I	MOVE5		/GET A WORD FROM THE SOURCE
	DCA I	MOVE6		/MOVE TO DESTINATION
	ISZ	MOVE5		/BUMP SOURCE POINTER
	ISZ	MOVE6		/BUMP DESTINATION COUNTER
	ISZ	MOVE4		/BUMP COUNTER
	JMP	MOVE1		/LOOP
	JMP I	MOVE0		/DONE

MOVE5,	.-.			/SOURCE POINTER FOR "MOVE"
MOVE6,	.-.			/DESTINATION POINTER FOR "MOVE"

	PAGE								/014 CJL
/	ROUTINE TO PARSE OFF A DEVICE NAME FROM THE COMMAND LINE.	/O14 CJL

/	CALLING SEQUENCE:

/	TAD	(POINTER)	/AC CONTAINS POINTER TO COMMAND LINE
/	JMS I	[DPARS]		/CALL ROUTINE
/	ERROR RETURN		/AC UNCHANGED
/	GOOD RETURN		/AC NOW POINTS TO REST OF LINE

/	DEVNUM=	DEVICE NUMBER TO USE.
/	":" IS THE FIFTH CHARACTER IF NOT USING DEFAULT DEVICE.

DPARS,	.-.			/DEVICE PARSE ROUTINE			/014 CJL
	DCA	DPAR10		/SAVE INITIAL POINTER TO LINE
	TAD	DPAR10		/GET POINTER
	JMS I	[NOSP]		/GET PAST ANY LEADING SPACES
	JMP	DFDEV		/GOT END OF LINE, USE DEFAULT DEVICE
	DCA	DPAR11		/SAVE POINTER TO LINE
	DCA	DEVNAME		/INITIALIZE THE DEVICE NAME		/014 CJL
	DCA	DEVNAME+1	/FOR "INQUIRE" FUNCTION			/014 CJL
	TAD	(DEVNAM)	/GET ADDRESS OF WHERE TO PUT DEVICE NAME/014 CJL
	DCA	PACK6P		/STORE IN PACK6 POINTER
	DCA	PACK6F		/INITIALIZE PACK6 FLAG FOR LOW BYTE	/014 CJL
	TAD	(-4)		/SET UP A COUNTER			/014 CJL
	DCA	DPAR13		/FOR NO MORE THAN 4 CHARS
DPAR1,	TAD I	DPAR11		/GET A CHAR FROM THE LINE
	SNA			/SKIP IF NOT <EOL>			/014 CJL
	JMP	DFDEV		/GOT AN <EOL>, USE DEFAULT DEVICE	/014 CJL
	TAD	(-":!200)	/CHECK FOR ":"				/034 CJL
	SNA CLA			/SKIP IF NOT END OF DEVICE NAME
	JMP	DPAR2		/DEVICE NAME SET UP
	TAD I	DPAR11		/RE-GET CHAR
	ISZ	DPAR11		/BUMP LINE POINTER
	PACK6			/PACK SIX-BIT				/014 CJL
	ISZ	DPAR13		/BUMP CHARACTER COUNTER			/014 CJL
	JMP	DPAR1		/CAN CONTINUE
	TAD I	DPAR11		/GET CHARACTER AFTER THE FOURTH		/014 CJL
	TAD	(-":!200)	/CHECK FOR ":"				/034 CJL
	SZA CLA			/SKIP IF YES, ALL IS OK
	JMP	DFDEV		/USE THE DEFAULT DEVICE
DPAR2,	ISZ	DPAR11		/BUMP POINTER PAST ":"
	TAD	(DEVNAM)	/GET PARSED DEVICE NAME ADDRESS		/014 CJL
	JMP	DPAR4		/DO AN OS/8 "INQUIRE"

DFDEV,	CLA CLL			/CLEAN UP				/019 CJL
	TAD	DPAR10		/GET ORIGINAL AC FOR
	DCA	DPAR11		/RETURN POINTER
DPAR4,	JMS	DVNUM		/GET DEVICE NUMBER
	JMP	DPAR8		/DEVICE NAME ERROR
	DCA	DEVNUM		/RETURN FOR CALLING PROGRAM
	TAD	DPAR11		/GET CURRENT POINTER
	ISZ	DPARS		/BUMP RETURN
	JMP I	DPARS		/RETURN					/014 CJL
DPAR8,	CLA CLL			/INSURE CLEAR AC
	TAD	DPAR10		/GET ORIGINAL AC
	JMP I	DPARS		/TAKE ERROR EXIT

DPAR10,	.-.			/TEMPORARY FOR DPARS			/014 CJL
DPAR11,	.-.			/TEMPORARY FOR DPARS			/014 CJL
DPAR13,	.-.			/TEMPORARY FOR DPARS			/014 CJL
DEFDEV,	DEVICE	DSK		/DEFAULT DEVICE
DEVNAM,	FILENAM	ZZZZZZ.ZZ	/DEFAULT FILENAME			/014 CJL

/	ROUTINE TO RETURN A DEVICE NUMBER FOR A DEVICE NAME.		/014 CJL

/	CALLING SEQUENCE:

/	TAD	(ADDRESS)	/AC=ADDRESS OF DEVICE NAME
/				/*OR* 0000 IF "DSK:" IS TO BE USED
/	ERROR RETURN		/INVALID DEVICE
/	GOOD RETURN		/AC=DEVICE NUMBER

DVNUM,	.-.			/DEVICE NUMBER ROUTINE			/014 CJL
	SNA			/SKIP IF DEVICE NAME SPECIFIED
	TAD	(DEFDEV)	/ELSE USE DEFAULT			/014 CJL
	DCA	DVNUM9		/SAVE IN LOCAL POINTER
	TAD I	DVNUM9		/GET FIRST TWO CHARACTERS OF NAME	/014 CJL
	DCA	DVNUM5		/PUT INTO CALL
	ISZ	DVNUM9		/BUMP POINTER
	TAD I	DVNUM9		/GET LAST TWO CHARACTERS OF NAME	/014 CJL
	DCA	DVNUM5+1	/PUT INTO CALL
	CIF	USRFLD		/GOTO USR FIELD				/020 CJL
	JMS I	[USRENTRY]	/CALL USER SERVICE ROUTINE		/035 CJL
	INQUIRE			/INQUIRE ABOUT HANDLER			/020 CJL
DVNUM5,	.-.			/FIRST TWO BYTES OF DEVICE NAME		/014 CJL
	.-.			/LAST TWO BYTES OF DEVICE NAME		/014 CJL
	0			/ENTRY POINT OF HANDLER RETURNED HERE
	JMP I	DVNUM		/ERROR, TAKE ERROR EXIT
	TAD	DVNUM5+1	/DEVICE NUMBER
	ISZ	DVNUM		/BUMP RETURN FOR NO ERROR
	JMP I	DVNUM		/RETURN

DVNUM9,	.-.			/LOCAL FOR "DVNUM"			/014 CJL
/	DEVICE HANDLER FETCH ROUTINE.					/020 CJL

/	CALLING SEQUENCE:

/	TAD	(HANDLERNUMBER)	/AC CONTAINS DEVICE HANDLER NUMBER
/	JMS I	[HFETCH]	/CALL ROUTINE
/	ERROR RETURN		/COULDN'T LOAD HANDLER
/	GOOD RETURN		/HANDLER LOADED

/	IF THE HANDLER WAS LOADED, THEN HNDADR CONTAINS THE HANDLER ENTRY POINT.

HFETCH,	.-.			/HANDLER FETCH ROUTINE
	DCA	HANDNUMBER	/STORE HANDLER NUMBER
	TAD	(HNDLR+1)	/GET OUR BUFFER+(TWO PAGE ALLOWED)
	DCA	HADR		/STORE IN-LINE
	TAD	HANDNUMBER	/GET HANDLER NUMBER AGAIN
	CIF	USRFLD		/GOTO USR FIELD
	JMS I	[USRENTRY]	/CALL USER SERVICE ROUTINE		/035 CJL
	FETCH			/FETCH HANDLER
HADR,	.-.			/WILL BE OUR SUGGESTED ADDRESS+TWO PAGES ALLOWED
	SKP			/COULDN'T DO IT
	ISZ	HFETCH		/BUMP TO GOOD RETURN
	CLA CLL			/CLEAN UP
	TAD	HADR		/GET ACTUAL HANDLER ADDRESS
	DCA	HNDADR		/STASH THE POINTER
	JMP I	HFETCH		/RETURN EITHER WAY

HANDNUM,.-.			/HANDLER NUMBER TEMPORARY

/	ROUTINE TO HANDLE THE "FINISH" COMMAND.				/021 CJL

FINSRV,	0
	JMS I	[CREST2]	/SETUP CONSOLE OUTPUT ROUTINES		/025 CJL
	TAD	(MSEND)		/GET SEND MODE VALUE			/045 CJL
	DCA	KMODE		/SETUP PROPER MODE			/045 CJL
	FPACK			/FORMAT A PACKET
	SRVFIN			/PACKET DATA ADDRESS
	STGEN			/PACKET TYPE

FIN2,	SPACK			/SEND PACKET
	1			/AWAIT RESPONSE
	FIN20-2			/DISPATCH LIST FOR RESPONSE		/027 CJL

/	NAK OR UNDEFINED RESPONSE HERE

FIN5,	ISZ	RTRYC		/BUMP RE-TRY COUNTER
	JMP	FIN2		/GET RESPONSE AND TRY AGAIN
	TAD	(NOFINISH)	/FAILED, RETURN MESSAGE			/025 CJL
	JMP I	FINSRV

/	ACK HERE

FIN10,	ISZ	FINSRV		/BUMP FOR NON-ERROR EXIT
	JMP I	FINSRV		/DONE

FIN20,	STACK;	FIN10		/ACK
	STNAK;	FIN5		/NAK
	0

SRVFIN,	"F&137			/SERVER KERMIT COMMAND TO SHUT DOWN
	-1			/END OF DATA

	PAGE
/	ROUTINE TO PARSE OFF A FILE NAME.
/	FILE NAME TO BE PARSED MUST BE LETTERS OR DIGITS AND BE NO MORE THAN
/	SIX CHARS FOR THE NAME AND TWO CHARS FOR THE EXTENSION.

/	ENTER WITH:	AC =	POINTER TO FILE NAME TO PARSE.
/			FNPTR =	POINTER TO WHERE TO PUT THE PARSED FILE NAME.

/	NON-ERROR EXIT: AC =	POINTER TO REMAINDER OF COMMAND LINE.
/				RETURN THE CALL + 2.

/	ERROR EXIT:	AC =	ORIGINAL POINTER.
/				RETURN THE CALL + 1.

PFNAM,	0
	DCA	PFN10		/SAVE POINTER TO FILE NAME STRING
	TAD	FNPTR		/GET POINTER TO FILE NAME BLOCK
	DCA	MQ		/SET FOR "CLEAR" ROUTINE		/032 CJL
	TAD	(-4		/FOUR WORDS TO CLEAR OUT
	CLEAR			/INIT THE FILE NAME BLOCK
	TAD	PFN10		/GET THE STRING POINTER
	JMS I	[NOSP]		/GET PAST ANY LEADING SPACES
	JMP	PFNAM9		/GOT EOL, NO FILE NAME
	DCA	PFN11		/SAVE POINTER
	TAD	FNPTR		/GET FILE NAME BLOCK POINTER
	DCA	PACK6P		/SET UP THE "PACK6" POINTER
	DCA	PACK6F		/INIT THE "PACK6" FLAG
	TAD	(-6		/MAX OF 6 CHARS FOR FILE NAME
	DCA	PFN15		/PUT INTO COUNTER
	DCA	WILDF		/INIT THE WILD CARD FLAG
	JMS	NAM		/MOVE AND PACK FILE NAME
	TAD I	PFN11		/GET THE TERM CHAR
	SPA			/SKIP IF NOT EOL
	JMP	PFNAM7		/EOL MEANS END OF FILE NAME
	TAD	(-".!200)	/COMPARE TO "."				/034 CJL
	SNA			/SKIP IF NO
	JMP	PFNAM3		/GO HANDLE EXTENSION
	TAD	(-" +".)	/COMPARE TO <SP>			/034 CJL
	SZA CLA			/SKIP IF WAS A SPACE
	JMP	PFNAM9		/NOT A SPACE, GOT AN ERROR
	JMP	PFNAM7		/IS A SPACE, END OF FILE NAME
PFNAM3,	ISZ	PFN11		/BUMP PAST THE "."
	TAD	FNPTR		/GET FILE NAME BLOCK POINTER
	TAD	(3)		/POINT TO EXTENSION			/032 CJL
	DCA	PACK6P		/SET "PACK6" POINTER
	DCA	PACK6F		/INIT "PACK6" FLAG
	NL7776			/SET -2					/032 CJL
	DCA	PFN15		/COUNTER FOR 2 EXT CHARS
	JMS	NAM		/NOW DO THE EXTENSION
	TAD I	PFN11		/GET THE TERM CHAR
	SPA			/SKIP IF NOT EOL
	JMP	PFNAM7		/GOT COMPLETE FILE NAME HERE
	TAD	[-" !200]	/COMPARE TO <SP>			/034 CJL
	SZA CLA			/SKIP IF IT WAS
	JMP	PFNAM9		/GOT A FILE NAME ERROR
PFNAM7,	ISZ	PFNAM		/BUMP RETURN FOR GOOD FILE NAME
	CLA CLL			/INSURE CLEAR AC
	TAD	PFN11		/GET CURRENT STRING POINTER
	JMP I	PFNAM		/AND RETURN

PFNAM9,	CLA CLL			/INSURE CLEAR AC
	TAD	PFN10		/GET ORIGINAL STRING POINTER
	JMP I	PFNAM		/TAKE ERROR RETURN

PFN10,	0			/TEMP FOR PFNAM ROUTINE
PFN11,	0			/TEMP FOR PFNAM ROUTINE
PFN15,	0			/TEMP FOR PFNAM ROUTINE
/	LOCAL ROUTINE TO "PFNAM" TO MOVE IN THE FILE NAME OR FILE EXTENSION.
/	ENTER WITH "PFN11" POINTING TO WHERE TO GET THE NAME OR EXTENSION.
/	AND "PFN15" EQUAL TO THE MAX NUMBER OF CHARS (6 FOR NAME, 2 FOR EXT).
/	THIS ROUTINE CHECKS FOR WILD CARD CHARS "*" AND "?" AND PUTS THE
/	"?" CHAR IN FOR ANY CHARS IN THE NAME THAT ARE WILD.  ALSO IF ANY
/	WILD CARD CHARS ARE FOUND THE FLAG "WILDC" IS SET SO BEFORE PARSING
/	ANY FILE NAME THE "WILDC" FLAG SHOULD BE INITIALIZED.

NAM,	0
NAM0,	TAD I	PFN11		/GET A CHAR FROM THE STRING
	JMS I	(ALPNUM)	/MUST BE ALPHA OR NUMBER
	SKP			/NOT A ALPHA NUMERIC
	JMP	NAM3		/IS ALPHA NUMERIC
	TAD	(-"?!200)	/COMPARE TO "?"				/034 CJL
	SNA			/SKIP IF NO
	JMP	NAM2		/YES, JUST PUT IT IN
	TAD	(-"*+"?)	/COMPARE TO "*"				/034 CJL
	SZA CLA			/SKIP IF YES
	JMP I	NAM		/TAKE THE FILE NAME ERROR EXIT
	ISZ	WILDF		/SET FLAG FOR WILD CARD FOUND
NAM1,	TAD	["?&77]		/GET WILD CARD CHARACTER		/034 CJL
	PACK6			/PUT IN NAME BLOCK
	ISZ	PFN15		/BUMP CHAR COUNTER
	JMP	NAM1		/LOOP TILL ALL FILLED
	ISZ	PFN11		/BUMP THE STRING POINTER
	JMP	NAM9		/EXIT WITH "PFN11" POINTING TO NEXT CHAR
NAM2,	ISZ	WILDF		/SET FLAG FOR WILD CARD FOUND
	TAD	["?&77]		/GET WILD CARD CHARACTER		/034 CJL
NAM3,	PACK6			/PUT THE CHAR INTO THE FILE NAME BLOCK
	ISZ	PFN11		/BUMP THE STRING POINTER
	ISZ	PFN15		/BUMP THE CHAR COUNTER
	JMP	NAM0		/LOOP

NAM4,	TAD I	PFN11		/NOW GET TO A TERMINATOR CHAR
	JMS I	(ALPNUM)	/BY FINDING FIRST NON-ALPHNUMERIC
	JMP	NAM9		/NOW WE CAN QUIT
	CLA CLL			/IGNORE EXCESS CHARS
	ISZ	PFN11		/BUMP THE STRING POINTER
	JMP	NAM4		/LOOP

NAM9,	CLA CLL			/LEAVE WITH A CLEAR AC
	JMP I	NAM		/RETURN
/	ROUTINE TO SEND A PACKET.
/	ENTER WITH ADDRESS OF PACKET DATA IN CALL + 1.
/	AND TYPE OF PACKET IN CALL + 2.
/	EXIT CALL + 4 IF ACK RETURNED.
/	EXIT CALL + 3 IF NAK OR OTHER PACKET TYPE RETURNED.

SNDP,	0
	TAD I	SNDP		/GET DATA ADDRESS
	DCA	SNDP1		/STORE IN CALL
	ISZ	SNDP		/BUMP POINTER
	TAD I	SNDP		/GET PACKET TYPE
	DCA	SNDP2		/STORE IN CALL
	ISZ	SNDP		/BUMP

	FPACK			/FORMAT A PACKET
SNDP1,	0			/DATA ADDRESS GOES HERE
SNDP2,	0			/PACKET TYPE GOES HERE

SNDP3,	SPACK			/SEND A DATA PACKET
	1			/GET RESPONSE
	SNDP9-2			/RESPONSE DISPATCH TABLE ADDRESS	/027 CJL

/	HERE ON NOT "NAK" OR "ACK" RESPONSE.

	SKP

/	HERE ON "ACK".

SNDP5,	ISZ	SNDP		/BUMP RETURN

	ISZ	SNDP		/BUMP RETURN
	JMP I	SNDP		/EXIT

/	HERE ON NAK.

SNDP4,	ISZ	RTRYC		/BUMP THE RE-TRY COUNTER
	JMP	SNDP3		/RE-TRY
	JMP I	SNDP		/TAKE RETURN + 3

SNDP9,	STACK;	SNDP5		/ACK
	STACK;	SNDP4		/NAK
	0

	PAGE								/014 CJL
	IFZERO	1	<

/	ROUTINE TO PARSE OFF A DECIMAL NUMBER.
/	ENTER ROUTINE WITH A POINTER TO THE PARSE LINE IN THE AC.
/	EXIT:	RETURN + 1 FOR NO NUMBER.
/		RETURN + 2 FOR INVALID NUMBER.
/		RETURN + 3 FOR VALID NUMBER.

/	IN ALL CASES ON RETURN THE AC WILL CONTAIN A POINTER TO THE NEXT CHAR TO PARSE
/	IN THE LINE.  ANY NUMBER  PARSED  WILL BE CONVERTED TO BINARY AND PUT INTO THE
/	REGISTER "BININP".

DECPRS,	0
	JMS I	[NOSP]		/GET PAST ANY LEADING SPACES
	JMP I	DECPRS		/GOT AN END OF LINE, AC POINTS TO IT
	DCA	DP10		/SAVE POINTER TO LINE
	TAD	DP10		/RE-GET POINTER TO LINE
	DCA	DP11		/STORE IN OUR LINE POINTER
	DCA	BININP		/INIT BINARY REGISTER
	DCA	DP13		/INIT PARSED NUMBER FLAG
	SKP			/SKIP INTO LOOP BELOW
DP1,	ISZ	DP11		/BUMP THE LINE POINTER
	TAD I	DP11		/GET A CHAR FROM THE LINE
	JMS	DECCK		/CHECK FOR PROPER ASCII DECIMAL
	JMP	DP5		/NOT PROPER ASCII DECIMAL
	ISZ	DP13		/FLAG NUMBER INPUT
	TAD	(-"0		/MAKE BINARY
	DCA	DP12		/AND STORE
	TAD	BININP		/GET PREVIOUS INPUT
	JMS	MUL10		/AND MULTIPLY TIMES 10
	SZL			/SKIP IF NO OVERFLOW ENCOUNTERED
	JMP	DP6		/GOT AN OVERFLOW ERROR
	TAD	DP12		/COMBINE WITH CURRENT INPUT
	SZL			/SKIP IF NO OVERFLOW ERROR
	JMP	DP6		/GOT AN OVERFLOW ERROR
	DCA	BININP		/RETURN ACCUMULATED SUM
	JMP	DP1		/LOOP

DP5,	CLA CLL			/AC MAY NOT BE CLEAR
	TAD	DP13		/ANY NUMBERS INPUT YET?
	SNA CLA			/SKIP IF YES
	JMP	DP6		/TAKE THE NO NUMBER INPUT RETURN
	ISZ	DECPRS		/BUMP THE RETURN
	ISZ	DECPRS		/TWICE FOR GOOD NUMBER INPUT RETURN
	TAD	DP11		/GET POINTER TO LINE
	JMP I	DECPRS		/AND RETURN

DP6,	CLA CLL			/AC MAY NOT BE CLEAR
	TAD	DP10		/GET ORIGINAL LINE POINTER
	ISZ	DECPRS		/BUMP THE RETURN
	JMP I	DECPRS		/TAKE THE INVALID NUMBER RETURN

			>
	IFZERO	1	<

DP10,	0			/TEMP FOR DECPRS
DP11,	0			/TEMP FOR DECPRS
DP12,	0			/TEMP FOR DECPRS
DP13,	0			/TEMP FOR DECPRS

/	ROUTINE TO MULTIPLY THE VALUE OF THE AC TIMES 10.
/	VALUE IN THE AC IS ASSUMED BINARY.

/	THE NUMBER IS RETURNED IN THE AC.  IF THE LINK IS SET THE MULTIPLY
/	OVERFLOWED 12 BITS.

MUL10,	0
	DCA	MULTMP		/SAVE THE NUMBER
	TAD	MULTMP		/GET THE NUMBER BACK
	CLL RTL			/MULTIPLY TIMES 4
	TAD	MULTMP		/TIMES 5
	SNL			/SKIP IF ALREADY OVERFLOWED		/025 CJL
	RAL			/TIMES 10
	JMP I	MUL10		/RETURN NUMBER IN AC
				/THE LINK HAS ANY OVERFLOW

MULTMP,	0			/TEMP STORAGE FOR MUL10 ROUTINE



/	ROUTINE TO CHECK FOR A VALID ASCII DECIMAL VALUE.

/	ENTER WITH ASCII CHAR IN THE AC.
/	EXIT RETURN + 1 IF NON-VALID ASCII DECIMAL WITH CHAR IN AC.
/	EXIT RETURN + 2 IF VALID ASCII DECIMAL WITH CHAR IN AC.

DECCK,	0
	DCA	DECCK5		/STORE THE CHAR TO CHECK
	TAD	DECCK5		/GET THE CHAR
	TAD	(-"0		/CHECK FOR LESS THAN 0
	SPA			/SKIP IF NOT LESS THAN 0
	JMP	DECCK1		/NON-ASCII DECIMAL
	TAD	("0-"9-1	/CHECK GREATER THAN 9
	SMA CLA			/SKIP IF LE 9
	JMP	DECCK1		/INVALID ASCII DECIMAL
	ISZ	DECCK		/BUMP RETURN FOR VALID ASCII DECIMAL
DECCK1,	TAD	DECCK5		/RE-GET ORIGINAL CHAR IN AC
	JMP I	DECCK		/RETURN


DECCK5,	0			/TEMP FOR "DECCK" ROUTINE

			>
/	ROUTINE TO INPUT A COMMAND LINE FROM THE KEYBOARD.		/013/014 CJL

LININP,	0
	TAD	(LINBUF		/GET ADDRESS OF LINE BUFFER
	DCA	LIN50		/STORE IN A POINTER
LIN1,	JMS I	(INPUT)		/GET A CHARACTER FROM THE KEYBOARD	/044 CJL
	TAD	(-CNTRLM)	/COMPARE TO <CR>			/034 CJL
	SNA			/SKIP IF NOT A RETURN
	JMP	LIN2		/LINE IS INPUT
	TAD	(-DELETE+CNTRLM)/COMPARE TO <DEL>			/034 CJL
	SNA CLA			/SKIP IF NOT A DELETE
	JMP	LIN5		/OFF TO HANDLE A DELETE
	TAD	LIN50		/GET VALUE OF LINE POINTER
	TAD	(-LINBUF-LINSIZ	/COMPARE WITH END OF LINE BUFFER
	SMA CLA			/SKIP IF ROOM IN LINE BUFFER
	JMP	LIN10		/BEEP FOR FULL BUFFER
	TAD	INCHAR		/GET THE KEYBOARD CHARACTER AGAIN	/044 CJL
	TAD	(-140)		/COMPARE TO LOWER-CASE LIMIT		/034 CJL
	SMA			/SKIP IF BELOW LIMIT			/034 CJL
	TAD	[-40]		/ELSE MAKE IT UPPER-CASE		/034 CJL
	TAD	(140)		/RESTORE THE CHARACTER			/034 CJL
	DCA I	LIN50		/STORE IN THE LINE BUFFER
	ISZ	LIN50		/BUMP THE LINE BUFFER POINTER
	NL7777			/SET -1					/032 CJL
	DCA I	LIN50		/TERMINATE THE LINE
	TAD	INCHAR		/GET THE LATEST KEYBOARD CHARACTER BACK	/044 CJL
	JMS I	[P7ECHO]	/PRINT IT				/043 CJL
	JMP	LIN1		/LOOP TILL A RETURN TYPED

LIN2,	NL7777			/SET -1					/032 CJL
	DCA I	LIN50		/INSURE STRING TERMINATED
	JMS I	[SCRIBE]	/DO A 					/025 CJL
	CRLF			/<CR>, <LF>				/025 CJL
	JMP I	LININP		/DONE

/	HANDLE A DELETE TYPED IN

LIN5,	TAD	LIN50		/FIND OUT FIRST IF...
	TAD	(-LINBUF	/WE ARE AT THE BEGINNING OF THE LINE
	SNA CLA			/SKIP IF NO
	JMP	LIN1		/JUST IGNORE THE DELETE
	NL7777			/SET -1					/032 CJL
	TAD	LIN50		/GET THE LINE POINTER
	DCA	LIN50		/RETURN BACKED UP
	DCA I	LIN50		/ZERO THE CHAR
	TAD	(CNTRLH)	/GET A <BS>				/025 CJL
	JMS I	[P7ECHO]	/PRINT IT				/043 CJL
	TAD	[" &177]	/GET A <SPACE>				/025 CJL
	JMS I	[P7ECHO]	/PRINT IT				/043 CJL
	TAD	(CNTRLH)	/GET A <BS>				/025 CJL
	JMS I	[P7ECHO]	/PRINT IT				/043 CJL
	JMP	LIN1		/BACK TO INPUT
/	HANDLE FULL LINE BUFFER HERE

LIN10,	CLA CLL			/ENSURE CLEAR AC
	TAD	[CNTRLG]	/GET A <BEL> CHARACTER			/025 CJL
	JMS I	[P7ECHO]	/PRINT IT				/043 CJL
	JMP	LIN1		/WAIT FOR EITHER RETURN OF DELETE KEY

LIN50,	0			/TEMP POINTER FOR "LININP" ROUTINE
/	ROUTINE TO PACK TWO SIX-BIT CHARACTERS INTO A WORD.		/032 CJL

/	CALLING SEQUENCE:

/	[PACK6PTR => CHARACTER PACKING AREA].
/	[PACK6FLAG=0 IF PACKING INTO HIGH-ORDER BYTE.
/	PACK6FLAG=4000 IF PACKING INTO LOW-ORDER BYTE].

/	TAD	CHAR		/AC CONTAINS CHARACTER TO BE PACKED
/	PACK6			/CALL VIA PAGE ZERO POINTER

/	RETURNS WITH AC CLEAR AND PACK6PTR AND PACK6FLAG UPDATED FOR NEXT PACKING.

PACK60,	.-.			/PACK SIX-BIT ROUTINE
	AND	[77]		/JUST SIX-BIT
	DCA	PACK6TEMP	/SAVE FOR NOW
	NL4000			/SET INVERSION BIT
	TAD	PACK6FLAG	/REVERSE THE FLAG
	DCA	PACK6FLAG	/STORE BACK
	SZL			/WAS IT CLEAR?
	JMP	PACKIT		/NO, GO DO LOW-ORDER
	TAD	PACK6TEMP	/GET THE CHARACTER
	RTL;RTL;RTL		/MOVE UP
	DCA I	PACK6PTR	/STORE IT
	JMP I	PACK60		/RETURN

PACKIT,	TAD I	PACK6PTR	/GET PREVIOUS HIGH-ORDER HALFWORD
	TAD	PACK6TEMP	/ADD ON LATEST
	DCA I	PACK6PTR	/STORE BOTH
	ISZ	PACK6PTR	/BUMP FOR NEXT TIME
	JMP I	PACK60		/RETURN

PACK6TE,.-.			/PACK6 TEMPORARY
/	ROUTINE TO COMPARE TWO FILE NAMES FOR EQUALITY.
/	THE ROUTINE WILL CHECK EACH OF THE 8 FILE NAME CHARS AND IF A
/	CHAR IN THE FIRST FILE NAME (THE ONE WE ARE LOOKING FOR) CONTAINS
/	A "?" IT WILL MATCH ON THE SECOND FILE NAME CHAR.
/	ENTER WITH "FCMP1" POINTING TO THE FILE NAME TO FIND, AND "FCMP2"
/	POINTING TO THE FILE NAME TO TRY AND MATCH.  EXIT + 1 IF NO MATCH
/	AND EXIT + 2 IF MATCH.  (IF NON-ZERO AC ON ENTRY, THE AC IS ASSUMED
/	TO HAVE THE VALUE FOR "FCMP2".)

FMATCH,	0
	SZA			/SKIP IF NO ARGUMENT IN AC
	DCA	FCMP2		/THIS ARGUMENT CAME IN THE AC
	TAD	FCMP1		/GET ADDRESS OF FIRST FILE NAME BLOCK
	DCA	GET6P		/STORE IN A POINTER
	DCA	GET6F		/INIT FLAG FOR "GET6" ROUTINE
	TAD	FCMP2		/GET ADDRESS OF SECOND FILE NAME BLOCK
	DCA	FMATP		/STORE IN A LOCAL POINTER
	DCA	FMATF		/INIT LOCAL FLAG
	TAD	(-10		/8 CHARS TO DO
	DCA	FMATC		/STORE IN LOCAL COUNTER

FMAT1,	NL4000			/SET 4000				/032 CJL
	TAD	FMATF		/GET FLAG
	DCA	FMATF		/RETURN FLAG, LINK CONTAINS STATUS
	TAD I	FMATP		/GET A WORD FROM THE SECOND NAME
	SZL			/SKIP IF HIGH-ORDER WANTED NOW		/032 CJL
	JMP	FSWIT		/JUMP IF LOW-ORDER WANTED NOW		/032 CJL
	RTR;RTR;RTR		/MOVE DOWN HIGH-ORDER			/032 CJL
	SKP			/DON'T BUMP YET				/032 CJL
FSWIT,	ISZ	FMATP		/BUMP THE POINTER			/032 CJL
	AND	[77]		/KEEP ONLY BOTTOM 6 BITS		/016 CJL
	DCA	FMATT		/STORE IN A TEMP
	GET6			/NOW GET A CHAR FROM FIRST NAME
	TAD	(-77		/CHECK IF WILD
	SNA			/SKIP IF NO
	JMP	FMAT2		/NO MATCH CHECK ON A WILD CARD
	TAD	[77]		/RESTORE THE CHARACTER			/014/016 CJL
	CIA			/NEGATE FOR COMPARE
	TAD	FMATT		/COMPARE WITH SECOND FILE NAME
	SZA CLA			/SKIP IF IS A MATCH
	JMP I	FMATCH		/THIS IS NOT A MATCH

FMAT2,	ISZ	FMATC		/BUMP COUNTER
	JMP	FMAT1		/LOOP, MORE TO CHECK
	ISZ	FMATCH		/BUMP RETURN FOR MATCH
	JMP I	FMATCH		/GOT A MATCH

FMATP,	0			/POINTER FOR "FMATCH"
FMATC,	0			/COUNTER FOR "FMATCH"
FMATF,	0			/FLAG FOR "FMATCH"
FMATT,	0			/TEMP FOR "FMATCH"
FCMP1,	0			/POINTER FOR FIRST FILE NAME BLOCK
FCMP2,	0			/POINTER FOR SECOND FILE NAME BLOCK
	PAGE								/014 CJL
/	REMOTE LINK INPUT ROUTINE.
/	CALL = RPACK.

ILINK,	0
	TAD	RETRY		/SET UP A RE-TRY COUNT
	DCA	ILINK6		/RE-TRY COUNT FOR INPUT ERRORS

ILINK0,	JMS I	(GETSOH)	/FIRST GET THE "SOH" BYTE
	JMP	ILINK2		/RETURN HERE ON TIME-OUT
	DCA	ILINK9		/INIT CHECKSUM REGISTER
	TAD	[RRLEN]		/GET REMOTE RECEIVE BUFFER ADDRESS
	DCA	ILINK8		/STORE IN LOCAL POINTER
	JMS I	(GETIR)		/GET A CHAR
	JMP	ILINK2		/GOT A RETURN OR TIME-OUT
	DCA I	ILINK8		/STORE LENGTH IN BUFFER
	TAD I	ILINK8		/GET LENGTH CHAR BACK
	TAD	(-40-1		/CHAR FUNCTION - LENGTH BYTE
	CIA			/NEGATE FOR COUNTER
	DCA	ILINK7		/STORE IN LOCAL COUNTER

ILINK1,	ISZ	ILINK8		/BUMP POINTER
	JMS I	(GETIR)		/GET NEXT CHAR
	JMP	ILINK2		/GOT A RETURN
	DCA I	ILINK8		/STORE IN BUFFER
	ISZ	ILINK7		/BUMP COUNTER
	JMP	ILINK1		/LOOP

	ISZ	ILINK8
	NL7777			/SET -1					/032 CJL
	DCA I	ILINK8
	TAD	ILINK9		/GET CALCULATED CHECKSUM
	JMS I	[CKSUM]		/CALCULATE 1 BYTE CHECKSUM
	CIA			/NEGATE FOR COMPARE
	DCA	ILINK7		/STORE TEMP
	JMS I	(GETIR)		/NOW GET CHECKSUM
	JMP	ILINK2		/GOT A RETURN
	TAD	ILINK7		/COMPARE WITH CALCULATED CHECKSUM
	SNA CLA			/SKIP IF NOT SAME
	JMP	ILINK4		/ARE SAME

ILINK2,	CLA CLL			/INSURE CLEAR AC
	ISZ	ILINK6		/BUMP RE-TRY COUNTER
	JMP	ILINK3		/CAN RE-TRY
	TAD	(RPERMSG)	/GET MESSAGE FOR FATAL PACKET ERROR	/025 CJL
	JMP I	[CLOOP7]	/AND ABORT THE MESS

ILINK3,	TAD	ABFLAG		/GET ABORT FLAG				/044 CJL
	SZA CLA			/SKIP IF NO
	JMP I	(ABORT)		/ABORT THIS
	JMS I	(SNDNAK)	/SEND BACK A "NAK"
	JMP	ILINK0		/AND TRY AGAIN
ILINK4,	TAD	ABFLAG		/GET ABORT FLAG				/044 CJL
	SNA CLA			/SKIP IF YES
	JMP I	ILINK		/NOPE, RETURN
	JMP I	(ABORT)

ILINK6,	0			/LOCAL TO "ILINK"
ILINK7,	0			/LOCAL TO "ILINK"
ILINK8,	0			/LOCAL TO "ILINK"
ILINK9,	0			/LOCAL TO "ILINK"

/	HELP COMMAND ROUTINE.						/024 CJL

HELPSRV,.-.			/HELP ROUTINE
	JMS I	[CRESET]	/RESET CONSOLE ROUTINE STUFF
	JMS I	[SCRIBE]	/GIVE THEM THE
	HELPMSG			/HELP MESSAGE
	TAD	ESCHAR		/GET THE ESCAPE CHARACTER
	JMS I	[ESCPRNT]	/PRINT IT
	JMS I	[SCRIBE]	/DO A
	CRLF			/<CR>, <LF>
	ISZ	HELPSRV		/BUMP PAST ERROR RETURN
	JMP I	HELPSRV		/RETURN

/	ROUTINE TO PRINT THE DATA IN THE RECEIVED PACKET.

PRIPAK,	0
	PRI8B;	RRDTA		/PRINT THE DATA
	JMS I	[SCRIBE]	/DO A					/025 CJL
	CRLF			/<CR>, <LF>				/025 CJL
	JMP I	PRIPAK		/DONE

	PAGE								/014 CJL
/	ROUTINE TO SERVICE A SEND REQUEST.

SNDSRV,	0
	JMS I	[CREST2]	/SETUP CONSOLE OUTPUT ROUTINES		/025 CJL
	TAD	(MSEND)		/FIRST SET MODE TO SEND
	DCA	KMODE		/PUT INTO MODE FLAG
	TAD	LPTR		/GET CURRENT LINE POINTER
	DCA	PRSERR		/SAVE LINE POSITION
	TAD	PRSERR		/GET LINE POSITION
	JMS I	[DPARS]		/TRY TO PARSE OFF A DEVICE NAME
	JMS	SNDERROR	/RETURN A DEVICE NAME ERROR		/026 CJL
SER1,	DCA	PRSERR		/SAVE LINE POINTER			/026 CJL
	TAD	(FNBLK		/GET FILE NAME BLOCK ADDRESS
	DCA	FNPTR		/STORE IN POINTER
	TAD	PRSERR		/GET STRING POINTER
	JMS I	[PFNAM]		/PARSE OFF THE FILE NAME
	JMS	SNDERROR	/FILE NAME PARSE ERROR			/026 CJL
SER2,	DCA	PRSERR		/SAVE THE STRING POINTER		/026 CJL
	TAD	PRSERR		/GET THE STRING POINTER
	JMS I	[NOSP]		/FIND THE END OF STRING
	SKP			/GOT END OF STRING HERE
	JMS	SNDERROR	/SYNTAX ERROR				/026 CJL
SER3,	DCA	PRSERR		/RETURN POINTER				/026 CJL
	TAD	DEVNUM		/GET THE DEVICE NUMBER PARSED
	JMS I	[HFETCH]	/FETCH A HANDLER FOR THIS
	JMS	SNDERROR	/HANDLER FETCH ERROR			/026 CJL
SER4,	DCA	FILFND		/INIT FILE FOUND FLAG
	DCA	INIFLG		/CLEAR THE INIT DONE FLAG
	NL0001			/INITIALIZE DIRECTORY			/028 CJL
	DCA	SLFLAG		/LOOKUP FLAG				/028 CJL
SNDSV1,	TAD	(FNBLK		/GET FILE NAME BLOCK ADDRESS
	DCA I	(FCMP1)		/SET FOR FILE TO FINE
	TAD	SLFLAG		/GET DIRECTORY FLAG			/028 CJL
	JMS I	(LUKUP)		/FIND A MATCH FOR THIS FILE
	JMS	SNDERROR	/DIRECTORY I/O ERROR			/026 CJL
SER5,	JMP	S00		/FILE NOT FOUND				/026 CJL
	ISZ	FILFND		/BUMP FILE FOUND COUNT
	DCA	SLFLAG		/DON'T INITIALIZE LOOKUP AGAIN
	JMS I	(SNDPRO)	/PROCESS THIS FILE FOR SEND
	JMS	SNDERROR	/ERROR IN FILE SEND PROCESS		/026 CJL
SER6,	TAD	WILDF		/WAS WILD CARD FILE SPEC?		/026 CJL
	SZA CLA			/SKIP IF NO
	JMP	SNDSV1		/GOT WILD CARD, TRY FOR NEXT
S00,	TAD	FILFND		/CHECK FOR ANY FILES FOUND
	SNA CLA			/SKIP IF YES
	JMS	SNDERROR	/RETURN FILE NOT FOUND ERROR		/026 CJL
SER7,	JMS	BRKXMT		/BREAK THE SEND				/026 CJL
	TAD	PRSERR		/GET CURRENT CURSOR POSITION
	DCA	LPTR		/UPDATE
	ISZ	SNDSRV		/BUMP RETURN
	JMP I	SNDSRV		/AND DONE
/	SEND ERRORS COME HERE.						/026 CJL

SNDERRO,.-.			/SEND ERROR ROUTINE
	CLA			/CLEAN UP
	TAD	SNDERROR	/GET CALLER
	JMS I	[SRCHTABLE]	/GO MATCH IT
	SNERTABLE-1-1		/IN ERROR TABLE
	JMP I	SNDSRV		/TAKE ERROR EXIT WITH MESSAGE ADDRESS IN AC

/	SEND ERROR MESSAGE DISPATCH TABLE.				/026 CJL

SNERTAB,-SER1;	DNERMSG		/DEVICE NAME ERROR
	-SER2;	FNERMSG		/FILE NAME ERROR
	-SER3;	FSERMSG		/FILE NAME SYNTAX ERROR
	-SER4;	SHFEMSG		/HANDLER FETCH ERROR
	-SER5;	SDERMSG		/DIRECTORY I/O ERROR
	-SER6;	SNDEMSG		/SEND ERROR
	-SER7;	NOTFND		/LOOKUP
	0			/THIS ENDS THE LIST

FILFND,	0			/HOLDS COUNT OF # OF FILES FOUND
SLFLAG,	.-.			/LOOKUP INITIALIZE FLAG			/028 CJL
FNBLK,	0
	0
	0
	0
/	ROUTINE TO RE-SET THE SEND.

BRKXMT,	.-.
	CLA CLL			/INSURE CLEAR AC
	DCA	INIFLG		/CLEAR THE INIT SEND FLAG
	FPACK			/FORMAT A PACKET
	NODATA			/NO DATA FOR THIS PACKET
	STEOT			/"EOT" PACKET TYPE
	SPACK			/SEND THE PACKET
	1			/READ RESPONSE				/042 CJL
	0			/DO NOT DISPATCH			/042 CJL
	JMP I	BRKXMT		/DONE

/	ROUTINE TO SEND OUT A NAK WITHOUT DISTURBING THE NORMAL PACKET BUFFER.

SNDNAK,	0
	NL7777			/-1					/042 CJL
	TAD	CURSEQ		/ADD ON CURRENT SEQUENCE NUMBER		/042 CJL
	AND	[77]		/MODULO 64				/042 CJL
	TAD	[40]		/TAKE CHAR(SEQUENCE NUMBER)		/042 CJL
	DCA	NAKPAK+2	/PUT IN NAK PACKET BUFFER
	TAD	NAKPAK+1	/GET LENGTH
	TAD	NAKPAK+2	/GET SEQ
	TAD	NAKPAK+3	/GET TYPE
	JMS I	[CKSUM]		/CALCULATE CHECKSUM
	DCA	NAKPAK+4	/PUT IN CHECKSUM
	TAD	REOL		/GET ANY EOL REQUIRED
	TAD	[-40]		/UN-CHAR IT				/014/016 CJL
	SNA			/SKIP IF USING
	NL7777			/NO EOL, PUT IN -1 INSTEAD		/032 CJL
	DCA	NAKPAK+5	/PUT EOL IN
	REM8B;	NAKPAK		/SEND NAK TO REMOTE
	JMP I	SNDNAK		/DONE


NAKPAK,	CNTRLA			/MARK					/042 CJL
	" &77+3			/LENGTH OF NAK PACKET			/042 CJL
	.-.			/SEQUENCE NUMBER GOES HERE		/042 CJL
	STNAK			/DATA TYPE
	.-.			/CHECKSUM				/042 CJL
	.-.			/<EOL> IF USED				/042 CJL
	-1			/TERMINATE

/	FILENAME BUFFER.						/014 CJL

NAMBUFF,ZBLOCK	12		/FILENAME.EXTENSION (WITH TERMINATOR) GOES HERE
	PAGE								/014 CJL
/	ROUTINE TO SERVICE A "GET" COMMAND.

GETSRV,	0
	JMS I	[CREST2]	/SETUP CONSOLE OUTPUT ROUTINES		/025 CJL
	TAD	(MREC)		/GET OUR MODE VALUE			/045 CJL
	DCA	KMODE		/SETUP NOW				/045 CJL
	TAD	LPTR		/GET CURRENT LINE POINTER
	DCA	PRSERR		/SAVE
	TAD	PRSERR		/RE-GET IT
	JMS I	[DPARS]		/PARSE OFF THE DEVICE NAME		/006/014 CJL
	JMP	GSRV50		/ERROR IN DEVICE NAME			/006
	JMS I	[NOSP]		/FIND BEGINNING OF A FILE NAME
	JMP	GSRV22		/GOT <EOL>, NO FILE NAME		/006/014 CJL
	DCA	GSRV90		/STORE BEGINNING ADDRESS
	TAD	GSRV90		/NOW WE LOOK FOR
	JMS I	[SP]		/THE END OF THE LINE
	SKP			/GOT THE END OF THE LINE HERE
	JMP	.-2		/NOT END YET, CONTINUE
	DCA	PRSERR		/STORE POINTER TO EOL
	NL7777			/SET -1					/032 CJL
	DCA I	PRSERR		/TERMINATE FILE NAME WITH -1
	DCA	CURSEQ		/RE-SET THE SEQUENCE
	TAD	GSRV90		/GET ADDRESS OF FILE NAME

GSRV10,	FPACK			/FORMAT THE PACKET
GSRV90,	0			/DATA ADDRESS HERE
	STRIN			/RECIEVE INIT PACKET

GSRV12,	SPACK			/SEND THE PACKET
	1			/GET RESPONSE
	GSRV80-2		/DISPATCH TABLE				/027 CJL

/	SERVICE A NAK OR UNDEFINED.

GSRV15,	ISZ	RTRYC		/BUMP THE RE-TRY COUNTER
	JMP	GSRV12		/TRY AGAIN
	JMP I	GETSRV		/GIVE UP

/	SERVICE A SEND/INIT FROM THE REMOTE.

GSRV20,	JMS I	(INPSRV)	/HANDLE JUST LIKE A RECEIVE
	JMP	GSRV21		/ERROR RETURN FROM "INPSRV"
	ISZ	GETSRV		/BUMP RETURN FOR NO ERROR
	TAD	PRSERR		/UPDATE THE CURRENT LINE POINTER
	DCA	LPTR
GSRV21,	JMP I	GETSRV

GSRV22,	CLA CLL			/MAKE SURE WE ARE CLEAR			/009/014 CJL
	TAD	[NOTFND]	/GET ERROR MESSAGE ADDRESS		/025 CJL
	JMP I	GETSRV		/TAKE ERROR RETURN			/009/014 CJL

/	GOT AN ERROR PACKET, DISPLAY ERROR AND ABORT.

GSRV40,	JMS I	[PRIPAK]	/PRINT OUT THE ERROR PACKET
	JMP I	GETSRV		/TAKE THE ERROR EXIT
/	GOT DEVICE ERROR.						/006/014 CJL

GSRV50,	CLA CLL			/ENSURE CLEAR AC			/006/014 CJL
	TAD	(DNERMSG)	/GET ERROR MESSAGE ADDRESS		/025 CJL
	JMP I	GETSRV		/TAKE ERROR RETURN			/006/014 CJL

/	DISPATCH TABLE.

GSRV80,	STERR;	GSRV40		/ERROR PACKET RETURNED
	STSIN;	GSRV20		/SEND INIT PACKET RETURNED
	STNAK;	GSRV15		/NAK PACKET RETURNED
	0			/TERMINATE TABLE
/	ROUTINE TO SERVICE A "RECEIVE" COMMAND.

RECSRV,	0
	JMS I	[CREST2]	/SETUP CONSOLE OUTPUT ROUTINES		/025 CJL
	TAD	(MREC)		/GET OUR MODE VALUE			/045 CJL
	DCA	KMODE		/SETUP NOW				/045 CJL
	TAD	LPTR		/GET CURRENT LINE POINTER
	DCA	PRSERR		/SAVE IT
	TAD	PRSERR		/GET IT BACK
	JMS I	[DPARS]		/PARSE OFF DEVICE NAME			/018 CJL
	JMP	RECS30		/ERROR IN DEVICE NAME			/018 CJL
	JMS I	[NOSP]		/CHECK IF BEGINNING OF FILE NAME	/014 CJL
	SKP			/GOT <EOL> HERE				/018 CJL
	JMP	RECS60		/SOMETHING ELSE ON LINE, ERROR		/014 CJL
	DCA	PRSERR		/SAVE CURRENT LINE POINTER		/018 CJL
	RPACK			/GET SEND/INIT PACKET FROM REMOTE
	JMS I	(DISPATCH)	/DISPATCH BASED ON RRTYP		/031 CJL
	RECS80-2		/TABLE ADDRESS				/027/031 CJL
	JMP	RECS60		/DON'T KNOW WHAT IT IS

/	GOT A SEND INIT PACKET.

RECS10,	JMS I	(INPSRV)	/OFF TO HANDLE INPUT
	JMP	RECS60		/ERROR RETURN

/	TAKE THE NON-ERROR RETURN.

RECS20,	ISZ	RECSRV		/BUMP FOR NON-ERROR RETURN
	TAD	PRSERR		/GET CURRENT CURSOR POSITION		/018 CJL
	DCA	LPTR		/UPDATE IT				/018 CJL
	JMP I	RECSRV

/	GOT ERROR IN DEVICE NAME.					/018 CJL

RECS30,	CLA CLL			/CLEAN UP				/018 CJL
	TAD	(DNERMSG)	/GET ERROR MESSAGE ADDRESS		/025 CJL
	JMP I	RECSRV		/TAKE ERROR RETURN			/018 CJL

/	TAKE THE ERROR RETURN.

RECS60,	CLA
	JMP I	RECSRV		/TAKE ERROR EXIT

/	DISPATCH TABLE.

RECS80,	STSIN;	RECS10		/SEND INIT PACKET DISPATCH
	STEOT;	RECS60		/END OF CONNECTION
	STBRK;	RECS20		/BREAK TRANSMISSION
	0

RECS90,	0			/TEMP FOR "RECSRV"
/	KEYBOARD LINE BUFFER.						/014 CJL

LINBUF,	ZBLOCK	LINSIZE		/LINE BUFFER

	PAGE								/014 CJL
/	ROUTINE TO SERVICE INPUT OF A FILE.

INPSRV,	0
	JMS I	(SETINI)	/SET UP INIT REGISTERS
	DCA	OFFLG		/INITIALIZE OUTPUT FILE FLAG		/036 CJL
	CIF	USRFLD		/GOTO USR FIELD				/037 CJL
	JMS I	[USRENTRY]	/CALL USER SERVICE ROUTINE		/037 CJL
	RESET			/RESET TABLES				/037 CJL
	DCA	CURSEQ		/RE-SET THE SEQUENCE NUMBER

	FPACK			/FORMAT A PACKET
	INIDAT			/PACKET DATA ADDRESS
	STACK			/"ACK" PACKET TYPE


INPS01,	SPACK			/SEND A PACKET
	1			/AWAIT RESPONSE
	INPS91-2		/DISPATCH TABLE ADDRESS			/027 CJL

/	NAK OR UNDEFINED RESPONSE HERE.

INPS02,	ISZ	RTRYC		/GOT A NAK, CHECK RE-TRY COUNT
	JMP	INPS01		/RE-TRY THE INIT
	JMS	INPERROR	/GIVE UP				/025 CJL

	IER02=	.		/ERROR TABLE ADDRESS			/039 CJL

INPS03,	FPACK			/FORMAT A PACKET
	NODATA			/NO DATA
	STACK			/"ACK" PACKET TYPE

INPS05,	SPACK			/SEND A PACKET
	1			/AWAIT RESPONSE
	INPS90-2		/DISPATCH TABLE ADDRESS			/027 CJL
	JMS	INPERROR	/UNDEFINED RESPONSE			/025 CJL

	IER05=	.		/ERROR TABLE ADDRESS			/039 CJL

/	GOT A DATA PACKET, WRITE TO OUTPUT FILE.

INPS10,	TAD	OFFLG		/CHECK THE OUTPUT FILE FLAG
	SNA CLA			/SKIP IF OUTPUT FILE OPEN
	JMS	INPERROR	/ABORT AND EXIT				/025 CJL
IER10,	JMS I	(WRIPAK)	/WRITE THE PACKET TO THE FILE		/039 CJL
	JMS	INPERROR	/ERROR WRITING PACKET			/025 CJL
IER11,	JMP	INPS03		/LOOP					/039 CJL
/	GOT A FILE HEADER PACKET, OPEN FILE.

INPS20,	TAD	OFFLG		/CHECK IF OUTPUT FILE OPEN
	SZA CLA			/SKIP IF NO
	JMS	INPERROR	/ABORT IF FILE ALREADY OPEN		/025 CJL
IER20,	TAD I	[RRLEN]		/GET CURRENT PACKET LENGTH		/039 CJL
	TAD	(-40-3		/CALCULATE LENGTH OF DATA
	SPA			/SKIP IF DATA IN THE PACKET
	JMS	INPERROR	/ELSE AN ERROR				/025 CJL
IER21,	TAD	(RRDTA)		/CALCULATE LAST BYTE IN DATA		/039 CJL
	DCA	INPS81		/STORE IN POINTER
	NL7777			/SET -1					/032 CJL
	DCA I	INPS81		/TERMINATE NAME WITH A MINUS WORD
	TAD	(FNBLK		/GET ADDRESS OF FILE NAME BLOCK
	DCA	FNPTR		/SAVE FOR NAME PARSE
	TAD	(RRDTA		/GET ADDRESS OF DATA IN PACKET
	JMS I	[PFNAM]		/PARSE OFF THE FILE NAME
	JMS	INPERROR	/ERROR IN FILE NAME			/025 CJL

/	GET TARGET DEVICE.

IER23,	CLA CLL			/CLEAR AC FROM FILE NAME PARSE		/039 CJL
	TAD	DEVNUM		/GET DEVICE NUMBER PARSED		/006
	DCA	ODNUMB		/SAVE OUTPUT DEVICE NUMBER
	TAD	ODNUMB		/GET NUMBER BACK
	JMS I	[HFETCH]	/FETCH HANDLER FOR THIS DEVICE
	JMS	INPERROR	/HANDLER FETCH ERROR			/025 CJL
IER24,	TAD	(FNBLK)		/GET ADDRESS OF FILE NAME BLOCK		/039 CJL
	DCA	INPS22		/PUT IN CALL
	TAD	ODNUMB		/GET DEVICE NUMBER
	CIF	USRFLD		/GOTO USR FIELD				/020 CJL
	JMS I	[USRENTRY]	/CALL USER SERVICE ROUTINE		/035 CJL
	ENTER			/ENTER TENTATIVE FILE			/020 CJL
INPS22,	0			/
	0			/
	JMS	INPERROR	/NO DIRECTORY ROOM			/025 CJL
IER22,	TAD	INPS22		/GET NEW FILE START BLOCK		/039 CJL
	DCA	FSBLK		/SAVE
	TAD	INPS22+1	/GET INDICATED MAXIMUM FILE SIZE	/021 CJL
	IAC			/GIVE ONE MORE THAN 2 LESS		/021 CJL
	DCA	FLEN		/SAVE AS DANGER COUNT			/021 CJL
	ISZ	OFFLG		/SET FLAG FOR OUTPUT FILE OPEN
	NL7777			/INDICATE INITIALIZATION		/020 CJL
	JMS I	[PUTBYTE]	/INITIALIZE OUTPUT FILE ROUTINE		/020 CJL
	HLT			/THIS CAN'T HAPPEN!			/020 CJL
	TAD	FNPTR		/GET POINTER TO 6 BIT FILE NAME
	JMS I	[FILN8]		/MAKE 8 BIT FORMATTED STRING
	JMS I	[SCRIBE]	/TELL THEM
	FRECMSG			/WE ARE RECEIVING
	PRI8B;	NAMBUF		/WHICH FILE WE ARE RECEIVING
	JMS I	[SCRIBE]	/DO A
	CRLF			/<CR>, <LF>
	JMP	INPS03		/LOOP
/	GOT AN END OF FILE PACKET.

INPS30,	TAD	OFFLG		/ANY OUTPUT FILE OPEN?
	SNA CLA			/SKIP IF YES
	JMS	INPERROR	/ERROR					/025 CJL
IER30,	JMS I	[FILCLOSE]	/CLOSE THE FILE				/020/039 CJL
	JMS	INPERROR	/ERROR CLOSING THE FILE			/025 CJL
IER31,/	DCA	OFFLG		/RE-SET FILE OPEN FLAG			/D009/039 CJL
	JMP	INPS03		/CONTINUE

/	GOT AN END OF TRANSMISSION PACKET.

INPS40,	TAD	OFFLG		/WAS A FILE OPEN?
	SZA CLA			/SKIP IF NO
	JMS I	[FILCLOSE]	/CLOSE ANY OPEN FILE			/020 CJL
	NOP			/ERROR CLOSING THE FILE **** FIX THIS ****
	FPACK			/FORMAT A PACKET
	NODATA			/NO DATA IN PACKET
	STACK			/"ACK" PACKET TYPE

	SPACK			/SEND THE PACKET
	0			/NO RESPONSE
	ISZ	INPSRV		/BUMP RETURN FOR NO ERROR
	JMP I	INPSRV		/TAKE NON-ERROR EXIT

/	GOT AN ERROR PACKET.

INPS50,	JMS I	[PRIPAK]	/PRINT THE PACKET DATA
	JMP I	INPSRV		/AND TAKE THE ERROR EXIT		/009/014 CJL

/	INPUT ERRORS COME HERE.						/025 CJL

INPERRO,.-.			/INPUT ERROR ROUTINE			/025 CJL
	FPACK			/FORMAT A PACKET			/025 CJL
	NODATA			/NO DATA				/025 CJL
	STBRK			/"BREAK LINK" PACKET TYPE		/025 CJL
	SPACK			/SEND THE PACKET			/025 CJL
	0			/NO RESPONSE				/025 CJL
	TAD	INPERROR	/GET CALLER				/025 CJL
	JMS I	[SRCHTABLE]	/TRY TO FIND A MATCH			/025 CJL
	INERTABLE-1-1		/IN ERROR TABLE				/025 CJL
	SNA			/SKIP IF FOUND PARTICULAR MESSAGE	/025 CJL
	TAD	(RERRMSG)	/ELSE USE GENERAL MESSAGE		/025 CJL
	JMP I	INPSRV		/TAKE ERROR RETURN			/025 CJL

/	TEMPS FOR "INPSRV".

INPS80,	0
INPS81,	0
	PAGE								/014 CJL
/	DISPATCH TABLES FOR "INPSRV".

INPS90,	STDAT;	INPS10		/HANDLE DATA PACKETS
	STEOF;	INPS30		/HANDLE EOF PACKET
	STEOT;	INPS40		/HANDLE END OF TRANSMISSION PACKET
	STFIL;	INPS20		/HANDLE FILE NAME PACKET
	STERR;	INPS50		/HANDLE ERROR PACKET
	0			/TERMINATE TABLE

INPS91,	STNAK;	INPS02		/HANDLE A NAK PACKET
	STFIL;	INPS20		/HANDLE FILE NAME PACKET
	STERR;	INPS50		/HANDLE ERROR PACKET
	0			/TERMINATE TABLE

/	INPUT ERROR MESSAGE DISPATCH TABLE.				/025/039 CJL

INERTAB,-IER05;	UPERMSG		/UNDEFINED PACKET ERROR			/025 CJL
	-IER11;	DSFLMSG		/DISK OVERFLOW ERROR			/042 CJL
	-IER22;	RIDEMSG		/DIRECTORY FULL ERROR			/025 CJL
	-IER23;	RFLNMSG		/RECEIVED FILE NAME ERROR		/025 CJL
	-IER24;	RHFEMSG		/HANDLER FETCH ERROR			/025 CJL
	-IER31;	FCLEMSG		/FILE CLOSE ERROR			/025 CJL
	0			/THIS ENDS THE LIST			/025 CJL
/	ROUTINE TO CHECK FOR AN ALPHABETIC OR NUMERIC CHAR.
/	ENTER WITH THE CHAR IN THE AC.
/	EXIT + 2 IF ALPHABETIC OR NUMERIC WITH CHAR IN THE AC.
/	EXIT + 1 IF NON-ALPHABETIC OR NUMERIC WITH CHAR IN THE AC.

ALPNUM,	0
	JMS	ALPHA		/CHECK FOR ALPHA FIRST
	SKP			/NON-ALPHA RETURN, MUST CHECK NUMERIC
	JMP	ALPNM1		/IS ALPHA, TAKE RETURN + 2
	JMS	NUMRC		/CHECK IF NUMERIC
	SKP			/NOT NUMERIC
ALPNM1,	ISZ	ALPNUM		/BUMP RETURN FOR ALPHA-NUMERIC
	JMP I	ALPNUM		/DONE


/	ROUTINE TO CHECK FOR AN ALPHABETIC CHARACTER.
/	ROUTINE ASSUMES UPPER CASE.
/	ENTER ROUTINE WITH CHAR IN THE AC.
/	EXIT + 2 IF THE CHAR IS ALPHABETIC WITH THE CHAR IN THE AC.
/	EXIT + 1 IF THE CHAR IS NOT ALPHABETIC WITH THE CHAR IN THE AC.

ALPHA,	0
	DCA	ALPHA1		/STORE THE CHAR FOR RETURN
	TAD	ALPHA1		/GET THE CHAR
	TAD	(-"Z!200-1)	/ADD ON UPPER LIMIT			/034 CJL
	CLL			/INIT LINK FOR A FLAG
	TAD	("Z-"A+1
	SZL			/SKIP IF NOT A LETTER
	ISZ	ALPHA		/IS A LETTER, BUMP RETURN
	CLA CLL			/CLEAR AC
	TAD	ALPHA1		/RESTORE CHAR IN THE AC
	JMP I	ALPHA		/TAKE PROPER RETURN

ALPHA1,	0			/TEMP FOR ALPHA ROUTINE

/	ROUTINE TO CHECK FOR A NUMERIC CHARACTER.
/	ENTER WITH THE CHAR TO CHECK IN THE AC.
/	EXIT + 2 IF NUMERIC WITH THE CHAR IN THE AC.
/	EXIT + 1 IF NON-NUMERIC WITH THE CHAR IN THE AC.

NUMRC,	0
	DCA	NUMRC1		/SAVE THE CHAR FOR RETURN
	TAD	NUMRC1		/GET THE CHAR BACK
	TAD	(-"9!200-1)	/ADD ON UPPER LIMIT			/034 CJL
	CLL			/INIT LINK FOR A FLAG
	TAD	["9-"0+1]						/016 CJL
	SZL			/SKIP IF NOT A DIGIT
	ISZ	NUMRC		/BUMP RETURN FOR NUMERIC
	CLA CLL			/CLEAR AC
	TAD	NUMRC1		/RESTORE CHAR IN THE AC
	JMP I	NUMRC		/DONE

NUMRC1,	0			/TEMP FOR NUMRC CHECK ROUTINE
/	ROUTINE TO WRITE THE CURRENT INPUT PACKET TO THE OUTPUT FILE.
/	ENTER:	NOTHING.
/	EXIT:	+ 2 = WRITE SUCCESSFUL.
/		+ 1 = WRITE NOT SUCCESSFUL.

WRIPAK,	0
	TAD I	[RRLEN]		/GET LENGTH OF PACKET
	TAD	(RRDTA-40-3	/CALCULATE END OF BUFFER
	DCA	W90		/PUT INTO POINTER
	DCA I	W90		/ZERO AFTER END OF BUFFER
	TAD	(RRDTA		/GET ADDRESS OF DATA
	DCA	W90		/PUT INTO POINTER

W10,	TAD I	W90		/GET A CHAR FROM PACKET
	SNA			/SKIP IF NOT END
	JMP	W60		/END, EXIT
	CIA			/NEGATE FOR COMPARE
	TAD	RQCTL		/COMPARE WITH CURRENT QUOTE CHAR
	SNA CLA			/SKIP IF NOT QUOTE CHAR
	JMP	W20		/IS QUOTE, HANDLE SPECIAL
	TAD	W92		/WAS LAST CHAR A QUOTE?
	SZA CLA			/SKIP IF NO
	TAD	(-100		/IT WAS, FIX UP THIS CHAR
	JMP	W25		/HANDLE REST BELOW

W20,	TAD	W92		/CURRENT CHAR A QUOTE, CHECK PREVIOUS
	SNA CLA			/SKIP IF YES
	JMP	W30		/JUST THIS CHAR IS QUOTE, SET FLAG

W25,	TAD I	W90		/GET CHAR FROM BUFFER
	JMS I	[PUTBYTE]	/OUTPUT TO FILE				/020 CJL
	JMP I	WRIPAK		/ERROR IN OUTPUT			/M020 CJL
	JMP	W35		/FINISH BELOW

W30,	NL0001 CLL		/GOTA SET FLAG FOR QUOTE CHARACTER	/032 CJL

W35,	DCA	W92		/SET UP QUOTE FLAG
	ISZ	W90		/BUMP POINTER
	JMP	W10		/LOOP

W60,	ISZ	WRIPAK		/BUMP RETURN FOR OK
	JMP I	WRIPAK		/DONE

W90,	0			/POINTER FOR "WRIPAK"
W92,	0			/TEMP FOR "WRIPAK"
/	TABLE SEARCH ROUTINE.						/025 CJL

/	CALLING SEQUENCE:

/	TAD	VALUE			/AC CONTAINS VALUE TO MATCH
/	JMS I	[SRCHTABLE]		/CALL ROUTINE
/	TABLE-2				/ADDRESS(TABLE)-2
/	RETURN				/ALWAYS RETURNS HERE

/	IF AC=0 THEN NO MATCH OCCURRED.

/	IF AC IS NON-ZERO, THEN AC CONTAINS CORRESPONDING VALUE TO MATCH WHICH IS ALSO
/	STORED IN TABLEJUMP.

/	TABLE FORMAT.

/	-VALUE;	CORRESPONDING VALUE	/TABLE PAIR
/	"";	""			/ADDITIONAL PAIRS AS NECESSARY
/	0				/ZERO TERMINATES THE TABLE

SRCHTAB,.-.				/TABLE SEARCH ROUTINE
	DCA	TABLEJUMP		/SAVE PASSED VALUE TO MATCH
	TAD I	SRCHTABLE		/GET PASSED POINTER ARGUMENT
	DCA	XR0			/STASH THE POINTER
	ISZ	SRCHTABLE		/BUMP PAST ARGUMENT
SRCHLUP,ISZ	XR0			/BUMP TO NEXT PAIR
	TAD I	XR0			/GET A TABLE VALUE
	SNA				/END OF TABLE?
	JMP I	SRCHTABLE		/YES, RETURN WITH CLEAR AC
	TAD	TABLEJUMP		/COMPARE TO DESIRED
	SZA CLA				/SKIP IF IT MATCHES
	JMP	SRCHLUP			/JUMP IF NOT
	TAD I	XR0			/GET CORRESPONDING VALUE
	DCA	TABLEJUMP		/STASH IT
	TAD	TABLEJUMP		/GET IT BACK
	JMP I	SRCHTABLE		/RETURN WITH CORRESPONDING VAUE IN AC

	PAGE								/014 CJL
	IFZERO	1	<

/	OS8 DIRECTORY FILE DATA SETUP.
/	ENTER WITH THE DIRECTORY DATE WORD IN THE AC.
/	EXIT WITH THE DATE IN THE BUFFER "DATBUF".

FILD8,	0
	DCA	FILD89		/SAVE THE DATE WORD
	TAD	FILD89		/GET DATA WORD
	AND	(7		/KEEP ONLY YEAR BITS
	TAD	(116		/ADD 78 YEARS
	MQL			/PUT INTO MQ REGISTER
	TAD	(DATEYR		/GET POINTER TO YEAR
	JMS	DECCON		/CONVERT TO ASCII DATE
	TAD	FILD89		/GET DATE WORD BACK
	CLL RTR			/SHIFT DAY DOWN
	RAR
	AND	(37		/KEEP ONLY DAY BITS
	MQL			/PUT IN MQ REGISTER
	TAD	(DATEDA		/GET POINTER TO DAY
	JMS	DECCON		/CONVERT TO ASCII DAY
	TAD	FILD89		/GET DATE WORD BACK
	BSW			/GET MONTH
	CLL RTR			/DOWN
	AND	(17		/KEEP ONLY MONTH BITS
	MQL			/INTO MQ REGISTER
	TAD	(DATEMO		/GET ADDRESS OF WHERE TO PUT MONTH
	JMS	DECCON		/CONVERT
	JMP I	FILD8		/ALL DONE

FILD89,	0			/TEMP FOR "FILD8"


/	ROUTINE  TO CONVERT A BINARY VALUE INTO A  TWO  DIGIT  ASCII  DECIMAL  NUMBER.
/	ENTER WITH WHERE TO STORE THE CONVERTED NUMBER IN THE AC AND THE NUMBER IN THE
/	MQ REGISTER.

DECCON,	0
	DCA	DECC20		/STORE THE POINTER
	TAD	("0&177-1	/GET AN ASCII ZERO
	DCA I	DECC20		/START OUT WITH A ZERO
	MQA			/GET THE BINARY VALUE
DECC01,	ISZ I	DECC20		/BUMP
	TAD	(-12		/SUB 10
	SMA			/SKIP IF NO MORE DIVISION
	JMP	DECC01		/ELSE KEEP GOING
	TAD	(12+"0&177	/CONVERT REMAINDER TO ASCII
	ISZ	DECC20		/BUMP POINTER
	DCA I	DECC20		/STORE
/	JMS	FMTDAT		/FORMAT FOR PRINTING			/D013
	JMP I	DECCON		/DONE

			>
	IFZERO	1	<

DECC20,	0			/LOCAL POINTER TO DECCON

/	ROUTINE TO SET UP THE DATE IN A MM-DD-YY FORMAT  TO  PUT IN FRONT OF A FILE TO
/	PASS THE FILES DATE (TEMPORY AND NOT PART OF THE KERMIT PROTOCOL).

FMTDAT,	0
	TAD	DATEMO		/GET FIRST CHAR OF DATE
	DCA	FDATE		/MOVE IT
	TAD	DATEMO+1
	DCA	FDATE+1
	TAD	DATEDA
	DCA	FDATE+3
	TAD	DATEDA+1
	DCA	FDATE+4
	TAD	DATEYR
	DCA	FDATE+6
	TAD	DATEYR+1
	DCA	FDATE+7
	JMP I	FMTDAT		/QUICK AND DIRTY

DATBUF,	"#&177			/FILE CREATION DATE ATTRIBUTE
	6+40			/LENGTH OF DATE (CHAR(X))
DATEYR,	0			/ASCII YEAR GOES HERE
	0
DATEMO,	0			/ASCII MONTH GOES HERE
	0
DATEDA,	0			/ASCII DAY GOES HERE
	0
	-1			/TERMINATE

/	FORMATTED DATE GOES HERE.

SETDAT,"ANGLEBRACKET&177	/COMMENT SIGN

FDATE,	0
	0
	"-&177
	0
	0
	"-&177
	0
	0
	12
	15
	-1

			>
/	DIRECTORY LOOKUP ROUTINE.					/028 CJL

/	CALLING SEQUENCE:

/	NL0001				/IF INITIALIZING THE DIRECTORY

/	OR

/	CLA				/CLEAR AC IF SUBSEQUENT CALL

/	JMS I	(LUKUP)			/CALL ROUTINE
/	I/O ERROR			/DIRECTORY I/O ERROR RETURN WITH AC DIRTY
/	NOT FOUND			/FILE NOT FOUND RETURN
/	FOUND				/LATEST FILE MATCHES REQUEST

/	SETS FLEN TO -(FILE LENGTH) IN RECORDS.

/	SETS FSBLK TO STARTING RECORD OF FILE.

/	MODIFIES DIRECTORY SEGMENT SLIGHTLY (NOT TO BE WRITTEN BACK).

/	DEPENDS ON DIRXR BEING UNTOUCHED BY OTHER ROUTINES.

LUKUP,	.-.				/DIRECTORY LOOKUP ROUTINE
	SNA				/INITIALIZING DIRECTORY?
	JMP	NXTFILE			/NO, JUST GET ANOTHER FILE IF POSSIBLE
NEXTSEG,DCA	DIRRECORD		/STORE LATEST DIRECTORY SEGMENT RECORD
	JMS I	HNDADR			/CALL I/O HANDLER
	PAGCNT^100+DIRFLD		/READ IN A DIRECTORY SEGMENT
	DIRBUFFER			/DIRECTORY I/O BUFFER
DIRRECO,.-.				/WILL BE LATEST SEGMENT NUMBER
	JMP I	LUKUP			/I/O ERROR, TAKE DIRTY IMMEDIATE RETURN
	CDF	DIRFLD			/GOTO DIRECTORY FIELD
	TAD I	(FRSTRECORD)		/GET FIRST RECORD OF FIRST ENTRY
	DCA	FSBLK			/STASH IT
	TAD	(ENTSTRT-1)		/POINT TO
	DCA	DIRXR			/ENTRIES
LOOKLUP,TAD I	DIRXR			/GET FIRST WORD OF ENTRY
	SNA				/SKIP IF NOT EMPTY
	JMP	EMPENTRY		/JUMP IF EMPTY ENTRY
	DCA	FNAME			/STORE FIRST FILENAME WORD
	TAD I	DIRXR			/GET NEXT
	DCA	FNAME+1			/STORE SECOND FILENAME WORD
	TAD I	DIRXR			/GET NEXT
	DCA	FNAME+2			/STORE THIRD FILENAME WORD
	TAD I	DIRXR			/GET NEXT
	DCA	FNAME+3			/STORE EXTENSION WORD
	NL7777				/BACKUP
	TAD I	(AIWNUMBER)		/GET ADDITIONAL INFORMATION WORD COUNT
	DCA	AIWCNT			/STASH THE COUNTER
DCADATW,DCA	DATWORD			/CLEAR THE DATE WORD
	TAD	DCADATW/(DCA	DATWORD)/GET STORING INSTRUCTION
	DCA	AIWSTORE		/STORE IN-LINE
	JMP	AIWTEST			/START LOOP THERE
AIWLUP,	TAD I	DIRXR		/GET A WORD FROM ENTRY
AIWSTOR,DCA	DATWORD+.-.	/STORE IN PROPER WORD
	ISZ	AIWSTORE	/BUMP TO NEXT INSTRUCTION
AIWTEST,ISZ	AIWCNT		/DONE ALL ADDITIONAL INFORMATION WORDS?
	JMP	AIWLUP		/NO, KEEP GOING
	TAD I	DIRXR		/GET THE FILE LENGTH
	SNA			/SKIP IF VALID
	JMP	TENTRY		/JUMP IF ONLY TENTATIVE FILE (NO LENGTH)
	DCA	FILENGTH	/STORE FILE LENGTH
	CDF	PRGFLD		/BACK TO OUR FIELD
/	JMS I	(FILTER)	/CHECK IF WE LIKE THIS ONE
	TAD	(FNAME)		/POINT TO LATEST FILENAME
	JMS I	(FMATCH)	/CHECK FOR A MATCH
	JMP	NXTFILE		/FORGET THIS ONE, IT DIDN'T MATCH
	TAD	FILENGTH	/GET FILE LENGTH
	DCA	FLEN		/GIVE TO CALLER TO DESTROY
	TAD	(FNAME)		/POINT TO FILENAME
	JMS I	[FILN8]		/PUT IN CHARACTER FORM IN BUFFER
	ISZ	LUKUP		/BUMP TO FILE MATCH RETURN
	JMP	FLEXIT		/EXIT THERE

/	COMES HERE FROM SUBSEQUENT CALL OR MATCH FAILURE.

NXTFILE,CDF	DIRFLD		/GOTO BUFFER FIELD
	TAD	FILENGTH	/GET LATEST FILE LENGTH
	SKP			/DON'T DO EMPTY LENGTH

/	COMES HERE TO BYPASS AN EMPTY ENTRY.

EMPENTR,TAD I	DIRXR		/GET LENGTH OF EMPTY
	CIA			/WANT POSITIVE FORM
	TAD	FSBLK		/UPDATE TO NEXT FILE RECORD
	DCA	FSBLK		/STORE UPDATED VALUE
TENTRY,	ISZ I	(FILECNT)	/DONE WITH THIS SEGMENT?
	JMP	LOOKLUP		/NO, KEEP GOING
	TAD I	(DIRLINK)	/GET LINK TO NEXT SEGMENT
	CDF	PRGFLD		/BACK TO OUR FIELD
	SZA			/END OF DIRECTORY?
	JMP	NEXTSEGMENT	/NO, GO DO NEXT SEGMENT
FLEXIT,	ISZ	LUKUP		/BUMP PAST I/O ERROR EXIT
	JMP I	LUKUP		/RETURN FOR FILE NOT FOUND

AIWCNT,	.-.			/ADDITIONAL INFORMATION WORD COUNTER
DATWORD,.-.			/DATE WORD STORED HERE (0000 IF NONE)
	ZBLOCK	7		/ROOM FOR MORE ADDITIONAL INFORMATION WORDS
FILENGT,.-.			/LATEST FILE LENGTH
FNAME,	ZBLOCK	4		/FILENAME AND EXTENSION STORED HERE

	PAGE
/	OS/8 FILE UNPACK ROUTINE.					/019 CJL

/	THIS ROUTINE UNPACKS BYTES FROM THE INPUT FILE ACCORDING TO THE  CURRENT VALUE
/	OF FILMODE:

/	FILMODE CONTAINS 0177 (ASCII MODE).  ALL BYTES ARE TREATED AS SEVEN-BIT  ASCII
/	CHARACTERS BY STRIPPING THE HIGH-ORDER BIT.  END OF FILE IS THE <^Z> CHARACTER
/	WHICH  WILL  BE  SENT  OR  NOT  ACCORDING  TO  THE  CONTENTS OF OCTLZFLAG.  IF
/	OCTLZFLAG CONTAINS  NON-ZERO,  THEN <^Z> WILL BE SENT AT <EOF>;  THE NEXT CALL
/	WILL YIELD THE  <EOF>  RETURN.   IF OCTLZFLAG CONTAINS ZERO, THEN DETECTION OF
/	<^Z> YIELDS THE <EOF> RETURN IMMEDIATELY.

/	FILMODE CONTAINS 4377 (BINARY  MODE).    ALL  BYTES  ARE  TREATED AS EIGHT-BIT
/	CHARACTERS AND WILL BE SENT  WITHOUT <^Z> CHECK.  THE NEXT CALL AFTER THE LAST
/	BYTE OF THE LAST RECORD HAS BEEN SENT YIELDS THE <EOF> RETURN.

/	CALLING CONSIDERATIONS:

/	OCTLZFLAG MUST BE SETUP ACCORDINGLY IF IN ASCII MODE.

/	FILMODE MUST BE SETUP ACCORDINGLY.

/	FLEN MUST CONTAIN -(FILE LENGTH IN  RECORDS) WHEN INITIALIZING THE INPUT FILE.
/	IT WILL BE MODIFIED BY CALLING THIS ROUTINE.

/	FSBLK MUST CONTAIN THE THE STARTING RECORD WHEN INITIALIZING THE INPUT FILE.

/	HNDADR MUST ALREADY BE SETUP TO CALL THE INPUT HANDLER.

/	CALLING SEQUENCE:

/	CLA				/OR NL7777 IF INITIALIZING THE INPUT FILE
/	JMS I	(GETBYTE)		/CALL ROUTINE
/	I/O ERROR RETURN		/FATAL INPUT ERROR OCCURRED; AC CONTAINS JUNK
/	END OF FILE			/<EOF> OCCURRED
/	GOOD RETURN			/AC CONTAINS LATEST SEVEN/EIGHT-BIT CHARACTER

GETBYTE,.-.				/GET A BYTE ROUTINE
	SNA CLA				/INITIALIZING?
	JMP I	PUTC			/NO, GO GET NEXT BYTE
	TAD	FSBLK			/GET STARTING RECORD OF INPUT FILE
	DCA	GETRECORD		/STORE IN-LINE
GETNEWR,JMS I	HNDADR			/CALL I/O HANDLER
	PAGCNT^100+BUFFLD		/READ SOME PAGES INTO BUFFER FIELD
GETCORE,FILBUFFER			/BUFFER ADDRESS
GETRECO,.-.				/WILL BE LATEST RECORD NUMBER
	JMP I	GETBYTE			/INPUT ERROR!
	TAD	GETCORE/(FILBUFFER)	/SETUP THE
	DCA	BUFPTR			/BUFFER POINTER
GETLOOP,DCA	THIRD			/CLEAR THIRD BYTE NOW
	JMS	PUTONE			/OBTAIN AND SEND BACK FIRST BYTE
	JMS	PUTONE			/OBTAIN AND SEND BACK SECOND BYTE
	TAD	THIRD			/GET THIRD BYTE
	JMS	PUTC			/SEND IT BACK
	TAD	BUFPTR			/GET THE POINTER
	TAD	(-PAGCNT^200-FILBUFFER)	/COMPARE TO LIMIT
	SZA CLA				/SKIP IF AT END
	JMP	GETLOOP			/KEEP GOING
	ISZ	GETRECORD		/BUMP TO NEXT RECORD
	ISZ	FLEN			/DONE ALL RECORDS? (BINARY MODE ONLY)
	JMP	GETNEWRECORD		/NO, GO DO ANOTHER ONE

/	BINARY <EOF> REACHED HERE.

	JMP	GETEOF			/TAKE SKIP RETURN TO MAIN CALLER

PUTONE,	.-.				/SEND BACK A BYTE ROUTINE
	CDF	BUFFLD			/GOTO BUFFER FIELD
	TAD I	BUFPTR			/GET LATEST WORD
	AND	[7400]			/JUST THIRD-BYTE NYBBLE
	CLL RAL				/MOVE UP
	TAD	THIRD			/GET OLD NYBBLE (IF ANY)
	RTL;RTL				/MOVE UP NYBBLE BITS
	DCA	THIRD			/SAVE FOR NEXT TIME
	TAD I	BUFPTR			/GET LATEST WORD AGAIN
	JMS	PUTC			/SEND BACK CURRENT BYTE
	ISZ	BUFPTR			/BUMP TO NEXT WORD
	JMP I	PUTONE			/RETURN

PUTC,	.-.				/SEND BACK LATEST BYTE ROUTINE
	CDF	PRGFLD			/BACK TO OUR FIELD
	RAL				/MOVE UP
	STL RAR				/MOVE DOWN WITH BIT[0] SET
	AND	FILMODE			/KEEP ONLY GOOD BITS
	TAD	[-CNTRLZ]		/COMPARE TO <^Z>
	SNA				/SKIP IF NOT ASCII MODE <EOF>
	JMP	GETEND			/JUMP IF ASCII MODE <EOF>
GETUPZ,	TAD	[CNTRLZ]		/RESTORE THE CHARACTER
	AND	[377]			/ENSURE EIGHT-BIT (MIGHT ALREADY BE SEVEN-BIT)
	ISZ	GETBYTE			/BUMP PAST <EOF> RETURN
GETEOF,	ISZ	GETBYTE			/BUMP PAST I/O ERROR RETURN
	JMP I	GETBYTE			/RETURN TO MAIN CALLER

/	GOT <Z> IN ASCII MODE.

GETEND,	TAD	OCTLZFLAG		/GET <^Z> DISPOSITION FLAG
	SNA CLA				/SKIP IF SET
	JMP	GETEOF			/JUST RETURN <EOF> CONDITION
	TAD	(GETEOF)		/POINT TO <EOF>
	DCA	PUTC			/FOR NEXT TIME
	JMP	GETUPZ			/GIVE THEM BACK <^Z> THIS TIME
/	OS/8 FILE PACK ROUTINE.						/020 CJL

/	THIS ROUTINE PACKS BYTES INTO THE OUTPUT  FILE  ACCORDING TO THE CURRENT VALUE
/	OF FILMODE:

/	FILMODE CONTAINS 0177 (ASCII MODE).  ALL BYTES  ARE TREATED AS SEVEN-BIT ASCII
/	CHARACTERS BY STRIPPING THE HIGH-ORDER BIT.

/	FILMODE  CONTAINS  4377  (BINARY MODE).  ALL BYTES ARE  TREATED  AS  EIGHT-BIT
/	CHARACTERS AND WILL BE WRITTEN AS IS.

/	CALLING CONSIDERATIONS:

/	FILMODE MUST BE SETUP ACCORDINGLY.

/	FLEN  MUST  CONTAIN  -(MAXIMUM  FILE LENGTH IN RECORDS) WHEN INITIALIZING  THE
/	TENTATIVE OUTPUT FILE.  IT WILL BE MODIFIED BY CALLING THIS ROUTINE.

/	FSBLK  MUST CONTAIN THE STARTING RECORD WHEN INITIALIZING THE TENTATIVE OUTPUT
/	FILE.

/	HNDADR MUST ALREADY BE SETUP TO CALL THE OUTPUT HANDLER.

/	CALLING SEQUENCE:

/	NL7777				/ANY NEGATIVE VALUE
/	JMS I	[PUTBYTE]		/CALL ROUTINE TO INITIALIZE
/	IMPOSSIBLE			/CAN'T RETURN HERE
/	GOOD RETURN			/ALWAYS RETURNS HERE

/	OR

/	TAD	(CHAR&377)		/ANY EIGHT-BIT (OR LESS) VALUE
/	JMS I	[PUTBYTE]		/CALL ROUTINE TO PACK A CHARACTER
/	ERROR RETURN			/I/O ERROR WHILE WRITING A BUFFER
/	GOOD RETURN			/CHARACTER PACKED WITH NO ERRORS

/	ALL RETURNS CLEAR THE AC.

PUTBYTE,.-.				/OUTPUT A BYTE ROUTINE
	SPA				/ARE WE INITIALIZING?
	JMP	PUTINITIALIZE		/YES
	AND	FILMODE			/REDUCE TO SEVEN-BIT/EIGHT-BIT
	DCA	LATEST			/SAVE LATEST CHARACTER
	CDF	BUFFLD			/GOTO BUFFER FIELD
	TAD	LATEST			/GET LATEST CHARACTER
	JMP I	PUTNEXT			/GO WHERE YOU SHOULD GO

PUTNEXT,.-.				/EXIT ROUTINE
	ISZ	PUTBYTE			/BUMP TO GOOD RETURN
PUTERRO,CLA CLL				/CLEAN UP
	CDF	PRGFLD			/BACK TO OUR FIELD
	JMP I	PUTBYTE			/RETURN TO MAIN CALLER
PUTINIT,CLA				/CLEAN UP
	TAD	FSBLK			/GET STARTING RECORD OF TENTATIVE FILE
	DCA	PUTRECORD		/STORE IN-LINE
	DCA I	(FLENGTH)		/CLEAR ACTUAL FILE LENGTH
PUTNEWR,TAD	PUTCORE/(FILEBUFFER)	/SETUP THE
	DCA	BUFPTR			/BUFFER POINTER
PUTLOOP,JMS	PUTNEXT			/GET A CHARACTER
	DCA I	BUFPTR			/STORE IT
	TAD	BUFPTR			/GET POINTER VALUE
	DCA	TEMPTR			/SAVE FOR LATER
	ISZ	BUFPTR			/BUMP TO NEXT
	JMS	PUTNEXT			/GET A CHARACTER
	DCA I	BUFPTR			/STORE IT
	JMS	PUTNEXT			/GET A CHARACTER
	RTL;RTL				/MOVE UP
	AND	[7400]			/ISOLATE HIGH NYBBLE
	TAD I	TEMPTR			/ADD ON FIRST BYTE
	DCA I	TEMPTR			/STORE COMPOSITE
	TAD	LATEST			/GET LATEST CHARACTER
	RTR;RTR;RAR			/MOVE UP AND
	AND	[7400]			/ISOLATE LOW NYBBLE
	TAD I	BUFPTR			/ADD ON SECOND BYTE
	DCA I	BUFPTR			/STORE COMPOSITE
	ISZ	BUFPTR			/BUMP TO NEXT
	TAD	BUFPTR			/GET LATEST POINTER VALUE
	TAD	(-PAGCNT^200-FILBUFFER)	/COMPARE TO LIMIT
	SZA CLA				/SKIP IF AT END
	JMP	PUTLOOP			/KEEP GOING
	CDF	PRGFLD			/BACK TO OUR FIELD
	ISZ	FLEN			/TOO MANY RECORDS?
	SKP				/SKIP IF NOT
	JMP I	PUTBYTE			/TAKE ERROR RETURN
	JMS I	HNDADR			/CALL I/O HANDLER
	PAGCNT^100+BUFFLD+WRITE		/WRITE SOME PAGES FROM BUFFER FIELD
PUTCORE,FILBUFFER			/BUFFER ADDRESS
PUTRECO,.-.				/WILL BE LATEST RECORD NUMBER
	JMP	PUTERROR		/OUTPUT ERROR!
	ISZ I	(FLENGTH)		/BUMP ACTUAL LENGTH
	ISZ	PUTRECORD		/BUMP TO NEXT RECORD
	JMP	PUTNEWRECORD		/KEEP GOING

BUFPTR,	.-.				/INPUT/OUTPUT BUFFER POINTER

/	ASCII FILE MODE <^Z> OUTPUT DISPOSITION FLAG.

OCTLZFL,OCLOSE				/ZERO=DON'T SEND <^Z> AT <EOF>,
					/NON-ZERO=SEND <^Z> AT <EOF>

	THIRD=	PUTNEXT			/THIRD BYTE TEMPORARY

	TEMPTR=	PUTONE			/TEMPORARY BUFFER POINTER
	PAGE
/	OUTPUT FILE CLOSE ROUTINE					/020 CJL

/	THIS  ROUTINE  CLOSES  THE OPEN OUTPUT FILE ACCORDING TO THE CURRENT VALUE  OF
/	FILMODE:

/	FILMODE  CONTAINS  0177  (ASCII  MODE).  ALL BYTES PRIOR TO CLOSE ARE STRIPPED
/	SEVEN-BIT CHARACTERS.    IF  THE  LAST  CHARACTER SENT TO PUTBYTE (CONTENTS OF
/	LATEST) IS A  <^Z>,  THEN  JUST  CLOSE THE FILE.  IF NOT, THEN IF ICTLZFLAG IS
/	NON-ZERO, INSERT A <^Z>  CHARACTER INTO THE FILE AS <EOF> INDICATOR, ELSE JUST
/	CLOSE THE FILE.

/	FILMODE CONTAINS 4377 (BINARY MODE).    ALL BYTES PRIOR TO CLOSE ARE EIGHT-BIT
/	CHARACTERS.  IF NECESSARY, <NUL> CHARACTERS WILL BE APPENDED TO THE END OF THE
/	LAST BLOCK OF THE FILE TO FILL IT.  THE FILE IS CLOSED OTHERWISE UNMODIFIED.

/	CALLING CONSIDERATIONS.

/	OFFLG MUST BE SET (OUTPUT FILE IS OPEN).

/	FLENGTH MUST CONTAIN THE ACTUAL FILE LENGTH.

/	LATEST MUST CONTAIN THE LAST BYTE SENT  TO  THE OUTPUT FILE VIA PUTBYTE (ASCII
/	MODE ONLY).

/	ICTLZFLAG MUST BE SETUP ACCORDINGLY.

/	FILMODE MUST BE SETUP ACCORDINGLY.

/	CALLING SEQUENCE:

/	CLA CLL			/CLEAR AC
/	JMS I	(FILCLOSE)	/CALL ROUTINE
/	ERROR RETURN		/ERROR WHILE CLOSING FILE
/	GOOD RETURN		/FILE CLOSED PROPERLY

/	ON RETURN, OFFLG WILL BE CLEAR; THE AC WILL BE CLEAR ALSO.

FILCLOS,.-.			/OUTPUT FILE CLOSE ROUTINE
	TAD	FILMODE		/GET CURRENT FILE MODE
	SPA CLA			/SKIP IF ASCII
	JMP	CLOSIT		/JUMP IF BINARY
	TAD	LATEST		/GET LATEST CHARACTER
	TAD	[-CNTRLZ]	/COMPARE TO <^Z>
	SZA CLA			/SKIP IF <^Z> ALREADY IN FILE
	TAD	ICTLZFLAG	/GET <^Z> DISPOSITION FLAG
	SNA CLA			/SKIP IF SET
	JMP	CLOSIT		/JUMP IF NOT
	TAD	[CNTRLZ]	/GET A <^Z>
CLOSLUP,JMS I	[PUTBYTE]	/OUTPUT A BYTE
	JMP	CLOSERROR	/ERROR WHILE WRITING
CLOSIT,	TAD I	(BUFPTR)	/GET THE BUFFER POINTER
	TAD	(-FILBUFFER)	/COMPARE TO RESET VALUE
	SZA CLA			/SKIP IF IT MATCHES
	JMP	CLOSLUP		/ELSE KEEP GOING
	TAD	ODNUMBER	/GET OUTPUT DEVICE NUMBER
	CIF	USRFLD		/GOTO USR FIELD
	JMS I	[USRENTRY]	/CALL USER SERVICE ROUTINE		/035 CJL
	CLOSE			/CLOSE FILE
	FNBLK			/=> FILENAME
FLENGTH,.-.			/ACTUAL FILE LENGTH
CLOSERR,SKP CLA			/ERROR WHILE CLOSING THE FILE
	ISZ	FILCLOSE	/BUMP RETURN IF NO ERRORS
	DCA	OFFLG		/CLEAR OUTPUT FILE OPEN FLAG
	JMP I	FILCLOSE	/RETURN TO CALLER

/	ASCII FILE MODE <^Z> INPUT DISPOSITION FLAG.

ICTLZFL,ICLOSE			/ZERO=DON'T ENSURE <^Z> IN FILE, NON-ZERO=PACK <^Z>
				/IF LAST CHARACTER WASN'T <^Z>
/	SEND PROCESSING

SNDPRO,	0
	TAD	INIFLG		/CHECK IF SEND/INIT HAS BEEN DONE
	SZA CLA			/SKIP IF NO
	JMP	SNDP10		/RIGHT INTO FILE TRANSFER
	TAD	(DEFCK		/SET UP DEFAULT CHECKSUM
	DCA	RCHKT
	TAD	(DEFEOL		/GET DEFAULT EOL
	DCA	REOL		/AND SET IT
	TAD	(DEFQCTL	/GET DEFAULT QUOTE CONTROL CHAR
	DCA	RQCTL		/AND SET IT UP
	TAD	(DEFMAXL+40	/GET DEFAULT MAX BUFFER SIZE
	DCA	RMAXL		/SET IT UP
	DCA	CURSEQ		/RE-SET SEQUENCE NUMBER
	JMS I	(SNDI00)	/HANDLE "SEND-INIT"
	JMP I	SNDPRO		/TAKE ERROR RETURN			/014 CJL

/	SEND FILE HEADER DISPATCH ROUTINE

SNDP10,	FPACK			/FORMAT A PACKET
	NAMBUF			/ADDRESS OF FILE HEADER FOR DATA
	STFIL			/"FIL" PACKET TYPE

SNDP11,	SPACK			/SEND A PACKET
	1			/AWAIT RESPONSE
	SNDP96-2		/DISPATCH TABLE ADDRESS			/026 CJL

/	GOT A NAK OR UNDEFINED HERE

SNDP12,	ISZ	RTRYC		/BUMP THE COUNTER
	JMP	SNDP11		/TRY AGAIN
	JMP I	SNDPRO		/TAKE ERROR RETURN			/014 CJL

/	FILE CREATION DATE HANDLING

SNDP15,	IFZERO	1	<

	TAD	RCAPAS		/CHECK IF REMOTE SUPPORTS FILE
	AND	(10		/  ATTRIBUTES
	SNA CLA			/SKIP IF YES
	JMP	SNDP20		/SKIP IF NO
	FPACK			/FORMAT PACKET
	DATBUF			/DATE DATA
	STATT			/"ATT" PACKET TYPE

SNDP16,	SPACK			/SEND THE PACKET
	1			/AWAIT RESPONSE
	SNDP98-2		/DISPATCH TABLE ADDRESS			/027 CJL
	JMP I	SNDPRO		/TAKE ERROR RETURN			/014 CJL

			>
/	GOT ACK HERE

SNDP20,	JMS I	[SCRIBE]	/TELL THEM				/025 CJL
	FSENMSG			/WE ARE SENDING				/025 CJL
	PRI8B;	NAMBUF		/TELL THEM THE NAME OF THE FILE
	JMS I	[SCRIBE]	/DO A					/025 CJL
	CRLF			/<CR>, <LF>				/025 CJL
	JMS	SLOOP
	SKP			/ERROR RETURN
	ISZ	SNDPRO		/BUMP FOR NON-ERROR EXIT
	JMP I	SNDPRO
/	DATA SEND LOOP.
/	ROUTINE TO GET CHARS FROM THE INPUT BUFFER AND SEND THEM TO REMOTE
/	VIA PACKET TRANSFERS.  RETURN + 1 IF ERROR, + 2 IF DONE.

SLOOP,	0
	JMS I	(INIOPB)	/INIT OUTPUT PACKET HOLD BUFFER
	NL7777			/INITIALIZE INPUT FILE ROUTINE		/019 CJL
SLOP01,	JMS I	(GETBYTE)	/GET A FILE CHARACTER			/019 CJL
	JMP I	SLOOP		/FATAL I/O ERROR			/026 CJL
	JMP	SLOP15		/HERE ON EOF
	JMS I	(OPBUF)		/PUT INTO PACKET BUFFER
	SKP			/RETURN HERE ON BUFFER FULL
	JMP	SLOP01		/RETURN HERE IF STILL ROOM

/	PACKET IS FULL HERE, WE MUST SEND IT.

	FPACK			/FORMAT A PACKET
	HOLDBF			/DATA ADDRESS
	STDAT			/"DAT" PACKET TYPE

SLOP05,	SPACK			/SEND PACKET
	1			/AWAIT RESPONSE
	SLOP90-2		/RESPONSE TABLE ADDRESS			/027 CJL

/	HERE ON NAK OR FALL THRU ON UNDEFINED RESPONSE ABOVE.

SLOP10,	ISZ	RTRYC		/BUMP THE RE-TRY COUNTER
	JMP	SLOP05		/TRY AGAIN
	JMP I	SLOOP		/TAKE ERROR RETURN			/026 CJL

/	HERE ON END OF FILE  --  SEND THEM WHAT WE HAVE.

SLOP15,	TAD I	(OP2)		/GET THE POINTER			/052 CJL
	TAD	(-HOLDBF)	/COMPARE TO EMPTY VALUE			/052 CJL
	SNA CLA			/SKIP IF NOT EMPTY			/052 CJL
	JMP	SLOP35		/JUMP IF EMPTY				/052 CJL
	FPACK			/FORMAT A PACKET
	HOLDBF			/ADDRESS OF DATA
	STDAT			/"DAT" PACKET TYPE

SLOP20,	SPACK			/SEND A PACKET
	1			/AWAIT RESPONSE
	SLOP92-2		/DISPATCH TABLE ADDRESS			/027 CJL

/	NAK FOR LAST PACKET.		

SLOP25,	ISZ	RTRYC		/BUMP RE-TRY COUNTER
	JMP	SLOP20		/TRY AGAIN
	JMP I	SLOOP		/TAKE ERROR RETURN			/026 CJL
/	ACK FOR FINAL PACKET, SEND AN EOF PACKET.

SLOP35,	JMS I	[SNDP]		/SEND A PACKET
	NODATA			/NO DATA
	STEOF			/MAKE IT AN EOF PACKET
	JMP I	SLOOP		/NAK, TAKE ERROR RETURN
	JMP I	SLOOP		/OTHER THAN ACK, NAK; TAKE ERROR RETURN	/026 CJL
	ISZ	SLOOP		/EOF ACCEPTED, BUMP FOR GOOD RETURN
	JMP I	SLOOP		/TAKE GOOD RETURN

	PAGE
SLOP90,	STACK;	SLOP01		/ACK, CONTINUE
	STNAK;	SLOP10		/NAK, HANDLE
	0

SLOP92,	STACK;	SLOP35		/ACK, CONTINUE
	STNAK;	SLOP25		/NAK, HANDLE
	0

/	COMMAND DISPATCH TABLE FOR SEND SERVICE.

SNDP96,	STACK;	SNDP15		/FILE HEADER ACKNOWLEDGED
	STNAK;	SNDP12		/NAK RETURNED, RE-TRY
	0			/END OF TABLE

SNDP98,	STACK;	SNDP20		/DATE ATTRIBUTE ACKNOWLEDGED
	0			/END OF TABLE
/	ROUTINE TO HANDLE A "SEND-INIT" COMMAND.
/	RETURN + 1 IF ERROR.
/	RETURN + 2 IF SUCCESSFUL.

SNDI00,	0
	FPACK			/FORMAT A PACKET
	INIDAT			/ADDRESS OF DATA FOR PACKET
	STSIN			/"SIN" PACKET TYPE

SNDI02,	SPACK			/SEND A PACKET
	1			/AWAIT RESPONSE
	SNDI80-2		/RESPONSE TABLE TYPE			/027 CJL

/	HERE ON NAK OR UNDEFINED.

SNDI05,	ISZ	RTRYC		/BUMP RE-TRY COUNTER
	JMP	SNDI02		/TRY AGAIN
	JMP I	SNDI00		/TAKE ERROR EXIT

/	HERE ON ACK.

SNDI10,	JMS	SETINI		/SET UP THE INIT REGISTERS
	NL0001 CLL		/NOW FLAG THE SEND/INIT DONE		/032 CJL
	DCA	INIFLG		/BY MAKING THIS NON-ZERO
	ISZ	SNDI00		/BUMP FOR NON-ERROR RETURN
	JMP I	SNDI00		/BACK TO MAIN SEND PROCESSING

SNDI80,	STACK;	SNDI10		/GOT AN ACK
	STNAK;	SNDI05		/NAK
	0			/END OF TABLE


/	ROUTINE TO MOVE THE SEND/INIT OR RECEIVE/INIT PACKET INTO THE INIT REGISTERS.

SETINI,	0
	TAD	(RMAXL		/GET ADDRESS OF RECEIVE INIT REGISTERS
	DCA	MQ		/SETUP FOR CLEAR ROUTINE		/032 CJL
	TAD	(RMAXL-INITEND)	/GET -(NUMBER OF REGISTERS)		/022 CJL
	CLEAR			/CLEAR OUT A CHUNK OF MEMORY		/M013
/	TAD	(RMAXL		/GET ADDRESS OF RECEIVE INIT REGISTERS
/	DCA	MQ		/SETUP FOR MOVE ROUTINE			/032 CJL
	TAD I	[RRLEN]		/GET LENGTH OF PACKET JUST INPUT
	TAD	(-40-4		/COUNT OF DATA RECEIVED
	TAD	(RMAXL-INITEND)	/COMPARE TO MAXIMUM ALLOWED		/022 CJL
	SMA SZA			/SKIP IF NOT TOO MANY			/022 CJL
	CLA			/ELSE USE ALLOWED MAXIMUM		/022 CJL
	TAD	(INITEND-RMAXL)	/RESTORE VALUE				/022 CJL
	CIA			/MAKE IT NEGATIVE
	DCA	MOVE4		/SAVE FOR "MOVE" ROUTINE
	TAD	(RRDTA		/ADDRESS OF DATA IN PACKET
	MOVE			/MOVE THE INIT REGISTERS
	JMP I	SETINI		/DONE
	IFZERO	1	<						/D013

/	ROUTINE TO SEND THE DATE IN A DATA PACKET.
/	RETURN + 1 IF ERROR, + 2 IF SUCCESSFUL.

DATOUT,	0
	JMS	INIOPB		/INSURE PACKET HOLD BUFFER INITIALIZED
	TAD	(SETDAT		/GET ADDRESS OF DATE
	DCA	DATOU9		/PUT INTO POINTER

DATOU1,	TAD I	DATOU9		/GET A CHAR
	ISZ	DATOU9		/BUMP POINTER
	SPA			/SKIP IF NOT ENT
	JMP	DATOU2		/DONE
	JMS	OPBUF		/PUT INTO HOLD BUFFER
	SKP			/HOLD FULL, SEND IT
	JMP	DATOU1		/LOOP

DATOU2,	CLA CLL			/INSURE CLEAR AC
	FPACK			/FORMAT A PACKET
	HOLDBF			/DATA ADDRESS
	STDAT			/DATA PACKET

DATOU3,	SPACK			/SEND THE PACKET
	1			/GET RESPONSE
	DATOU7-2		/DISPATCH TABLE ADDRESS			/027 CJL

/	HERE ON NAK OR UNDEFINED RESPONSE.

DATOU4,	ISZ	RTRYC		/BUMP RE-TRY COUNTER
	JMP	DATOU3		/TRY AGAIN
	JMP I	DATOUT		/ABORT

/	HERE ON ACK.

DATOU5,	ISZ	DATOUT		/BUMP FOR GOOD RETURN
	JMP I	DATOUT		/EXIT

DATOU7,	STACK;	DATOU5		/ACK
	STNAK;	DATOU4		/NAK
	0

DATOU9,	0			/TEMP POINTER FOR DATOUT

			>						/D013
/	HANDLE AN ABORT REQUEST.

ABORT,	CLA CLL			/INSURE CLEAR AC
	DCA	ABFLAG		/CLEAR ABORT FLAG NOW			/044 CJL
	TAD	KMODE		/GET CURRENT MODE
	TAD	(-MSEND		/IS IT A SEND?
	SZA			/SKIP IF YES
	JMP	ABORT2		/NOT SEND

	JMS I	[SNDP]		/SEND OUT A PACKET
	ABORT9			/WHICH HAS A "D" IN THE DATA
	STEOF			/AND IS AN EOF PACKET
	NOP			/WE GOT NAK BACK HERE
	NOP			/WE GOT NEITHER NAK OR ACK HERE
	JMS I	(BRKXMT)	/BREAK THE SEND
	JMP	ABORT3		/FINISH THE ABORT

ABORT2,	TAD	(MSEND-MREC	/CHECK IF IN RECEIVE MODE
	SZA CLA			/SKIP IF YES
	JMP	ABORT3		/JUST BACK TO COMMAND LOOP
	JMS I	[SNDP]		/SEND A PACKET BACK FOR AN ABORT

	IFZERO	1	<						/D009

	ABORT8			/WHICH HAS AN "X" IN THE DATA
	STACK			/MAKE IT AN ACK PACKET
	NOP			/NAK HERE
	NOP			/NOT NAK OR ACK HERE

			>						/D009

	NODATA			/NO DATA				/A009
	STBRK			/BREAK TRANSMISSION			/A009
	NOP			/NAK HERE				/A009
	CLA			/NOT ACK OR NAK HERE			/A009
	TAD	OFFLG		/GET FILE OPEN FLAG			/A009
	SZA CLA			/IS IT OPEN YET?			/A009
	JMS I	[FILCLOSE]	/CLOSE THE OUTPUT FILE			/020 CJL
	CLA			/ERROR DURING CLOSE **** FIX THIS ****
ABORT3,	TAD	(ABMSG)		/GET MESSAGE ADDRESS			/044 CJL
	JMP I	[CLOOP7]	/DISPLAY THE ABORT

ABORT9,	"D&137			/DATA PACKET FOR SEND ABORT
	-1

	PAGE								/014 CJL
/	ROUTINE TO PRINT 8 BIT CHARS ON THE  TTY.  ENTER ROUTINE WITH THE ADDRESS OF
/	THE TEXT IN THE AC OR IF AC IS  ZERO  THE  ADDRESS  IS  IN THE CALL + 1.  TEXT
/	TERMINATES ON A MINUS WORD.

PRI8B0,	0
	SZA			/SKIP IF ADDRESS NOT IN AC
	JMP	PRI8B1		/ADDRESS IS IN THE AC
	TAD I	PRI8B0		/GET ADDRESS FROM CALL + 1
	ISZ	PRI8B0		/BUMP RETURN POINTER
PRI8B1,	DCA	MQ		/SAVE ADDRESS OF STRING			/032 CJL
	TAD	[P7ECHO]	/GET CONSOLE OUTPUT ROUTINE ADDRESS	/043 CJL
	JMS	EIGHTB		/AND SEND IT
	JMP I	PRI8B0		/ALL DONE

/	ROUTINE TO SEND 8 BIT CHARS DOWN THE REMOTE LINE.    ENTER  ROUTINE  WITH  THE
/	ADDRESS OF THE TEXT IN THE AC OR IF AC IS ZERO THE ADDRESS IS IN THE CALL + 1.
/	TEXT TERMINATES ON A MINUS WORD.

REM8B0,	0
	SZA			/SKIP IF ADDRESS NOT IN AC
	JMP	REM8B1		/ADDRESS IN AC
	TAD I	REM8B0		/GET ADDRESS FROM CALL + 1
	ISZ	REM8B0		/BUMP RETURN

REM8B1,	DCA	MQ		/SAVE ADDRESS OF STRING			/032 CJL
	TAD	(COMOUT)	/GET ADDRESS OF REMOTE OUTPUT ROUTINE	/046 CJL
	JMS	EIGHTB		/AND SEND THE STRING
	JMP I	REM8B0		/DONE


/	ROUTINE TO SEND 8 BIT DATA.  ENTER WITH ADDRESS OF DATA  IN  THE  MQ  AND  THE
/	ADDRESS  OF  THE ROUTINE TO TAKE EACH BYTE IN THE AC.  TEXT  TERMINATES  ON  A
/	MINUS WORD.

EIGHTB,	0
	DCA	EIGHT5		/STORE POINTER TO ROUTINE
	TAD	MQ		/GET STRING POINTER			/032 CJL
	DCA	EIGHT6		/STORE IN LOCAL POINTER

EIGHT1,	TAD I	EIGHT6		/GET A CHAR
	ISZ	EIGHT6		/BUMP THE POINTER
	SPA			/SKIP IF NOT EOL
	JMP	EIGHT2		/GOT EOL
	JMS I	EIGHT5		/CALL OUTPUT ROUTINE
	CLA CLL			/INSURE CLEAR AC
	JMP	EIGHT1		/LOOP

EIGHT2,	CLA CLL			/CLEAR THE AC
	JMP I	EIGHTB		/DONE

EIGHT5,	0			/POINTER TO ROUTINE TO DO OUTPUT
EIGHT6,	0			/POINTER TO TEXT TO OUTPUT
/	ROUTINE TO UNPACK 6-BT	CHARS FROM MEMORY.  BEFORE  CALLING INIT "GET6P" AS  A
/	POINTER  TO THE STRING LOCATION AND "GET6F" SHOULD BE ZEROED TO START WITH THE
/	TOP BYTE OF THE FIRST MEMORY LOCATION.

GET60,	0
	NL4000			/SET 4000				/032 CJL
	TAD	GET6F		/GET THE FLAG
	DCA	GET6F		/RETURN THE FLAG
	TAD I	GET6P		/GET TWO BYTES
	SZL			/HIGH-ORDER WANTED?			/032 CJL
	JMP	GETSWT		/JUMP IF NOT				/032 CJL
	RTR;RTR;RTR		/MOVE DOWN HIGH-ORDER HALF		/032 CJL
	SKP			/DON'T BUMP POINTER YET			/032 CJL
GETSWT,	ISZ	GET6P		/BUMP TO NEXT WORD			/032 CJL
	AND	[77]		/STRIP UNUSED BITS			/016 CJL
	JMP I	GET60		/DONE


/	LOCAL ROUTINE  TO  "FILN8"  TO  MAKE  THE 6 BIT CHAR IN THE AC INTO 8 BITS AND
/	STORE IN A STRING.

MOV8,	.-.			/6-BIT CHARACTER => 7-BIT CHARACTER	/028 CJL
	SNA			/SKIP IF SOMETHING PASSED		/028 CJL
	TAD	[" &77]		/ELSE SUPPLY A <SPACE>			/025 CJL
	TAD	[" &77]		/INVERT THE CHARACTER			/028 CJL
	AND	[77]		/JUST SIX-BITS				/014/016 CJL
	TAD	[" &77]		/MAKE IT SEVEN-BIT ASCII		/028 CJL
	DCA I	MOV8P		/STORE IN THE STRING			/028 CJL
	ISZ	MOV8P		/BUMP POINTER FOR NEXT TIME		/028 CJL
	JMP I	MOV8		/RETURN					/028 CJL

MOV8P,	0			/POINTER FOR "MOV8" ROUTINE
/	ROUTINE TO PULL A FILE	NAME  IN 6 BIT POINTED TO  BY THE AC  AND PLACE IN THE
/	FILE NAME BUFFER IN  8  BIT  ADDING  IN  THE  "."  TO  SEPARATE  FILE NAME AND
/	EXTENSION.  A MINUS WORD WILL FOLLOW THE NAME.

FILN8,	0
	DCA	GET6P		/SET POINTER FOR "GET6"
	DCA	GET6F		/SET FLAG FOR "GET6"
	TAD	(NAMBUF		/GET ADDRESS OF THE NAME BUFFER
	DCA	MOV8P		/SET IN A POINTER
	TAD	(-6		/6 NAME CHARS TO DO
	DCA	FILN8C		/SAVE IN COUNTER
	GET6			/PULL A CHAR
	SZA			/SKIP IF A SPACE
	JMS	MOV8		/PUT INTO THE BUFFER
	ISZ	FILN8C		/BUMP COUNTER
	JMP	.-4		/LOOP TILL ALL 6 DONE
	TAD	(".&177)	/GET A "."				/034 CJL
	JMS	MOV8		/PUT WITH FILE NAME
	NL7776			/SET -2					/032 CJL
	DCA	FILN8C		/2 EXTENSION CHARS
	GET6			/GET NEXT CHAR
	SZA			/SKIP IF A SPACE
	JMS	MOV8		/PUT WITH NAME
	ISZ	FILN8C		/BUMP COUNTER
	JMP	.-4		/LOOP
	NL7777			/SET -1					/032 CJL
	DCA I	MOV8P		/TERMINATE THE STRING
	JMP I	FILN8		/AND RETURN

FILN8C,	0			/COUNTER FOR "FILN8"

	PAGE
/	CONSOLE I/O ROUTINES, ETC.					/023 CJL

/	CONSOLE MESSAGE PRINT ROUTINE.

/	CALLING SEQUENCE:

/	JMS I	[SCRIBE]	/CALL MESSAGE PRINT ROUTINE
/	MESSAGEADDRESS		/MESSAGE ADDRESS PASSED IN-LINE

/	AC CAN BE DIRTY ON CALL.

/	RETURNS WITH CLEAR AC.

/	MESSAGE FORMAT:

/	ALL UPPER-CASE CHARACTERS ARE ALLOWED  TO  EXIST IN THE MESSAGE EXCEPT '%' AND
/	'^' WHICH ARE RESERVED.  A  ZERO  HALF-WORD TERMINATES THE MESSAGE STRING.  IF
/	'%' IS DETECTED, A <CR> AND <LF>  WILL  BE  OUTPUT.    IF '^' IS DETECTED, THE
/	PREVAILING CASE WILL BE REVERSED.  INITIAL CASE IS LOWER-CASE.  IF 'UPONLY' IS
/	SET  TO  7740,  ALL  CASE CHANGES ARE IGNORED AND  THE  OUTPUT  IS  FORCED  TO
/	UPPER-CASE  ONLY.    THE MESSAGE ADDRESS MUST BE IN FIELD  ONE  AND  MUST  NOT
/	OVERLAP  AREAS  RESERVED FOR OTHER PURPOSES (OS/8 RESIDENT AT 17600-17777, USR
/	LOCATIONS 10000-11777, ETC.).


SCRIBE,	.-.			/CONSOLE MESSAGE PRINT ROUTINE
	CLA			/CLEAN UP				/029 CJL
	TAD	[P7ECHO]	/POINT TO				/043 CJL
RSCRENT,DCA	MSGOUT		/CONSOLE PRINT ROUTINE
	TAD I	SCRIBE		/GET IN-LINE POINTER ARGUMENT
	DCA	SCRPTR		/STASH THE POINTER
	ISZ	SCRIBE		/BUMP PAST ARGUMENT
	TAD	UPONLY		/GET UPPER-ONLY VALUE			/030 CJL
	TAD	[140]		/ADD ON LOWER-CASE VALUE		/030 CJL
	DCA	SCRCASE		/STORE INITIAL CASE VALUE
SCRLUP,	CDF	MSGFLD		/GOTO MESSAGE FIELD
	TAD I	SCRPTR		/GET LEFT HALF-WORD
	RTR;RTR;RTR		/MOVE OVER
	JMS	SCRPRNT		/PRINT IT
	CDF	MSGFLD		/GOTO MESSAGE FIELD
	TAD I	SCRPTR		/GET RIGHT HALF-WORD
	JMS	SCRPRNT		/PRINT IT
	ISZ	SCRPTR		/BUMP TO NEXT PAIR
	JMP	SCRLUP		/KEEP GOING
SCRPRNT,.-.			/CHARACTER PRINT ROUTINE
	CDF	PRGFLD		/BACK TO OUR FIELD
	AND	[77]		/JUST SIX BITS
	SNA			/END OF MESSAGE?
	JMP I	SCRIBE		/YES, RETURN TO ORIGINAL CALLER
	DCA	SCRCHAR		/NO, SAVE FOR NOW
	TAD	SCRCHAR		/GET IT BACK
	TAD	(-"%!200)	/IS IT "%"?
	SNA			/SKIP IF NOT
	JMP	SCRCRLF		/JUMP IF IT MATCHES
	TAD	[-"^+100+"%]	/IS IT "^"
	SNA CLA			/SKIP IF NOT
	JMP	SCRFLIP		/JUMP IF IT MATCHES
	TAD	SCRCHAR		/GET THE CHARACTER
	AND	[40]		/DOES CASE MATTER?
	SNA CLA			/SKIP IF NOT
	TAD	SCRCASE		/ELSE GET PREVAILING CASE
	TAD	SCRCHAR		/GET THE CHARACTER
SCRPRLF,JMS I	MSGOUT		/PRINT THE CHARACTER
	JMP I	SCRPRNT		/RETURN

SCRCRLF,TAD	[CNTRLM]	/GET A <CR>
	JMS I	MSGOUT		/PRINT IT
	TAD	[CNTRLJ]	/GET A <LF>
	JMP	SCRPRLF		/CONTINUE THERE

SCRFLIP,TAD	UPONLY		/GET UPPER-ONLY FLAG
	SZA CLA			/SKIP IF OFF
	JMP I	SCRPRNT		/RETURN IF ON
	TAD	SCRCASE		/GET CURRENT CASE
	CIA			/INVERT IT
	TAD	(140+100)	/ADD SUM OF POSSIBLE VALUES
	DCA	SCRCASE		/STORE NEW INVERTED CASE
	JMP I	SCRPRNT		/RETURN

/	REMOTE LINE MESSAGE PRINT ROUTINE.

/	CALLING SEQUENCE:

/	JMS I	[RSCRIBE]	/CALL MESSAGE PRINT ROUTINE
/	MESSAGEADDRESS		/MESSAGE ADDRESS PASSED IN-LINE

/	AC CAN BE DIRTY ON CALL.

/	RETURNS WITH CLEAR AC.

/	MESSAGE FORMAT AND RESTRICTIONS ARE IDENTICAL TO SCRIBE ROUTINE.

RSCRIBE,.-.			/REMOTE LINE MESSAGE PRINT ROUTINE
	CLA			/CLEAN UP				/029 CJL
	TAD	RSCRIBE		/GET OUR CALLER
	DCA	SCRIBE		/MAKE IT THEIRS
	TAD	(COMOUT)	/POINT TO REMOTE OUTPUT ROUTINE
	JMP	RSCRENTRY	/CONTINUE THERE
/	ESCAPE CHARACTER PRINT ROUTINE.

/	CALLING SEQUENCE:

/	TAD	ESCHAR		/OR OTHER CHARACTER TO PRINT
/	JMS I	[ESCPRNT]	/CALL ROUTINE
/	RETURNS WITH CLEAR AC HERE

/	CAUSES CHARACTER TO PRINT LITERALLY IF CHARACTER>37.
/	CAUSES MESSAGE "CONTROL-" FOLLOWED BY CHARACTER+100 IF CHARACTER<40.

ESCPRNT,.-.			/ESCAPE CHARACTER PRINT ROUTINE
	DCA	ESCTEMP		/SAVE PASSED VALUE
	TAD	ESCTEMP		/GET IT BACK
	TAD	[-40]		/COMPARE TO CONTROL LIMIT
	SMA CLA			/SKIP IF LESS THAN LIMIT
	JMP	ESPRINT		/JUMP IF NOT
	JMS I	[SCRIBE]	/GIVE THEM THE
	CONTMSG			/CONTROL MESSAGE
	TAD	[100]		/MAKE IT UPPER-CASE, NOT CONTROL
ESPRINT,TAD	ESCTEMP		/GET ORIGINAL VALUE
	JMS I	[P7ECHO]	/PRINT IT				/043 CJL
	JMP I	ESCPRNT		/RETURN

	MSGOUT=	RSCRIBE		/OUTPUT ROUTINE POINTER

ESCTEMP,.-.			/TEMPORARY FOR ESCPRNT ROUTINE
SCRCASE,.-.			/CURRENT MESSAGE CASE
SCRCHAR,.-.			/LATEST MESSAGE CHARACTER
SCRPTR,	.-.			/MESSAGE POINTER

	PAGE
/	ROUTINE TO HANDLE THE "CONNECT" COMMAND.			/025 CJL

CONSRV,	.-.			/CONNECT SERVICE ROUTINE
	JMS I	[CREST2]	/SETUP CONSOLE OUTPUT ROUTINES		/025 CJL
	JMS I	[SCRIBE]	/GIVE THE
	CONNMSG			/OPENING MESSAGE
	TAD	ESCHAR		/GET THE CURRENT <ESCAPE> CHARACTER
	JMS I	[ESCPRNT]	/PRINT IT
	JMS I	[SCRIBE]	/GIVE THEM THE
	CON2MSG			/BRIDGING MESSAGE
	JMS I	[SCRIBE]	/PRINT OUT THE
	CPUMSG			/ACTUAL CPU TYPE
	JMS I	[SCRIBE]	/GIVE THEM THE
	CON3MSG			/CLOSING MESSAGE
CORESET,DCA	ESCFLAG		/CLEAR <ESCAPE> SEEN FLAG
	TAD	ESCHAR		/GET THE <ESCAPE> CHARACTER
	DCA	ESCH		/STORE IN SEARCH LIST
	JMS I	(CONRESET)	/RESET CONSOLE ROUTINES
	JMS I	(REMRESET)	/RESET REMOTE LINE ROUTINES
CONNLUP,TAD	KEYERROR	/GET KEYBOARD ERROR FLAG
	SNA			/SKIP IF KEYBOARD ERROR
	TAD	RINERROR	/ELSE GET REMOTE ERROR FLAG
	SZA CLA			/SKIP IF NEITHER KEYBOARD NOR REMOTE LINE ERRORS
	JMP	KERROR		/JUMP IF KEYBOARD ERROR
	JMS I	(CONTEST)	/TEST IF CONSOLE CAN TAKE OUTPUT
	JMP	TESTKEYBOARD	/JUMP IF NOT
	JMS I	(REMINPUT)	/TEST IF ANY REMOTE INPUT
	SKP			/SKIP IF NONE
	JMS I	(CONOUT)	/OUTPUT TO CONSOLE
TESTKEY,TAD	ECHOFLAG	/GET LOCAL ECHO FLAG
	TAD	ESCFLAG		/ADD ON <ESCAPE> SEEN FLAG
	SNA CLA			/SKIP IF LOCAL ECHO POSSIBLY NEEDED
	JMP	NOLOCALECHO	/JUMP IF NOT
	JMS I	(CONTEST)	/TEST IF CONSOLE CAN TAKE OUTPUT
	JMP	BUFCHECK	/JUMP IF NOT
NOLOCAL,JMS I	(REMTEST)	/TEST IF REMOTE CAN TAKE OUTPUT
	JMP	BUFCHECK	/JUMP IF NOT
	JMS I	(KEYINPUT)	/TEST IF ANY KEYBOARD INPUT
	JMP	BUFCHECK	/JUMP IF NOT
	DCA	KEYLATEST	/SAVE FOR LATER
	TAD	KEYLATEST	/GET IT BACK
	AND	[177]		/WANT SEVEN-BIT VERSION FOR TESTS
	CIA			/INVERT IT
	DCA	TESTCHAR	/SAVE FOR LATER
	TAD	ESCFLAG		/<ESCAPE> SEEN LAST TIME?
	SNA CLA			/SKIP IF SO
	JMP	NOESCAPE	/JUMP IF NOT
	TAD	TESTCHAR	/GET TEST VAUE
	JMS I	[SRCHTABLE]	/SEARCH FOR IT
	ESCLIST-1-1		/SEARCH TABLE POINTER
	SNA CLA			/SKIP IF FOUND
	JMP	ESCOMPLAIN	/JUMP IF NOT
	JMP I	TABLEJUMP	/GO WHERE YOU'RE SUPPOSED TO
/	COMES HERE IF PREVIOUS WAS NOT THE <ESCAPE> CHARACTER.

NOESCAP,TAD	TESTCHAR	/GET THE LATEST CHARACTER
	TAD	ESCHAR		/COMPARE TO <ESCAPE> CHARACTER
	SZA CLA			/SKIP IF IT MATCHES
	JMP	OUTCHAR		/JUMP IF NOT
	NL7777			/SET THE
/	DCA	ESCFLAG		/<ESCAPE> SEEN FLAG
/	JMP	BUFCHECK	/CONTINUE THERE
	JMP	NOESENTRY	/CONTINUE THERE

/	COMES HERE IF BOTH PREVIOUS AND LATEST ARE THE <ESCAPE> CHARACTER.

ESCTYPE,DCA	ESCFLAG		/CLEAR THE <ESCAPE> SEEN FLAG AND OUTPUT

/	COMES HERE IF PREVIOUS AND LATEST CHARACTER ARE NOT THE <ESCAPE> CHARACTER.

OUTCHAR,TAD	ECHOFLAG	/GET LOCAL ECHO FLAG
	SNA CLA			/SKIP IF SET
	JMP	NOECHO		/JUMP IF NOT
	TAD	KEYLATEST	/GET LATEST CHARACTER
	JMS I	(CONOUT)	/OUTPUT TO CONSOLE
NOECHO,	TAD	KEYLATEST	/GET LATEST CHARACTER
	JMS I	(REMOUT)	/OUTPUT TO REMOTE
	JMP	BUFCHECK	/CONTINUE THERE

/	COMES HERE IF PREVIOUS WAS THE <ESCAPE> CHARACTER AND THE LATEST IS NOT
/	A VALID <ESCAPE> COMMAND CHARACTER.

ESCOMPL,TAD	[CNTRLG]	/GET A <BEL>
	JMS I	(CONOUT)	/OUTPUT TO CONSOLE
NOESENT,DCA	ESCFLAG		/CLEAR <ESCAPE> SEEN FLAG
BUFCHEC,JMS I	PUPSTATUS	/UPDATE THE PORT STATUS			/047 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE USE ONLY.  THE DEFAULT INSTRUCTION IS FOR
/	KL8 INTERFACES.

	*BUFCHECK		/OVERLAY DECMATE CODE			/047 CJL

BUFCHEC,NOP			/DON'T CHECK PORT STATUS		/047 CJL

	JMS I	(RINUPDATE)	/CHECK FOR MORE REMOTE INPUT
	JMS I	(KEYUPDATE)	/CHECK FOR MORE KEYBOARD INPUT
	JMS I	(REMUPDATE)	/CHECK FOR MORE REMOTE OUTPUT
	JMS I	(CONUPDATE)	/CHECK FOR MORE CONSOLE OUTPUT
	JMP	CONNLUP		/GO BACK FOR MORE

/	COMES HERE ON <ESCAPE> C(LOSE).

ESCLOSE,ISZ	CONSRV		/BUMP TO GOOD RETURN
	JMP I	CONSRV		/RETURN
KERRLUP,JMS I	PUPSTATUS	/UPDATE THE PORT STATUS			/047 CJL

/	THE ABOVE INSTRUCTION IS FOR DECMATE USE ONLY.  THE DEFAULT INSTRUCTION IS FOR
/	KL8 INTERFACES.

	*KERRLUP		/OVERLAY DECMATE CODE			/047 CJL

KERRLUP,NOP			/DON'T CHECK PORT STATUS		/047 CJL

	JMS I	(RINUPDATE)	/CHECK FOR MORE REMOTE INPUT
	JMS I	(KEYUPDATE)	/CHECK FOR MORE KEYBOARD INPUT
	JMS I	(REMUPDATE)	/CHECK FOR MORE REMOTE OUTPUT
	JMS I	(CONUPDATE)	/CHECK FOR MORE CONSOLE OUTPUT

/	COMES HERE ON KEYBOARD INPUT ERROR.

KERROR,	JMS I	(CONTEST)	/CONSOLE READY FOR OUTPUT?
	JMP	KERRLUP		/NO, GO WAIT AWHILE
	TAD I	(CONINSERT)	/GET CONSOLE INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD I	(CONREMOVE)	/COMPARE TO CONSOLE REMOVAL POINTER
	SZA CLA			/SKIP IF CONSOLE OUTPUT BUFFER EMPTY
	JMP	KERRLUP		/GO WAIT FOR AWHILE
	TAD	KEYERROR	/KEYBOARD INPUT ERROR?
	SNA CLA			/SKIP IF SO
	JMP	RIERTST		/JUMP IF NOT
	JMS I	[SCRIBE]	/TELL THEM
	KERRMSG			/WE HAD A KEYBOARD ERROR
RIERTST,TAD	RINERROR	/REMOTE INPUT ERROR?
	SNA CLA			/SKIP IF SO
	JMP	CORESET		/JUMP IF NOT
	JMS I	[SCRIBE]	/TELL THEM
	RIERMSG			/WE HAD A REMOTE LINE ERROR
	JMP	CORESET		/RESTART

/	<ESCAPE> CHARACTER SEARCH LIST.

ESCLIST,UPPERC;	ESCLOSE		/<ESCAPE> C(LOSE)
	LOWERC;	ESCLOSE		/<ESCAPE> C(LOSE) (LOWER-CASE)
ESCH,	.-.;	ESCTYPE		/<ESCAPE> <ESCAPE>
	0			/THIS ENDS THE LIST

/	LOCAL ECHO FLAG FOR CONNECT MODE.

ECHOFLA,INIECHO			/0=DON'T ECHO, NON-ZERO=ECHO		/039 CJL
ESCFLAG,.-.			/<ESCAPE> CHARACTER SEEN FLAG
KEYLATE,.-.			/LATEST KEYBOARD CHARACTER
PUPSTAT,UPSTATUS		/POINTER TO DECMATE STATUS UPDATE	/047 CJL
TESTCHA,.-.			/LATEST KEYBOARD TEST CHARACTER
	PAGE
/	CONNECT-MODE SUPPORT ROUTINES.					/047 CJL

/	CONSOLE KEYBOARD ROUTINES.					/047 CJL

/	KEYBOARD INPUT ROUTINE.						/026 CJL

/	CALLING SEQUENCE:

/	JMS I	(KEYINPUT)	/CALL ROUTINE
/	NO INPUT		/RETURN IF NO INPUT
/	INPUT			/RETURN IF INPUT AVAILABLE

/	THE AC WILL BE CLEAR IF THE IMMEDIATE RETURN IS TAKEN FOR NO INPUT.

/	THE AC WILL CONTAIN THE LATEST CHARACTER IF THE SKIP RETURN IS TAKEN.

KEYINPU,.-.			/KEYBOARD INPUT ROUTINE
	TAD	KEYINSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	KEYREMOVE	/COMPARE TO REMOVAL POINTER
	SNA CLA			/SKIP IF BUFFER NOT EMPTY
	JMP	KEYCHECK	/JUMP IF BUFFER EMPTY
	TAD	KEYREMOVE	/GET REMOVAL POINTER
	DCA	KEYTEMP		/SAVE FOR LATER
	NL0001			/SET INCREMENT
	TAD	KEYREMOVE	/UPDATE REMOVAL POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	[KEYBUFFER]	/MAKE IT ABSOLUTE
	DCA	KEYREMOVE	/STORE UPDATED POINTER
	CDF	BUFFLD		/GOTO BUFFER FIELD
	TAD I	KEYTEMP		/GET THE LATEST CHARACTER
	CDF	PRGFLD		/BACK TO OUR FIELD
	SKP			/DON'T GET ANOTHER CHARACTER		/047 CJL

/	COMES HERE IF BUFFER IS EMPTY.

KEYCHEC,JMS	KEYGET		/TRY TO GET A CHARACTER NOW		/047 CJL
	ISZ	KEYINPUT	/GOT ONE, SO TAKE SKIP RETURN		/047 CJL
	JMP I	KEYINPUT	/RETURN EITHER WAY
/	KEYBOARD BUFFER UPDATE ROUTINE.					/026 CJL

/	CALLING SEQUENCE:

/	JMS I	(KEYUPDATE)	/CALL ROUTINE

/	RETURNS  WITH  CLEAR  AC.    ANY  KEYBOARD  INPUT  WHICH JUST OCCURRED WILL BE
/	BUFFERED;  CALLS TO KEYINPUT WILL RETRIEVE THE CHARACTERS.

KEYUPDA,.-.			/KEYBOARD BUFFER UPDATE ROUTINE
	JMS	KEYGET		/TRY TO GET A CHARACTER NOW		/047 CJL
	SKP			/GOT ONE, DON'T LEAVE YET		/047 CJL
	JMP I	KEYUPDATE	/CHARACTER NOT AVAILABLE NOW, RETURN	/047 CJL
	CDF	BUFFLD		/GOTO BUFFER FIELD
	DCA I	KEYINSERT	/STORE IN THE BUFFER
	CDF	PRGFLD		/BACK TO OUR FIELD
	NL0001			/SET INCREMENT
	TAD	KEYINSERT	/UPDATE POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	[KEYBUFFER]	/MAKE IT ABSOLUTE
	DCA	KEYINSERT	/STORE BACK UPDATED POINTER
	TAD	KEYINSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	KEYREMOVE	/COMPARE TO REMOVAL POINTER
	SNA CLA			/SKIP IF NOT EQUAL
KSERROR,ISZ	KEYERROR	/INDICATE KEYBOARD ERROR
	JMP I	KEYUPDATE	/RETURN
	JMP	KSERROR		/MAKE SURE ERROR IS INDICATED
/	KEYBOARD GET A CHARACTER ROUTINE.				/047 CJL

/	CALLING SEQUENCE:

/	JMS	KEYGET		/CALL ROUTINE
/	CHARACTER AVAILABLE	/RETURNS HERE WITH LATEST CHARACTER
/	NO CHARACTER AVAILABLE	/RETURNS HERE IF NO CHARACTER OR HANDLED FLOW-CONTROL

/	NORMAL RETURN HAS LATEST CHARACTER IN AC.

/	SKIP RETURN HAS CLEAR AC.

/	IF FLOWFLAG=0, FLOW CHARACTERS ARE UNPROCESSED AND CAUSE NORMAL RETURN.

KEYGET,	.-.			/KEYBOARD GET A CHARACTER ROUTINE
KGTEST,	KSFIOT			/FLAG UP?
	JMP	KEYGNONE	/NO, TAKE SKIP RETURN
KGREAD,	KRBIOT			/YES, READ THE CHARACTER
	SPA			/SKIP IF NO UART ERRORS
	ISZ	KEYERROR	/INDICATE KEYBOARD ERROR
	SKP			/SKIP IF NOT TOO MANY ERRORS
	JMP	.-2		/ENSURE KEYBOARD ERROR IS INDICATED
	AND	[377]		/JUST EIGHT-BIT
	DCA	KEYTEMP		/SAVE FOR NOW
	TAD	FLOWFLAG	/GET FLOW CONTROL FLAG
	SNA CLA			/SKIP IF SET
	JMP	KEYGEXIT	/JUMP IF NOT
	TAD	KEYTEMP		/GET THE CHARACTER
	AND	[177]		/JUST SEVEN-BIT
	TAD	[-CNTRLS]	/COMPARE TO <^S>
	SNA			/SKIP IF OTHER
	JMP	KWATSET		/JUMP IF IT MATCHES
	TAD	[-CNTRLQ+CNTRLS]/COMPARE TO <^S>
	SNA CLA			/SKIP IF OTHER
	JMP	KWATCLEAR	/JUMP IF IT MATCHES
KEYGEXI,TAD	KEYTEMP		/GET THE CHARACTER
	JMP I	KEYGET		/TAKE IMMEDIATE RETURN

/	COMES HERE ON <^S> TO SET OUTPUT WAIT.

KWATSET,NL4000			/SET WAIT VALUE

/	COMES HERE ON <^Q> TO CLEAR OUTPUT WAIT.

KWATCLE,DCA	CONWAIT		/STORE NEW STATE
KEYGNON,ISZ	KEYGET		/BUMP RETURN ADDRESS
	JMP I	KEYGET		/TAKE SKIP RETURN
/	CONSOLE TERMINAL ROUTINES.

/	CONSOLE OUTPUT ROUTINE.

/	CALLING SEQUENCE:

/	TAD	CHAR		/CHARACTER TO OUTPUT IN AC
/	JMS I	(CONOUT)	/CALL ROUTINE
/	RETURN			/RETURNS HERE WITH CLEAR AC

CONOUT,	.-.			/CONSOLE OUTPUT ROUTINE
	DCA	CONTEMP		/SAVE PASSED VALUE
	TAD	CONINSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	CONREMOVE	/COMPARE TO REMOVAL POINTER
	TAD	CONWAIT		/ADD ON WAIT STATUS
	SZA CLA			/SKIP IF BUFFER EMPTY AND NOT WAITING	/047 CJL
	JMP	CSTUFF		/JUMP IF CHARACTER MUST BE BUFFERED
	TAD	CONTEMP		/GET PASSED VALUE			/047 CJL
	JMS I	(CONPUT)	/TRY TO OUTPUT THE CHARACTER NOW			/047 CJL
	JMP	CSTUFF		/COULDN'T OUTPUT IT, SO BUFFER IT	/047 CJL
	JMP I	CONOUT		/RETURN

CSTUFF,	TAD	CONTEMP		/GET THE CHARACTER
	CDF	BUFFLD		/GOTO BUFFER FIELD
	DCA I	CONINSERT	/STORE THE CHARACTER
	CDF	PRGFLD		/BACK TO OUR FIELD
	NL0001			/SET INCREMENT
	TAD	CONINSERT	/UPDATE POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	[CONBUFFER]	/MAKE IT ABSOLUTE
	DCA	CONINSERT	/STORE BACK UPDATED POINTER
	JMP I	CONOUT		/RETURN

/	CONSOLE OUTPUT TEST ROUTINE.

/	CALLING SEQUENCE:

/	JMS I	(CONTEST)	/CALL ROUTINE
/	NOT READY		/RETURN IF OUTPUT NOT READY FOR NEXT CHARACTER
/	READY			/OUTPUT CAN ACCEPT ANOTHER CHARACTER NOW

CONTEST,.-.			/CONSOLE OUTPUT TEST ROUTINE
	NL0001			/SET BUFFER INCREMENT
	TAD	CONINSERT	/GET UPDATED INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	CONREMOVE	/COMPARE TO REMOVAL POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	SZA CLA			/SKIP IF BUFFER IS FULL
	ISZ	CONTEST		/BUMP RETURN IF NOT
	JMP I	CONTEST		/RETURN EITHER WAY
/	CONSOLE OUTPUT BUFFER UPDATE ROUTINE.

/	CALLING SEQUENCE:

/	JMS I	(CONUPDATE)	/CALL ROUTINE
/	RETURN			/RETURN WITH CLEAR AC

/	THE CONSOLE OUTPUT BUFFERING ROUTINES WILL  UPDATE  POINTERS,  ETC.    IF  ANY
/	STATUS HAS CHANGED SINCE THE LAST CALL.

CONUPDA,.-.			/CONSOLE OUTPUT UPDATE ROUTINE
	TAD	CONWAIT		/FLOW CONTROL WAIT SET?
	SZA CLA			/SKIP IF NOT
	JMP I	CONUPDATE	/JUST RETURN IF SO
	TAD	CONINSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	CONREMOVE	/COMPARE TO REMOVAL POINTER
	SNA CLA			/SKIP IF BUFFER CONTAINS SOMETHING	/047 CJL
	JMP I	CONUPDATE	/RETURN IF BUFFER EMPTY			/047 CJL
	CDF	BUFFLD		/GOTO BUFFER FIELD
	TAD I	CONREMOVE	/GET A CHARACTER FROM THE BUFFER
	CDF	PRGFLD		/BACK TO OUR FIELD
	JMS I	(CONPUT)	/TRY TO OUTPUT THE CHARACTER NOW	/047 CJL
	JMP I	CONUPDATE	/COULDN'T DO IT, SO JUST RETURN		/047 CJL
	NL0001			/SET BUFFER INCREMENT
	TAD	CONREMOVE	/UPDATE REMOVAL POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	[CONBUFFER]	/MAKE IT ABSOLUTE
	DCA	CONREMOVE	/STORE UPDATED POINTER
	JMP I	CONUPDATE	/RETURN

CONINSE,.-.			/CONSOLE OUTPUT INSERTION POINTER
CONREMO,.-.			/CONSOLE OUTPUT REMOVAL POINTER

/	CONSOLE FLOW CONTROL WAIT FLAG.

CONWAIT,.-.			/0=DON'T WAIT, 4000=WAIT FOR <^Q>
KEYINSE,.-.			/KEYBOARD BUFFER INSERTION POINTER
KEYREMO,.-.			/KEYBOARD BUFFER REMOVAL POINTER

	CONTEMP=CONUPDATE	/CONSOLE OUTPUT TEMPORARY

	KEYTEMP=CONUPDATE	/KEYBOARD INPUT TEMPORARY

	PAGE
/	REMOTE LINE ROUTINES.

/	REMOTE LINE INPUT ROUTINE.					/026 CJL

/	CALLING SEQUENCE:

/	JMS I	(REMINPUT)	/CALL ROUTINE
/	NO INPUT		/RETURN IF NO INPUT
/	INPUT			/RETURN IF INPUT AVAILABLE

/	THE AC WILL BE CLEAR IF THE IMMEDIATE RETURN IS TAKEN FOR NO INPUT.

/	THE AC WILL CONTAIN THE LATEST CHARACTER IF THE SKIP RETURN IS TAKEN.

REMINPU,.-.			/REMOTE LINE INPUT ROUTINE
	TAD	RININSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	RINREMOVE	/COMPARE TO REMOVAL POINTER
	SNA CLA			/SKIP IF BUFFER NOT EMPTY
	JMP	RINCHECK	/JUMP IF BUFFER EMPTY
	TAD	RINREMOVE	/GET REMOVAL POINTER
	DCA	RINTEMP		/SAVE FOR LATER
	NL0001			/SET INCREMENT
	TAD	RINREMOVE	/UPDATE REMOVAL POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	(RINBUFFER)	/MAKE IT ABSOLUTE
	DCA	RINREMOVE	/STORE UPDATED POINTER
	CDF	BUFFLD		/GOTO BUFFER FIELD
	TAD I	RINTEMP		/GET THE LATEST CHARACTER
	CDF	PRGFLD		/BACK TO OUR FIELD
	DCA	RINTEMP		/SAVE FOR LATER
	TAD	FLOWFLAG	/GET FLOW CONTROL FLAG
	SNA CLA			/SKIP IF SET
	JMP	REMINEXIT	/JUMP IF NOT
	NL4000			/SET WAITING VALUE
	TAD	RINWAIT		/ARE WE WAITING TO EMPTY?
	SZA CLA			/SKIP IF SO
	JMP	REMINEXIT	/JUMP IF NOT
	TAD	RININSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	RINREMOVE	/COMPARE TO REMOVAL POINTER
	AND	[BUFSIZE^3%4]	/JUST 3/4 BITS
	SZA CLA			/SKIP IF BUFFER NOW 1/4 FULL (OR LESS)
	JMP	REMINEXIT	/JUMP IF NOT
	NL7777			/SET BUFFER EMPTYING VALUE
	DCA	RINWAIT		/STORE FOR OUTPUT ROUTINE
REMINEX,TAD	RINTEMP		/GET THE CHARACTER
	SKP			/DON'T GET ANOTHER ONE			/047 CJL

/	COMES HERE IF REMOTE LINE INPUT BUFFER IS EMPTY.

RINCHEC,JMS	RINGET		/TRY TO GET A CHARACTER NOW		/047 CJL
	ISZ	REMINPUT	/GOT ONE, SO TAKE SKIP RETURN		/047 CJL
	JMP I	REMINPUT	/RETURN EITHER WAY
/	REMOTE LINE INPUT BUFFER UPDATE ROUTINE.			/026 CJL

/	CALLING SEQUENCE:

/	JMS I	(RINUPDATE)	/CALL ROUTINE

/	RETURNS WITH CLEAR AC.  ANY REMOTE LINE  INPUT  WHICH  JUST  OCCURRED  WILL BE
/	BUFFERED;  CALLS TO REMINPUT WILL RETRIEVE THE CHARACTERS.

RINUPDA,.-.			/REMOTE LINE INPUT BUFFER UPDATE ROUTINE
	JMS	RINGET		/TRY TO GET A CHARACTER NOW		/047 CJL
	SKP			/GOT ONE, DON'T LEAVE YET		/047 CJL
	JMP I	RINUPDATE	/CHARACTER NOT AVAILABLE NOW, RETURN	/047 CJL
	CDF	BUFFLD		/GOTO BUFFER FIELD
	DCA I	RININSERT	/STORE IN THE BUFFER
	CDF	PRGFLD		/BACK TO OUR FIELD
	NL0001			/SET INCREMENT
	TAD	RININSERT	/UPDATE POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	(RINBUFFER)	/MAKE IT ABSOLUTE
	DCA	RININSERT	/STORE BACK UPDATED POINTER
	TAD	RININSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	RINREMOVE	/COMPARE TO REMOVAL POINTER
	SNA			/SKIP IF BUFFER NOT FULL
	ISZ	RINERROR	/INDICATE REMOTE LINE INPUT ERROR
	SKP			/SKIP IF NO OVERFLOW
	JMP	.-2		/ENSURE ERROR IS SET
	TAD	[BUFSIZE^3%4]	/SUBTRACT 1/4 BUFFER'S WORTH
	AND	[BUFSIZE^3%4]	/JUST 3/4 BUFFER BITS
	SNA CLA			/SKIP IF NOT 3/4 FULL
	TAD	FLOWFLAG	/ELSE CHECK IF FLOW CONTROL IS ENABLED
	SNA CLA			/SKIP IF 3/4 FULL AND FLOW CONTROL IS ENABLED
	JMP I	RINUPDATE	/JUST RETURN
	TAD	RINWAIT		/GET INPUT WAIT FLAG
	SNA CLA			/SKIP IF ALREADY SET
	ISZ	RINWAIT		/SET TO <^S> STATE
	JMP I	RINUPDATE	/RETURN
/	REMOTE LINE GET A CHARACTER ROUTINE.				/047 CJL

/	CALLING SEQUENCE:

/	JMS I	(RINGET)	/CALL ROUTINE
/	CHARACTER AVAILABLE	/RETURNS HERE WITH LATEST CHARACTER
/	NO CHARACTER AVAILABLE	/RETURNS HERE IF NO CHARACTER OR HANDLED FLOW-CONTROL

/	NORMAL RETURN HAS LATEST CHARACTER IN AC.

/	SKIP RETURN HAS CLEAR AC.

/	IF FLOWFLAG=0, FLOW CHARACTERS ARE UNPROCESSED AND CAUSE NORMAL RETURN.

RINGET,	.-.			/REMOTE LINE GET A CHARACTER ROUTINE
RINTEST,TAD	INFLAG		/IS INPUT AVAILABLE?
RINGT0,	SNA CLA			/SKIP IF SO
RINREAD,JMP	RINGNONE	/JUMP IF NOT
RINGT1,	DCA	INFLAG		/CLEAR AVAILABILITY FLAG
RINGT2,	IRB			/READ IN THE CHARACTER

/	THE ABOVE INSTRUCTIONS ARE FOR DECMATE II USE ONLY.  THE  DEFAULT INSTRUCTIONS
/	ARE FOR KL8 INTERFACES.

	*RINTEST		/OVERLAY DECMATE II CODE

RINTEST,RKSFIOT			/FLAG UP?
RINGT0,	JMP	RINGNONE	/NO, TAKE SKIP RETURN
RINREAD,RKRBIOT			/YES, READ THE CHARACTER
RINGT1,	SKP			/NO ERRORS ON DECMATE I

/	THE ABOVE INSTRUCTION IS FOR DECMATE I USE ONLY.    THE DEFAULT INSTRUCTION IS
/	FOR KL8 INTERFACES.

	*RINGT1			/OVERLAY DECMATE I CODE

RINGT1,	SPA			/SKIP IF NO UART ERRORS
RING2,	ISZ	RINERROR	/INDICATE REMOTE LINE INPUT ERROR
	SKP			/SKIP IF NOT TOO MANY ERRORS
	JMP	.-2		/ENSURE REMOTE LINE INPUT ERROR IS INDICATED
	AND	[377]		/JUST EIGHT-BIT
	DCA	RINTEMP		/SAVE FOR NOW
	TAD	FLOWFLAG	/GET FLOW CONTROL FLAG
	SNA CLA			/SKIP IF SET
	JMP	RINGEXIT	/JUMP IF NOT
	TAD	RINTEMP		/GET THE CHARACTER
	AND	[177]		/JUST SEVEN-BIT
	TAD	[-CNTRLS]	/COMPARE TO <^S>
	SNA			/SKIP IF OTHER
	JMP	RWATSET		/JUMP IF IT MATCHES
	TAD	[-CNTRLQ+CNTRLS]/COMPARE TO <^S>
	SNA CLA			/SKIP IF OTHER
	JMP	RWATCLEAR	/JUMP IF IT MATCHES
RINGEXI,TAD	RINTEMP		/GET THE CHARACTER
	JMP I	RINGET		/TAKE IMMEDIATE RETURN
/	COMES HERE ON <^S> TO SET OUTPUT WAIT.

RWATSET,NL4000			/SET WAIT VALUE

/	COMES HERE ON <^Q> TO CLEAR OUTPUT WAIT.

RWATCLE,DCA	REMWAIT		/STORE NEW STATE
RINGNON,ISZ	RINGET		/BUMP RETURN ADDRESS
	JMP I	RINGET		/TAKE SKIP RETURN

/	REMOTE LINE RESET ROUTINE.					/026 CJL

/	CALLING SEQUENCE:

/	JMS I	(REMRESET)	/CALL ROUTINE
/	RETURN			/RETURN WITH CLEAR AC

/	RETURNS WITH CLEAR AC AND ALL REMOTE LINE VARIABLES RESET.

REMRESE,.-.			/REMOTE LINE RESET ROUTINE
	TAD	[REMBUFFER]	/SETUP THE REMOTE LINE
	DCA	REMINSERT	/OUTPUT INSERTION POINTER
	TAD	[REMBUFFER]	/SETUP THE REMOTE LINE
	DCA	REMREMOVE	/OUTPUT REMOVAL POINTER
	TAD	(RINBUFFER)	/SETUP THE REMOTE LINE
	DCA	RININSERT	/INPUT INSERTION POINTER
	TAD	(RINBUFFER)	/SETUP THE REMOTE LINE
	DCA	RINREMOVE	/INPUT REMOVAL POINTER
	DCA	REMWAIT		/CLEAR REMOTE OUTPUT WAIT
	DCA	RINWAIT		/CLEAR REMOTE INPUT WAIT
	DCA	RINERROR	/CLEAR REMOTE INPUT ERROR
	JMP I	REMRESET	/RETURN

RININSE,.-.			/REMOTE INPUT INSERTION POINTER
RINREMO,.-.			/REMOTE INPUT REMOVAL POINTER
RINTEMP,.-.			/REMOTE INPUT TEMPORARY			/047 CJL

	PAGE
/	REMOTE LINE OUTPUT ROUTINE.

/	CALLING SEQUENCE:

/	TAD	CHAR		/CHARACTER TO OUTPUT IN AC
/	JMS I	(REMOUT)	/CALL ROUTINE
/	RETURN			/RETURNS HERE WITH CLEAR AC

REMOUT,	.-.			/REMOTE LINE OUTPUT ROUTINE
	DCA	REMTEMP		/SAVE PASSED VALUE
	TAD	REMINSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	REMREMOVE	/COMPARE TO REMOVAL POINTER
	TAD	REMWAIT		/ADD ON WAIT STATUS
	SZA CLA			/SKIP IF BUFFER EMPTY AND NOT WAITING	/047 CJL
	JMP	RSTUFF		/JUMP IF CHARACTER MUST BE BUFFERED
	TAD	REMTEMP		/GET PASSED VALUE			/047 CJL
	JMS I	(REMPUT)	/TRY TO OUTPUT THE CHARACTER NOW	/047 CJL
	JMP	RSTUFF		/COULDN'T OUTPUT IT, SO BUFFER IT	/047 CJL
	JMP I	REMOUT		/RETURN

RSTUFF,	TAD	REMTEMP		/GET THE CHARACTER
	CDF	BUFFLD		/GOTO BUFFER FIELD
	DCA I	REMINSERT	/STORE IN BUFFER
	CDF	PRGFLD		/BACK TO OUR FIELD
	NL0001			/SET BUFFER INCREMENT
	TAD	REMINSERT	/BUMP INSERTION POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	[REMBUFFER]	/MAKE IT ABSOLUTE
	DCA	REMINSERT	/STORE UPDATED POINTER
	JMP I	REMOUT		/RETURN

/	REMOTE LINE OUTPUT TEST ROUTINE.

/	CALLING SEQUENCE:

/	JMS I	(REMTEST)	/CALL ROUTINE
/	NOT READY		/RETURN IF OUTPUT NOT READY FOR NEXT CHARACTER
/	READY			/OUTPUT CAN ACCEPT ANOTHER CHARACTER NOW

/	AC WILL BE CLEARED AFTER THE CALL.

REMTEST,.-.			/REMOTE LINE OUTPUT TEST ROUTINE
	NL0001			/SET BUFFER INCREMENT
	TAD	REMINSERT	/GET INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	REMREMOVE	/COMPARE TO REMOVAL POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	SZA CLA			/SKIP IF BUFFER IS FULL
	ISZ	REMTEST		/BUMP RETURN IF BUFFER IS NOT FULL
	JMP I	REMTEST		/RETURN EITHER WAY
/	REMOTE LINE OUTPUT BUFFER UPDATE ROUTINE.

/	CALLING SEQUENCE:

/	JMS I	(REMUPDATE)	/CALL ROUTINE
/	RETURN			/RETURN WITH CLEAR AC

/	THE REMOTE LINE OUTPUT  BUFFERING  ROUTINES WILL UPDATE POINTERS, ETC.  IF ANY
/	STATUS HAS CHANGED SINCE THE LAST CALL.

REMUPDA,.-.			/REMOTE LINE OUTPUT UPDATE ROUTINE
	TAD	RINWAIT		/GET INPUT WAIT FLAG
	CLL RAL			/MAIN STATE BIT TO LINK
	SNA CLA			/SKIP IF OUTPUT FLOW CHARACTER NEEDED	/047 CJL
	JMP	REMCHECK	/JUMP IF CHARACTER NOT NEEDED NOW	/047 CJL
	TAD	(CNTRLQ)	/ASSUME RELEASE CHARACTER NEEDED	/047 CJL
	SNL			/SKIP IF SO				/047 CJL
	TAD	[CNTRLS-CNTRLQ]	/ELSE CHANGE IT TO HOLD CHARACTER	/047 CJL
	JMS I	(REMPUT)	/TRY TO OUTPUT IT NOW			/047 CJL
	JMP	REMCHECK	/COULDN'T DO IT, FORGET IT FOR NOW	/047 CJL
	CML RAR			/SET NEW STATE VALUE			/047 CJL
	DCA	RINWAIT		/STORE IT
REMCHEC,TAD	REMWAIT		/GET OUTPUT WAIT FLAG
	SZA CLA			/SKIP IF NOT WAITING
	JMP I	REMUPDATE	/JUST RETURN IF WAITING
	TAD	REMINSERT	/GET OUTPUT INSERTION POINTER
	CIA			/INVERT FOR TEST
	TAD	REMREMOVE	/COMPARE TO OUTPUT REMOVAL POINTER
	SNA CLA			/SKIP IF BUFFER CONTAINS SOMETHING	/047 CJL
	JMP I	REMUPDATE	/RETURN IF BUFFER EMPTY			/047 CJL
	CDF	BUFFLD		/GOTO BUFFER FIELD
	TAD I	REMREMOVE	/GET A CHARACTER FROM THE BUFFER
	CDF	PRGFLD		/BACK TO OUR FIELD
	JMS I	(REMPUT)	/TRY TO OUTPUT THE CHARACTER NOW	/047 CJL
	JMP I	REMUPDATE	/COULDN'T DO IT, SO JUST RETURN		/047 CJL
	NL0001			/SET BUFFER INCREMENT
	TAD	REMREMOVE	/BUMP REMOVAL POINTER
	AND	[BUFSIZE-1]	/JUST BUFFER BITS
	TAD	[REMBUFFER]	/MAKE IT ABSOLUTE
	DCA	REMREMOVE	/STORE UPDATED POINTER
	JMP I	REMUPDATE	/RETURN

	REMTEMP=REMUPDATE	/REMOTE OUTPUT TEMPORARY
/	LOW-LEVEL CONSOLE OUTPUT ROUTINE.				/047 CJL

/	CALLING SEQUENCE:

/	[CHARACTER TO OUTPUT IN THE AC]

/	JMS I	(CONPUT)	/CALL ROUTINE
/	NO OUTPUT		/RETURNS HERE IF OUTPUT UNAVAILABLE
/	OUTPUT			/RETURNS HERE IF CHARACTER WAS OUTPUT

CONPUT,	.-.			/CONSOLE OUTPUT ROUTINE
CONTSF,	TSFIOT			/FLAG UP?
	JMP	CONCLEAR	/NO, FORGET IT
CONTLS,	TLSIOT			/YES, OUTPUT THE CHARACTER NOW
	ISZ	CONPUT		/TAKE SKIP RETURN
CONCLEA,CLA			/CLEAN UP
	JMP I	CONPUT		/RETURN EITHER WAY

/	CONSOLE RESET ROUTINE.						/026 CJL

/	CALLING SEQUENCE:

/	JMS I	(CONRESET)	/CALL ROUTINE
/	RETURN			/RETURN WITH CLEAR AC

/	RETURNS WITH CLEAR AC AND ALL CONSOLE VARIABLES RESET.

CONRESE,.-.			/CONSOLE RESET ROUTINE
	TAD	[CONBUFFER]	/SETUP THE
	DCA I	(CONINSERT)	/CONSOLE OUTPUT INSERTION POINTER
	TAD	[CONBUFFER]	/SETUP THE
	DCA I	(CONREMOVE)	/CONSOLE OUTPUT REMOVAL POINTER
	TAD	[KEYBUFFER]	/SETUP THE
	DCA I	(KEYINSERT)	/KEYBOARD INSERTION POINTER
	TAD	[KEYBUFFER]	/SETUP THE
	DCA I	(KEYREMOVE)	/KEYBOARD REMOVAL POINTER
	DCA I	(CONWAIT)	/CLEAR OUTPUT WAIT
	DCA	KEYERROR	/CLEAR KEYBOARD ERROR
	JMP I	CONRESET	/RETURN
/	LOW-LEVEL REMOTE LINE OUTPUT ROUTINE.				/047 CJL

/	CALLING SEQUENCE:

/	[CHARACTER TO OUTPUT IN THE AC]

/	JMS I	(REMPUT)	/CALL ROUTINE
/	NO OUTPUT		/RETURNS HERE IF OUTPUT UNAVAILABLE
/	OUTPUT			/RETURNS HERE IF CHARACTER WAS OUTPUT

REMPUT,	.-.			/REMOTE LINE OUTPUT ROUTINE
DM1AN2,	AND	[377]		/ENSURE EIGHT BIT			/049 CJL

/	THE  ABOVE INSTRUCTION IS FOR DECMATE I USE ONLY.  THE DEFAULT INSTRUCTION  IS
/	FOR KL8 INTERFACES.

	*DM1AN2			/OVERLAY DECMATE II CODE		/049 CJL

DM1AN2,	SKP			/WE'RE NOT A DECMATE I			/049 CJL
	TAD	[400]		/SET WRITE BIT				/049 CJL
REMTSF,	DCA	RMPTEMP		/SAVE PASSED VALUE
RMPUT0,	TAD	OUTFLAG		/CHECK IF OUTPUT IS AVAILABLE
REMTLS,	SNA CLA			/SKIP IF SO
RMPUT1,	JMP I	REMPUT		/RETURN IF NOT
REMCLEA,TAD	RMPTEMP		/GET THE PASSED VALUE
RMPUT2,	OLS			/OUTPUT THE CHARACTER NOW

/	THE ABOVE INSTRUCTIONS ARE FOR DECMATE II USE ONLY.  THE DEFAULT  INSTRUCTIONS
/	ARE FOR KL8 INTERFACES.

	*REMTSF			/OVERLAY DECMATE II CODE

REMTSF,	RTSFIOT			/FLAG UP?
RMPUT0,	JMP	REMCLEAR	/NO, FORGET IT
REMTLS,	RTLSIOT			/YES, OUTPUT THE CHARACTER NOW
RMPUT1,	ISZ	REMPUT		/TAKE SKIP RETURN
REMCLEA,CLA			/CLEAN UP
RMPUT2,	JMP I	REMPUT		/RETURN EITHER WAY

	CLA			/CLEAN UP
	DCA	OUTFLAG		/INDICATE OUTPUT IS UNAVAILABLE
	ISZ	REMPUT		/TAKE SKIP RETURN
	JMP I	REMPUT		/RETURN TO CALLER

	RMPTEMP=CONRESET	/REMOTE OUTPUT TEMPORARY

	PAGE
/	SEVEN-BIT COMMAND TABLES.					/034 CJL

	CMDTBL=	.		/COMMAND TABLE HERE

	"C&177;	"O&177;	"N&177	/\
	"N&177;	"E&177;	"C&177	/ >CONNECT COMMAND
	"T&177;	-1		//
	CONSRV			/CONNECT ROUTINE ADDRESS

	"F&177;	"I&177;	"N&177	/\
	"I&177;	"S&177;	"H&177	/ >FINISH COMMAND
	-1			//
	FINSRV			/FINISH ROUTINE ADDRESS

	"E&177;	"X&177;	"I&177	/EXIT
	"T&177;	-1		/COMMAND
	EXITKERMIT		/EXIT ROUTINE ADDRESS

	"S&177;	"E&177;	"N&177	/SEND
	"D&177;	-1		/COMMAND
	SNDSRV			/SEND ROUTINE ADDRESS

	"G&177;	"E&177;	"T&177	/GET
	-1			/COMMAND
	GETSRV			/GET ROUTINE ADDRESS

	"R&177;	"E&177;	"C&177	/\
	"E&177;	"I&177;	"V&177	/ >RECEIVE COMMAND
	"E&177;	-1		//
	RECSRV			/RECEIVE ROUTINE ADDRESS
	"H&177;	"E&177;	"L&177	/HELP
	"P&177;	-1		/COMMAND
	HELPSRV			/HELP ROUTINE ADDRESS

	-1			/THIS ENDS THE TABLE			/034 CJL

/	REMOTE PACKET INPUT BUFFER.					/014 CJL

RRBUF,	0			/MARK
RRLEN,	0			/PACKET LENGTH
RRSEQ,	0			/PACKET SEQ
RRTYP,	0			/PACKET TYPE

	DECIMAL

RRDTA,	ZBLOCK	91		/DATA GOES HERE

	OCTAL

RTERMI,	0			/ADD LOCATION WHERE TERMINATOR IS STORED/A004
				/ON RECEIVE IF BUFFER IS MAXIMUM LENGTH	/A004

/	REMOTE PACKET OUTPUT BUFFER

RSBUF,	CNTRLA			/PACKET BUFFER (BEGINS WITH "SOH")	/034 CJL
RSLEN,	0			/PACKET LENGTH GOES HERE
RSSEQ,	0			/PACKET SEQUENCE GOES HERE
RSTYP,	0			/PACKET TYPE GOES HERE

	DECIMAL

RSDTA,	ZBLOCK	91		/DATA GOES HERE

	0			/CHECKSUM HERE ON MAX PACKET
	0			/EOL (IF USED HERE ON MAX PACKET)
	0			/INTERNAL TERMINATOR HERE ON MAX PACKET

	OCTAL
/	SEND-INIT PACKET DEFINITION

INIDAT,	DECIMAL

	94+32			/94 CHARS MAX

	OCTAL

	"/&177			/15 SECOND TIME-OUT			/M013/014 CJL
	" &177			/NO PADDING
	0+100&177		/NO PADDING CHAR
	" &177+15		/CR FOR EOL
	"#&177			/QUOTE CHAR
	"N&137			/NO 8TH BIT QUOTING
	"1&177			/CHECK TYPE 1
	" &177			/NO REPEAT CHAR
	" &177+0		/NO EXTRA CAPABILITY
NODATA,	-1			/END OF DATA (USE THIS FOR SENDING NO-DATA)
	PAGE			/GET TO NEXT PAGE			/028 CJL

/	NO-INTERRUPT CONSOLE INPUT/OUTPUT SUPPORT ROUTINES.		/023 CJL

/	MODIFIED FOR FORCED-ECHO AND COLUMN-COUNTING.			/043 CJL

/	CONSOLE INPUT ROUTINE.  RETURNS  LATEST  CHARACTER  WITHOUT  ECHOING.   MAY BE
/	CALLED WITH DIRTY AC.  RETURNS LATEST SEVEN-BIT CHARACTER TYPED WHILE FIELDING
/	POTENTIAL <^S>/<^Q> PROTOCOL.

INPUT,	.-.			/CONSOLE INPUT ROUTINE
INPWAIT,JMS	CHKUP		/TRY TO GET A CHARACTER
	TAD	INCHAR		/GET THE CHARACTER
	SNA			/SKIP IF ANYTHING CAME IN
	JMP	INPWAIT		/WAIT FOR ANYTHING
	JMP I	INPUT		/RETURN WITH LATEST CHARACTER

/	CONSOLE  OUTPUT  ROUTINE.    OUTPUTS  CHARACTER  IN  AC  (INCLUDING  <HT>  VIA
/	SIMULATION).  RETURNS WITH CLEAR AC.  SUBJECT TO CONSOLE ECHO STATUS (ECHOSW).

P7CH,	.-.			/CONSOLE OUTPUT ROUTINE
	TAD	(-CNTRLI)	/COMPARE TO <HT>
	SNA			/SKIP IF OTHER
	JMP	DOTAB		/JUMP IF <HT>
	TAD	L11/(CNTRLI)	/RESTORE THE CHARACTER
	JMS	P7CHAR		/PRINT IT (UPDATING COLUMN COUNT)
	JMP I	P7CH		/RETURN

DOTAB,	TAD	[" &177]	/GET A <SPACE>
	JMS	P7CHAR		/OUTPUT IT
	TAD	COLUMN		/GET CURRENT COLUMN COUNT
	AND	[7]		/JUST TAB BITS
	SZA CLA			/SKIP IF NOW AT NEW TAB STOP
	JMP	DOTAB		/ELSE KEEP GOING
	JMP I	P7CH		/RETURN

/	FORCED-ECHO  CONSOLE  OUTPUT ROUTINE.  SAME AS P7CH BUT CLEARS  ECHOSW  BEFORE
/	OUTPUT OF THE CHARACTER.

P7ECHO,	.-.			/CONSOLE OUTPUT WITH FORCED-ECHO ROUTINE
	DCA	P7TEMP		/SAVE PASSED VALUE
	DCA	ECHOSW		/CLEAR ECHO STATUS
	TAD	P7TEMP		/RESTORE THE CHARACTER
	JMS	P7CH		/CALL MAIN ROUTINE
	JMP I	P7ECHO		/RETURN
CHKUP,	.-.				/CHECK FOR <^C>, ETC. ROUTINE
	JMS	CTLCTST			/CALL LOW-LEVEL INPUT CHECK ROUTINE
	SNA				/SKIP IF ANYTHING CAME BACK
	JMP	CHKCLR			/ELSE FORGET IT
	TAD	(-CNTRLP)		/COMPARE TO <^P>
	SNA				/SKIP IF OTHER
	JMP	DOUP			/GO HANDLE <^P> THERE
	IAC	/TAD	(-CNTRLO+CNTRLP)/COMPARE TO <^O>
	SNA				/SKIP IF OTHER
	JMP	DOUO			/GO HANDLER <^O> THERE
	TAD	(-CNTRLS+CNTRLO)	/COMPARE TO <^S>
	SZA CLA				/SKIP IF IT MATCHES
	JMP I	CHKUP			/RETURN ON UNIMPORTANT CHARACTERS
UQWAIT,	JMS	CTLCTST			/CALL LOW-LEVEL INPUT CHECK ROUTINE
	TAD	(-CNTRLQ)		/COMPARE TO <^Q>
	SZA CLA				/SKIP IF IT MATCHES
	JMP	UQWAIT			/ELSE WAIT FOR <^Q> FOREVER
CHKCLR,	DCA	INCHAR			/OBLITERATE INPUT CHARACTER
	JMP I	CHKUP			/RETURN

/	COMES HERE TO HANDLE <^P>.

DOUP,	TAD	("P&177)		/GET A "P"
	JMS	UPRINT			/PRINT "^P"
	JMP I	UPADDRESS		/GO WHERE YOU SHOULD

/	COMES HERE TO HANDLE <^O>.

DOUO,	TAD	("O&177)		/GET AN "O"
	JMS	UPRINT			/PRINT "^O"
	NL4000				/SET REVERSING BIT
	TAD	ECHOSW			/REVERSE THE ECHO STATE
	DCA	ECHOSW			/STORE BACK
	JMP	CHKCLR			/OBLITERATE <^O> AND RETURN

CTLCTST,.-.				/LOW-LEVEL <^C> TEST ROUTINE
	CLA				/CLEAN UP
KSFLOC,	KSFIOT				/FLAG UP?
	JMP I	CTLCTST			/NO, JUST RETURN
KRSZAP,	KRSIOT				/**** 6120 **** KRBIOT
	AND	[177]			/JUST SEVEN-BIT
	DCA	INCHAR			/SAVE THE CHARACTER
	NL7775				/SET -<^C> VALUE
	TAD	INCHAR			/COMPARE TO CHARACTER
	SNA CLA				/SKIP IF OTHER THAN <^C>
	JMP I	UCADDRESS		/JUMP IF <^C>
KCCZAP,	KCCIOT				/**** 6120 **** 0000
	TAD	INCHAR			/GET THE CHARACTER
	JMP I	CTLCTST			/RETURN
P7CHAR,	.-.			/LOWER-LEVEL CONSOLE PRINT ROUTINE
	DCA	P7TEMP		/SAVE PASSED VALUE
P7AGN,	JMS	CHKUP		/CHECK FOR <^C>, ETC.
	TAD	ECHOSW		/GET CURRENT ECHO STATUS
	SPA CLA			/SKIP IF ECHO ON
	JMP	P7OFF		/JUMP IF ECHO OFF
	TAD	P7TEMP		/GET THE PASSED VALUE BACK
	JMS	P7OUT		/TRY TO OUTPUT IT
	JMP	P7AGN		/COULDN'T OUTPUT, GO WAIT THERE
P7OFF,	JMS	CHKUP		/CHECK FOR <^C>, ETC.
	TAD	P7TEMP		/GET THE CHARACTER BACK
	AND	[140]		/JUST QUADRANT BITS
	SZA CLA			/SKIP IF CONTROL CHARACTER
	ISZ	COLUMN		/BUMP COLUMN IF PRINTING CHARACTER
L11,	CNTRLI/NOP		/JUST IN CASE
	TAD	P7TEMP		/GET THE CHARACTER AGAIN
	TAD	(-CNTRLM)	/COMPARE TO <CR>
	SNA			/SKIP IF NOT <CR>
	DCA	COLUMN		/CLEAR COLUMN COUNT ON <CR>
	TAD	(-CNTRLH+CNTRLM)/COMPARE TO <BS>
	SNA CLA			/SKIP IF OTHER
	NL7777			/SET BACKUP VALUE
	TAD	COLUMN		/UPDATE COLUMN COUNT
	DCA	COLUMN		/STORE BACK
	JMP I	P7CHAR		/RETURN

P7OUT,	.-.			/LOW-LEVEL CONSOLE OUTPUT ROUTINE
P7TSF,	TSFIOT			/FLAG UP?
	JMP I	P7OUT		/NO, TAKE IMMEDIATE RETURN WITH AC INTACT
P7TLS,	TLSIOT			/YES, OUTPUT IT
	CLA			/CLEAN UP
	ISZ	P7OUT		/BUMP RETURN ADDRESS
	JMP I	P7OUT		/TAKE SKIP RETURN TO CALLER

/	COMES HERE TO HANDLE <^C> IF SO ENABLED.

UPCPRT,	TAD	("C&177)	/GET A "C"
	JMS	UPRINT		/PRINT "^C"
KCCZP2,	KCCIOT			/**** 6120 **** 0000
	JMP I	[CLOOP]		/RESTART

UPRINT,	.-.			/"^"<CHARACTER> PRINTING ROUTINE
	DCA	P7TEMP		/SAVE PASSED VALUE
	TAD	("^&177)	/GET AN "^"
	JMS	P7OUT		/OUTPUT IT
	JMP	.-1		/WAIT FOR IT
	TAD	P7TEMP		/GET PASSED VALUE
	JMS	P7OUT		/OUTPUT IT
	JMP	.-1		/WAIT FOR IT
	JMP I	UPRINT		/RETURN

P7TEMP,	.-.			/OUTPUT ROUTINE TEMPORARY
	PAGE

/	HANDLER I/O BUFFER DEFINITIONS.					/014 CJL

	HNDLR=	.		/BUFFER FOR DISK I/O HANDLER		/014 CJL

	*PAGCNT^200+HNDLR	/RESET ORIGIN PAST HANDLER BUFFER	/014 CJL

	IFNZRO	SBOOT-.&4000	<ERROR	.>				/028 CJL

	*SBOOT-1		/JUST BEFORE EXIT ADDRESS		/025 CJL

	EXITKER=.		/WHERE TO EXIT TO			/025 CJL
/	ONCE-ONLY INITIALIZATION CODE.					/024 CJL

	*HNDLR			/OVER AVAILABLE SPACE

INITIAL,CLA CLL			/CLEAN UP
COUTINI,TLSIOT			/RAISE CONSOLE OUTPUT FLAG		/046 CJL
	TAD	INITIA/(CLA CLL)/GET REPLACEMENT INSTRUCTION
	DCA I	[CLOOP]		/DON'T COME BACK TO US
	JMS I	(MACHINE)	/IDENTIFY CPU TYPE
	DCA	CPUTEMP		/SAVE IT
	TAD	CPUTEMP		/GET CPU TYPE
	TAD	(-13)		/COMPARE TO DEADLY 6120 VALUE
	SNA CLA			/SKIP IF OTHER
	JMP	INI6120		/JUMP IF IT MATCHES
ROUTINI,RTLSIOT			/INITIALIZE REMOTE OUTPUT		/046 CJL
RININIT,RKRBIOT			/INITIALIZE REMOTE INPUT		/046 CJL
	CLA			/CLEAN UP
INITPRT,JMS I	[SCRIBE]	/GIVE THEM THE
	INITMSG			/OPENING MESSAGE
	JMS I	[SCRIBE]	/GIVE THEM THE
	DAYMSG			/DAY MESSAGE
	JMS I	[SCRIBE]	/GIVE THEM THE
	MONMSG			/MONTH MESSAGE
	JMS I	[SCRIBE]	/GIVE THEM THE
	YEARMSG			/YEAR MESSAGE
	JMS I	[SCRIBE]	/GIVE THEM THE
	CPUTMSG			/CPU ID MESSAGE
	TAD	CPUTEMP		/*1
	CLL RTL			/*4
	TAD	CPUTEMP		/*5
	TAD	(CPULIST)	/POINT TO PROPER MESSAGE
	DCA	TST6120		/STORE IN-LINE
	JMS I	[SCRIBE]	/TELL THEM THEIR
TST6120,0			/ACTUAL CPU ID
	JMS I	[SCRIBE]	/GIVE THEM THE
	CLOSMSG			/CLOSING MESSAGE
DMPRZAP,JMP	.+3		/**** DECMATE USAGE DETECTED **** 0000
	JMS I	[SCRIBE]	/GIVE THEM THE
SPZAP,	DMPOMSG			/DECMATE PORT MESSAGE
	JMS I	[SCRIBE]	/GIVE THEM THE
	CRLF			/END OF LINE
	JMS I	[SCRIBE]	/GIVE THEM THE
	LCLMSG			/LOCAL PREFERENCE MESSAGE
	JMS I	[SCRIBE]	/TELL THEM THEY CAN
	THLPMSG			/ASK FOR HELP
	TAD	CPUTEMP		/GET CPU TYPE
	CLL RTL			/*4
	TAD	(CPUPRMPT-1)	/POINT TO PROPER ENTRY
	DCA	XR0		/STASH THE POINTER
	TAD	(-4)		/GET MOVE COUNT
	JMS	MESMOVE		/MOVE THE PROPER PROMPT TEXT
	PROMID-1		/TO THERE
	TAD	CPUTEMP		/*1
	CLL RTL			/*4
	TAD	CPUTEMP		/*5
	TAD	(CPUIDLST-1)	/POINT TO PROPER ENTRY
	DCA	XR0		/STASH THE POINTER
	TAD	(-5)		/GET MOVE COUNT
	JMS	MESMOVE		/MOVE THE PROPER CPU ID TEXT
	CPUMSG-1		/TO THERE
	CIF	USRFLD		/GOTO USR FIELD				/035 CJL
	JMS I	(USR)		/CALL USER SERVICE ROUTINE		/035 CJL
	USRIN			/LOCK USR IN				/035 CJL

/	DO FURTHER INITIALIZATION HERE.

	JMP I	[CLOOP]		/GO BACK TO KERMIT PROPER

/	COMES HERE TO INITIALIZE 6120-BASED MACHINES.			/046 CJL

INI6120,DCA I	(KCCZAP)	/ELIMINATE KCCIOT
	DCA I	(KCCZP2)	/ELIMINATE KCCIOT
	ISZ I	(KRSZAP)	/TURN KRSIOT
	ISZ I	(KRSZAP)	/INTO KRBIOT
	TAD	ROUTINITIALIZE	/GET OUTPUT INITIALIZE INSTRUCTION	/046 CJL
	TAD	(-6336)		/COMPARE TO POSSIBLE VALUE		/046 CJL
	SZA CLA			/SKIP IF IT MATCHES SERIAL PRINTER VALUE/046 CJL
	JMP	TRYDM1		/JUMP IF NOT CONFIGURED FOR SERIAL PORT	/046 CJL
	TAD	RININITIALIZE	/GET INPUT INITIALIZE INSTRUCTION	/046 CJL
	TAD	(-6326)		/COMPARE TO POSSIBLE VALUE		/046 CJL
	SNA CLA			/SKIP IF NOT CONFIGURED FOR SERIAL PORT	/046 CJL
	JMP	DMSER		/JUMP IF SERIAL PORT CONFIGURATION	/046 CJL
TRYDM1,	CLSK			/SKIP ON, CLEAR CLOCK FLAG IF DECMATE II/046 CJL
	NOP			/JUST IN CASE				/046 CJL
	CLCL			/CLEAR VT278 CLOCK FLAG			/046 CJL
	NOP			/JUST IN CASE				/046 CJL
	ISZ	TST6120		/WASTE					/046 CJL
	JMP	.-1		/SOME TIME				/046 CJL
	CLSK8A			/VT278 CLOCK FLAG UP?			/046 CJL
	JMP	TRYDM2		/NO, TRY DECMATE II, ETC.		/046 CJL
	DCA	DMPRZAP		/MAKE IT PRINT OUR MESSAGE		/050 CJL
	CIF CDF	DMIFLD		/GOTO DECMATE ONCE-ONLY CODE FIELD	/046 CJL
	JMP I	(DM1INIT)	/CONTINUE THERE				/046 CJL

TRYDM2,	CLSK			/CLOCK FLAG UP?				/046 CJL
	JMP	ROUTINITIALIZE	/NO, MUST BE SOMEBODY ELSE!		/046 CJL
	DCA	DMPRZAP		/MAKE IT PRINT OUR MESSAGE		/048 CJL
	CIF CDF	DMIFLD		/GOTO DECMATE ONCE-ONLY FIELD		/046 CJL
	JMP I	(DM2INIT)	/CONTINUE THERE				/046 CJL

/	COMES HERE IF SERIAL PORT CONFIGURATION ON DECMATE.

DMSER,	DCA	DMPRZAP		/MAKE IT PRINT OUR MESSAGE		/048 CJL
	TAD	(DMPPMSG)	/GET OUR MESSAGE ADDRESS		/048 CJL
	DCA	SPZAP		/STORE IN-LINE				/048 CJL
	JMP	ROUTINITIALIZE	/CONTINUE THERE
MESMOVE,.-.			/MESSAGE MOVE ROUTINE
	DCA	MMOVCNT		/SAVE PASSED COUNT
	TAD I	MESMOVE		/GET THE PASSED ARGUMENT
	DCA	XR1		/SET IT UP
	ISZ	MESMOVE		/BUMP PAST ARGUMENT
	CDF	MSGFLD		/GOTO BUFFER FIELD
MESMVLP,TAD I	XR0		/GET A WORD
	DCA I	XR1		/PUT A WORD
	ISZ	MMOVCNT		/DONE YET?
	JMP	MESMVLP		/NO, GO BACK
	CDF	PRGFLD		/BACK TO OUR FIELD
	JMP I	MESMOVE		/YES, RETURN

CPUTEMP,.-.			/TEMPORARY FOR MACHINE TYPE
MMOVCNT,.-.			/TEMPORARY FOR MOVE COUNT

	PAGE
/	CPU IDENTIFYING ROUTINE.					/024 CJL

/	RETURNS VALUE IN AC ACCORDING TO THE FOLLOWING RULE:

/	AC	CPU TYPE

/	0	UNKNOWN (DCC112, MP-12?)
/	1	PDP-5 (THE INCOMPATIBLE ONE!)
/	2	PDP-8 (THE REAL ONE!)
/	3	PDP-8/S	(THE SLOW ONE!)
/	4	LINC-8 (THE STRANGE ONE!)
/	5	PDP-8/I (THE ORANGE ONE!)
/	6	PDP-8/L (THE STRIPPED-DOWN ONE!)
/	7	PDP-12 (THE GREEN ONE! (BLUE?))
/	10	PDP-8/E (THE FAST ONE!)
/	11	PDP-8/A (THE WIDE ONE!)
/	12	6100 (THE MICRO ONE!)
/	13	6120 (THE HARRIS ONE!)

MACHINE,.-.			/MACHINE IDENTIFYING ROUTINE
	CLA CLL			/THIS WORKS ON EVERYBODY!
	TAD	0		/GET PDP-5 PC
	DCA	MACHTEMP	/SAVE IT
	TAD	(IMA5-1)	/GET PDP-5 NEW PC
	DCA	0		/STORE IT

/	IF WE GET HERE, WE'RE NOT A PDP-5.

	TAD	MACHTEMP	/GET OLD LOCATION ZERO
	DCA	0		/RESTORE IT
	NL3776			/PDP-8/I, L WEIRDNESS
	TAD	(-3776)		/COMPARE TO POSSIBLE VALUE
	SNA CLA			/SKIP IF NOT THOSE TWO
	JMP	IMA8IL		/JUMP IF ONE OF THEM

/	IF WE GET HERE, WE'RE NOT A PDP-8/I OR PDP-8/L.

	NL7776			/SETUP -2
	TAD	(-7776)		/COMPARE TO EXPECTED VALUE
	SZA CLA			/SKIP IF OK
	JMP	IMA8S		/JUMP IF RETARDED BROTHER

/	IF WE GET HERE, WE'RE NOT A PDP-8/S.

	NL0100			/SETUP 0100
	TAD	(-100)		/COMPARE TO EXPECTED VALUE
	SNA CLA			/SKIP IF STRAIGHT PDP-8
	JMP	IMAOMNIBUS	/JUMP IF NEWER CPU
/	IF WE GET HERE, WE ARE A PDP-8, BUT ARE WE A LINC-8?

	NL7777				/SETUP LINC TEST VALUE
	IACA				/LOAD LINC "A" REGISTER
	CLA				/CLEAN UP
	IAAC				/GET IT BACK
	IAC				/ADD ONE
	SNA CLA				/SKIP IF NO LINC HARDWARE
	JMP	IMAL8			/JUMP IF LINC-8

/	SINCE WE DON'T CARE ABOUT PERIPHERALS, WE ARE A PDP-8.

	JMP	IMA8			/GO TELL THEM WE ARE A PDP-8

/	COMES HERE IF PDP-8/I OR PDP-8/L.

IMA8IL,	NL7777				/SETUP TEST VALUE
	CLA!401				/DO PDP-8/I GROUP THREE EAE CLA
	SZA CLA				/SKIP IF PDP-8/I
	JMP	IMA8L			/JUMP IF NOT

/	IF WE GET HERE, WE ARE A PDP-8/I, BUT ARE WE A PDP-12?

	LINC				/GOTO LINC MODE
	COM				/COMPLEMENT AC IF PDP-12, ELSE A HARMLESS AND
	PDP				/GOTO PDP8 MODE IF PDP-12, ELSE HARMLESS AND
	IAC				/ADD ONE FOR TEST
	SNA CLA				/SKIP IF JUST PDP-8/I
	JMP	IMA12			/JUMP IF ACTUALLY A LINC-8/I

/	SINCE WE DON'T CARE ABOUT PERIPHERALS, WE ARE JUST A PDP-8/I.

	JMP	IMA8I			/TELL THEM WE ARE A PDP-8/I

IMAOMNI,RTL RTR				/DO STRANGE OMNIBUS INSTRUCTION
PC8A,	SNA				/SKIP IF NOT A MICRO CHIP
	JMP	IMA61			/JUMP IF ONE OF THOSE THINGS
	TAD	(.&7600+16^7777)	/CHECK FOR PDP-8/E VALUE
	SNA				/SKIP IF NOT HIM
	JMP	IMA8E			/JUMP IF IT IS A PDP-8/E (/F OR /M OR 8A-6XX)
	TAD	(.&7600+16-PC8A)	/COMPARE TO PDP-8/A VALUE	/051 CJL
	SNA CLA				/SKIP IF SOMEBODY ELSE
	JMP	IMA8A			/JUMP IF IT MATCHES

/	IF WE GET HERE, SOME STRANGE PROCESSOR IS RUNNING US.

	JMP	IMAUNKNOWN		/YOU FIGURE IT OUT!
/	IF WE GET HERE, WE ARE A 6100 OR 6120.

IMA61,	NL0010			/DO 6120 SPECIAL INSTRUCTION
	TAD	(-10)		/COMPARE TO EXPECTED VALUE
	SNA CLA			/SKIP IF OTHER
	JMP	IMA6120		/JUMP IF IT MATCHES

/	WE APPARENTLY ARE ON A 6100, SO TELL THEM SO.

	JMP	IMA6100		/TELL THEM WE ARE A 6100 MACHINE (VT-78, ETC.)

/	RETURN GAUNTLET.

IMA6120,IAC			/SET 6120 VALUE
IMA6100,IAC			/SET 6100 VALUE
IMA8A,	IAC			/SET PDP-8/A VALUE
IMA8E,	IAC			/SET PDP-8/E VALUE
IMA12,	IAC			/SET PDP-12 VALUE
IMA8L,	IAC			/SET PDP-8/L VALUE
IMA8I,	IAC			/SET PDP-8/I VALUE
IMAL8,	IAC			/SET LINC-8 VALUE
IMA8S,	IAC			/SET PDP-8/S VALUE
IMA8,	IAC			/SET PDP-8 VALUE
IMA5,	IAC			/SET PDP-5 VALUE
IMAUNKN,JMP I	MACHINE		/RETURN

MACHTEM,.-.			/TEMPORARY FOR LOCATION ZERO

	PAGE
	FIELD	PRGFLD%10	/DUMP THE LITERALS NOW
/	LAYOUT OF FIELD ONE (PERMANENT CONTENTS).			/046 CJL

	NOPUNCH				/FOOL THE ASSEMBLER		/046 CJL

	FIELD	USRFLD%10		/USR FIELD			/046 CJL

	*0				/WHERE IT LOADS			/046 CJL

USRLOAD,ZBLOCK	200-.			/GET TO ENTRY POINT		/046 CJL

	USRENTR=.			/LOCKED-IN USR ENTRY POINT	/046 CJL

USRENTR,ZBLOCK	2000-.			/USR OWNS REST OF THIS AREA	/046 CJL

	FILBUFF=.			/FILE I/O DONE HERE		/046 CJL

	FIELD	BUFFLD%10		/FILE I/O BUFFER FIELD		/046 CJL

	*FILBUFFER			/RESET ORIGIN			/046 CJL

FILBUFF,ZBLOCK	PAGCNT^200		/THIS IS THE FILE I/O BUFFER	/046 CJL

	DIRBUFF=.			/DIRECTORY LOOKUP I/O DONE HERE	/028 CJL

	FIELD	DIRFLD%10		/DIRECTORY LOOKUP BUFFER FIELD	/028 CJL

	*DIRBUFFER			/RESET ORIGIN			/028 CJL

FILECNT,.-.				/-(NUMBER OF ENTRIES IN THIS SEGMENT)
FRSTREC,.-.				/FIRST RECORD OF FIRST ENTRY IN THIS SEGMENT
DIRLINK,.-.				/LINK TO NEXT SEGMENT; 0 IF LAST ACTIVE ONE
	.-.				/TENTATIVE ENTRY POINTER STORED HERE
AIWNUMB,.-.				/-(NUMBER OF ADDITIONAL INFORMATION WORDS)

	ENTSTRT=.			/FILE ENTRIES START HERE	/046 CJL

	ZBLOCK	PAGCNT^200+DIRBUFFER-.	/DIRECTORY ENTRIES HERE		/046 CJL

/	CONNECT MODE I/O BUFFERS.					/026 CJL

KEYBUFF,ZBLOCK	BUFSIZE			/KEYBOARD BUFFER		/026 CJL
CONBUFF,ZBLOCK	BUFSIZE			/CONSOLE OUTPUT BUFFER		/026 CJL
RINBUFF,ZBLOCK	BUFSIZE			/REMOTE INPUT BUFFER		/026 CJL
REMBUFF,ZBLOCK	BUFSIZE			/REMOTE OUTPUT BUFFER		/026 CJL

	FLD1ADR=.			/SPACE AVAILABLE FOR TEXT, ETC.	/046 CJL

	ENPUNCH				/UN-FOOL THE ASSEMBLER		/046 CJL
/	DECMATE ONCE-ONLY CODE.						/046 CJL

	FIELD	DMIFLD%10		/DECMATE ONCE-ONLY CODE FIELD	/046 CJL

	*USRLOAD			/OVER USR ROUTINE		/046 CJL

/	PAGE ZERO FOR ONCE-ONLY CODE.					/046 CJL

	*10				/GET TO AUTO-INDEX AREA		/048 CJL

XR0,	.-.				/AUTO-INDEX ZERO		/048 CJL

	*USRENTRY			/OVER USR ENTRY POINT		/046 CJL

/	DECMATE I ONCE-ONLY CODE.					/046 CJL

DM1INIT,JMS I	(DM1PORT)		/INITIALIZE THE REMOTE PORTS	/050 CJL
	TAD	(DM1LIST-1)		/POINT TO REPLACEMENT LIST	/050 CJL
	JMS	REPLACE			/ZAP IN ALL OF OUR PATCHES	/050 CJL
	CDF	PRGFLD			/GOTO MAIN FIELD		/050 CJL
	TAD I	(DIRXR)			/GET PORT SELECTION		/050 CJL
	SNA CLA				/SKIP IF PORT 1 REQUIRED	/050 CJL
	JMP	USEP0			/JUMP IF PORT 0 REQUIRED	/050 CJL
	TAD	(DM1SEC-1)		/POINT TO REPLACEMENT LIST	/050 CJL
	JMS	REPLACE			/ZAP IN SECONDARY PATCHES	/050 CJL
USEP0,	CIF CDF	PRGFLD			/BACK TO REST OF INITIALIZATION	/046 CJL
	JMP I	(INITPRT)		/CONTINUE THERE			/046 CJL

/	DECMATE II, ETC. ONCE-ONLY CODE.				/046 CJL

DM2INIT,JMS I	(DMIPORT)		/INITIALIZE THE REMOTE PORT	/048 CJL
	TAD	(DM2LIST-1)		/POINT TO REPLACEMENT LIST	/048 CJL
	JMS	REPLACE			/ZAP IN ALL OF OUR PATCHES	/048 CJL
	CIF CDF	PRGFLD			/BACK TO REST OF INITIALIZATION	/046 CJL
	JMP I	(INITPRT)		/CONTINUE THERE			/046 CJL

REPLACE,.-.				/REPLACEMENT ROUTINE		/048 CJL
	DCA	XR0			/SAVE PASSED LIST POINTER	/048 CJL
REPLUP,	CDF	DMIFLD			/BACK TO OUR FIELD		/048 CJL
	TAD I	XR0			/GET AN ADDRESS			/048 CJL
	SNA				/SKIP IF NOT AT END OF LIST	/048 CJL
	JMP I	REPLACE			/RETURN IF END OF LIST		/048 CJL
	DCA	REPADR			/STASH THE ADDRESS		/048 CJL
	TAD I	XR0			/GET THE REPLACEMENT VALUE	/048 CJL
	CDF	PRGFLD			/GOTO ZAPPING FIELD		/048 CJL
	DCA I	REPADR			/ZAP IT IN			/048 CJL
	JMP	REPLUP			/KEEP GOING			/048 CJL

REPADR,	.-.				/REPLACEMENT ADDRESS TEMPORARY	/048 CJL
/	DECMATE I PORT INITIALIZE ROUTINE				/050 CJL

DM1PORT,.-.				/DECMATE I PORT INITIALIZE ROUTINE
	TAD	(234)			/GET PORT 0 SCD ENABLE VALUE
	WCON0				/WRITE PORT 0 CONTROL REGISTER
	NL0000				/INDICATE PORT 0
	JMS	PRTINIT			/INITIALIZE PORT 0

/	CHANGE ALL IOTS TO PORT 1 VALUES.

IOCLUP,	ISZ	PSETF1			/BUMP SET FLAG INSTRUCTION
	ISZ	PDUMRD			/BUMP DUMMY READ INSTRUCTION
	ISZ	PSETF2			/BUMP SET FLAG INSTRUCTION
	ISZ	PSKIP			/BUMP SKIP ON FLAG INSTRUCTION
	ISZ	PLOAD			/BUMP LOAD INSTRUCTION
	ISZ	IOTCNT			/DONE YET?
	JMP	IOCLUP			/NO, KEEP GOING

	TAD	(234)			/GET PORT 1 SCD ENABLE VALUE
	WCON1				/WRITE PORT 1 CONTROL REGISTER
	NL4000				/INDICATE PORT 1
	JMS	PRTINIT			/INITIALIZE PORT 1
	JMP I	DM1PORT			/RETURN

PRTINIT,.-.				/LOW-LEVEL PORT INTIALIZE ROUTINE
	RACD				/RESET DESIRED PORT
	ISZ	PWASTE			/WASTE
	JMP	.-1			/SOME TIME
	CLA				/CLEAN UP
PSETF1,	RTFL0				/SET THE FLAG NOW
	TAD	(2516)			/SETUP FOR 8 BITS, NO PARITY, ETC.
	JMS	PSEND			/SEND TO MODE REGISTER 1
	CDF	PRGFLD			/GOTO MAIN FIELD
	TAD I	(RATE)			/GET BAUD RATE NOW
	CDF	DMIFLD			/BACK TO OUR FIELD
	TAD	(2460)			/ADD ON CLOCK ENABLES, ETC.
	JMS	PSEND			/SEND TO MODE REGISTER 2
	TAD	(3425)			/GET ENABLE AND RESET VALUE
	JMS	PSEND			/SEND TO COMMAND REGISTER
PDUMRD,	RKRB0				/DO A DUMMY READ NOW
PSETF2,	RTFL0				/SET THE FLAG NOW
	CLA				/CLEAN UP
	JMP I	PRTINIT			/RETURN

PSEND,	.-.				/PORT WRITE ROUTINE
PSKIP,	RTSF0				/FLAG UP?
	JMP	PSKIP			/NO, WAIT FOR IT
PLOAD,	RTLS0				/YES, LOAD THE VALUE
	CLA				/CLEAN UP
	JMP I	PSEND			/RETURN

IOTCNT,	RKFL0-RKFL1			/INTER-DEVICE IOT COUNT
PWASTE,	0				/TIMER TEMPORARY
	PAGE
/	DECMATE II, ETC. PORT INITIALIZE ROUTINE.			/048 CJL

/	THIS ROUTINE IS MOSTLY  "DARK  GREY MAGIC" WHICH IS PRIMARILY DERIVED FROM THE
/	"OFFICIAL" INFORMATION TAKEN FROM THE ONLY KNOWN DOCUMENTATION, THE DECMATE II
/	PROGRAMMER'S REFERENCE MANUAL:  EK-DECM2-RM-001.  VARIOUS EMPLOYEES OF DIGITAL
/	EQUIPMENT CORPORATION (A MULTI-NATIONAL COMPANY) HAVE ADDITIONALLY CONTRIBUTED
/	TO THIS EFFORT BY PROVIDING PORTIONS OF THE  "SACRED SLUSHWARE NOTES" ON A NOT
/	NECESSARILY  WILLING  BASIS  THROUGH  THEIR RELEASED WORKS, SUCH AS,  BUT  NOT
/	LIMITED TO, THE SOURCES OF THE PARTICULAR VERSION OF KERMIT-8  KNOWN  AS K278.
/	IT  IS  ASSUMED THAT THESE PEOPLE HAVE ACCESS TO BETTER DOCUMENTATION  OF  THE
/	HARDWARE, AND  ESPECIALLY  DOCUMENTATION  OF  THE  THREE  DIFFERENT  MODELS OF
/	DECMATE (II, III, III+) THAT THESE ISSUES APPLY TO.

/	SINCE IT IS NOT KNOWN WHETHER THE K278, ETC.  CODE IS SPECIFIC AND PRECISE, OR
/	MERELY SLOPPY, VARIOUS "QUIRKY" CODING TECHNIQUES HAVE BEEN LEFT "AS IS", WITH
/	COMMENTS   REGARDING  POTENTIAL  VARIANCE  WITH  DOCUMENTATION  NOTED    WHERE
/	NECESSARY.  THE ORDER OF ACCESS TO THE  REGISTERS HAS BEEN LEFT INTACT IN CASE
/	OF POTENTIAL INTERACTION.  SEVERAL CHANGES HAVE BEEN MADE  BEYOND THIS WORK AS
/	A  RESULT  OF  TRIAL-AND-ERROR, AND ALSO HAND DIS-ASSEMBLY OF SEVERAL  DECMATE
/	DISKETTES' CONTENTS.

/	IT IS HOPED THAT FUTURE "NEGOTIATIONS" WITH DEC ALLOW FOR PROPER DISCLOSURE OF
/	THESE ISSUES TO AVOID POTENTIAL SOFTWARE FAILURES  EVIDENT  IN  THESE ROUTINES
/	DUE TO LACK OF PROPER DOCUMENTATION.

DMIPORT,.-.			/COMMUNICATIONS PORT INITIALIZE ROUTINE

/	ACCORDING TO THE DECMATE II MANUAL, THE FOLLOWING INSTRUCTION IS UNDEFINED.

	MPRESET			/RESET MULTIPROTOCOL COMMUNICATIONS CONTROLLER CHIP

/	THE DECMATE III HAS  AN  INTERNAL  MODEM  OPTION WHICH IS NOT AVAILABLE IN THE
/	DECMATE II.  THE INTERFACE  TO THIS DEVICE IS APPARENTLY SHARED WITH THE MPSCC
/	MODEM INTERFACE WE NORMALLY USE, SO THE REGISTER ACCESS MUST BE MORE CAREFULLY
/	DEFINED.  THE APPARENT DIFFERENTIATION IS THE CURRENT VALUE OF THE DATA FIELD,
/	NAMELY EITHER FIELD 0 OR 1.  IT  IS  NOT  KNOWN WHETHER THE THREE-BIT VALUE OF
/	THE DATA FIELD IS SIGNIFICENT (PRESUMABLY FOR FUTURE EXPANSION), OR MERELY THE
/	DATA  FIELD'S  LOW-ORDER  BIT  IS  USED, AS ALL KNOWN EXAMPLES  OF  ALLEDGEDLY
/	FUNCTIONAL CODE USE APPROPRIATE CDF 00 AND CDF 10 ONLY.   APPARENTLY THE MODEM
/	INTERFACE IS REFERRED TO AS "A" AND THE MPSCC INTERFACE IS REFERRED TO AS "B".

	TAD	(030)		/GET RESET VALUE
	CDF	00		/TALKING TO REGISTER 0A
	MPSCC			/RESET COMMUNICATIONS CHIP
	CDF	10		/TALKING TO REGISTER 0B
	MPSCC			/RESET COMMUNICATIONS CHIP
/	ACCORDING  TO  THE  DECMATE II MANUAL, CONTROL	REGISTER  2 "HAS  NO  RELEVANT
/	BITS...  IF IT IS EVER WRITTEN, IT MUST BE WRITTEN WITH ALL ZEROS." APPARENTLY
/	THE  MODEM  INTERFACE  DEMANDS  A  NON-ZERO  VALUE  BE  WRITTEN  TO REGISTER 2
/	(PRESUMABLY TO  DISABLE  IT).  TO SATISFY THE ABOVE REQUIREMENT (WHATEVER THIS
/	IMPLIES!), REGISTER 2(B)  IS  WRITTEN  WITH ALL ZEROS *LAST* IN CASE THIS IS A
/	DECMATE II WHERE THE DATA FIELD CONSIDERATIONS ARE MEANINGLESS.

	CDF	00		/TALKING TO REGISTER 0A
	NL0002			/WANT REGISTER 2A
	MPSCC			/SELECT IT
	TAD	(020-2)		/GET RESET VALUE
	MPSCC			/LOAD IT
	CDF	10		/TALKING TO REGISTER 0B
	NL0002			/WANT REGISTER 2B
	MPSCC			/SELECT IT
	NL0000			/GET RESET VALUE (000)
	MPSCC			/LOAD IT

/	THE K278 CODE DOES NOT HAVE SETUP CODE FOR REGISTER 4B, PRESUMABLY BECAUSE THE
/	CODE PERFORMS A PANEL  REQUEST  (PRQ3) WHICH SETS UP THE EQUIVALENT VALUES FOR
/	ASYNCHRONOUS OPERATION WITH ONE STOP  BIT  AND  NO PARITY.  IT IS NOT KNOWN IF
/	THE DECMATE III EVEN *HAS* A  REGISTER  4B, BUT PRESUMABLY IT IS AVAILABLE FOR
/	LOADING THE RIGHT VALUES COMPATIBLE WITH THE DECMATE II, OR ATTEMPTING TO LOAD
/	IT IS INNOCUOUS. 

	CDF	00		/TALKING TO REGISTER 0A
	NL0004			/WANT REGISTER 4A
	MPSCC			/SELECT IT
	TAD	(104-4)		/SETUP FOR ASYNCHRONOUS, ONE STOP BIT, NO PARITY
	MPSCC			/LOAD IT
	CDF	10		/TALKING TO REGISTER 0B
	NL0004			/WANT REGISTER 4B
	MPSCC			/SELECT IT
	TAD	(104-4)		/SETUP FOR ASYNCHRONOUS, ONE STOP BIT, NO PARITY
	MPSCC			/LOAD IT
/	THE  DOCUMENTED VALUES	(FOR DECMATE II) REGARDING CONTROL REGISTER 1 INDICATE
/	THE PROPER VALUE OF 022, WHERE BIT[9] IS DEFINED AS A ZERO.   THE VALUE OF 026
/	IS  TAKEN  FROM  K278  WHERE  PRESUMABLY  THE  EXTRA BIT IS NECESSARY FOR SOME
/	DECMATE III OBSCURITY.

/	THE FOLLOWING CODE IS  REDUNDANT  FOR  LOADING  REGISTER  0A  BEFORE AND AFTER
/	LOADING REGISTER 0B.  THIS  IS  EITHER A MISTAKE OR OBSCURELY NECESSARY (TAKEN
/	FROM K278).

	CDF	00		/TALKING TO REGISTER 0A
	NL0001			/WANT REGISTER 1A
	MPSCC			/SELECT IT
	TAD	(026-1)		/GET SETUP VALUE
	MPSCC			/LOAD IT
	CDF	10		/TALKING TO REGISTER 0B
	NL0001			/WANT REGISTER 1B
	MPSCC			/SELECT IT
	TAD	(026-1)		/GET SETUP VALUE
	MPSCC			/LOAD IT
	CDF	00		/TALKING TO REGISTER 0A
	NL0001			/WANT REGISTER 1A
	MPSCC			/SELECT IT
	TAD	(026-1)		/GET SETUP VALUE
	MPSCC			/LOAD IT

/	THE DECMATE III INTERNAL MODEM IS PROBABLY ASYNCHRONOUS 8 BIT  ONLY.  ASSUMING
/	THE RECEIVE SIDE OF THE INTERNAL MODEM IS ALWAYS "ENABLED", REGISTER  3A WOULD
/	BE  UNNECESSARY.  THE K278 CODE DOES NOT ADDRESS REGISTER 3 AS  AN  A/B  PAIR,
/	PRESUMABLY  BECAUSE  REGISTER  3 IS NOT DECODED AND IS EFFECTIVELY REGISTER 3B
/	REGARDLESS OF  THE  DATA FIELD.  THIS IS EITHER TRUE, OR THE K278 CODING FAILS
/	TO PROPERLY INITIALIZE THE DECMATE III MPSCC PORT.

	NL0003			/WANT REGISTER 3
	MPSCC			/SELECT IT
	TAD	(301-3)		/SETUP FOR 8 BITS AND ENABLE RECIVER
	MPSCC			/LOAD IT

/	A SIMILAR  SITUATION  EXISTS  FOR  THE  TRANSMITTER  SIDE  OF  THE DECMATE III
/	INTERNAL MODEM.  REGISTER 5 IS UTILIZED ACCORDINGLY.

	TAD	(5-301)		/WANT REGISTER 5
	MPSCC			/SELECT IT
	TAD	(150-5)		/GET TRANSMITTER ENABLE, 8 BITS VALUE
	MPSCC			/LOAD IT

/	THE DECMATE II REFERENCE  MANUAL  INDICATES  THE  PROPER SETTING FOR THE MODEM
/	CONTROL REGISTER AS EITHER 030  OR  130  DEPENDING ON WHETHER BIT[5] INDICATES
/	INTERNAL OR EXTERNAL TIMING (WHERE ONE  OF  THESE  IS ILLEGAL FOR ASYNCHRONOUS
/	OPERATION!).  THE SETTING OF BITS [10]  AND  [11]  WOULD  INDICATE ENABLING OF
/	BOTH  LOCAL  AND  REMOTE LOOPBACKS, YET WE SET  ONLY  THESE  BITS  (ALA  K278)
/	ALLEDGEDLY FOR THE PURPOSE OF SETTING RTS AND DTR  (WHICH  ARE  DOCUMENTED  AS
/	BEING BITS[7] AND [8] RESPECTIVELY).

	NL0003			/SET VALUE
	MLC			/LOAD IT
	CLA			/CLEAN UP

/	THE BAUD RATE SHOULD BE SET HERE IF DESIRED.

/	TAD	BAUD		/GET BAUD RATE
/	MSB			/LOAD IT
	CLA			/CLEAN UP
	JMP I	DMIPORT		/RETURN
/	DECMATE II, ETC. REPLACEMENT LIST.				/048 CJL

DM2LIST,CLDMZAP				/	 *CLDMZAP

		DMINIT&177+JMSC		/CLDMZAP,JMS	 DMINIT

	SETBAUD				/	 *SETBAUD		/050 CJL

		MSB			/SETBAUD,MSB			/050 CJL

	INLUP				/	 *INLUP

		TAD	INFLAG		/INLUP,	 TAD	 INFLAG

	INSKIP				/	 *INSKIP

		NOTYET&177+JMPC		/INSKIP, JMP	 NOTYET
	INLUP1;	DCA	INFLAG		/INLUP1, DCA	 INFLAG
	INREAD;	IRB			/INREAD, IRB

	INSTATUS			/	 *INSTATUS

		UPSTATUS&177+JMSC	/INSTATU,JMS	 UPSTATUS

	GETFL1				/	 *GETFL1

		UPSTATUS&177+JMSC	/GETFL1, JMS	 UPSTATUS

	COMWAIT				/	 *COMWAIT

		GETFLOW&177+JMSC	/COMWAIT,JMS	 GETFLOW

	NOWAIT				/	 *NOWAIT

		TAD	OUTFLAG		/NOWAIT, TAD	 OUTFLAG
	CMOUT1;	SNA CLA			/CMOUT1, SNA CLA
	CMOUT2;	OWAIT&177+JMPC		/CMOUT2, JMP	 OWAIT
	DM1AND;	DCA	OUTFLAG		/DM1AND, DCA	 OUTFLAG
	CMOUT3;	OUTEMP&177+TADC		/CMOUT3, TAD	 OUTEMP
	CMOUT4;	OLS			/CMOUT4, OLS

	BUFCHECK			/	 *BUFCHECK

		PUPSTATUS&177+JMSIC	/BUFCHEC,JMS I	 PUPSTATUS

	KERRLUP				/	 *KERRLUP

		PUPSTATUS&177+JMSIC	/KERRLUP,JMS I	 PUPSTATUS
	RINTEST				/	 *RINTEST

		TAD	INFLAG		/RINTEST,TAD	 INFLAG
	RINGT0;	SNA CLA			/RINGT0, SNA CLA
	RINREAD;RINGNONE&177+JMPC	/RINREAD,JMP	 RINGNONE
	RINGT1;	DCA	INFLAG		/RINGT1, DCA	 INFLAG
	RINGT2;	IRB			/RINGT2, IRB

	REMTSF				/	 *REMTSF

		RMPTEMP&177+DCAC	/REMTSF, DCA	 RMPTEMP
	RMPUT0;	TAD	OUTFLAG		/RMPUT0, TAD	 OUTFLAG
	REMTLS;	SNA CLA			/REMTLS, SNA CLA
	RMPUT1;	REMPUT&177+JMPIC	/RMPUT1, JMP I	 REMPUT
	REMCLEA;RMPTEMP&177+TADC	/REMCLEA,TAD	 RMPTEMP
	RMPUT2;	OLS			/RMPUT2, OLS

	0				/THIS ENDS THE LIST

	PAGE
/	DECMATE I REPLACEMENT LIST.					/050 CJL

DM1LIST,CLDMZAP				/	 *CLDMZAP

		DMINIT&177+JMSC		/CLDMZAP,JMS	 DMINIT

	SETBAUD				/	 *SETBAUD

		NOP			/SETBAUD,NOP

	DMI01				/	 *DMI01

		DM234&177+TADC		/DMI01,	 TAD	 DM234/(234)
	DMI02;	WCON0			/DMI02,	 WCON0
	DMI03;	NL0000			/DMI03,	 NL0000
	DMI04;	RACD			/DMI04,	 RACD
	DMI05;	DMWASTE&177+ISZC	/DMI05,	 ISZ	 DMWASTE
	DMI06;	DMI05&177+JMPC		/DMI06,	 JMP	 DMI05
	DMI07;	DMWASTE&177+ISZC	/DMI07,	 ISZ	 DMWASTE
	DMI08;	DMI07&177+JMPC		/DMI08,	 JMP	 DMI07
	DMI09;	RTFL0			/DMI09,	 RTFL0
	DMI10;	DM2516&177+TADC		/DMI10,	 TAD	 DM2516/(2516)
	DMI11;	DMSEND&177+JMSC		/DMI11,	 JMS	 DMSEND
	DMI12;	TAD	RATE		/DMI12,	 TAD	 RATE
	DMI13;	DM2460&177+TADC		/DMI13,	 TAD	 DM2460/(2460)
	DMI14;	DMSEND&177+JMSC		/DMI14,	 JMS	 DMSEND
	DMI15;	DM3425&177+TADC		/DMI15,	 TAD	 DM3425/(3425)
	DMI16;	DMSEND&177+JMSC		/DMI16,	 JMS	 DMSEND
	DMI17;	RKRB0			/DMI17,	 RKRB0

	DMISET				/	 *DMISET

		RTFL0			/DMISET, RTFL0

	DMISKP				/	 *DMISKP

		RTSF0			/DMISKP, RTSF0
	DMIOUT				/	 *DMIOUT

		RTLS0			/DMIOUT, RTLS0

	INSKIP				/	 *INSKIP

		RKSF0			/INSKIP, RKSF0

	INREAD				/	 *INREAD

		RKRB0			/INREAD, RKRB0

	COMWAIT				/	 *COMWAIT

		GETFLOW&177+JMSC	/COMWAIT,JMS	 GETFLOW

	NOWAIT				/	 *NOWAIT

		RTSF0			/NOWAIT, RTSF0
	CMOUT1;	OWAIT&177+JMPC		/CMOUT1, JMP	 OWAIT

	DM1AND				/	 *DM1AND

		AND377			/DM1AND, AND	 [377]

	CMOUT4				/	 *CMOUT4

		RTLS0			/CMOUT4, RTLS0

	RINTEST				/	 *RINTEST

		RKSF0			/RINTEST,RKSF0

	RINREAD				/	 *RINREAD

		RKRB0			/RINREAD,RKRB0
	RINGT1;	SKP			/RINGT1, SKP

	DM1AN2				/	 *DM1AN2

		AND377			/DM1AN2, AND	 [377]

	REMTSF				/	 *REMTSF

		RTSF0			/REMTSF, RTSF0

	REMTLS				/	 *REMTLS

		RTLS0			/REMTLS, RTLS0

	0				/THIS ENDS THE LIST
/	DECMATE I SECONDARY REPLACEMENT LIST				/050 CJL

DM1SEC,	DMI02				/	 *DMI02

		WCON1			/DMI02,	 WCON1
	DMI03;	NL4000			/DMI03,	 NL4000

	DMI09				/	 *DMI09

		RTFL1			/DMI09,	 RTFL1

	DMI17				/	 *DMI17

		RKRB1			/DMI17,	 RKRB1

	DMISET				/	 *DMISET

		RTFL1			/DMISET, RTFL1

	DMISKP				/	 *DMISKP

		RTSF1			/DMISKP, RTSF1

	DMIOUT				/	 *DMIOUT

		RTLS1			/DMIOUT, RTLS1

	INSKIP				/	 *INSKIP

		RKSF1			/INSKIP, RKSF1

	INREAD				/	 *INREAD

		RKRB1			/INREAD, RKRB1

	NOWAIT				/	 *NOWAIT

		RTSF1			/NOWAIT, RTSF1

	CMOUT4				/	 *CMOUT4

		RTLS1			/CMOUT4, RTLS1

	RINTEST				/	 *RINTEST

		RKSF1			/RINTEST,RKSF1

	RINREAD				/	*RINREAD

		RKRB1			/RINREAD,RKRB1

	REMTSF				/	 *REMTSF

		RTSF1			/REMTSF, RTSF1
	REMTLS				/	 *REMTLS

		RTLS1			/REMTLS, RTLS1

	0				/THIS ENDS THE LIST
/	ONCE-ONLY TEXT MESSAGES.					/024 CJL

	FIELD	BUFFLD%10		/FILE I/O BUFFER FIELD

	*FILBUFFER			/OVER FILE I/O BUFFER

/	LOCAL PREFERENCE MESSAGE.					/024 CJL

/	USE SOMETHING APPROPRIATE HERE TO CUSTOMIZE KERMIT-12 TO YOUR MACHINE.

/	THIS LOCATION SHOULD BE MAINTAINED SINCE IT IS DOCUMENTED TO BE HERE.

	XLIST	OFF
	IFZERO	GENMSG			<
	XLIST	ON
LCLMSG,	*LCLMSG+40			/EMPTY HOLE FOR USER MESSAGE	/039 CJL

	XLIST	OFF			>
	IFNZRO	GENMSG			<
	IFNZRO	LEDERLE		<
	XLIST	ON
LCLMSG,	TEXT	"%^T^HANKS TO: ^B^ILL ^S^MITH AND ^D^INGER ^M^ILLER%"

	XLIST	OFF		>
	IFNZRO	UMSG		<
	XLIST	ON
LCLMSG,	TEXT	"%^I^NSERT LOCAL USER MESSAGE HERE!%^"

	XLIST	OFF		>
	IFZERO	LEDERLE!UMSG	<
	XLIST	ON
LCLMSG,	TEXT	"^^^^^^^^^^^^^^^^^^^^^^"/DEFAULT IS NO MESSAGE

	XLIST	OFF		>
	IFNZRO	LCLMSG+40-.	<
	XLIST	ON
	ZBLOCK	LCLMSG+40-.		/LEAVE PATCHING SPACE

	XLIST	OFF		>
					>
	XLIST	ON
CLOSMSG,TEXT	"^]^"			/CPU TYPE CLOSING MESSAGE
/	CPU IDENTIFICATION LIST; ALL MUST BE 5 WORDS LONG (EXCEPT LAST)./024 CJL

CPULIST,TEXT	"^U^NKNOWN"		/00=UNKNOWN
	TEXT	"^PDP^-5^^"		/01=PDP-5
	TEXT	"^PDP^-8^^"		/02=PDP-8
	TEXT	"^PDP^-8/S"		/03=PDP-8/S
	TEXT	"^LINC^-8^"		/04=LINC-8
	TEXT	"^PDP^-8/I"		/05=PDP-8/I
	TEXT	"^PDP^-8/L"		/06=PDP-8/L
	TEXT	"^PDP^-12^"		/07=PDP-12
	TEXT	"^PDP^-8/E"		/10=PDP-8/E
	TEXT	"^PDP^-8/A"		/11=PDP-8/A
	TEXT	"6100^^^^^"			/12=6100
	TEXT	"6120^"				/13=6120; LAST CAN BE SHORT!
CPUTMSG,TEXT	"%^[C^PU TYPE IS: "		/CPU TYPE MESSAGE
DAYMSG,	DAY%12^66+DAY+6060			/DAY MESSAGE
	TEXT	" "
DMPOMSG,TEXT	" ^[U^SING ^C^OMMUNICATIONS"	/DECMATE PORT MESSAGE
	TEXT	" ^P^ORT^]"
DMPPMSG,TEXT	" ^[U^SING ^P^RINTER ^P^ORT^]^"	/DECMATE SERIAL PORT MESSAGE
INITMSG,TEXT	"%^PS/8 PS/12 OS/8 OS/12 "	/INITIAL MESSAGE
	TEXT	"OS/78 OS/278  K^ERMIT-12  ^V"
INMSG2,	VERSION%12^66+VERSION+6060		/VERSION DIGITS
INMSG3,	"^^100+REVISION				/REVISION
	TEXT	"   "				/END OF MESSAGE
	XLIST	OFF
	IFZERO	MONTH-1		<
	XLIST	ON
MONMSG,	TEXT	"^J^ANUARY ^"			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-2		<
	XLIST	ON
MONMSG,	TEXT	"^F^EBRUARY "			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-3		<
	XLIST	ON
MONMSG,	TEXT	"^M^ARCH ^"			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-4		<
	XLIST	ON
MONMSG,	TEXT	"^A^PRIL ^"			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-5		<
	XLIST	ON
MONMSG,	TEXT	"^M^AY ^"			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-6		<
	XLIST	ON
MONMSG,	TEXT	"^J^UNE "			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-7		<
	XLIST	ON
MONMSG,	TEXT	"^J^ULY "			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-10	<
	XLIST	ON
MONMSG,	TEXT	"^A^UGUST "			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-11	<
	XLIST	ON
MONMSG,	TEXT	"^S^EPTEMBER ^"			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-12	<
	XLIST	ON
MONMSG,	TEXT	"^O^CTOBER ^"			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-13	<
	XLIST	ON
MONMSG,	TEXT	"^N^OVEMBER "			/MONTH MESSAGE
	XLIST	OFF		>
	IFZERO	MONTH-14	<
	XLIST	ON
MONMSG,	TEXT	"^D^ECEMBER "			/MONTH MESSAGE
	XLIST	OFF		>
	IFNZRO	MONMSG+7-.	<
	XLIST	ON

	ZBLOCK	MONMSG+7-.			/EMPTY SPACE FOR ALIGNMENT

	XLIST	OFF		>
	XLIST	ON
THLPMSG,TEXT	"%^T^YPE ^HELP<CR>^ FOR HELP%^"	/TYPE HELP MESSAGE
YEARMSG,TEXT	"19"				/YEAR MESSAGE
	YEAR%12^66+YEAR+6060			/YEAR DIGITS
	TEXT	"^"				/END OF MESSAGE
/	CPU-SPECIFIC PROMPT LIST.					/024 CJL

CPUPRMP,TEXT	"??^>^^^"	/UNKNOWN
	TEXT	"5^>^^^^"	/PDP-5
	TEXT	"8^>^^^^"	/PDP-8
	TEXT	"8^/S>^^"	/PDP-8/S
	TEXT	"LINC-8>"	/LINC-8
	TEXT	"8^/I>^^"	/PDP-8/I
	TEXT	"8^/L>^^"	/PDP-8/L
	TEXT	"12^>^^^"	/PDP-12
	TEXT	"8^/E>^^"	/PDP-8/E
	TEXT	"8^/A>^^"	/PDP-8/A
	TEXT	"78^>^^^"	/6100
	TEXT	"278^>^^"	/6120
/	CPU-SPECIFIC IDENTIFICATION LIST.				/025 CJL

CPUIDLS,TEXT	"^U^NKNOWN"	/UNKNOWN
	TEXT	"^PDP^-5^^"	/PDP-5
	TEXT	"^PDP^-8^^"	/PDP-8
	TEXT	"^PDP^-8/S"	/PDP-8/S
	TEXT	"^LINC^-8^"	/LINC-8
	TEXT	"^PDP^-8/I"	/PDP-8/I
	TEXT	"^PDP^-8/L"	/PDP-8/L
	TEXT	"^PDP^-12^"	/PDP-12
	TEXT	"^PDP^-8/E"	/PDP-8/E
	TEXT	"^PDP^-8/A"	/PDP-8/A
	TEXT	"^VT^-78^^"	/VT-78
	TEXT	"^DEC^MATE"	/6120
	FIELD	MSGFLD%10			/MESSAGE FIELD

	*FLD1ADR				/PERMANENT LOAD ADDRESS	/046 CJL
						/TEXT MESSAGES LOAD HERE/046 CJL

ABMSG,	TEXT	"%^F^ILE ^A^BORT%^"		/FILE ABORT MESSAGE
CMERMSG,TEXT	"?^I^NVALID COMMAND^"		/COMMAND ERROR MESSAGE
CONNMSG,TEXT	"%(^C^ONNECTING TO HOST, TYPE "	/FIRST CONNECT MESSAGE
CONTMSG,TEXT	"^C^ONTROL-^"			/CONTROL CHARACTER MESSAGE
CON2MSG,TEXT	" ^C^ TO RETURN TO ^"		/BRIDGING CONNECT MESSAGE
CON3MSG,TEXT	")%^"				/FINAL CONNECT MESSAGE
CPUMSG,	ZBLOCK	5				/CPU ID MESSAGE GOES HERE
/CRLF,	TEXT	"%"				/<CR>, <LF> MESSAGE
DNERMSG,TEXT	"?^E^RROR IN DEVICE NAME"	/DEVICE NAME ERROR MESSAGE
DSFLMSG,TEXT	"?^D^ISK FULL!"			/DISK OUT OF ROOM ERROR MESSAGE
FCLEMSG,TEXT	"?^E^RROR CLOSING FILE"		/FILE CLOSE ERROR MESSAGE
FNERMSG,	TEXT	"?^E^RROR IN FILE NAME"	/FILE NAME ERROR MESSAGE
FRECMSG,TEXT	"^R^ECEIVING FILE: ^"		/RECEIVING FILE MESSAGE
FSENMSG,TEXT	"^S^ENDING FILE: ^"		/SENDING FILE MESSAGE
FSERMSG,TEXT	"?^F^ILE NAME SYNTAX ERROR"	/FILE NAME ERROR MESSAGE
HELPMSG,TEXT	"%^S^UPPORTED COMMANDS ARE:%%"	/HELP MESSAGE
	TEXT	"^CONNECT^ (TO REMOTE SYSTEM) %"
	TEXT	"^SEND DEV:FILNAM.EX^ %"
	TEXT	"^RECEIVE DEV:^ (FILENAME AND EXTENSION ^NOT^ ALLOWED)%"
	TEXT	"^GET DEV:FILNAM.EX^%"
	TEXT	"^FINISH^ (SERVER)%"
	TEXT	"^EXIT^ (TO OPERATING SYSTEM) %"
	TEXT	"^HELP^ (THIS MESSAGE)%"
	TEXT	"%^E^SCAPE CHARACTER: "
KERRMSG,TEXT	"%^K^EYBOARD INPUT ERROR!%"	/KEYBOARD ERROR MESSAGE

	CRLF=	.-1				/<CR>, <LF> MESSAGE
NOFINIS,TEXT	"?^U^NABLE TO TELL HOST THAT "	/FINISH ERROR MESSAGE
	TEXT	"SESSION IS FINISHED"
NOTFND,	TEXT	"?^U^NABLE TO LOCATE FILE^"	/FILE NOT FOUND MESSAGE
PRMTMSG,TEXT	"^K^ERMIT-^"			/STATIC PORTION OF PROMPT MESSAGE
PROMID,	ZBLOCK	23				/MODIFIED PORTION OF PROMPT MESSAGE
RERRMSG,TEXT	"?^R^ECEIVE FAILURE^"		/GENERAL RECEIVE FAILURE MESSAGE
RFLNMSG,TEXT	"?^E^RROR IN RECEIVED FILE NAME"/RECEIVED NAME ERROR MESSAGE
	TEXT	"^"
RHFEMSG,TEXT	"^U^NABLE TO RECEIVE - HANDLER"	/HANDLER FETCH ERROR MESSAGE
	TEXT	" ERROR^"
RIDEMSG,TEXT	"?^U^NABLE TO RECEIVE -"	/DIRECTORY FULL ERROR MESSAGE
	TEXT	" INSUFFICIENT DIRECTORY SPACE"
RIERMSG,TEXT	"%^R^EMOTE LINE INPUT ERROR!%^"	/REMOTE LINE ERROR MESSAGE
RPERMSG,TEXT	"?^U^NABLE TO RECEIVE LATEST "	/LATEST PACKET ERROR MESSAGE
	TEXT	"PACKET^"
SDERMSG,TEXT	"?^U^NABLE TO SEND - DIRECTORY "/DIRECTORY INPUT ERROR MESSAGE
	TEXT	"ERROR"
SHFEMSG,TEXT	"?^U^NABLE TO SEND - HANDLER "	/HANDLER FETCH ERROR MESSAGE
	TEXT	"ERROR"
SNDEMSG,TEXT	"?^U^NABLE TO SEND"		/GENERAL SEND ERROR MESSAGE
UPERMSG,TEXT	"?^U^NABLE TO RECEIVE - DATA "	/RECEIVED DATA ERROR MESSAGE
	TEXT	"ERROR"

	$					/THAT'S ALL FOLK!
