68K GAS  S68K_001.s 			page 1


   1               	| Borrowed init code from 
   2               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   3               	
   4               	RAM_START	= 0x00000	| Beginning of the SRAM
   5               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
   6               	RAM_END		= 0x7FFFF	| 512KB SRAM
   7               	ROM_START	= 0x80000	| ROM start
   8               	ROM_CODE	= ROM_START+1024| Skip vector table
   9               	ROM_END		= 0x87FFF	| End of 32KB EPROM
  10               	
  11               	|||||||||||||||||||||||||||||||||
  12               	| 68681 Duart Register Addresses
  13               	|
  14               	DUART = 0x0F0000	  | Base Addr of DUART
  15               	MRA   = DUART+0		  | Mode Register A           (R/W)
  16               	SRA   = DUART+2       | Status Register A         (r)
  17               	CSRA  = DUART+2       | Clock Select Register A   (w)
  18               	CRA   = DUART+4       | Commands Register A       (w)
  19               	RBA   = DUART+6       | Receiver Buffer A         (r)
  20               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  21               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  22               	ISR   = DUART+10      | Interrupt Status Register (R)
  23               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  24               	MRB   = DUART+16      | Mode Register B           (R/W)
  25               	SRB   = DUART+18      | Status Register B         (R)
  26               	CSRB  = DUART+18      | Clock Select Register B   (W)
  27               	CRB   = DUART+20      | Commands Register B       (W)
  28               	RBB   = DUART+22      | Reciever Buffer B         (R)
  29               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  30               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  31               	OPC   = DUART+26      | Output port config        (W)
  32               	INU   = DUART+26      | Input port (unlatched)    (R)
  33               	OPS   = DUART+28      | Output port Set           (W)
  34               	OPR   = DUART+30      | Output port Clear         (W)
  35               	
  36               	||||||||||||||||||||||||||||||||||
  37               	| ASCII Control Characters
  38               	|
  39               	BEL   = 0x07
  40               	BKSP  = 0x08       | CTRL-H
  41               	TAB   = 0x09
  42               	LF    = 0x0A
  43               	CR    = 0x0D
  44               	ESC   = 0x1B
  45               	
  46               	CTRLC	=	0x03
  47               	CTRLX	=	0x18     | Line Clear
  48               	
  49 0000 0000 0000 		.ORG	ROM_START
  49      0000 0000 
  49      0000 0000 
  49      0000 0000 
  49      0000 0000 
  50               	
  51               	| FIRST 8 bytes loaded after reset |
  52 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  53 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
68K GAS  S68K_001.s 			page 2


  54               	
  55 80008 0000 0000 	        .ORG ROM_CODE
  55      0000 0000 
  55      0000 0000 
  55      0000 0000 
  55      0000 0000 
  56 80400 4E71      		nop
  57 80402 4FF9 0007 		lea			STACK_END,%sp
  57      FFFC 
  58 80408 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  58      0008 0000 
  59 80410 4E71      		nop
  60               	|
  61               	| Test the first two SRAM location
  62               	|
  63 80412 203C DEAD 		move.l	#0xDEADBEEF, %d0	| Test Pattern #1
  63      BEEF 
  64 80418 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  65 8041c 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  66 8041e 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
  67 80420 B042      		cmp			%d2, %d0
  68 80422 6600 00D6 		bne			FERVR2						
  69 80426 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  69      AAAA 
  70 8042c 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
  71 80430 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
  72 80432 2611      		move.l	(%a1), %d3				| Read back
  73 80434 B243      		cmp			%d3, %d1
  74 80436 6600 00C2 		bne			FERVR2
  75 8043a 4E71      		nop
  76               	| Test bits of first location (as bytes)
  77 8043c 7001      		move.l	#1, %d0
  78 8043e 207C 0000 		move.l	#0, %a0
  78      0000 
  79               	loop1stLoc:
  80 80444 1080      		move.b	%d0, (%a0)
  81 80446 1210      		move.b	(%a0), %d1
  82 80448 B200      		cmp.b		%d0, %d1
  83 8044a 6600 00B4 		bne			failBitTest
  84 8044e E348      		lsl			#1, %d0
  85 80450 0C80 0000 		cmp.l		#0x00000100, %d0
  85      0100 
  86 80456 6600 FFEC 		bne			loop1stLoc
  87               	|
  88               	| Test all address lines, 512KB SRAM
  89               	| Write incrementing pattern to data bits
  90               	|
  91 8045a 7001      		move.l	#1, %d0		| Fill pattern
  92 8045c 7401      		move.l	#1, %d2
  93 8045e 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
  93      0001 
  94               	loopAdrFill:
  95 80464 1080      		move.b	%d0,(%a0)	| Do the write
  96 80466 5240      		addq		#1, %d0		| Increment the pattern
  97 80468 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
  98 8046a E38A      		lsl.l		#1, %d2		| Shift temp addr
  99 8046c 2042      		move.l	%d2, %a0	| Put back into addr reg
68K GAS  S68K_001.s 			page 3


 100 8046e 0C82 0008 		cmp.l		#0x00080000,%d2
 100      0000 
 101 80474 6600 FFEE 		bne			loopAdrFill
 102               	| Check
 103 80478 7001      		move.l	#1, %d0
 104 8047a 7401      		move.l	#1, %d2
 105 8047c 207C 0000 		move.l	#1, %a0
 105      0001 
 106               	loopAdrCk:
 107 80482 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 108 80484 B200      		cmp.b		%d0, %d1
 109 80486 6600 007E 		bne			failAdrTest
 110 8048a 5240      		addq		#1, %d0
 111 8048c 2408      		move.l	%a0, %d2 
 112 8048e E38A      		lsl.l		#1, %d2
 113 80490 2042      		move.l	%d2, %a0
 114 80492 0C82 0008 		cmp.l		#0x00080000,%d2
 114      0000 
 115 80498 6600 FFE8 		bne			loopAdrCk
 116               	|
 117               	| Done with address test of SRAM
 118               	|
 119 8049c 4EBA 01E8 		jsr     initDuart       | Setup the serial port
 120               		
 121 804a0 41FA 02D0 		lea		BANNER_MSG, %a0
 122 804a4 4EBA 008E 		jsr		printString1
 123 804a8 41FA 02B6 		lea		RAM_PASS_MSG, %a0
 124 804ac 4EBA 0086 		jsr		printString1
 125               	|
 126               	|	jsr		inChar
 127               	|	jsr		outChar
 128               	|	jmp		FERVR
 129               	|
 130               	|	lea		READINLINE, %a0
 131               	|	jsr		printString1
 132               	interpLoop:
 133 804b0 41FA 0340 	    lea     msgPrompt, %a0   | Prompt
 134 804b4 6100 007E 	    bsr.w   printString
 135 804b8 4EBA 00AC 		jsr		readLine
 136 804bc 4EBA 013A 		jsr		lineToUpper
 137 804c0 13FC 0004 		move.b	#0x04, OPS		| Blink LED on DUART Out2
 137      000F 001C 
 138 804c8 4EBA 014C 		jsr		parseLine
 139 804cc 4EBA 0242 		jsr		delay1Sec
 140 804d0 13FC 0004 		move.b	#0x04, OPR
 140      000F 001E 
 141 804d8 6000 FFD6 		bra		interpLoop
 142               		
 143               	FERVR:
 144 804dc 4E71      		nop
 145 804de 13FC 0004 		move.b	#0x04, OPS		| Blink LED on DUART Out2
 145      000F 001C 
 146 804e6 4EBA 0228 		jsr		delay1Sec
 147 804ea 13FC 0004 		move.b	#0x04, OPR
 147      000F 001E 
 148 804f2 4EBA 021C 		jsr		delay1Sec
 149 804f6 4EFA FFE4 		jmp		FERVR
68K GAS  S68K_001.s 			page 4


 150               	|
 151               	FERVR2:
 152 804fa 4E71      		nop
 153 804fc 4EFA FFFC 		jmp	FERVR2
 154               	failBitTest:
 155 80500 4E71      		nop
 156 80502 4EFA FFFC 		jmp	failBitTest
 157               	failAdrTest:
 158 80506 4E71      		nop
 159 80508 4EFA FFFC 		jmp	failAdrTest
 160               	
 161               	|||||
 162               	| Writes a character to Port A, blocking if not ready (Full buffer)
 163               	|  - Takes a character in D0
 164               	outChar1:
 165               	outChar:
 166 8050c 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 166      000F 0002 
 167 80514 6700 FFF6 	    beq     outChar1     
 168 80518 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 168      0006 
 169 8051e 4E75      	    rts
 170               	
 171               	| Writes a character to Port A, blocking if not ready (Full buffer)
 172               	|  - Takes a character in D0
 173               	outChar2:
 174 80520 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 174      000F 0012 
 175 80528 6700 FFF6 	    beq     outChar2     
 176 8052c 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 176      0016 
 177 80532 4E75      	    rts
 178               	
 179               	******
 180               	* Print a null terminated string
 181               	*
 182               	printString1:
 183               	printString:
 184               	 PSloop:
 185 80534 1018      	    move.b  (%a0)+, %d0  | Read in character
 186 80536 6704      	    beq.s   PSend         | Check for the null
 187               	    
 188 80538 61D2      	    bsr.s   outChar      | Otherwise write the character
 189 8053a 60F8      	    bra.s   PSloop        | And continue
 190               	PSend:
 191 8053c 4E75      	    rts
 192               	
 193               	
 194               	|||||
 195               	| Reads in a character from Port A, blocking if none available
 196               	|  - Returns character in D0
 197               	|    
 198               	inChar1:
 199               	inChar:
 200 8053e 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 200      000F 0002 
 201 80546 6700 FFF6 	    beq     inChar1
68K GAS  S68K_001.s 			page 5


 202 8054a 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 202      0006 
 203 80550 4E75      	    rts
 204               	
 205               	inChar2:
 206 80552 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 206      000F 0012 
 207 8055a 6700 FFF6 	    beq     inChar2
 208 8055e 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 208      0016 
 209 80564 4E75      	    rts
 210               	
 211               	| Read in a line into the line buffer
 212               	readLine:
 213 80566 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 214 8056a 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 214      FBAE 
 215 80570 B542      	    eor.w   %d2, %d2           	| Clear the character counter
 216               	 RLloop:
 217 80572 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 218 80576 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 219 8057a 6722      	    beq.s   RLBS
 220 8057c 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 221 80580 673A      	    beq.s   RLlineClr
 222 80582 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 223 80586 6758      	    beq.s   RLEndLn
 224 80588 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 225 8058c 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 226               	 .char:                      	| Normal character to be inserted into the buffer
 227 8058e 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 228 80592 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 229 80594 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 230 80596 5242      	    addq.w  #1, %d2           	| Increment character count
 231 80598 6100 FF72 	    bsr.w   outChar          	| Echo the character
 232 8059c 60D4      	    bra.s   RLloop            	| And get the next one
 233               	 RLBS:
 234 8059e 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 235 805a0 67D0      	    beq.s   RLloop            	| Then ignore it
 236 805a2 6100 FF68 	    bsr.w   outChar          	| Backspace
 237 805a6 103C 0020 	    move.b  #' ', %d0
 238 805aa 6100 FF60 	    bsr.w   outChar          	| Space
 239 805ae 103C 0008 	    move.b  #BKSP, %d0
 240 805b2 6100 FF58 	    bsr.w   outChar          	| Backspace
 241 805b6 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 242 805b8 5382      	    subq.l  #1, %d2           	| And current character count
 243 805ba 60B6      	    bra.s   RLloop            	| And goto the next character
 244               	 RLlineClr:
 245 805bc 4A42      	    tst     %d2               	| Anything to clear?
 246 805be 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 247 805c0 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 248               	 RLlineClrloop:
 249 805c2 103C 0008 	    move.b  #BKSP, %d0
 250 805c6 6100 FF44 	    bsr.w   outChar          	| Backspace
 251 805ca 103C 0020 	    move.b  #' ', %d0
 252 805ce 6100 FF3C 	    bsr.w   outChar          	| Space
 253 805d2 103C 0008 	    move.b  #BKSP, %d0
 254 805d6 6100 FF34 	    bsr.w   outChar          	| Backspace
68K GAS  S68K_001.s 			page 6


 255 805da 5342      	    subq.w  #1, %d2          
 256 805dc 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 257 805de 6092      	    bra.s   RLloop   
 258               	 RLEndLn:
 259 805e0 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 260 805e4 103C 000A 	    move.b  #LF, %d0
 261 805e8 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 262 805ec 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 263 805f0 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 264 805f2 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 265 805f6 4E75      	    rts                      	| And return
 266               	
 267               	
 268               	| Convert line buffer to upper case
 269               	lineToUpper:
 270 805f8 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 270      FBAE 
 271               	 LUloop:
 272 805fe 1010      	    move.b  (%a0), %d0        | Read in a character
 273 80600 0C00 0061 	    cmp.b   #'a', %d0         
 274 80604 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 275 80606 0C00 007A 	    cmp.b   #'z', %d0
 276 8060a 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 277 8060c 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
 278               	 LUnext:
 279 80610 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 280 80612 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 281 80614 4E75      	    rts
 282               	
 283               	|
 284               	| Parse Line
 285               	|
 286               	parseLine:
 287 80616 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 288 8061a 41F9 0007 	    lea     varLineBuf, %a0
 288      FBAE 
 289               	 PLfindCommand:
 290 80620 1018      	    move.b  (%a0)+, %d0
 291 80622 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 292 80626 6700 FFF8 	    beq.w   PLfindCommand    
 293 8062a 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 294 8062e 6700 0052 	    beq.w   .examine
 295 80632 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 296 80636 6700 004A 	    beq.w   .deposit
 297 8063a 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 298 8063e 6700 0042 	    beq.w   .run
 299 80642 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 300 80646 6700 0016 	    beq.w   .help
 301 8064a 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 302 8064e 6708      	    beq.s   .exit               
 303               	 .invalid:   
 304 80650 41FA 0133 	    lea     msgInvalidCommand, %a0
 305 80654 6100 FEDE 	    bsr.w   printString
 306               	 .exit:
 307 80658 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 308 8065c 4E75      	    rts
 309               	
68K GAS  S68K_001.s 			page 7


 310               	 .help:
 311 8065e 41FA 013A 	    lea     msgHelp, %a0
 312 80662 6100 FED0 	    bsr.w   printString
 313 80666 6000 FFF0 	    bra.w   .exit
 314               	 .invalidAddr:
 315 8066a 41FA 0172 	    lea     msgInvalidAddress, %a0
 316 8066e 6100 FEC4 	    bsr.w   printString
 317 80672 6000 FFE4 	    bra.w   .exit
 318               	 .invalidVal:
 319 80676 41FA 016A 	    lea     msgInvalidValue, %a0
 320 8067a 6100 FEB8 	    bsr.w   printString
 321 8067e 6000 FFD8 	    bra.w   .exit
 322               	
 323               	.examine:
 324               	.deposit:
 325               	.run:
 326 80682 6000 FFD4 		bra	.exit
 327               		
 328               	|||||
 329               	| Initializes the 68681 DUART port A as 9600 8N1 
 330               	initDuart:
 331 80686 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 331      000F 0004 
 332 8068e 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 332      000F 0004 
 333 80696 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 333      000F 0004 
 334               	    
 335 8069e 13FC 0080 	    move.b  #0x80, ACR       | Baud Rate Set #2
 335      000F 0008 
 336 806a6 13FC 00BB 	    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 336      000F 0002 
 337 806ae 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 337      000F 0000 
 338 806b6 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 338      000F 0000 
 339               	    
 340 806be 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 340      000F 0004 
 341               	
 342 806c6 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 342      000F 0014 
 343 806ce 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 343      000F 0014 
 344 806d6 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 344      000F 0014 
 345               	    
 346 806de 13FC 00BB 	    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 346      000F 0012 
 347 806e6 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 347      000F 0010 
 348 806ee 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 348      000F 0010 
 349               	    
 350 806f6 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 350      000F 0014 
 351               		
68K GAS  S68K_001.s 			page 8


 352 806fe 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 352      000F 001A 
 353 80706 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 353      000F 001E 
 354 8070e 4E75      	    rts    
 355               	
 356               	delay1Sec:
 357 80710 203C 0003 		move.l	#200000, %d0	| rough count
 357      0D40 
 358               	delay1Loop:
 359 80716 5380      		sub.l	#1, %d0			
 360 80718 6600 FFFC 		bne		delay1Loop
 361 8071c 4E75      		rts
 362               	
 363               	READINLINE:	  
 364 8071e 5265 6164 		.ascii  "Reading in line"
 364      696E 6720 
 364      696E 206C 
 364      696E 65
 365 8072d 0D0A 00   		dc.b CR,LF,EOT
 366               	L_TO_UPPER_MSG:  
 367 80730 436F 6E76 		.ascii  "Convert line to upper case"
 367      6572 7420 
 367      6C69 6E65 
 367      2074 6F20 
 367      7570 7065 
 368 8074a 0D0A 00   		dc.b CR,LF,EOT
 369               	WRITEOUTLINE:	  
 370 8074d 5772 6974 		.ascii  "Writing out line"
 370      696E 6720 
 370      6F75 7420 
 370      6C69 6E65 
 371 8075d 0D0A 00   		dc.b CR,LF,EOT
 372               	RAM_PASS_MSG:  
 373 80760 5241 4D20 		.ascii  "RAM Test Passed"
 373      5465 7374 
 373      2050 6173 
 373      7365 64
 374 8076f 0D0A 00   		dc.b CR,LF,EOT
 375               	BANNER_MSG:	
 376 80772 5349 4D50 		.ascii  "SIMPLE-68008 CPU"
 376      4C45 2D36 
 376      3830 3038 
 376      2043 5055 
 377 80782 0D0A 00   		dc.b CR,LF,EOT
 378               	msgInvalidCommand:
 379 80785 496E 7661 	    .ascii "Invalid Command"
 379      6C69 6420 
 379      436F 6D6D 
 379      616E 64
 380 80794 0D0A 00   		dc.b CR,LF,EOT
 381               	CRLF_MSG:	
 382 80797 0D0A 00   		dc.b CR,LF,EOT
 383               	msgHelp:
 384 8079a 4176 6169 	    .ascii	"Available Commands: "
 384      6C61 626C 
 384      6520 436F 
68K GAS  S68K_001.s 			page 9


 384      6D6D 616E 
 384      6473 3A20 
 385 807ae 0D0A      		dc.b	CR,LF
 386 807b0 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (H)elp"
 386      7861 6D69 
 386      6E65 2020 
 386      2020 2844 
 386      2965 706F 
 387 807db 0D0A 00   		dc.b	CR,LF,EOT
 388               	msgInvalidAddress:
 389 807de 00        	    dc.b	"Invalid Address"
 390 807df 0D0A 00   		dc.b 	CR,LF,EOT
 391               	msgInvalidValue:
 392 807e2 496E 7661 	    .ascii	"Invalid Value"
 392      6C69 6420 
 392      5661 6C75 
 392      65
 393 807ef 0D0A 00   		dc.b	CR,LF,EOT
 394               	msgPrompt:
 395 807f2 3E20      		.ascii "> "
 396 807f4 00        	    dc.b EOT
 397               		
 398               	MAX_LINE_LENGTH = 80
 399               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
68K GAS  S68K_001.s 			page 10


DEFINED SYMBOLS
          S68K_001.s:4      *ABS*:0000000000000000 RAM_START
          S68K_001.s:5      *ABS*:000000000007fffc STACK_END
          S68K_001.s:6      *ABS*:000000000007ffff RAM_END
          S68K_001.s:7      *ABS*:0000000000080000 ROM_START
          S68K_001.s:8      *ABS*:0000000000080400 ROM_CODE
          S68K_001.s:9      *ABS*:0000000000087fff ROM_END
          S68K_001.s:14     *ABS*:00000000000f0000 DUART
          S68K_001.s:15     *ABS*:00000000000f0000 MRA
          S68K_001.s:16     *ABS*:00000000000f0002 SRA
          S68K_001.s:17     *ABS*:00000000000f0002 CSRA
          S68K_001.s:18     *ABS*:00000000000f0004 CRA
          S68K_001.s:19     *ABS*:00000000000f0006 RBA
          S68K_001.s:20     *ABS*:00000000000f0006 TBA
          S68K_001.s:21     *ABS*:00000000000f0008 ACR
          S68K_001.s:22     *ABS*:00000000000f000a ISR
          S68K_001.s:23     *ABS*:00000000000f000a IMR
          S68K_001.s:24     *ABS*:00000000000f0010 MRB
          S68K_001.s:25     *ABS*:00000000000f0012 SRB
          S68K_001.s:26     *ABS*:00000000000f0012 CSRB
          S68K_001.s:27     *ABS*:00000000000f0014 CRB
          S68K_001.s:28     *ABS*:00000000000f0016 RBB
          S68K_001.s:29     *ABS*:00000000000f0016 TBB
          S68K_001.s:30     *ABS*:00000000000f0018 IVR
          S68K_001.s:31     *ABS*:00000000000f001a OPC
          S68K_001.s:32     *ABS*:00000000000f001a INU
          S68K_001.s:33     *ABS*:00000000000f001c OPS
          S68K_001.s:34     *ABS*:00000000000f001e OPR
          S68K_001.s:39     *ABS*:0000000000000007 BEL
          S68K_001.s:40     *ABS*:0000000000000008 BKSP
          S68K_001.s:41     *ABS*:0000000000000009 TAB
          S68K_001.s:42     *ABS*:000000000000000a LF
          S68K_001.s:43     *ABS*:000000000000000d CR
          S68K_001.s:44     *ABS*:000000000000001b ESC
          S68K_001.s:46     *ABS*:0000000000000003 CTRLC
          S68K_001.s:47     *ABS*:0000000000000018 CTRLX
          S68K_001.s:151    .text:00000000000804fa FERVR2
          S68K_001.s:79     .text:0000000000080444 loop1stLoc
          S68K_001.s:154    .text:0000000000080500 failBitTest
          S68K_001.s:94     .text:0000000000080464 loopAdrFill
          S68K_001.s:106    .text:0000000000080482 loopAdrCk
          S68K_001.s:157    .text:0000000000080506 failAdrTest
          S68K_001.s:330    .text:0000000000080686 initDuart
          S68K_001.s:375    .text:0000000000080772 BANNER_MSG
          S68K_001.s:182    .text:0000000000080534 printString1
          S68K_001.s:372    .text:0000000000080760 RAM_PASS_MSG
          S68K_001.s:132    .text:00000000000804b0 interpLoop
          S68K_001.s:394    .text:00000000000807f2 msgPrompt
          S68K_001.s:183    .text:0000000000080534 printString
          S68K_001.s:212    .text:0000000000080566 readLine
          S68K_001.s:269    .text:00000000000805f8 lineToUpper
          S68K_001.s:286    .text:0000000000080616 parseLine
          S68K_001.s:356    .text:0000000000080710 delay1Sec
          S68K_001.s:143    .text:00000000000804dc FERVR
          S68K_001.s:164    .text:000000000008050c outChar1
          S68K_001.s:165    .text:000000000008050c outChar
          S68K_001.s:173    .text:0000000000080520 outChar2
68K GAS  S68K_001.s 			page 11


          S68K_001.s:184    .text:0000000000080534 PSloop
          S68K_001.s:190    .text:000000000008053c PSend
          S68K_001.s:198    .text:000000000008053e inChar1
          S68K_001.s:199    .text:000000000008053e inChar
          S68K_001.s:205    .text:0000000000080552 inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_001.s:216    .text:0000000000080572 RLloop
          S68K_001.s:233    .text:000000000008059e RLBS
          S68K_001.s:244    .text:00000000000805bc RLlineClr
          S68K_001.s:258    .text:00000000000805e0 RLEndLn
          S68K_001.s:226    .text:000000000008058e .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_001.s:248    .text:00000000000805c2 RLlineClrloop
          S68K_001.s:271    .text:00000000000805fe LUloop
          S68K_001.s:278    .text:0000000000080610 LUnext
          S68K_001.s:289    .text:0000000000080620 PLfindCommand
          S68K_001.s:323    .text:0000000000080682 .examine
          S68K_001.s:324    .text:0000000000080682 .deposit
          S68K_001.s:325    .text:0000000000080682 .run
          S68K_001.s:310    .text:000000000008065e .help
          S68K_001.s:306    .text:0000000000080658 .exit
          S68K_001.s:303    .text:0000000000080650 .invalid
          S68K_001.s:378    .text:0000000000080785 msgInvalidCommand
          S68K_001.s:383    .text:000000000008079a msgHelp
          S68K_001.s:314    .text:000000000008066a .invalidAddr
          S68K_001.s:388    .text:00000000000807de msgInvalidAddress
          S68K_001.s:318    .text:0000000000080676 .invalidVal
          S68K_001.s:391    .text:00000000000807e2 msgInvalidValue
          S68K_001.s:358    .text:0000000000080716 delay1Loop
          S68K_001.s:363    .text:000000000008071e READINLINE
          S68K_001.s:366    .text:0000000000080730 L_TO_UPPER_MSG
          S68K_001.s:369    .text:000000000008074d WRITEOUTLINE
          S68K_001.s:381    .text:0000000000080797 CRLF_MSG

UNDEFINED SYMBOLS
EOT
Invalid Address
