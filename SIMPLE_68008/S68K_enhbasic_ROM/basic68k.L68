0008085A Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/28/2024 5:32:56 PM

00000000                             1  *************************************************************************************
00000000                             2  *                                           *
00000000                             3  *   Enhanced BASIC for the Motorola MC680xx                     *
00000000                             4  *                                           *
00000000                             5  *   This version is for the SIMPLE-68008 single board computer.                 *
00000000                             6  *   Original by lots of people (see below), but resurrected by Jeff Tranter (tranter@pobox.com) *
00000000                             7  *                                           *
00000000                             8  *************************************************************************************
00000000                             9  *                                           *
00000000                            10  *   Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
00000000                            11  *   for personal use only. All commercial rights are reserved.          *
00000000                            12  *                                           *
00000000                            13  *   More 68000 and other projects can be found on my website at ..          *
00000000                            14  *                                           *
00000000                            15  *    http://mycorner.no-ip.org/index.html                       *
00000000                            16  *                                           *
00000000                            17  *   mail : leeedavison@googlemail.com                       *
00000000                            18  *                                           *
00000000                            19  *************************************************************************************
00000000                            20  
00000000                            21  * Ver 3.52
00000000                            22  
00000000                            23  * Ver 3.52 stops USING$() from reading beyond the end of the format string
00000000                            24  * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
00000000                            25  * Ver 3.50 unary minus in concatenate generates a type mismatch error
00000000                            26  * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
00000000                            27  * Ver 3.48 allows scientific notation underflow in the USING$() function
00000000                            28  * Ver 3.47 traps the use of array elements as the FOR loop variable
00000000                            29  * Ver 3.46 updates function and function variable handling
00000000                            30  
00000000                            31  *************************************************************************************
00000000                            32  *
00000000                            33  * Ver 3.45 makes the handling of non existant variables consistent and gives the
00000000                            34  * option of not returning an error for a non existant variable. If this is the
00000000                            35  * behaviour you want just change novar to some non zero value
00000000                            36  
00000000  =00000000                 37  novar       EQU 0               * non existant variables cause errors
00000000                            38  
00000000                            39  
00000000                            40  *************************************************************************************
00000000                            41  
00000000                            42  * Ver 3.44 adds overflow indication to the USING$() function
00000000                            43  * Ver 3.43 removes an undocumented feature of concatenating null strings
00000000                            44  * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
00000000                            45  * Ver 3.41 removes undocumented features of the USING$() function
00000000                            46  * Ver 3.40 adds the USING$() function
00000000                            47  * Ver 3.33 adds the file requester to LOAD and SAVE
00000000                            48  * Ver 3.32 adds the optional ELSE clause to IF .. THEN
00000000                            49  
00000000                            50  *************************************************************************************
00000000                            51  *
00000000                            52  * Version 3.25 adds the option to change the behaviour of INPUT so that a null
00000000                            53  * response does not cause a program break. If this is the behaviour you want just
00000000                            54  * change nobrk to some non zero value.
00000000                            55  
00000000  =00000000                 56  nobrk       EQU 0               * null response to INPUT causes a break
00000000                            57  
00000000                            58  
00000000                            59  *************************************************************************************
00000000                            60  *
00000000                            61  * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
00000000                            62  * pointer in a3. this means that this could now be run as a task on a multitasking
00000000                            63  * system where memory resources may change.
00000000                            64  
Line 65 ERROR: Illegal symbol
00000000                            65  |||||||||||||||||||||||||||||||||
Line 66 ERROR: Illegal symbol
00000000                            66  | 68681 Duart Register Addresses
Line 67 ERROR: Illegal symbol
00000000                            67  |
Line 68 ERROR: Invalid syntax
00000000                            68  DUART EQU 0x0F0000      * Base Addr of DUART
Line 69 ERROR: Undefined symbol
00000000                            69  MRA   EQU DUART+0       * Mode Register A           (R/W)
Line 70 ERROR: Undefined symbol
00000000                            70  SRA   EQU DUART+2       * Status Register A         (r)
Line 71 ERROR: Undefined symbol
00000000                            71  CSRA  EQU DUART+2       * Clock Select Register A   (w)
Line 72 ERROR: Undefined symbol
00000000                            72  CRA   EQU DUART+4       * Commands Register A       (w)
Line 73 ERROR: Undefined symbol
00000000                            73  RBA   EQU DUART+6       * Receiver Buffer A         (r)
Line 74 ERROR: Undefined symbol
00000000                            74  TBA   EQU DUART+6       * Transmitter Buffer A      (w)
Line 75 ERROR: Undefined symbol
00000000                            75  ACR   EQU DUART+8       * Aux. Control Register     (R/W)
Line 76 ERROR: Undefined symbol
00000000                            76  ISR   EQU DUART+10      * Interrupt Status Register (R)
Line 77 ERROR: Undefined symbol
00000000                            77  IMR   EQU DUART+10      * Interrupt Mask Register   (W)
Line 78 ERROR: Undefined symbol
00000000                            78  MRB   EQU DUART+16      * Mode Register B           (R/W)
Line 79 ERROR: Undefined symbol
00000000                            79  SRB   EQU DUART+18      * Status Register B         (R)
Line 80 ERROR: Undefined symbol
00000000                            80  CSRB  EQU DUART+18      * Clock Select Register B   (W)
Line 81 ERROR: Undefined symbol
00000000                            81  CRB   EQU DUART+20      * Commands Register B       (W)
Line 82 ERROR: Undefined symbol
00000000                            82  RBB   EQU DUART+22      * Reciever Buffer B         (R)
Line 83 ERROR: Undefined symbol
00000000                            83  TBB   EQU DUART+22      * Transmitter Buffer B      (W)
Line 84 ERROR: Undefined symbol
00000000                            84  IVR   EQU DUART+24      * Interrupt Vector Register (R/W)
Line 85 ERROR: Undefined symbol
00000000                            85  OPC   EQU DUART+26      * Output port config        (W)
Line 86 ERROR: Undefined symbol
00000000                            86  INU   EQU DUART+26      * Input port (unlatched)    (R)
Line 87 ERROR: Undefined symbol
00000000                            87  OPS   EQU DUART+28      * Output port Set           (W)
Line 88 ERROR: Undefined symbol
00000000                            88  OPR   EQU DUART+30      * Output port Clear         (W)
00000000                            89  
00000000                            90  *************************************************************************************
00000000                            91  
00000000                            92  
00000000                            93      INCLUDE "basic68k.inc"
00000000                            94  
00000000                            95  
00000000                            96          ORG     0           * start of RAM
00000000                            97   
00000000                            98  ram_strt    ds.l    $100            * allow 1K for the stack, this should be plenty
00000400                            99                          * for any BASIC program that doesn't do something
00000400                           100                          * silly, it could even be much less.
00000400                           101  ram_base
00000400                           102  LAB_WARM    ds.w    1           * BASIC warm start entry point
00000402                           103  Wrmjpv  ds.l    1           * BASIC warm start jump vector
00000406                           104  
00000406                           105  Usrjmp  ds.w    1           * USR function JMP address
00000408                           106  Usrjpv  ds.l    1           * USR function JMP vector
0000040C                           107  
0000040C                           108  
0000040C                           109  V_INPT  ds.w    1           * non halting scan input device entry point
0000040E                           110  V_INPTv ds.l    1           * non halting scan input device jump vector
00000412                           111  
00000412                           112  V_OUTP  ds.w    1           * send byte to output device entry point
00000414                           113  V_OUTPv ds.l    1           * send byte to output device jump vector
00000418                           114  
00000418                           115  V_LOAD  ds.w    1           * load BASIC program entry point
0000041A                           116  V_LOADv ds.l    1           * load BASIC program jump vector
0000041E                           117  
0000041E                           118  V_SAVE  ds.w    1           * save BASIC program entry point
00000420                           119  V_SAVEv ds.l    1           * save BASIC program jump vector
00000424                           120  
00000424                           121  V_CTLC  ds.w    1           * save CTRL-C check entry point
00000426                           122  V_CTLCv ds.l    1           * save CTRL-C check jump vector
0000042A                           123  
0000042A                           124  Itemp       ds.l    1           * temporary integer (for GOTO etc)
0000042E                           125  
0000042E                           126  Smeml       ds.l    1           * start of memory       (start of program)
00000432                           127  
00000432                           128  
00000432                           129  Sfncl       ds.l    1           * start of functions    (end of Program)
00000436                           130  
00000436                           131  
00000436                           132  Svarl       ds.l    1           * start of variables    (end of functions)
0000043A                           133  
0000043A                           134  
0000043A                           135  Sstrl       ds.l    1           * start of strings  (end of variables)
0000043E                           136  
0000043E                           137  
0000043E                           138  Sarryl  ds.l    1           * start of arrays       (end of strings)
00000442                           139  
00000442                           140  
00000442                           141  Earryl  ds.l    1           * end of arrays     (start of free mem)
00000446                           142  Sstorl  ds.l    1           * string storage        (moving down)
0000044A                           143  Ememl       ds.l    1           * end of memory     (upper bound of RAM)
0000044E                           144  Sutill  ds.l    1           * string utility ptr
00000452                           145  Clinel  ds.l    1           * current line      (Basic line number)
00000456                           146  Blinel  ds.l    1           * break line        (Basic line number)
0000045A                           147  
0000045A                           148  Cpntrl  ds.l    1           * continue pointer
0000045E                           149  Dlinel  ds.l    1           * current DATA line
00000462                           150  Dptrl       ds.l    1           * DATA pointer
00000466                           151  Rdptrl  ds.l    1           * read pointer
0000046A                           152  Varname ds.l    1           * current var name
0000046E                           153  Cvaral  ds.l    1           * current var address
00000472                           154  Lvarpl  ds.l    1           * variable pointer for LET and FOR/NEXT
00000476                           155  
00000476                           156  des_sk_e    ds.l    6           * descriptor stack end address
0000048E                           157  des_sk                  * descriptor stack start address
0000048E                           158                          * use a4 for the descriptor pointer
0000048E                           159          ds.w    1           
00000490                           160  Ibuffs  ds.l    $40         * start of input buffer
00000590                           161  Ibuffe
00000590                           162                          * end of input buffer
00000590                           163  
00000590                           164  FAC1_m  ds.l    1           * FAC1 mantissa1
00000594                           165  FAC1_e  ds.w    1           * FAC1 exponent
00000596  =00000595                166  FAC1_s  EQU FAC1_e+1        * FAC1 sign (b7)
00000596                           167          ds.w    1           
00000598                           168  
00000598                           169  FAC2_m  ds.l    1           * FAC2 mantissa1
0000059C                           170  FAC2_e  ds.l    1           * FAC2 exponent
000005A0  =0000059D                171  FAC2_s  EQU FAC2_e+1        * FAC2 sign (b7)
000005A0  =0000059E                172  FAC_sc  EQU FAC2_e+2        * FAC sign comparison, Acc#1 vs #2
000005A0  =0000059F                173  flag        EQU FAC2_e+3        * flag byte for divide routine
000005A0                           174  
000005A0                           175  PRNlword    ds.l    1           * PRNG seed long word
000005A4                           176  
000005A4                           177  ut1_pl  ds.l    1           * utility pointer 1
000005A8                           178  
000005A8                           179  Asptl       ds.l    1           * array size/pointer
000005AC                           180  Astrtl  ds.l    1           * array start pointer
000005B0                           181  
000005B0  =000005AC                182  numexp  EQU Astrtl      * string to float number exponent count
000005B0  =000005AD                183  expcnt  EQU Astrtl+1        * string to float exponent count
000005B0                           184  
000005B0  =000005AF                185  expneg  EQU Astrtl+3        * string to float eval exponent -ve flag
000005B0                           186  
000005B0                           187  func_l  ds.l    1           * function pointer
000005B4                           188  
000005B4                           189  
000005B4                           190                          * these two need to be a word aligned pair !
000005B4                           191  Defdim  ds.w    1           * default DIM flag
000005B6  =000005B4                192  cosout  EQU Defdim      * flag which CORDIC output (re-use byte)
000005B6  =000005B5                193  Dtypef  EQU Defdim+1        * data type flag, $80=string, $40=integer, $00=float
000005B6                           194  
000005B6                           195  
000005B6                           196  Binss       ds.l    4           * number to bin string start (32 chrs)
000005C6                           197  
000005C6                           198  Decss       ds.l    1           * number to decimal string start (16 chrs)
000005CA                           199          ds.w    1           *
000005CC                           200  Usdss       ds.w    1           * unsigned decimal string start (10 chrs)
000005CE                           201  
000005CE                           202  Hexss       ds.l    2           * number to hex string start (8 chrs)
000005D6                           203  
000005D6                           204  BHsend  ds.w    1           * bin/decimal/hex string end
000005D8                           205  
000005D8                           206  
000005D8                           207  prstk       ds.b    1           * stacked function index
000005D9                           208  
000005D9                           209  tpower  ds.b    1           * remember CORDIC power
000005DA                           210  
000005DA                           211  Asrch       ds.b    1           * scan-between-quotes flag, alt search character
000005DB                           212  
000005DB                           213  Dimcnt  ds.b    1           * # of dimensions
000005DC                           214  
000005DC                           215  Breakf  ds.b    1           * break flag, $00=END else=break
000005DD                           216  Oquote  ds.b    1           * open quote flag (Flag: DATA; LIST; memory)
000005DE                           217  Gclctd  ds.b    1           * garbage collected flag
000005DF                           218  Sufnxf  ds.b    1           * subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000005E0                           219  Imode       ds.b    1           * input mode flag, $00=INPUT, $98=READ
000005E1                           220  
000005E1                           221  Cflag       ds.b    1           * comparison evaluation flag
000005E2                           222  
000005E2                           223  TabSiz  ds.b    1           * TAB step size
000005E3                           224  
000005E3                           225  comp_f  ds.b    1           * compare function flag, bits 0,1 and 2 used
000005E4                           226                          * bit 2 set if >
000005E4                           227                          * bit 1 set if =
000005E4                           228                          * bit 0 set if <
000005E4                           229  
000005E4                           230  Nullct  ds.b    1           * nulls output after each line
000005E5                           231  TPos        ds.b    1           * BASIC terminal position byte
000005E6                           232  TWidth  ds.b    1           * BASIC terminal width byte
000005E7                           233  Iclim       ds.b    1           * input column limit
000005E8                           234  ccflag  ds.b    1           * CTRL-C check flag
000005E9                           235  ccbyte  ds.b    1           * CTRL-C last received byte
000005EA                           236  ccnull  ds.b    1           * CTRL-C last received byte 'life' timer
000005EB                           237  
000005EB                           238  
000005EB                           239  file_byte   ds.b    1           * load/save data byte
000005EC                           240  file_id ds.l    1           * load/save file ID
000005F0                           241  
Line 242 ERROR: Invalid opcode
000005F0                           242          even                    * dummy even value and zero pad byte
000005F0                           243  
000005F0                           244  prg_strt
000005F0                           245  
000005F0  =00002000                246  ram_addr    EQU $02000      * RAM start address
000005F0  =0007E000                247  ram_size    EQU $7E000      * RAM size
000005F0                           248  
000005F0                           249  -------------------- end include --------------------
000005F0                           250                              * RAM offset definitions
000005F0                           251  
000005F0                           252  * Use this value to run out of ROM
00080800                           253      ORG     $080800         * past the vectors in a real system
00080800                           254  * Use this value to run out of RAM
00080800                           255  *   ORG     $000800         * past the vectors in a real system
00080800                           256  
Line 257 ERROR: Invalid opcode
00080800                           257  ACIA_1   =      $000F0000        * Console DUART base address
00080800                           258  
00080800  6000 0058                259           BRA    code_start       * For convenience, so you can start from first address
00080804                           260  
00080804                           261  *************************************************************************************
00080804                           262  *
00080804                           263  * the following code is simulator specific, change to suit your system
00080804                           264  
00080804                           265  * output character to the console from register d0.b
00080804                           266  
00080804                           267  VEC_OUT
00080804  48E7 4080                268          MOVEM.L  A0/D1,-(A7)    * Save working registers
Line 269 ERROR: Undefined symbol
00080808  41F9 004DBD16            269          LEA.L    SRA,A0         * A0 points to console DUART
0008080E                           270  TXNOTREADY
0008080E  1210                     271          MOVE.B   (A0),D1        * Read DUART status
00080810  0801 0002                272          BTST     #2,D1          * Test Tx RDY bit
00080814  67F8                     273          BEQ.S    TXNOTREADY     * Until DUART Tx ready
Line 274 ERROR: Undefined symbol
00080816  13C0 005455CC            274          MOVE.B   D0,TBA         * Write character to send
0008081C  4CDF 0102                275          MOVEM.L  (A7)+,A0/D1    * Restore working registers
00080820  4E75                     276          RTS
00080822                           277  
00080822                           278  *************************************************************************************
00080822                           279  *
00080822                           280  * input a character from the console into register d0
00080822                           281  * else return Cb=0 if there's no character available
00080822                           282  
00080822                           283  VEC_IN
00080822  48E7 4080                284      MOVEM.L  A0/D1,-(A7)    * Save working registers
Line 285 ERROR: Undefined symbol
00080826  41F9 004DBD16            285      LEA.L    SRA,A0         * A0 points to console DUART
0008082C  1210                     286      MOVE.B   (A0),D1        * Read DUART status
0008082E  0801 0000                287      BTST     #0,D1          * Test Rx Data Ready bit
00080832  6710                     288      BEQ.S    RXNOTREADY     * Branch If DUART Rx not ready
Line 289 ERROR: Undefined symbol
00080834  1039 004DBD16            289      MOVE.B   RBA,D0         * Read character received
0008083A  4CDF 0102                290      MOVEM.L  (A7)+,A0/D1    * Restore working registers
0008083E  003C 0001                291      ORI.b    #1,CCR         * Set the carry, flag we got a byte
00080842  4E75                     292      RTS                     * Return
00080844                           293  RXNOTREADY:
00080844  4CDF 0102                294      MOVEM.L  (A7)+,A0/D1    * Restore working registers
00080848  023C 00FE                295      ANDI.b  #$FE,CCR        * Clear the carry, flag character available
0008084C  4E75                     296      RTS
0008084E                           297  
0008084E                           298  *************************************************************************************
0008084E                           299  *
0008084E                           300  * LOAD routine for the TS2 computer (not implemented)
0008084E                           301  
0008084E                           302  VEC_LD
0008084E  7E2E                     303      MOVEQ       #$2E,d7                 * error code $2E "Not implemented" error
00080850  6000 01B8                304      BRA     LAB_XERR            * do error #d7, then warm start
00080854                           305  
00080854                           306  *************************************************************************************
00080854                           307  *
00080854                           308  * SAVE routine for the TS2 computer (not implemented)
00080854                           309  
00080854                           310  VEC_SV
00080854  7E2E                     311      MOVEQ   #$2E,d7         * error code $2E "Not implemented" error
00080856  6000 01B2                312      BRA     LAB_XERR        * do error #d7, then warm start
0008085A                           313  
0008085A                           314  *************************************************************************************
0008085A                           315  *
0008085A                           316  * turn off simulator key echo
0008085A                           317  
0008085A                           318  code_start
0008085A                           319                                  * Set up ACIA parameters
Line 320 ERROR: Undefined symbol
0008085A  13FC 0030 005455C4       320      move.b  #$30, CRA       | Reset Transmitter
Line 321 ERROR: Undefined symbol
00080862  13FC 0020 005455C4       321      move.b  #$20, CRA       | Reset Receiver
Line 322 ERROR: Undefined symbol
0008086A  13FC 0010 005455CC       322      move.b  #$10, CRA       | Reset Mode Register Pointer
00080872                           323      
Line 324 ERROR: Undefined symbol
00080872  13FC 0080 005455CC       324      move.b  #$80, ACR       | Baud Rate Set #2
Line 325 ERROR: Undefined symbol
0008087A  13FC 00BB 005455D8       325      move.b  #$BB, CSRA      | Set Tx and Rx rates to 9600
Line 326 ERROR: Undefined symbol
00080882  13FC 0093 005455CC       326      move.b  #$93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
Line 327 ERROR: Undefined symbol
0008088A  13FC 0007 005455D8       327      move.b  #$07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
00080892                           328      
Line 329 ERROR: Undefined symbol
00080892  13FC 0005 005455C4       329      move.b  #$05, CRA       | Enable Transmit/Recieve
0008089A                           330  
Line 331 ERROR: Undefined symbol
0008089A  13FC 0030 005455C4       331      move.b  #$30, CRB       | Reset Transmitter
Line 332 ERROR: Undefined symbol
000808A2  13FC 0020 005455C4       332      move.b  #$20, CRB       | Reset Receiver
Line 333 ERROR: Undefined symbol
000808AA  13FC 0010 005455CC       333      move.b  #$10, CRB       | Reset Mode Register Pointer
000808B2                           334      
Line 335 ERROR: Undefined symbol
000808B2  13FC 00BB 005455D8       335      move.b  #$BB, CSRB      | Set Tx and Rx rates to 9600
Line 336 ERROR: Undefined symbol
000808BA  13FC 0093 005455CC       336      move.b  #$93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
Line 337 ERROR: Undefined symbol
000808C2  13FC 0007 005455D8       337      move.b  #$07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
000808CA                           338      
Line 339 ERROR: Undefined symbol
000808CA  13FC 0005 005455C4       339      move.b  #$05, CRB       | Enable Transmit/Recieve
000808D2                           340      
Line 341 ERROR: Undefined symbol
000808D2  13FC 0000 005455CC       341      move.b  #$00, OPC        | Output port configuration (all bit are outs)
Line 342 ERROR: Undefined symbol
000808DA  13FC 00FC 005455C8       342      move.b  #$FC, OPR        | Clear all outputs
000808E2                           343  
000808E2                           344  * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
000808E2                           345  * in d0. these values are at the end of the .inc file
000808E2                           346  
000808E2  207C 00002000            347      MOVEA.l #ram_addr,a0        * tell BASIC where RAM starts
000808E8  203C 0007E000            348      MOVE.l  #ram_size,d0        * tell BASIC how big RAM is
000808EE                           349  
000808EE                           350  * end of simulator specific code
000808EE                           351  
000808EE                           352  
000808EE                           353  ****************************************************************************************
000808EE                           354  ****************************************************************************************
000808EE                           355  ****************************************************************************************
000808EE                           356  ****************************************************************************************
000808EE                           357  *
000808EE                           358  * Register use :- (must improve this !!)
000808EE                           359  *
000808EE                           360  *   a6 -    temp Bpntr              * temporary BASIC execute pointer
000808EE                           361  *   a5 -    Bpntr                   * BASIC execute (get byte) pointer
000808EE                           362  *   a4 -    des_sk                      * descriptor stack pointer
000808EE                           363  *   a3 -    ram_strt                * start of RAM. all RAM references are offsets
000808EE                           364  *                           * from this value
000808EE                           365  *
000808EE                           366  
000808EE                           367  *************************************************************************************
000808EE                           368  *
000808EE                           369  * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
000808EE                           370  * in d0
000808EE                           371  
000808EE                           372  LAB_COLD
000808EE  B0BC 00004000            373      CMP.l       #$4000,d0           * compare size with 16k
000808F4  6C08                     374      BGE.s       LAB_sizok           * branch if >= 16k
000808F6                           375  
000808F6  7005                     376      MOVEQ       #5,d0               * error 5 - not enough RAM
000808F8  1E3C 00E4                377          move.b          #228,D7                         * Go to TUTOR function
000808FC  4E4E                     378          trap            #14                             * Call TRAP14 handler
000808FE                           379  
000808FE                           380  LAB_sizok
000808FE  2648                     381      MOVEA.l a0,a3               * copy RAM base to a3
00080900  D1C0                     382      ADDA.l  d0,a0               * a0 is top of RAM
00080902  2748 044A                383      MOVE.l  a0,Ememl(a3)        * set end of mem
00080906  4FEB 0400                384      LEA     ram_base(a3),sp     * set stack to RAM start + 1k
0008090A                           385  
0008090A  303C 4EF9                386      MOVE.w  #$4EF9,d0           * JMP opcode
0008090E  204F                     387      MOVEA.l sp,a0               * point to start of vector table
00080910                           388  
00080910  30C0                     389      MOVE.w  d0,(a0)+            * LAB_WARM
00080912  43FA FFDA                390      LEA     LAB_COLD(pc),a1     * initial warm start vector
00080916  20C9                     391      MOVE.l  a1,(a0)+            * set vector
00080918                           392  
00080918  30C0                     393      MOVE.w  d0,(a0)+            * Usrjmp
0008091A  43FA 00DC                394      LEA     LAB_FCER(pc),a1     * initial user function vector
0008091E                           395                              * "Function call" error
0008091E  20C9                     396      MOVE.l  a1,(a0)+            * set vector
00080920                           397  
00080920  30C0                     398      MOVE.w  d0,(a0)+            * V_INPT JMP opcode
00080922  43FA FEFE                399      LEA     VEC_IN(pc),a1       * get byte from input device vector
00080926  20C9                     400      MOVE.l  a1,(a0)+            * set vector
00080928                           401  
00080928  30C0                     402      MOVE.w  d0,(a0)+            * V_OUTP JMP opcode
0008092A  43FA FED8                403      LEA     VEC_OUT(pc),a1      * send byte to output device vector
0008092E  20C9                     404      MOVE.l  a1,(a0)+            * set vector
00080930                           405  
00080930  30C0                     406      MOVE.w  d0,(a0)+            * V_LOAD JMP opcode
00080932  43FA FF1A                407      LEA     VEC_LD(pc),a1       * load BASIC program vector
00080936  20C9                     408      MOVE.l  a1,(a0)+            * set vector
00080938                           409  
00080938  30C0                     410      MOVE.w  d0,(a0)+            * V_SAVE JMP opcode
0008093A  43FA FF18                411      LEA     VEC_SV(pc),a1       * save BASIC program vector
0008093E  20C9                     412      MOVE.l  a1,(a0)+            * set vector
00080940                           413  
00080940  30C0                     414      MOVE.w  d0,(a0)+            * V_CTLC JMP opcode
00080942  43FA 261E                415      LEA     VEC_CC(pc),a1       * save CTRL-C check vector
00080946  20C9                     416      MOVE.l  a1,(a0)+            * set vector
00080948                           417  
00080948                           418  * set-up start values
00080948                           419  
00080948                           420  *##LAB_GMEM
00080948  7000                     421      MOVEQ       #$00,d0         * clear d0
0008094A  1740 05E4                422      MOVE.b  d0,Nullct(a3)       * default NULL count
0008094E  1740 05E5                423      MOVE.b  d0,TPos(a3)         * clear terminal position
00080952  1740 05E8                424      MOVE.b  d0,ccflag(a3)       * allow CTRL-C check
00080956  3740 05EE                425      MOVE.w  d0,prg_strt-2(a3)       * clear start word
0008095A  3740 05D6                426      MOVE.w  d0,BHsend(a3)       * clear value to string end word
0008095E                           427  
0008095E  177C 0050 05E6           428      MOVE.b  #$50,TWidth(a3)     * default terminal width byte for simulator
00080964  177C 000E 05E2           429      MOVE.b  #$0E,TabSiz(a3)     * save default tab size = 14
0008096A                           430  
0008096A  177C 0038 05E7           431      MOVE.b  #$38,Iclim(a3)      * default limit for TAB = 14 for simulator
00080970                           432  
00080970  49EB 048E                433      LEA     des_sk(a3),a4       * set descriptor stack start
00080974                           434  
00080974  41EB 05F0                435      LEA     prg_strt(a3),a0     * get start of mem
00080978  2748 042E                436      MOVE.l  a0,Smeml(a3)        * save start of mem
0008097C                           437  
0008097C  6100 0322                438      BSR     LAB_1463            * do "NEW" and "CLEAR"
00080980  6100 0898                439      BSR     LAB_CRLF            * print CR/LF
00080984  202B 044A                440      MOVE.l  Ememl(a3),d0        * get end of mem
00080988  90AB 042E                441      SUB.l       Smeml(a3),d0        * subtract start of mem
0008098C                           442  
0008098C  6100 1BCC                443      BSR     LAB_295E            * print d0 as unsigned integer (bytes free)
00080990  41FA 33EE                444      LEA     LAB_SMSG(pc),a0     * point to start message
00080994  6100 08E2                445      BSR     LAB_18C3            * print null terminated string from memory
00080998                           446  
00080998  41FA 29D2                447      LEA     LAB_RSED(pc),a0     * get pointer to value
0008099C  6100 1A68                448      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
000809A0                           449  
000809A0  41FA 0092                450      LEA     LAB_1274(pc),a0     * get warm start vector
000809A4  2748 0402                451      MOVE.l  a0,Wrmjpv(a3)       * set warm start vector
000809A8  6100 1FD2                452      BSR     LAB_RND         * initialise
000809AC  4EEB 0400                453      JMP     LAB_WARM(a3)        * go do warm start
000809B0                           454  
000809B0                           455  
000809B0                           456  *************************************************************************************
000809B0                           457  *
000809B0                           458  * do format error
000809B0                           459  
000809B0                           460  LAB_FOER
000809B0  7E2C                     461      MOVEQ       #$2C,d7         * error code $2C "Format" error
000809B2  6056                     462      BRA.s       LAB_XERR            * do error #d7, then warm start
000809B4                           463  
000809B4                           464  
000809B4                           465  *************************************************************************************
000809B4                           466  *
000809B4                           467  * do address error
000809B4                           468  
000809B4                           469  LAB_ADER
000809B4  7E2A                     470      MOVEQ       #$2A,d7         * error code $2A "Address" error
000809B6  6052                     471      BRA.s       LAB_XERR            * do error #d7, then warm start
000809B8                           472  
000809B8                           473  
000809B8                           474  *************************************************************************************
000809B8                           475  *
000809B8                           476  * do wrong dimensions error
000809B8                           477  
000809B8                           478  LAB_WDER
000809B8  7E28                     479      MOVEQ       #$28,d7         * error code $28 "Wrong dimensions" error
000809BA  604E                     480      BRA.s       LAB_XERR            * do error #d7, then warm start
000809BC                           481  
000809BC                           482  
000809BC                           483  *************************************************************************************
000809BC                           484  *
000809BC                           485  * do undimensioned array error
000809BC                           486  
000809BC                           487  LAB_UDER
000809BC  7E26                     488      MOVEQ       #$26,d7         * error code $26 "undimensioned array" error
000809BE  604A                     489      BRA.s       LAB_XERR            * do error #d7, then warm start
000809C0                           490  
000809C0                           491  
000809C0                           492  *************************************************************************************
000809C0                           493  *
000809C0                           494  * do undefined variable error
000809C0                           495  
000809C0                           496  LAB_UVER
000809C0                           497  
000809C0                           498  * if you do want a non existant variable to return an error then leave the novar
000809C0                           499  * value at the top of this file set to zero
000809C0                           500  
000809C0                 TRUE      501   ifeq   novar
000809C0                           502  
000809C0  7E24                     503      MOVEQ       #$24,d7         * error code $24 "undefined variable" error
000809C2  6046                     504      BRA.s       LAB_XERR            * do error #d7, then warm start
000809C4                           505  
000809C4                           506   endc
000809C4                           507  
000809C4                           508  * if you want a non existant variable to return a null value then set the novar
000809C4                           509  * value at the top of this file to some non zero value
000809C4                           510  
000809C4                 FALSE     511   ifne   novar
000809C4                           512   endc
000809C4                           513  
000809C4                           514  
000809C4                           515  *************************************************************************************
000809C4                           516  *
000809C4                           517  * do loop without do error
000809C4                           518  
000809C4                           519  LAB_LDER
000809C4  7E22                     520      MOVEQ       #$22,d7         * error code $22 "LOOP without DO" error
000809C6  6042                     521      BRA.s       LAB_XERR            * do error #d7, then warm start
000809C8                           522  
000809C8                           523  
000809C8                           524  *************************************************************************************
000809C8                           525  *
000809C8                           526  * do undefined function error
000809C8                           527  
000809C8                           528  LAB_UFER
000809C8  7E20                     529      MOVEQ       #$20,d7         * error code $20 "Undefined function" error
000809CA  603E                     530      BRA.s       LAB_XERR            * do error #d7, then warm start
000809CC                           531  
000809CC                           532  
000809CC                           533  *************************************************************************************
000809CC                           534  *
000809CC                           535  * do can't continue error
000809CC                           536  
000809CC                           537  LAB_CCER
000809CC  7E1E                     538      MOVEQ       #$1E,d7         * error code $1E "Can't continue" error
000809CE  603A                     539      BRA.s       LAB_XERR            * do error #d7, then warm start
000809D0                           540  
000809D0                           541  
000809D0                           542  *************************************************************************************
000809D0                           543  *
000809D0                           544  * do string too complex error
000809D0                           545  
000809D0                           546  LAB_SCER
000809D0  7E1C                     547      MOVEQ       #$1C,d7         * error code $1C "String too complex" error
000809D2  6036                     548      BRA.s       LAB_XERR            * do error #d7, then warm start
000809D4                           549  
000809D4                           550  
000809D4                           551  *************************************************************************************
000809D4                           552  *
000809D4                           553  * do string too long error
000809D4                           554  
000809D4                           555  LAB_SLER
000809D4  7E1A                     556      MOVEQ       #$1A,d7         * error code $1A "String too long" error
000809D6  6032                     557      BRA.s       LAB_XERR            * do error #d7, then warm start
000809D8                           558  
000809D8                           559  
000809D8                           560  *************************************************************************************
000809D8                           561  *
000809D8                           562  * do type missmatch error
000809D8                           563  
000809D8                           564  LAB_TMER
000809D8  7E18                     565      MOVEQ       #$18,d7         * error code $18 "Type mismatch" error
000809DA  602E                     566      BRA.s       LAB_XERR            * do error #d7, then warm start
000809DC                           567  
000809DC                           568  
000809DC                           569  *************************************************************************************
000809DC                           570  *
000809DC                           571  * do illegal direct error
000809DC                           572  
000809DC                           573  LAB_IDER
000809DC  7E16                     574      MOVEQ       #$16,d7         * error code $16 "Illegal direct" error
000809DE  602A                     575      BRA.s       LAB_XERR            * do error #d7, then warm start
000809E0                           576  
000809E0                           577  
000809E0                           578  *************************************************************************************
000809E0                           579  *
000809E0                           580  * do divide by zero error
000809E0                           581  
000809E0                           582  LAB_DZER
000809E0  7E14                     583      MOVEQ       #$14,d7         * error code $14 "Divide by zero" error
000809E2  6026                     584      BRA.s       LAB_XERR            * do error #d7, then warm start
000809E4                           585  
000809E4                           586  
000809E4                           587  *************************************************************************************
000809E4                           588  *
000809E4                           589  * do double dimension error
000809E4                           590  
000809E4                           591  LAB_DDER
000809E4  7E12                     592      MOVEQ       #$12,d7         * error code $12 "Double dimension" error
000809E6  6022                     593      BRA.s       LAB_XERR            * do error #d7, then warm start
000809E8                           594  
000809E8                           595  
000809E8                           596  *************************************************************************************
000809E8                           597  *
000809E8                           598  * do array bounds error
000809E8                           599  
000809E8                           600  LAB_ABER
000809E8  7E10                     601      MOVEQ       #$10,d7         * error code $10 "Array bounds" error
000809EA  601E                     602      BRA.s       LAB_XERR            * do error #d7, then warm start
000809EC                           603  
000809EC                           604  
000809EC                           605  *************************************************************************************
000809EC                           606  *
000809EC                           607  * do undefined satement error
000809EC                           608  
000809EC                           609  LAB_USER
000809EC  7E0E                     610      MOVEQ       #$0E,d7         * error code $0E "Undefined statement" error
000809EE  601A                     611      BRA.s       LAB_XERR            * do error #d7, then warm start
000809F0                           612  
000809F0                           613  
000809F0                           614  *************************************************************************************
000809F0                           615  *
000809F0                           616  * do out of memory error
000809F0                           617  
000809F0                           618  LAB_OMER
000809F0  7E0C                     619      MOVEQ       #$0C,d7         * error code $0C "Out of memory" error
000809F2  6016                     620      BRA.s       LAB_XERR            * do error #d7, then warm start
000809F4                           621  
000809F4                           622  
000809F4                           623  *************************************************************************************
000809F4                           624  *
000809F4                           625  * do overflow error
000809F4                           626  
000809F4                           627  LAB_OFER
000809F4  7E0A                     628      MOVEQ       #$0A,d7         * error code $0A "Overflow" error
000809F6  6012                     629      BRA.s       LAB_XERR            * do error #d7, then warm start
000809F8                           630  
000809F8                           631  
000809F8                           632  *************************************************************************************
000809F8                           633  *
000809F8                           634  * do function call error
000809F8                           635  
000809F8                           636  LAB_FCER
000809F8  7E08                     637      MOVEQ       #$08,d7         * error code $08 "Function call" error
000809FA  600E                     638      BRA.s       LAB_XERR            * do error #d7, then warm start
000809FC                           639  
000809FC                           640  
000809FC                           641  *************************************************************************************
000809FC                           642  *
000809FC                           643  * do out of data error
000809FC                           644  
000809FC                           645  LAB_ODER
000809FC  7E06                     646      MOVEQ       #$06,d7         * error code $06 "Out of DATA" error
000809FE  600A                     647      BRA.s       LAB_XERR            * do error #d7, then warm start
00080A00                           648  
00080A00                           649  
00080A00                           650  *************************************************************************************
00080A00                           651  *
00080A00                           652  * do return without gosub error
00080A00                           653  
00080A00                           654  LAB_RGER
00080A00  7E04                     655      MOVEQ       #$04,d7         * error code $04 "RETURN without GOSUB" error
00080A02  6006                     656      BRA.s       LAB_XERR            * do error #d7, then warm start
00080A04                           657  
00080A04                           658  
00080A04                           659  *************************************************************************************
00080A04                           660  *
00080A04                           661  * do syntax error
00080A04                           662  
00080A04                           663  LAB_SNER
00080A04  7E02                     664      MOVEQ       #$02,d7         * error code $02 "Syntax" error
00080A06  6002                     665      BRA.s       LAB_XERR            * do error #d7, then warm start
00080A08                           666  
00080A08                           667  
00080A08                           668  *************************************************************************************
00080A08                           669  *
00080A08                           670  * do next without for error
00080A08                           671  
00080A08                           672  LAB_NFER
00080A08  7E00                     673      MOVEQ       #$00,d7         * error code $00 "NEXT without FOR" error
00080A0A                           674  
00080A0A                           675  
00080A0A                           676  *************************************************************************************
00080A0A                           677  *
00080A0A                           678  * do error #d7, then warm start
00080A0A                           679  
00080A0A                           680  LAB_XERR
00080A0A  6100 02CA                681      BSR     LAB_1491            * flush stack & clear continue flag
00080A0E  6100 080A                682      BSR     LAB_CRLF            * print CR/LF
00080A12  43FA 2FE4                683      LEA     LAB_BAER(pc),a1     * start of error message pointer table
00080A16  3E31 7000                684      MOVE.w  (a1,d7.w),d7        * get error message offset
00080A1A  41F1 7000                685      LEA     (a1,d7.w),a0        * get error message address
00080A1E  6100 0858                686      BSR     LAB_18C3            * print null terminated string from memory
00080A22  41FA 331F                687      LEA     LAB_EMSG(pc),a0     * point to " Error" message
00080A26                           688  LAB_1269
00080A26  6100 0850                689      BSR     LAB_18C3            * print null terminated string from memory
00080A2A  202B 0452                690      MOVE.l  Clinel(a3),d0       * get current line
00080A2E  6B04                     691      BMI.s       LAB_1274            * go do warm start if -ve # (was immediate mode)
00080A30                           692  
00080A30                           693                              * else print line number
00080A30  6100 1B1C                694      BSR     LAB_2953            * print " in line [LINE #]"
00080A34                           695  
00080A34                           696  * BASIC warm start entry point, wait for Basic command
00080A34                           697  
00080A34                           698  LAB_1274
00080A34  41FA 3340                699      LEA     LAB_RMSG(pc),a0     * point to "Ready" message
00080A38  6100 083E                700      BSR     LAB_18C3            * go do print string
00080A3C                           701  
00080A3C                           702  * wait for Basic command - no "Ready"
00080A3C                           703  
00080A3C                           704  LAB_127D
00080A3C  72FF                     705      MOVEQ       #-1,d1          * set to -1
00080A3E  2741 0452                706      MOVE.l  d1,Clinel(a3)       * set current line #
00080A42  1741 05DC                707      MOVE.b  d1,Breakf(a3)       * set break flag
00080A46  4BEB 0490                708      LEA     Ibuffs(a3),a5       * set basic execute pointer ready for new line
00080A4A                           709  LAB_127E
00080A4A  6100 00EC                710      BSR     LAB_1357            * call for BASIC input
00080A4E  6100 0BF4                711      BSR     LAB_GBYT            * scan memory
00080A52  67F6                     712      BEQ.s       LAB_127E            * loop while null
00080A54                           713  
00080A54                           714  * got to interpret input line now ....
00080A54                           715  
00080A54  6508                     716      BCS.s       LAB_1295            * branch if numeric character, handle new
00080A56                           717                              * BASIC line
00080A56                           718  
00080A56                           719                              * no line number so do immediate mode, a5
00080A56                           720                              * points to the buffer start
00080A56  6100 0156                721      BSR     LAB_13A6            * crunch keywords into Basic tokens
00080A5A                           722                              * crunch from (a5), output to (a0)
00080A5A                           723                              * returns ..
00080A5A                           724                              * d2 is length, d1 trashed, d0 trashed,
00080A5A                           725                              * a1 trashed
00080A5A  6000 03C4                726      BRA     LAB_15F6            * go scan & interpret code
00080A5E                           727  
00080A5E                           728  
00080A5E                           729  *************************************************************************************
00080A5E                           730  *
00080A5E                           731  * handle a new BASIC line
00080A5E                           732  
00080A5E                           733  LAB_1295
00080A5E  6100 063A                734      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00080A62  6100 014A                735      BSR     LAB_13A6            * crunch keywords into Basic tokens
00080A66                           736                              * crunch from (a5), output to (a0)
00080A66                           737                              * returns .. d2 is length,
00080A66                           738                              * d1 trashed, d0 trashed, a1 trashed
00080A66  222B 042A                739      MOVE.l  Itemp(a3),d1        * get required line #
00080A6A  6100 0218                740      BSR     LAB_SSLN            * search BASIC for d1 line number
00080A6E                           741                              * returns pointer in a0
00080A6E  6532                     742      BCS.s       LAB_12E6            * branch if not found
00080A70                           743  
00080A70                           744                              * aroooogah! line # already exists! delete it
00080A70  2250                     745      MOVEA.l (a0),a1         * get start of block (next line pointer)
00080A72  202B 0432                746      MOVE.l  Sfncl(a3),d0        * get end of block (start of functions)
00080A76  9089                     747      SUB.l       a1,d0               * subtract start of block ( = bytes to move)
00080A78  E288                     748      LSR.l       #1,d0               * /2 (word move)
00080A7A  5380                     749      SUBQ.l  #1,d0               * adjust for DBF loop
00080A7C  4840                     750      SWAP        d0              * swap high word to low word
00080A7E  2448                     751      MOVEA.l a0,a2               * copy destination
00080A80                           752  LAB_12AE
00080A80  4840                     753      SWAP        d0              * swap high word to low word
00080A82                           754  LAB_12B0
00080A82  34D9                     755      MOVE.w  (a1)+,(a2)+         * copy word
00080A84  51C8 FFFC                756      DBF     d0,LAB_12B0         * decrement low count and loop until done
00080A88                           757  
00080A88  4840                     758      SWAP        d0              * swap high word to low word
00080A8A  51C8 FFF4                759      DBF     d0,LAB_12AE         * decrement high count and loop until done
00080A8E                           760  
00080A8E  274A 0432                761      MOVE.l  a2,Sfncl(a3)        * start of functions
00080A92  274A 0436                762      MOVE.l  a2,Svarl(a3)        * save start of variables
00080A96  274A 043A                763      MOVE.l  a2,Sstrl(a3)        * start of strings
00080A9A  274A 043E                764      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00080A9E  274A 0442                765      MOVE.l  a2,Earryl(a3)       * save end of arrays
00080AA2                           766  
00080AA2                           767                              * got new line in buffer and no existing same #
00080AA2                           768  LAB_12E6
00080AA2  102B 0490                769      MOVE.b  Ibuffs(a3),d0       * get byte from start of input buffer
00080AA6  6764                     770      BEQ.s       LAB_1325            * if null line go do line chaining
00080AA8                           771  
00080AA8                           772                              * got new line and it isn't empty line
00080AA8  226B 0432                773      MOVEA.l Sfncl(a3),a1        * get start of functions (end of block to move)
00080AAC  45F1 2008                774      LEA     8(a1,d2),a2         * copy it, add line length and add room for
00080AB0                           775                              * pointer and line number
00080AB0                           776  
00080AB0  274A 0432                777      MOVE.l  a2,Sfncl(a3)        * start of functions
00080AB4  274A 0436                778      MOVE.l  a2,Svarl(a3)        * save start of variables
00080AB8  274A 043A                779      MOVE.l  a2,Sstrl(a3)        * start of strings
00080ABC  274A 043E                780      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00080AC0  274A 0442                781      MOVE.l  a2,Earryl(a3)       * save end of arrays
00080AC4  276B 044A 0446           782      MOVE.l  Ememl(a3),Sstorl(a3)    * copy end of mem to start of strings, clear
00080ACA                           783                              * strings
00080ACA                           784  
00080ACA  2209                     785      MOVE.l  a1,d1               * copy end of block to move
00080ACC  9288                     786      SUB.l       a0,d1               * subtract start of block to move
00080ACE  E289                     787      LSR.l       #1,d1               * /2 (word copy)
00080AD0  5381                     788      SUBQ.l  #1,d1               * correct for loop end on -1
00080AD2  4841                     789      SWAP        d1              * swap high word to low word
00080AD4                           790  LAB_12FF
00080AD4  4841                     791      SWAP        d1              * swap high word to low word
00080AD6                           792  LAB_1301
00080AD6  3521                     793      MOVE.w  -(a1),-(a2)         * decrement pointers and copy word
00080AD8  51C9 FFFC                794      DBF     d1,LAB_1301         * decrement & loop
00080ADC                           795  
00080ADC  4841                     796      SWAP        d1              * swap high word to low word
00080ADE  51C9 FFF4                797      DBF     d1,LAB_12FF         * decrement high count and loop until done
00080AE2                           798  
00080AE2                           799  * space is opened up, now copy the crunched line from the input buffer into the space
00080AE2                           800  
00080AE2  43EB 0490                801      LEA     Ibuffs(a3),a1       * source is input buffer
00080AE6  2448                     802      MOVEA.l a0,a2               * copy destination
00080AE8  72FF                     803      MOVEQ       #-1,d1          * set to allow re-chaining
00080AEA  24C1                     804      MOVE.l  d1,(a2)+            * set next line pointer (allow re-chaining)
00080AEC  24EB 042A                805      MOVE.l  Itemp(a3),(a2)+     * save line number
00080AF0  E24A                     806      LSR.w       #1,d2               * /2 (word copy)
00080AF2  5342                     807      SUBQ.w  #1,d2               * correct for loop end on -1
00080AF4                           808  LAB_1303
00080AF4  34D9                     809      MOVE.w  (a1)+,(a2)+         * copy word
00080AF6  51CA FFFC                810      DBF     d2,LAB_1303         * decrement & loop
00080AFA                           811  
00080AFA  6010                     812      BRA.s       LAB_1325            * go test for end of prog
00080AFC                           813  
00080AFC                           814  * rebuild chaining of BASIC lines
00080AFC                           815  
00080AFC                           816  LAB_132E
00080AFC  5048                     817      ADDQ.w  #8,a0               * point to first code byte of line, there is
00080AFE                           818                              * always 1 byte + [EOL] as null entries are
00080AFE                           819                              * deleted
00080AFE                           820  LAB_1330
00080AFE  4A18                     821      TST.b       (a0)+               * test byte 
00080B00  66FC                     822      BNE.s       LAB_1330            * loop if not [EOL]
00080B02                           823  
00080B02                           824                              * was [EOL] so get next line start
00080B02  3208                     825      MOVE.w  a0,d1               * past pad byte(s)
00080B04  0241 0001                826      ANDI.w  #1,d1               * mask odd bit
00080B08  D0C1                     827      ADD.w       d1,a0               * add back to ensure even
00080B0A  2288                     828      MOVE.l  a0,(a1)         * save next line pointer to current line
00080B0C                           829  LAB_1325
00080B0C  2248                     830      MOVEA.l a0,a1               * copy pointer for this line
00080B0E  4A90                     831      TST.l       (a0)                * test pointer to next line
00080B10  66EA                     832      BNE.s       LAB_132E            * not end of program yet so we must
00080B12                           833                              * go and fix the pointers
00080B12                           834  
00080B12  6100 0198                835      BSR     LAB_1477            * reset execution to start, clear variables
00080B16                           836                              * and flush stack
00080B16  6000 FF24                837      BRA     LAB_127D            * now we just wait for Basic command, no "Ready"
00080B1A                           838  
00080B1A                           839  
00080B1A                           840  *************************************************************************************
00080B1A                           841  *
00080B1A                           842  * receive a line from the keyboard
00080B1A                           843                              * character $08 as delete key, BACKSPACE on
00080B1A                           844                              * standard keyboard
00080B1A                           845  LAB_134B
00080B1A  6100 0776                846      BSR     LAB_PRNA            * go print the character
00080B1E  7020                     847      MOVEQ       #' ',d0         * load [SPACE]
00080B20  6100 0770                848      BSR     LAB_PRNA            * go print
00080B24  7008                     849      MOVEQ       #$08,d0         * load [BACKSPACE]
00080B26  6100 076A                850      BSR     LAB_PRNA            * go print
00080B2A  5341                     851      SUBQ.w  #$01,d1         * decrement the buffer index (delete)
00080B2C  6010                     852      BRA.s       LAB_1359            * re-enter loop
00080B2E                           853  
00080B2E                           854  * print "? " and get BASIC input
00080B2E                           855  * return a0 pointing to the buffer start
00080B2E                           856  
00080B2E                           857  LAB_INLN
00080B2E  6100 0760                858      BSR     LAB_18E3            * print "?" character
00080B32  7020                     859      MOVEQ       #' ',d0         * load " "
00080B34  6100 075C                860      BSR     LAB_PRNA            * go print
00080B38                           861  
00080B38                           862  * call for BASIC input (main entry point)
00080B38                           863  * return a0 pointing to the buffer start
00080B38                           864  
00080B38                           865  LAB_1357
00080B38  7200                     866      MOVEQ       #$00,d1         * clear buffer index
00080B3A  41EB 0490                867      LEA     Ibuffs(a3),a0       * set buffer base pointer
00080B3E                           868  LAB_1359
00080B3E  4EAB 040C                869      JSR     V_INPT(a3)          * call scan input device
00080B42  64FA                     870      BCC.s       LAB_1359            * loop if no byte
00080B44                           871  
00080B44  67F8                     872      BEQ.s       LAB_1359            * loop if null byte
00080B46                           873  
00080B46  B03C 0007                874      CMP.b       #$07,d0         * compare with [BELL]
00080B4A  6718                     875      BEQ.s       LAB_1378            * branch if [BELL]
00080B4C                           876  
00080B4C  B03C 000D                877      CMP.b       #$0D,d0         * compare with [CR]
00080B50  6700 06C2                878      BEQ     LAB_1866            * do CR/LF exit if [CR]
00080B54                           879  
00080B54  4A41                     880      TST.w       d1              * set flags on buffer index
00080B56  6606                     881      BNE.s       LAB_1374            * branch if not empty
00080B58                           882  
00080B58                           883  * the next two lines ignore any non printing character and [SPACE] if the input buffer
00080B58                           884  * is empty
00080B58                           885  
00080B58  B03C 0020                886      CMP.b       #' ',d0         * compare with [SP]+1
00080B5C  63E0                     887      BLS.s       LAB_1359            * if < ignore character
00080B5E                           888  
00080B5E                           889  *## CMP.b       #' '+1,d0           * compare with [SP]+1
00080B5E                           890  *## BCS.s       LAB_1359            * if < ignore character
00080B5E                           891  
00080B5E                           892  LAB_1374
00080B5E  B03C 0008                893      CMP.b       #$08,d0         * compare with [BACKSPACE]
00080B62  67B6                     894      BEQ.s       LAB_134B            * go delete last character
00080B64                           895  
00080B64                           896  LAB_1378
00080B64  B27C 00FF                897      CMP.w       #(Ibuffe-Ibuffs-1),d1   * compare character count with max-1
00080B68  640C                     898      BCC.s       LAB_138E            * skip store & do [BELL] if buffer full
00080B6A                           899  
00080B6A  1180 1000                900      MOVE.b  d0,(a0,d1.w)        * else store in buffer
00080B6E  5241                     901      ADDQ.w  #$01,d1         * increment index
00080B70                           902  LAB_137F
00080B70  6100 0720                903      BSR     LAB_PRNA            * go print the character
00080B74  60C8                     904      BRA.s       LAB_1359            * always loop for next character
00080B76                           905  
00080B76                           906  * announce buffer full
00080B76                           907  
00080B76                           908  LAB_138E
00080B76  7007                     909      MOVEQ       #$07,d0         * [BELL] character into d0
00080B78  60F6                     910      BRA.s       LAB_137F            * go print the [BELL] but ignore input character
00080B7A                           911  
00080B7A                           912  
00080B7A                           913  *************************************************************************************
00080B7A                           914  *
00080B7A                           915  * copy a hex value without crunching
00080B7A                           916  
00080B7A                           917  LAB_1392
00080B7A  1180 2000                918      MOVE.b  d0,(a0,d2.w)        * save the byte to the output
00080B7E  5242                     919      ADDQ.w  #1,d2               * increment the buffer save index
00080B80                           920  
00080B80  5241                     921      ADDQ.w  #1,d1               * increment the buffer read index
00080B82  1035 1000                922      MOVE.b  (a5,d1.w),d0        * get a byte from the input buffer
00080B86  6700 0094                923      BEQ     LAB_13EC            * if [EOL] go save it without crunching
00080B8A                           924  
00080B8A  B03C 0020                925      CMP.b       #' ',d0         * compare the character with " "
00080B8E  67EA                     926      BEQ.s       LAB_1392            * if [SPACE] just go save it and get another
00080B90                           927  
00080B90  B03C 0030                928      CMP.b       #'0',d0         * compare the character with "0"
00080B94  654A                     929      BCS.s       LAB_13C6            * if < "0" quit the hex save loop
00080B96                           930  
00080B96  B03C 0039                931      CMP.b       #'9',d0         * compare with "9"
00080B9A  63DE                     932      BLS.s       LAB_1392            * if it is "0" to "9" save it and get another
00080B9C                           933  
00080B9C  7ADF                     934      MOVEQ       #-33,d5         * mask xx0x xxxx, ASCII upper case
00080B9E  CA00                     935      AND.b       d0,d5               * mask the character
00080BA0                           936  
00080BA0  BA3C 0041                937      CMP.b       #'A',d5         * compare with "A"
00080BA4  6540                     938      BCS.s       LAB_13CC            * if < "A" quit the hex save loop
00080BA6                           939  
00080BA6  BA3C 0046                940      CMP.b       #'F',d5         * compare with "F"
00080BAA  63CE                     941      BLS.s       LAB_1392            * if it is "A" to "F" save it and get another
00080BAC                           942  
00080BAC  6038                     943      BRA.s       LAB_13CC            * else continue crunching
00080BAE                           944  
00080BAE                           945  * crunch keywords into Basic tokens
00080BAE                           946  * crunch from (a5), output to (a0)
00080BAE                           947  * returns ..
00080BAE                           948  * d4 trashed
00080BAE                           949  * d3 trashed
00080BAE                           950  * d2 is length
00080BAE                           951  * d1 trashed
00080BAE                           952  * d0 trashed
00080BAE                           953  * a1 trashed
00080BAE                           954  
00080BAE                           955  * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
00080BAE                           956  * old list search
00080BAE                           957  
00080BAE                           958  LAB_13A6
00080BAE  7200                     959      MOVEQ       #0,d1               * clear the read index
00080BB0  2401                     960      MOVE.l  d1,d2               * clear the save index
00080BB2  1741 05DD                961      MOVE.b  d1,Oquote(a3)       * clear the open quote/DATA flag
00080BB6                           962  LAB_13AC
00080BB6  7000                     963      MOVEQ       #0,d0               * clear word
00080BB8  1035 1000                964      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00080BBC  675E                     965      BEQ.s       LAB_13EC            * if null save byte then continue crunching
00080BBE                           966  
00080BBE  B03C 005F                967      CMP.b       #'_',d0         * compare with "_"
00080BC2  6458                     968      BCC.s       LAB_13EC            * if >= "_" save byte then continue crunching
00080BC4                           969  
00080BC4  B03C 003C                970      CMP.b       #'<',d0         * compare with "<"
00080BC8  641C                     971      BCC.s       LAB_13CC            * if >= "<" go crunch
00080BCA                           972  
00080BCA  B03C 0030                973      CMP.b       #'0',d0         * compare with "0"
00080BCE  644C                     974      BCC.s       LAB_13EC            * if >= "0" save byte then continue crunching
00080BD0                           975  
00080BD0  1740 05DA                976      MOVE.b  d0,Asrch(a3)        * save buffer byte as search character
00080BD4  B03C 0022                977      CMP.b       #$22,d0         * is it quote character?
00080BD8  6776                     978      BEQ.s       LAB_1410            * branch if so (copy quoted string)
00080BDA                           979  
00080BDA  B03C 0024                980      CMP.b       #'$',d0         * is it the hex value character?
00080BDE  679A                     981      BEQ.s       LAB_1392            * if so go copy a hex value
00080BE0                           982  
00080BE0                           983  LAB_13C6
00080BE0  B03C 002A                984      CMP.b       #'*',d0         * compare with "*"
00080BE4  6536                     985      BCS.s       LAB_13EC            * if <= "*" save byte then continue crunching
00080BE6                           986  
00080BE6                           987                              * crunch rest
00080BE6                           988  LAB_13CC
00080BE6  082B 0006 05DD           989      BTST.b  #6,Oquote(a3)       * test open quote/DATA token flag
00080BEC  662E                     990      BNE.s       LAB_13EC            * branch if b6 of Oquote set (was DATA)
00080BEE                           991                              * go save byte then continue crunching
00080BEE                           992  
00080BEE  0400 002A                993      SUB.b       #$2A,d0         * normalise byte
00080BF2  D040                     994      ADD.w       d0,d0               * *2 makes word offset (high byte=$00)
00080BF4  43FA 2C04                995      LEA     TAB_CHRT(pc),a1     * get keyword offset table address
00080BF8  3031 0000                996      MOVE.w  (a1,d0.w),d0        * get offset into keyword table
00080BFC  6B6E                     997      BMI.s       LAB_141F            * branch if no keywords for character
00080BFE                           998  
00080BFE  43FA 2F90                999      LEA     TAB_STAR(pc),a1     * get keyword table address
00080C02  D2C0                    1000      ADDA.w  d0,a1               * add keyword offset
00080C04  76FF                    1001      MOVEQ       #-1,d3          * clear index
00080C06  3801                    1002      MOVE.w  d1,d4               * copy read index
00080C08                          1003  LAB_13D6
00080C08  5243                    1004      ADDQ.w  #1,d3               * increment table index
00080C0A  1031 3000               1005      MOVE.b  (a1,d3.w),d0        * get byte from table
00080C0E                          1006  LAB_13D8
00080C0E  6B0A                    1007      BMI.s       LAB_13EA            * branch if token, save token and continue
00080C10                          1008                              * crunching
00080C10                          1009  
00080C10  5244                    1010      ADDQ.w  #1,d4               * increment read index
00080C12  B035 4000               1011      CMP.b       (a5,d4.w),d0        * compare byte from input buffer
00080C16  67F0                    1012      BEQ.s       LAB_13D6            * loop if character match
00080C18                          1013  
00080C18  6040                    1014      BRA.s       LAB_1417            * branch if no match
00080C1A                          1015  
00080C1A                          1016  LAB_13EA
00080C1A  3204                    1017      MOVE.w  d4,d1               * update read index
00080C1C                          1018  LAB_13EC
00080C1C  1180 2000               1019      MOVE.b  d0,(a0,d2.w)        * save byte to output
00080C20  5242                    1020      ADDQ.w  #1,d2               * increment buffer save index
00080C22  5241                    1021      ADDQ.w  #1,d1               * increment buffer read index
00080C24  4A00                    1022      TST.b       d0              * set flags
00080C26  674A                    1023      BEQ.s       LAB_142A            * branch if was null [EOL]
00080C28                          1024  
00080C28                          1025                              * d0 holds token or byte here
00080C28  0400 003A               1026      SUB.b       #$3A,d0         * subtract ":"
00080C2C  6706                    1027      BEQ.s       LAB_13FF            * branch if it was ":" (is now $00)
00080C2E                          1028  
00080C2E                          1029                              * d0 now holds token-$3A
00080C2E  B03C 0049               1030      CMP.b       #(TK_DATA-$3A),d0       * compare with DATA token - $3A
00080C32  6604                    1031      BNE.s       LAB_1401            * branch if not DATA
00080C34                          1032  
00080C34                          1033                              * token was : or DATA
00080C34                          1034  LAB_13FF
00080C34  1740 05DD               1035      MOVE.b  d0,Oquote(a3)       * save token-$3A ($00 for ":", TK_DATA-$3A for
00080C38                          1036                              * DATA)
00080C38                          1037  LAB_1401
00080C38  0400 0055               1038      SUB.b       #(TK_REM-$3A),d0        * subtract REM token offset
00080C3C  6600 FF78               1039      BNE     LAB_13AC            * If wasn't REM then go crunch rest of line
00080C40                          1040  
00080C40  1740 05DA               1041      MOVE.b  d0,Asrch(a3)        * else was REM so set search for [EOL]
00080C44                          1042  
00080C44                          1043                              * loop for REM, "..." etc.
00080C44                          1044  LAB_1408
00080C44  1035 1000               1045      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00080C48  67D2                    1046      BEQ.s       LAB_13EC            * branch if null [EOL]
00080C4A                          1047  
00080C4A  B02B 05DA               1048      CMP.b       Asrch(a3),d0        * compare with stored character
00080C4E  67CC                    1049      BEQ.s       LAB_13EC            * branch if match (end quote, REM, :, or DATA)
00080C50                          1050  
00080C50                          1051                              * entry for copy string in quotes, don't crunch
00080C50                          1052  LAB_1410
00080C50  1180 2000               1053      MOVE.b  d0,(a0,d2.w)        * save byte to output
00080C54  5242                    1054      ADDQ.w  #1,d2               * increment buffer save index
00080C56  5241                    1055      ADDQ.w  #1,d1               * increment buffer read index
00080C58  60EA                    1056      BRA.s       LAB_1408            * loop
00080C5A                          1057  
00080C5A                          1058  * not found keyword this go so find the end of this word in the table
00080C5A                          1059  
00080C5A                          1060  LAB_1417
00080C5A  3801                    1061      MOVE.w  d1,d4               * reset read pointer
00080C5C                          1062  LAB_141B
00080C5C  5243                    1063      ADDQ.w  #1,d3               * increment keyword table pointer, flag
00080C5E                          1064                              * unchanged
00080C5E  1031 3000               1065      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00080C62  6AF8                    1066      BPL.s       LAB_141B            * if not end of keyword go do next byte
00080C64                          1067  
00080C64  5243                    1068      ADDQ.w  #1,d3               * increment keyword table pointer flag
00080C66                          1069                              * unchanged
00080C66  1031 3000               1070      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00080C6A  66A2                    1071      BNE.s       LAB_13D8            * go test next word if not zero byte (table end)
00080C6C                          1072  
00080C6C                          1073                              * reached end of table with no match
00080C6C                          1074  LAB_141F
00080C6C  1035 1000               1075      MOVE.b  (a5,d1.w),d0        * restore byte from input buffer
00080C70  60AA                    1076      BRA.s       LAB_13EC            * go save byte in output and continue crunching
00080C72                          1077  
00080C72                          1078                              * reached [EOL]
00080C72                          1079  LAB_142A
00080C72  7000                    1080      MOVEQ       #0,d0               * ensure longword clear
00080C74  0102                    1081      BTST        d0,d2               * test odd bit (fastest)
00080C76  6706                    1082      BEQ.s       LAB_142C            * branch if no bytes to fill
00080C78                          1083  
00080C78  1180 2000               1084      MOVE.b  d0,(a0,d2.w)        * clear next byte
00080C7C  5242                    1085      ADDQ.w  #1,d2               * increment buffer save index
00080C7E                          1086  LAB_142C
00080C7E  2180 2000               1087      MOVE.l  d0,(a0,d2.w)        * clear next line pointer, EOT in immediate mode
00080C82  4E75                    1088      RTS
00080C84                          1089  
00080C84                          1090  
00080C84                          1091  *************************************************************************************
00080C84                          1092  *
00080C84                          1093  * search Basic for d1 line number from start of mem
00080C84                          1094  
00080C84                          1095  LAB_SSLN
00080C84  206B 042E               1096      MOVEA.l Smeml(a3),a0        * get start of program mem
00080C88  6002                    1097      BRA.s       LAB_SCLN            * go search for required line from a0
00080C8A                          1098  
00080C8A                          1099  LAB_145F
00080C8A  2040                    1100      MOVEA.l d0,a0               * copy next line pointer
00080C8C                          1101  
00080C8C                          1102  * search Basic for d1 line number from a0
00080C8C                          1103  * returns Cb=0 if found
00080C8C                          1104  * returns a0 pointer to found or next higher (not found) line
00080C8C                          1105  
00080C8C                          1106  LAB_SCLN
00080C8C  2018                    1107      MOVE.l  (a0)+,d0            * get next line pointer and point to line #
00080C8E  6708                    1108      BEQ.s       LAB_145E            * is end marker so we're done, do 'no line' exit
00080C90                          1109  
00080C90  B290                    1110      CMP.l       (a0),d1         * compare this line # with required line #
00080C92  6EF6                    1111      BGT.s       LAB_145F            * loop if required # > this #
00080C94                          1112  
00080C94  5948                    1113      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00080C96  4E75                    1114      RTS
00080C98                          1115  
00080C98                          1116  LAB_145E
00080C98  5948                    1117      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00080C9A  5380                    1118      SUBQ.l  #1,d0               * make end program found = -1, set carry
00080C9C  4E75                    1119      RTS
00080C9E                          1120  
00080C9E                          1121  
00080C9E                          1122  *************************************************************************************
00080C9E                          1123  *
00080C9E                          1124  * perform NEW
00080C9E                          1125  
00080C9E                          1126  LAB_NEW
00080C9E  664C                    1127      BNE.s       RTS_005         * exit if not end of statement (do syntax error)
00080CA0                          1128  
00080CA0                          1129  LAB_1463
00080CA0  206B 042E               1130      MOVEA.l Smeml(a3),a0        * point to start of program memory
00080CA4  7000                    1131      MOVEQ       #0,d0               * clear longword
00080CA6  20C0                    1132      MOVE.l  d0,(a0)+            * clear first line, next line pointer
00080CA8  2748 0432               1133      MOVE.l  a0,Sfncl(a3)        * set start of functions
00080CAC                          1134  
00080CAC                          1135  * reset execution to start, clear variables and flush stack
00080CAC                          1136  
00080CAC                          1137  LAB_1477
00080CAC  2A6B 042E               1138      MOVEA.l Smeml(a3),a5        * reset BASIC execute pointer
00080CB0  534D                    1139      SUBQ.w  #1,a5               * -1 (as end of previous line)
00080CB2                          1140  
00080CB2                          1141  * "CLEAR" command gets here
00080CB2                          1142  
00080CB2                          1143  LAB_147A
00080CB2  276B 044A 0446          1144      MOVE.l  Ememl(a3),Sstorl(a3)    * save end of mem as bottom of string space
00080CB8  202B 0432               1145      MOVE.l  Sfncl(a3),d0        * get start of functions
00080CBC  2740 0436               1146      MOVE.l  d0,Svarl(a3)        * start of variables
00080CC0  2740 043A               1147      MOVE.l  d0,Sstrl(a3)        * start of strings
00080CC4  2740 043E               1148      MOVE.l  d0,Sarryl(a3)       * set start of arrays
00080CC8  2740 0442               1149      MOVE.l  d0,Earryl(a3)       * set end of arrays
00080CCC                          1150  LAB_1480
00080CCC  7000                    1151      MOVEQ       #0,d0               * set Zb
00080CCE  1740 05EA               1152      MOVE.b  d0,ccnull(a3)       * clear get byte countdown
00080CD2  6100 01CE               1153      BSR     LAB_RESTORE         * perform RESTORE command
00080CD6                          1154  
00080CD6                          1155  * flush stack & clear continue flag
00080CD6                          1156  
00080CD6                          1157  LAB_1491
00080CD6  49EB 048E               1158      LEA     des_sk(a3),a4       * reset descriptor stack pointer
00080CDA                          1159  
00080CDA  201F                    1160      MOVE.l  (sp)+,d0            * pull return address
00080CDC  4FEB 0400               1161      LEA     ram_base(a3),sp     * set stack to RAM start + 1k, flush stack
00080CE0  2F00                    1162      MOVE.l  d0,-(sp)            * restore return address
00080CE2                          1163  
00080CE2  7000                    1164      MOVEQ       #0,d0               * clear longword
00080CE4  2740 045A               1165      MOVE.l  d0,Cpntrl(a3)       * clear continue pointer
00080CE8  1740 05DF               1166      MOVE.b  d0,Sufnxf(a3)       * clear subscript/FNX flag
00080CEC                          1167  RTS_005
00080CEC  4E75                    1168      RTS
00080CEE                          1169  
00080CEE                          1170  
00080CEE                          1171  *************************************************************************************
00080CEE                          1172  *
00080CEE                          1173  * perform CLEAR
00080CEE                          1174  
00080CEE                          1175  LAB_CLEAR
00080CEE  67C2                    1176      BEQ.s       LAB_147A            * if no following byte go do "CLEAR"
00080CF0                          1177  
00080CF0  4E75                    1178      RTS                     * was following byte (go do syntax error)
00080CF2                          1179  
00080CF2                          1180  
00080CF2                          1181  *************************************************************************************
00080CF2                          1182  *
00080CF2                          1183  * perform LIST [n][-m]
00080CF2                          1184  
00080CF2                          1185  LAB_LIST
00080CF2  6512                    1186      BCS.s       LAB_14BD            * branch if next character numeric (LIST n...)
00080CF4                          1187  
00080CF4  72FF                    1188      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00080CF6  2741 042A               1189      MOVE.l  d1,Itemp(a3)        * save to Itemp
00080CFA                          1190  
00080CFA  7200                    1191      MOVEQ       #0,d1               * set start to $00000000
00080CFC  4A00                    1192      TST.b       d0              * test next byte
00080CFE  670A                    1193      BEQ.s       LAB_14C0            * branch if next character [NULL] (LIST)
00080D00                          1194  
00080D00  B03C 00B3               1195      CMP.b       #TK_MINUS,d0        * compare with token for -
00080D04  66E6                    1196      BNE.s       RTS_005         * exit if not - (LIST -m)
00080D06                          1197  
00080D06                          1198                              * LIST [[n]-[m]] this sets the n, if present,
00080D06                          1199                              * as the start and end
00080D06                          1200  LAB_14BD
00080D06  6100 0392               1201      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00080D0A                          1202  LAB_14C0
00080D0A  6100 FF78               1203      BSR     LAB_SSLN            * search BASIC for d1 line number
00080D0E                          1204                              * (pointer in a0)
00080D0E  6100 0934               1205      BSR     LAB_GBYT            * scan memory
00080D12  6716                    1206      BEQ.s       LAB_14D4            * branch if no more characters
00080D14                          1207  
00080D14                          1208                              * this bit checks the - is present
00080D14  B03C 00B3               1209      CMP.b       #TK_MINUS,d0        * compare with token for -
00080D18  66D2                    1210      BNE.s       RTS_005         * return if not "-" (will be Syntax error)
00080D1A                          1211  
00080D1A  72FF                    1212      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00080D1C  2741 042A               1213      MOVE.l  d1,Itemp(a3)        * save Itemp
00080D20                          1214  
00080D20                          1215                              * LIST [n]-[m] the - was there so see if
00080D20                          1216                              * there is an m to set as the end value
00080D20  6100 0920               1217      BSR     LAB_IGBY            * increment & scan memory
00080D24  6704                    1218      BEQ.s       LAB_14D4            * branch if was [NULL] (LIST n-)
00080D26                          1219  
00080D26  6100 0372               1220      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00080D2A                          1221  LAB_14D4
00080D2A  177C 0000 05DD          1222      MOVE.b  #$00,Oquote(a3)     * clear open quote flag
00080D30  6100 04E8               1223      BSR     LAB_CRLF            * print CR/LF
00080D34  2018                    1224      MOVE.l  (a0)+,d0            * get next line pointer
00080D36  67B4                    1225      BEQ.s       RTS_005         * if null all done so exit
00080D38                          1226  
00080D38  2240                    1227      MOVEA.l d0,a1               * copy next line pointer
00080D3A  6100 012C               1228      BSR     LAB_1629            * do CRTL-C check vector
00080D3E                          1229  
00080D3E  2018                    1230      MOVE.l  (a0)+,d0            * get this line #
00080D40  B0AB 042A               1231      CMP.l       Itemp(a3),d0        * compare end line # with this line #
00080D44  62A6                    1232      BHI.s       RTS_005         * if this line greater all done so exit
00080D46                          1233  
00080D46                          1234  LAB_14E2
00080D46  48E7 00C0               1235      MOVEM.l a0-a1,-(sp)         * save registers
00080D4A  6100 180E               1236      BSR     LAB_295E            * print d0 as unsigned integer
00080D4E  4CDF 0300               1237      MOVEM.l (sp)+,a0-a1         * restore registers
00080D52  7020                    1238      MOVEQ       #$20,d0         * space is the next character
00080D54                          1239  LAB_150C
00080D54  6100 053C               1240      BSR     LAB_PRNA            * go print the character
00080D58  B03C 0022               1241      CMP.b       #$22,d0         * was it " character
00080D5C  6606                    1242      BNE.s       LAB_1519            * branch if not
00080D5E                          1243  
00080D5E                          1244                              * we're either entering or leaving quotes
00080D5E  0A2B 00FF 05DD          1245      EOR.b       #$FF,Oquote(a3)     * toggle open quote flag
00080D64                          1246  LAB_1519
00080D64  1018                    1247      MOVE.b  (a0)+,d0            * get byte and increment pointer
00080D66  6608                    1248      BNE.s       LAB_152E            * branch if not [EOL] (go print)
00080D68                          1249  
00080D68                          1250                              * was [EOL]
00080D68  2049                    1251      MOVEA.l a1,a0               * copy next line pointer
00080D6A  2008                    1252      MOVE.l  a0,d0               * copy to set flags
00080D6C  66BC                    1253      BNE.s       LAB_14D4            * go do next line if not [EOT]
00080D6E                          1254  
00080D6E  4E75                    1255      RTS
00080D70                          1256  
00080D70                          1257  LAB_152E
00080D70  6AE2                    1258      BPL.s       LAB_150C            * just go print it if not token byte
00080D72                          1259  
00080D72                          1260                              * else it was a token byte so maybe uncrunch it
00080D72  4A2B 05DD               1261      TST.b       Oquote(a3)          * test the open quote flag
00080D76  6BDC                    1262      BMI.s       LAB_150C            * just go print character if open quote set
00080D78                          1263  
00080D78                          1264                              * else uncrunch BASIC token
00080D78  45FA 2AEA               1265      LEA     LAB_KEYT(pc),a2     * get keyword table address
00080D7C  727F                    1266      MOVEQ       #$7F,d1         * mask into d1
00080D7E  C200                    1267      AND.b       d0,d1               * copy and mask token
00080D80  E549                    1268      LSL.w       #2,d1               * *4
00080D82  45F2 1000               1269      LEA     (a2,d1.w),a2        * get keyword entry address
00080D86  101A                    1270      MOVE.b  (a2)+,d0            * get byte from keyword table
00080D88  6100 0508               1271      BSR     LAB_PRNA            * go print the first character
00080D8C  7200                    1272      MOVEQ       #0,d1               * clear d1
00080D8E  121A                    1273      MOVE.b  (a2)+,d1            * get remaining length byte from keyword table
00080D90  6BD2                    1274      BMI.s       LAB_1519            * if -ve done so go get next byte
00080D92                          1275  
00080D92  3012                    1276      MOVE.w  (a2),d0         * get offset to rest
00080D94  45FA 2DFA               1277      LEA     TAB_STAR(pc),a2     * get keyword table address
00080D98  45F2 0000               1278      LEA     (a2,d0.w),a2        * get address of rest
00080D9C                          1279  LAB_1540
00080D9C  101A                    1280      MOVE.b  (a2)+,d0            * get byte from keyword table
00080D9E  6100 04F2               1281      BSR     LAB_PRNA            * go print the character
00080DA2  51C9 FFF8               1282      DBF     d1,LAB_1540         * decrement and loop if more to do
00080DA6                          1283  
00080DA6  60BC                    1284      BRA.s       LAB_1519            * go get next byte
00080DA8                          1285  
00080DA8                          1286  
00080DA8                          1287  *************************************************************************************
00080DA8                          1288  *
00080DA8                          1289  * perform FOR
00080DA8                          1290  
00080DA8                          1291  LAB_FOR
00080DA8  6100 0390               1292      BSR     LAB_LET         * go do LET
00080DAC                          1293  
00080DAC  202B 0472               1294      MOVE.l  Lvarpl(a3),d0       * get the loop variable pointer
00080DB0  B0AB 043A               1295      CMP.l       Sstrl(a3),d0        * compare it with the end of vars memory
00080DB4  6C00 FC22               1296      BGE     LAB_TMER            * if greater go do type mismatch error
00080DB8                          1297  
00080DB8                          1298  * test for not less than the start of variables memory if needed
00080DB8                          1299  *
00080DB8                          1300  *   CMP.l       Svarl(a3),d0        * compare it with the start of variables memory
00080DB8                          1301  *   BLT     LAB_TMER            * if not variables memory do type mismatch error
00080DB8                          1302  
00080DB8                          1303  *   MOVEQ       #28,d0          * we need 28 bytes !
00080DB8                          1304  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00080DB8                          1305  
00080DB8  6100 0214               1306      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00080DBC                          1307                              * returns a0 as pointer to [:] or [EOL]
00080DBC  2E88                    1308      MOVE.l  a0,(sp)         * push onto stack (and dump the return address)
00080DBE  2F2B 0452               1309      MOVE.l  Clinel(a3),-(sp)        * push current line onto stack
00080DC2                          1310  
00080DC2  70AA                    1311      MOVEQ       #TK_TO-$100,d0      * set "TO" token
00080DC4  6100 0874               1312      BSR     LAB_SCCA            * scan for CHR$(d0) else syntax error/warm start
00080DC8  6100 0702               1313      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00080DCC  1F2B 05B5               1314      MOVE.b  Dtypef(a3),-(sp)        * push the FOR variable data type onto stack
00080DD0  6100 06F8               1315      BSR     LAB_EVNM            * evaluate expression and check is numeric else
00080DD4                          1316                              * do type mismatch
00080DD4                          1317  
00080DD4  2F2B 0590               1318      MOVE.l  FAC1_m(a3),-(sp)        * push TO value mantissa
00080DD8  3F2B 0594               1319      MOVE.w  FAC1_e(a3),-(sp)        * push TO value exponent and sign
00080DDC                          1320  
00080DDC  277C 80000000 0590      1321      MOVE.l  #$80000000,FAC1_m(a3)   * set default STEP size mantissa
00080DE4  377C 8100 0594          1322      MOVE.w  #$8100,FAC1_e(a3)       * set default STEP size exponent and sign
00080DEA                          1323  
00080DEA  6100 0858               1324      BSR     LAB_GBYT            * scan memory
00080DEE  B03C 00AF               1325      CMP.b       #TK_STEP,d0         * compare with STEP token
00080DF2  6608                    1326      BNE.s       LAB_15B3            * jump if not "STEP"
00080DF4                          1327  
00080DF4                          1328                              * was STEP token so ....
00080DF4  6100 084C               1329      BSR     LAB_IGBY            * increment & scan memory
00080DF8  6100 06D0               1330      BSR     LAB_EVNM            * evaluate expression & check is numeric
00080DFC                          1331                              * else do type mismatch
00080DFC                          1332  LAB_15B3
00080DFC  2F2B 0590               1333      MOVE.l  FAC1_m(a3),-(sp)        * push STEP value mantissa
00080E00  3F2B 0594               1334      MOVE.w  FAC1_e(a3),-(sp)        * push STEP value exponent and sign
00080E04                          1335  
00080E04  2F2B 0472               1336      MOVE.l  Lvarpl(a3),-(sp)        * push variable pointer for FOR/NEXT
00080E08  3F3C 0081               1337      MOVE.w  #TK_FOR,-(sp)       * push FOR token on stack
00080E0C                          1338  
00080E0C  6018                    1339      BRA.s       LAB_15C2            * go do interpreter inner loop
00080E0E                          1340  
00080E0E                          1341  LAB_15DC                        * have reached [EOL]+1
00080E0E  300D                    1342      MOVE.w  a5,d0               * copy BASIC execute pointer
00080E10  C07C 0001               1343      AND.w       #1,d0               * and make line start address even
00080E14  DAC0                    1344      ADD.w       d0,a5               * add to BASIC execute pointer
00080E16  201D                    1345      MOVE.l  (a5)+,d0            * get next line pointer
00080E18  6700 FC1A               1346      BEQ     LAB_1274            * if null go to immediate mode, no "BREAK"
00080E1C                          1347                              * message (was immediate or [EOT] marker)
00080E1C                          1348  
00080E1C  275D 0452               1349      MOVE.l  (a5)+,Clinel(a3)        * save (new) current line #
00080E20                          1350  LAB_15F6
00080E20  6100 0822               1351      BSR     LAB_GBYT            * get BASIC byte
00080E24  611A                    1352      BSR.s       LAB_15FF            * go interpret BASIC code from (a5)
00080E26                          1353  
00080E26                          1354  * interpreter inner loop (re)entry point
00080E26                          1355  
00080E26                          1356  LAB_15C2
00080E26  6140                    1357      BSR.s       LAB_1629            * do CRTL-C check vector
00080E28  4A2B 0452               1358      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00080E2C  6B04                    1359      BMI.s       LAB_15D1            * branch if immediate mode
00080E2E                          1360  
00080E2E  274D 045A               1361      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00080E32                          1362  LAB_15D1
00080E32  101D                    1363      MOVE.b  (a5)+,d0            * get this byte & increment pointer
00080E34  67D8                    1364      BEQ.s       LAB_15DC            * loop if [EOL]
00080E36                          1365  
00080E36  B03C 003A               1366      CMP.b       #$3A,d0         * compare with ":"
00080E3A  67E4                    1367      BEQ.s       LAB_15F6            * loop if was statement separator
00080E3C                          1368  
00080E3C  6000 FBC6               1369      BRA     LAB_SNER            * else syntax error, then warm start
00080E40                          1370  
00080E40                          1371  
00080E40                          1372  *************************************************************************************
00080E40                          1373  *
00080E40                          1374  * interpret BASIC code from (a5)
00080E40                          1375  
00080E40                          1376  LAB_15FF
00080E40  6700 008C               1377      BEQ     RTS_006         * exit if zero [EOL]
00080E44                          1378  
00080E44                          1379  LAB_1602
00080E44  0A00 0080               1380      EORI.b  #$80,d0         * normalise token
00080E48  6B00 02F0               1381      BMI     LAB_LET         * if not token, go do implied LET
00080E4C                          1382  
00080E4C  B03C 0028               1383      CMP.b       #(TK_TAB-$80),d0        * compare normalised token with TAB
00080E50  6400 FBB2               1384      BCC     LAB_SNER            * branch if d0>=TAB, syntax error/warm start
00080E54                          1385                              * only tokens before TAB can start a statement
00080E54                          1386  
00080E54  4880                    1387      EXT.w       d0              * byte to word (clear high byte)
00080E56  D040                    1388      ADD.w       d0,d0               * *2
00080E58  41FA 2868               1389      LEA     LAB_CTBL(pc),a0     * get vector table base address
00080E5C  3030 0000               1390      MOVE.w  (a0,d0.w),d0        * get offset to vector
00080E60  4870 0000               1391      PEA     (a0,d0.w)           * push vector
00080E64  6000 07DC               1392      BRA     LAB_IGBY            * get following byte & execute vector
00080E68                          1393  
00080E68                          1394  
00080E68                          1395  *************************************************************************************
00080E68                          1396  *
00080E68                          1397  * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00080E68                          1398  * key press is detected.
00080E68                          1399  
00080E68                          1400  LAB_1629
00080E68  4EEB 0424               1401      JMP     V_CTLC(a3)          * ctrl c check vector
00080E6C                          1402  
00080E6C                          1403  * if there was a key press it gets back here .....
00080E6C                          1404  
00080E6C                          1405  LAB_1636
00080E6C  B03C 0003               1406      CMP.b       #$03,d0         * compare with CTRL-C
00080E70  670C                    1407      BEQ.s       LAB_163B            * STOP if was CTRL-C
00080E72                          1408  
00080E72                          1409  LAB_1639
00080E72  4E75                    1410      RTS                     *
00080E74                          1411  
00080E74                          1412  
00080E74                          1413  *************************************************************************************
00080E74                          1414  *
00080E74                          1415  * perform END
00080E74                          1416  
00080E74                          1417  LAB_END
00080E74  66FC                    1418      BNE.s       LAB_1639            * exit if something follows STOP
00080E76  177C 0000 05DC          1419      MOVE.b  #0,Breakf(a3)       * clear break flag, indicate program end
00080E7C                          1420  
00080E7C                          1421  
00080E7C                          1422  *************************************************************************************
00080E7C                          1423  *
00080E7C                          1424  * perform STOP
00080E7C                          1425  
00080E7C                          1426  LAB_STOP
00080E7C  66F4                    1427      BNE.s       LAB_1639            * exit if something follows STOP
00080E7E                          1428  
00080E7E                          1429  LAB_163B
00080E7E  43EB 0590               1430      LEA     Ibuffe(a3),a1       * get buffer end
00080E82  BBC9                    1431      CMPA.l  a1,a5               * compare execute address with buffer end
00080E84  650A                    1432      BCS.s       LAB_164F            * branch if BASIC pointer is in buffer
00080E86                          1433                              * can't continue in immediate mode
00080E86                          1434  
00080E86                          1435                              * else...
00080E86  274D 045A               1436      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00080E8A                          1437  LAB_1647
00080E8A  276B 0452 0456          1438      MOVE.l  Clinel(a3),Blinel(a3)   * save break line
00080E90                          1439  LAB_164F
00080E90  584F                    1440      ADDQ.w  #4,sp               * dump return address, don't return to execute
00080E92                          1441                              * loop
00080E92  102B 05DC               1442      MOVE.b  Breakf(a3),d0       * get break flag
00080E96  6700 FB9C               1443      BEQ     LAB_1274            * go do warm start if was program end
00080E9A                          1444  
00080E9A  41FA 2E9F               1445      LEA     LAB_BMSG(pc),a0     * point to "Break"
00080E9E  6000 FB86               1446      BRA     LAB_1269            * print "Break" and do warm start
00080EA2                          1447  
00080EA2                          1448  
00080EA2                          1449  *************************************************************************************
00080EA2                          1450  *
00080EA2                          1451  * perform RESTORE
00080EA2                          1452  
00080EA2                          1453  LAB_RESTORE
00080EA2  206B 042E               1454      MOVEA.l Smeml(a3),a0        * copy start of memory
00080EA6  6720                    1455      BEQ.s       LAB_1624            * branch if next character null (RESTORE)
00080EA8                          1456  
00080EA8  6100 01F0               1457      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00080EAC  B2AB 0452               1458      CMP.l       Clinel(a3),d1       * compare current line # with required line #
00080EB0  630E                    1459      BLS.s       LAB_GSCH            * branch if >= (start search from beginning)
00080EB2                          1460  
00080EB2  204D                    1461      MOVEA.l a5,a0               * copy BASIC execute pointer
00080EB4                          1462  LAB_RESs
00080EB4  4A18                    1463      TST.b       (a0)+               * test next byte & increment pointer
00080EB6  66FC                    1464      BNE.s       LAB_RESs            * loop if not EOL
00080EB8                          1465  
00080EB8  3008                    1466      MOVE.w  a0,d0               * copy pointer
00080EBA  C07C 0001               1467      AND.w       #1,d0               * mask odd bit
00080EBE  D0C0                    1468      ADD.w       d0,a0               * add pointer
00080EC0                          1469                              * search for line in Itemp from (a0)
00080EC0                          1470  LAB_GSCH
00080EC0  6100 FDCA               1471      BSR     LAB_SCLN            * search for d1 line number from a0
00080EC4                          1472                              * returns Cb=0 if found
00080EC4  6500 FB26               1473      BCS     LAB_USER            * go do "Undefined statement" error if not found
00080EC8                          1474  
00080EC8                          1475  LAB_1624
00080EC8  4A20                    1476      TST.b       -(a0)               * decrement pointer (faster)
00080ECA  2748 0462               1477      MOVE.l  a0,Dptrl(a3)        * save DATA pointer
00080ECE                          1478  RTS_006
00080ECE  4E75                    1479      RTS
00080ED0                          1480  
00080ED0                          1481  
00080ED0                          1482  *************************************************************************************
00080ED0                          1483  *
00080ED0                          1484  * perform NULL
00080ED0                          1485  
00080ED0                          1486  LAB_NULL
00080ED0  6100 10DA               1487      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00080ED4  1740 05E4               1488      MOVE.b  d0,Nullct(a3)       * save new NULL count
00080ED8  4E75                    1489      RTS
00080EDA                          1490  
00080EDA                          1491  
00080EDA                          1492  *************************************************************************************
00080EDA                          1493  *
00080EDA                          1494  * perform CONT
00080EDA                          1495  
00080EDA                          1496  LAB_CONT
00080EDA  6600 FB28               1497      BNE     LAB_SNER            * if following byte exit to do syntax error
00080EDE                          1498  
00080EDE  4A2B 0452               1499      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00080EE2  6A00 FAE8               1500      BPL     LAB_CCER            * if running go do can't continue error
00080EE6                          1501  
00080EE6  202B 045A               1502      MOVE.l  Cpntrl(a3),d0       * get continue pointer
00080EEA  6700 FAE0               1503      BEQ     LAB_CCER            * go do can't continue error if we can't
00080EEE                          1504  
00080EEE                          1505                              * we can continue so ...
00080EEE  2A40                    1506      MOVEA.l d0,a5               * save continue pointer as BASIC execute pointer
00080EF0  276B 0456 0452          1507      MOVE.l  Blinel(a3),Clinel(a3)   * set break line as current line
00080EF6  4E75                    1508      RTS
00080EF8                          1509  
00080EF8                          1510  
00080EF8                          1511  *************************************************************************************
00080EF8                          1512  *
00080EF8                          1513  * perform RUN
00080EF8                          1514  
00080EF8                          1515  LAB_RUN
00080EF8  660C                    1516      BNE.s       LAB_RUNn            * if following byte do RUN n
00080EFA                          1517  
00080EFA  6100 FDB0               1518      BSR     LAB_1477            * execution to start, clear vars & flush stack
00080EFE  274D 045A               1519      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00080F02  6000 FF22               1520      BRA     LAB_15C2            * go do interpreter inner loop
00080F06                          1521                              * (can't RTS, we flushed the stack!)
00080F06                          1522  
00080F06                          1523  LAB_RUNn
00080F06  6100 FDAA               1524      BSR     LAB_147A            * go do "CLEAR"
00080F0A  601C                    1525      BRA.s       LAB_16B0            * get n and do GOTO n
00080F0C                          1526  
00080F0C                          1527  
00080F0C                          1528  *************************************************************************************
00080F0C                          1529  *
00080F0C                          1530  * perform DO
00080F0C                          1531  
00080F0C                          1532  LAB_DO
00080F0C                          1533  *   MOVE.l  #$05,d0         * need 5 bytes for DO
00080F0C                          1534  *   BSR.s       LAB_1212            * check room on stack for A bytes
00080F0C  2F0D                    1535      MOVE.l  a5,-(sp)            * push BASIC execute pointer on stack
00080F0E  2F2B 0452               1536      MOVE.l  Clinel(a3),-(sp)        * push current line on stack
00080F12  3F3C 009C               1537      MOVE.w  #TK_DO,-(sp)        * push token for DO on stack
00080F16  487A FF0E               1538      PEA     LAB_15C2(pc)        * set return address
00080F1A  6000 0728               1539      BRA     LAB_GBYT            * scan memory & return to interpreter inner loop
00080F1E                          1540  
00080F1E                          1541  
00080F1E                          1542  *************************************************************************************
00080F1E                          1543  *
00080F1E                          1544  * perform GOSUB
00080F1E                          1545  
00080F1E                          1546  LAB_GOSUB
00080F1E                          1547  *   MOVE.l  #10,d0          * need 10 bytes for GOSUB
00080F1E                          1548  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00080F1E  2F0D                    1549      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00080F20  2F2B 0452               1550      MOVE.l  Clinel(a3),-(sp)        * push current line
00080F24  3F3C 008D               1551      MOVE.w  #TK_GOSUB,-(sp)     * push token for GOSUB
00080F28                          1552  LAB_16B0
00080F28  6100 071A               1553      BSR     LAB_GBYT            * scan memory
00080F2C  487A FEF8               1554      PEA     LAB_15C2(pc)        * return to interpreter inner loop after GOTO n
00080F30                          1555  
00080F30                          1556  * this PEA is needed because either we just cleared the stack and have nowhere to return
00080F30                          1557  * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
00080F30                          1558  * we whould have returned to is buried. This burried return address will be unstacked by
00080F30                          1559  * the corresponding RETURN command
00080F30                          1560  
00080F30                          1561  
00080F30                          1562  *************************************************************************************
00080F30                          1563  *
00080F30                          1564  * perform GOTO
00080F30                          1565  
00080F30                          1566  LAB_GOTO
00080F30  6100 0168               1567      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00080F34  206B 042E               1568      MOVEA.l Smeml(a3),a0        * get start of memory
00080F38  B2AB 0452               1569      CMP.l       Clinel(a3),d1       * compare current line with wanted #
00080F3C  630E                    1570      BLS.s       LAB_16D0            * branch if current # => wanted #
00080F3E                          1571  
00080F3E  204D                    1572      MOVEA.l a5,a0               * copy BASIC execute pointer
00080F40                          1573  LAB_GOTs
00080F40  4A18                    1574      TST.b       (a0)+               * test next byte & increment pointer
00080F42  66FC                    1575      BNE.s       LAB_GOTs            * loop if not EOL
00080F44                          1576  
00080F44  3008                    1577      MOVE.w  a0,d0               * past pad byte(s)
00080F46  C07C 0001               1578      AND.w       #1,d0               * mask odd bit
00080F4A  D0C0                    1579      ADD.w       d0,a0               * add to pointer
00080F4C                          1580  
00080F4C                          1581  LAB_16D0
00080F4C  6100 FD3E               1582      BSR     LAB_SCLN            * search for d1 line number from a0
00080F50                          1583                              * returns Cb=0 if found
00080F50  6500 FA9A               1584      BCS     LAB_USER            * if carry set go do "Undefined statement" error
00080F54                          1585  
00080F54  2A48                    1586      MOVEA.l a0,a5               * copy to basic execute pointer
00080F56  534D                    1587      SUBQ.w  #1,a5               * decrement pointer
00080F58  274D 045A               1588      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00080F5C  4E75                    1589      RTS
00080F5E                          1590  
00080F5E                          1591  
00080F5E                          1592  *************************************************************************************
00080F5E                          1593  *
00080F5E                          1594  * perform LOOP
00080F5E                          1595  
00080F5E                          1596  LAB_LOOP
00080F5E  0C6F 009C 0004          1597      CMP.w       #TK_DO,4(sp)        * compare token on stack with DO token
00080F64  6600 FA5E               1598      BNE     LAB_LDER            * branch if no matching DO
00080F68                          1599  
00080F68  1E00                    1600      MOVE.b  d0,d7               * copy following token (byte)
00080F6A  672E                    1601      BEQ.s       LoopAlways          * if no following token loop forever
00080F6C                          1602  
00080F6C  BE3C 003A               1603      CMP.b       #':',d7         * compare with ":"
00080F70  6728                    1604      BEQ.s       LoopAlways          * if no following token loop forever
00080F72                          1605  
00080F72  0407 00B0               1606      SUB.b       #TK_UNTIL,d7        * subtract token for UNTIL
00080F76  6708                    1607      BEQ.s       DoRest          * branch if was UNTIL
00080F78                          1608  
00080F78  5307                    1609      SUBQ.b  #1,d7               * decrement result
00080F7A  6600 FA88               1610      BNE     LAB_SNER            * if not WHILE go do syntax error & warm start
00080F7E                          1611                              * only if the token was WHILE will this fail
00080F7E                          1612  
00080F7E  7EFF                    1613      MOVEQ       #-1,d7          * set invert result longword
00080F80                          1614  DoRest
00080F80  6100 06C0               1615      BSR     LAB_IGBY            * increment & scan memory
00080F84  6100 055C               1616      BSR     LAB_EVEX            * evaluate expression
00080F88  4A2B 0594               1617      TST.b       FAC1_e(a3)          * test FAC1 exponent
00080F8C  6706                    1618      BEQ.s       DoCmp               * if = 0 go do straight compare
00080F8E                          1619  
00080F8E  177C 00FF 0594          1620      MOVE.b  #$FF,FAC1_e(a3)     * else set all bits
00080F94                          1621  DoCmp
00080F94  BF2B 0594               1622      EOR.b       d7,FAC1_e(a3)       * EOR with invert byte
00080F98  6614                    1623      BNE.s       LoopDone            * if <> 0 clear stack & back to interpreter loop
00080F9A                          1624  
00080F9A                          1625                              * loop condition wasn't met so do it again
00080F9A                          1626  LoopAlways
00080F9A  276F 0006 0452          1627      MOVE.l  6(sp),Clinel(a3)        * copy DO current line
00080FA0  2A6F 000A               1628      MOVE.l  10(sp),a5           * save BASIC execute pointer
00080FA4                          1629  
00080FA4  41FA FE80               1630      LEA     LAB_15C2(pc),a0     * get return address
00080FA8  2E88                    1631      MOVE.l  a0,(sp)         * dump the call to this routine and set the
00080FAA                          1632                              * return address
00080FAA  6000 0698               1633      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00080FAE                          1634                              * loop
00080FAE                          1635  
00080FAE                          1636                              * clear stack & back to interpreter loop
00080FAE                          1637  LoopDone
00080FAE  4FEF 000E               1638      LEA     14(sp),sp           * dump structure and call from stack
00080FB2  6014                    1639      BRA.s       LAB_DATA            * go perform DATA (find : or [EOL])
00080FB4                          1640  
00080FB4                          1641  
00080FB4                          1642  *************************************************************************************
00080FB4                          1643  *
00080FB4                          1644  * perform RETURN
00080FB4                          1645  
00080FB4                          1646  LAB_RETURN
00080FB4  6616                    1647      BNE.s       RTS_007         * exit if following token to allow syntax error
00080FB6                          1648  
00080FB6  0C6F 008D 0004          1649      CMP.w       #TK_GOSUB,4(sp)     * compare token from stack with GOSUB
00080FBC  6600 FA42               1650      BNE     LAB_RGER            * do RETURN without GOSUB error if no matching
00080FC0                          1651                              * GOSUB
00080FC0                          1652  
00080FC0  5C4F                    1653      ADDQ.w  #6,sp               * dump calling address & token
00080FC2  275F 0452               1654      MOVE.l  (sp)+,Clinel(a3)        * pull current line
00080FC6  2A5F                    1655      MOVE.l  (sp)+,a5            * pull BASIC execute pointer
00080FC8                          1656                              * now do perform "DATA" statement as we could be
00080FC8                          1657                              * returning into the middle of an ON <var> GOSUB
00080FC8                          1658                              * n,m,p,q line (the return address used by the
00080FC8                          1659                              * DATA statement is the one pushed before the
00080FC8                          1660                              * GOSUB was executed!)
00080FC8                          1661  
00080FC8                          1662  
00080FC8                          1663  *************************************************************************************
00080FC8                          1664  *
00080FC8                          1665  * perform DATA
00080FC8                          1666  
00080FC8                          1667  LAB_DATA
00080FC8  6104                    1668      BSR.s       LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00080FCA                          1669                              * returns a0 as pointer to [:] or [EOL]
00080FCA  2A48                    1670      MOVEA.l a0,a5               * skip rest of statement
00080FCC                          1671  RTS_007
00080FCC  4E75                    1672      RTS
00080FCE                          1673  
00080FCE                          1674  
00080FCE                          1675  *************************************************************************************
00080FCE                          1676  *
00080FCE                          1677  * scan for next BASIC statement ([:] or [EOL])
00080FCE                          1678  * returns a0 as pointer to [:] or [EOL]
00080FCE                          1679  
00080FCE                          1680  LAB_SNBS
00080FCE  204D                    1681      MOVEA.l a5,a0               * copy BASIC execute pointer
00080FD0  7222                    1682      MOVEQ       #$22,d1         * set string quote character
00080FD2  743A                    1683      MOVEQ       #$3A,d2         * set look for character = ":"
00080FD4  6008                    1684      BRA.s       LAB_172D            * go do search
00080FD6                          1685  
00080FD6                          1686  LAB_172C
00080FD6  B400                    1687      CMP.b       d0,d2               * compare with ":"
00080FD8  6708                    1688      BEQ.s       RTS_007a            * exit if found
00080FDA                          1689  
00080FDA  B200                    1690      CMP.b       d0,d1               * compare with '"'
00080FDC  670C                    1691      BEQ.s       LAB_1725            * if found go search for [EOL]
00080FDE                          1692  
00080FDE                          1693  LAB_172D
00080FDE  1018                    1694      MOVE.b  (a0)+,d0            * get next byte
00080FE0  66F4                    1695      BNE.s       LAB_172C            * loop if not null [EOL]
00080FE2                          1696  
00080FE2                          1697  RTS_007a
00080FE2  5348                    1698      SUBQ.w  #1,a0               * correct pointer
00080FE4  4E75                    1699      RTS
00080FE6                          1700  
00080FE6                          1701  LAB_1723
00080FE6  B200                    1702      CMP.b       d0,d1               * compare with '"'
00080FE8  67F4                    1703      BEQ.s       LAB_172D            * if found go search for ":" or [EOL]
00080FEA                          1704  
00080FEA                          1705  LAB_1725
00080FEA  1018                    1706      MOVE.b  (a0)+,d0            * get next byte
00080FEC  66F8                    1707      BNE.s       LAB_1723            * loop if not null [EOL]
00080FEE                          1708  
00080FEE  60F2                    1709      BRA.s       RTS_007a            * correct pointer & return
00080FF0                          1710  
00080FF0                          1711  
00080FF0                          1712  *************************************************************************************
00080FF0                          1713  *
00080FF0                          1714  * perform IF
00080FF0                          1715  
00080FF0                          1716  LAB_IF
00080FF0  6100 04F0               1717      BSR     LAB_EVEX            * evaluate expression
00080FF4  6100 064E               1718      BSR     LAB_GBYT            * scan memory
00080FF8  B03C 00AD               1719      CMP.b       #TK_THEN,d0         * compare with THEN token
00080FFC  6714                    1720      BEQ.s       LAB_174B            * if it was THEN then continue
00080FFE                          1721  
00080FFE                          1722                              * wasn't IF .. THEN so must be IF .. GOTO
00080FFE  B03C 0089               1723      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00081002  6600 FA00               1724      BNE     LAB_SNER            * if not GOTO token do syntax error/warm start
00081006                          1725  
00081006                          1726                              * was GOTO so check for GOTO <n>
00081006  204D                    1727      MOVE.l  a5,a0               * save the execute pointer
00081008  6100 0638               1728      BSR     LAB_IGBY            * scan memory, test for a numeric character
0008100C  2A48                    1729      MOVE.l  a0,a5               * restore the execute pointer
0008100E  6400 F9F4               1730      BCC     LAB_SNER            * if not numeric do syntax error/warm start
00081012                          1731  
00081012                          1732  LAB_174B
00081012  102B 0594               1733      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00081016  671E                    1734      BEQ.s       LAB_174E            * if result was zero go look for an ELSE
00081018                          1735  
00081018  6100 0628               1736      BSR     LAB_IGBY            * increment & scan memory
0008101C  6500 FF12               1737      BCS     LAB_GOTO            * if numeric do GOTO n
00081020                          1738                              * a GOTO <n> will never return to the IF
00081020                          1739                              * statement so there is no need to return
00081020                          1740                              * to this code
00081020                          1741  
00081020  B03C 008E               1742      CMP.b       #TK_RETURN,d0       * compare with RETURN token
00081024  6700 FE1E               1743      BEQ     LAB_1602            * if RETURN then interpret BASIC code from (a5)
00081028                          1744                              * and don't return here
00081028                          1745  
00081028  6100 FE16               1746      BSR     LAB_15FF            * else interpret BASIC code from (a5)
0008102C                          1747  
0008102C                          1748  * the IF was executed and there may be a following ELSE so the code needs to return
0008102C                          1749  * here to check and ignore the ELSE if present
0008102C                          1750  
0008102C  1015                    1751      MOVE.b  (a5),d0         * get the next basic byte
0008102E  B03C 00A9               1752      CMP.b       #TK_ELSE,d0         * compare it with the token for ELSE
00081032  6794                    1753      BEQ     LAB_DATA            * if ELSE ignore the following statement
00081034                          1754  
00081034                          1755  * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00081034                          1756  * following ELSE will, correctly, cause a syntax error
00081034                          1757  
00081034  4E75                    1758      RTS                     * else return to interpreter inner loop
00081036                          1759  
00081036                          1760  * perform ELSE after IF
00081036                          1761  
00081036                          1762  LAB_174E
00081036  101D                    1763      MOVE.b  (a5)+,d0            * faster increment past THEN
00081038  76A9                    1764      MOVEQ       #TK_ELSE,d3         * set search for ELSE token
0008103A  788B                    1765      MOVEQ       #TK_IF,d4           * set search for IF token
0008103C  7A00                    1766      MOVEQ       #0,d5               * clear the nesting depth
0008103E                          1767  LAB_1750
0008103E  101D                    1768      MOVE.b  (a5)+,d0            * get next BASIC byte & increment ptr
00081040  6720                    1769      BEQ.s       LAB_1754            * if EOL correct the pointer and return
00081042                          1770  
00081042  B004                    1771      CMP.b       d4,d0               * compare with "IF" token
00081044  6604                    1772      BNE.s       LAB_1752            * skip if not nested IF
00081046                          1773  
00081046  5245                    1774      ADDQ.w  #1,d5               * else increment the nesting depth ..
00081048  60F4                    1775      BRA.s       LAB_1750            * .. and continue looking
0008104A                          1776  
0008104A                          1777  LAB_1752
0008104A  B003                    1778      CMP.b       d3,d0               * compare with ELSE token
0008104C  66F0                    1779      BNE.s       LAB_1750            * if not ELSE continue looking
0008104E                          1780  
0008104E                          1781  LAB_1756
0008104E  51CD FFEE               1782      DBF     d5,LAB_1750         * loop if still nested
00081052                          1783  
00081052                          1784  * found the matching ELSE, now do <{n|statement}>
00081052                          1785  
00081052  6100 05F0               1786      BSR     LAB_GBYT            * scan memory
00081056  6500 FED8               1787      BCS     LAB_GOTO            * if numeric do GOTO n
0008105A                          1788                              * code will return to the interpreter loop
0008105A                          1789                              * at the tail end of the GOTO <n>
0008105A                          1790  
0008105A  6000 FDE4               1791      BRA     LAB_15FF            * else interpret BASIC code from (a5)
0008105E                          1792                              * code will return to the interpreter loop
0008105E                          1793                              * at the tail end of the <statement>
0008105E                          1794  
0008105E                          1795  
0008105E                          1796  *************************************************************************************
0008105E                          1797  *
0008105E                          1798  * perform REM, skip (rest of) line
0008105E                          1799  
0008105E                          1800  LAB_REM
0008105E  4A1D                    1801      TST.b       (a5)+               * test byte & increment pointer
00081060  66FC                    1802      BNE.s       LAB_REM         * loop if not EOL
00081062                          1803  
00081062                          1804  LAB_1754
00081062  534D                    1805      SUBQ.w  #1,a5               * correct the execute pointer
00081064  4E75                    1806      RTS
00081066                          1807  
00081066                          1808  
00081066                          1809  *************************************************************************************
00081066                          1810  *
00081066                          1811  * perform ON
00081066                          1812  
00081066                          1813  LAB_ON
00081066  6100 0F44               1814      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
0008106A  1400                    1815      MOVE.b  d0,d2               * copy byte
0008106C  6100 05D6               1816      BSR     LAB_GBYT            * restore BASIC byte
00081070  3F00                    1817      MOVE.w  d0,-(sp)            * push GOTO/GOSUB token
00081072  B03C 008D               1818      CMP.b       #TK_GOSUB,d0        * compare with GOSUB token
00081076  6708                    1819      BEQ.s       LAB_176C            * branch if GOSUB
00081078                          1820  
00081078  B03C 0089               1821      CMP.b       #TK_GOTO,d0         * compare with GOTO token
0008107C  6600 F986               1822      BNE     LAB_SNER            * if not GOTO do syntax error, then warm start
00081080                          1823  
00081080                          1824  * next character was GOTO or GOSUB
00081080                          1825  
00081080                          1826  LAB_176C
00081080  5302                    1827      SUBQ.b  #1,d2               * decrement index (byte value)
00081082  6606                    1828      BNE.s       LAB_1773            * branch if not zero
00081084                          1829  
00081084  301F                    1830      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token
00081086  6000 FDBC               1831      BRA     LAB_1602            * go execute it
0008108A                          1832  
0008108A                          1833  LAB_1773
0008108A  6100 05B6               1834      BSR     LAB_IGBY            * increment & scan memory
0008108E  610A                    1835      BSR.s       LAB_GFPN            * get fixed-point number into temp integer & d1
00081090                          1836                              * (skip this n)
00081090  B03C 002C               1837      CMP.b       #$2C,d0         * compare next character with ","
00081094  67EA                    1838      BEQ.s       LAB_176C            * loop if ","
00081096                          1839  
00081096  301F                    1840      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token (run out of options)
00081098  4E75                    1841      RTS                     * and exit
0008109A                          1842  
0008109A                          1843  
0008109A                          1844  *************************************************************************************
0008109A                          1845  *
0008109A                          1846  * get fixed-point number into temp integer & d1
0008109A                          1847  * interpret number from (a5), leave (a5) pointing to byte after #
0008109A                          1848  
0008109A                          1849  LAB_GFPN
0008109A  7200                    1850      MOVEQ       #$00,d1         * clear integer register
0008109C  2001                    1851      MOVE.l  d1,d0               * clear d0
0008109E  6100 05A4               1852      BSR     LAB_GBYT            * scan memory, Cb=1 if "0"-"9", & get byte
000810A2  642E                    1853      BCC.s       LAB_1786            * return if carry clear, chr was not "0"-"9"
000810A4                          1854  
000810A4  2F02                    1855      MOVE.l  d2,-(sp)            * save d2
000810A6                          1856  LAB_1785
000810A6  2401                    1857      MOVE.l  d1,d2               * copy integer register
000810A8  D281                    1858      ADD.l       d1,d1               * *2
000810AA  6500 F958               1859      BCS     LAB_SNER            * if overflow do syntax error, then warm start
000810AE                          1860  
000810AE  D281                    1861      ADD.l       d1,d1               * *4
000810B0  6500 F952               1862      BCS     LAB_SNER            * if overflow do syntax error, then warm start
000810B4                          1863  
000810B4  D282                    1864      ADD.l       d2,d1               * *1 + *4
000810B6  6500 F94C               1865      BCS     LAB_SNER            * if overflow do syntax error, then warm start
000810BA                          1866  
000810BA  D281                    1867      ADD.l       d1,d1               * *10
000810BC  6500 F946               1868      BCS     LAB_SNER            * if overflow do syntax error, then warm start
000810C0                          1869  
000810C0  0400 0030               1870      SUB.b       #$30,d0         * subtract $30 from byte
000810C4  D280                    1871      ADD.l       d0,d1               * add to integer register, the top 24 bits are
000810C6                          1872                              * always clear
000810C6  6900 F93C               1873      BVS     LAB_SNER            * if overflow do syntax error, then warm start
000810CA                          1874                              * this makes the maximum line number 2147483647
000810CA  6100 0576               1875      BSR     LAB_IGBY            * increment & scan memory
000810CE  65D6                    1876      BCS.s       LAB_1785            * loop for next character if "0"-"9"
000810D0                          1877  
000810D0  241F                    1878      MOVE.l  (sp)+,d2            * restore d2
000810D2                          1879  LAB_1786
000810D2  2741 042A               1880      MOVE.l  d1,Itemp(a3)        * save Itemp
000810D6  4E75                    1881      RTS
000810D8                          1882  
000810D8                          1883  
000810D8                          1884  *************************************************************************************
000810D8                          1885  *
000810D8                          1886  * perform DEC
000810D8                          1887  
000810D8                          1888  LAB_DEC
000810D8  3F3C 8180               1889      MOVE.w  #$8180,-(sp)        * set -1 sign/exponent
000810DC  600A                    1890      BRA.s       LAB_17B7            * go do DEC
000810DE                          1891  
000810DE                          1892  
000810DE                          1893  *************************************************************************************
000810DE                          1894  *
000810DE                          1895  * perform INC
000810DE                          1896  
000810DE                          1897  LAB_INC
000810DE  3F3C 8100               1898      MOVE.w  #$8100,-(sp)        * set 1 sign/exponent
000810E2  6004                    1899      BRA.s       LAB_17B7            * go do INC
000810E4                          1900  
000810E4                          1901                              * was "," so another INCR variable to do
000810E4                          1902  LAB_17B8
000810E4  6100 055C               1903      BSR     LAB_IGBY            * increment and scan memory
000810E8                          1904  LAB_17B7
000810E8  6100 0768               1905      BSR     LAB_GVAR            * get variable address in a0
000810EC                          1906  
000810EC                          1907  * if you want a non existant variable to return a null value then set the novar
000810EC                          1908  * value at the top of this file to some non zero value
000810EC                          1909  
000810EC                 FALSE    1910   ifne   novar
000810EC                          1911   endc
000810EC                          1912  
000810EC  4A2B 05B5               1913      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
000810F0                          1914                              * $00=float
000810F0  6B00 F8E6               1915      BMI     LAB_TMER            * if string do "Type mismatch" error/warm start
000810F4                          1916  
000810F4  6636                    1917      BNE.s       LAB_INCI            * go do integer INC/DEC
000810F6                          1918  
000810F6  2748 0472               1919      MOVE.l  a0,Lvarpl(a3)       * save var address
000810FA  6100 130A               1920      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
000810FE  277C 80000000 0598      1921      MOVE.l  #$80000000,FAC2_m(a3)   * set FAC2 mantissa for 1
00081106  3017                    1922      MOVE.w  (sp),d0         * move exponent & sign to d0
00081108  3740 059C               1923      MOVE.w  d0,FAC2_e(a3)       * move exponent & sign to FAC2
0008110C  176B 0595 059E          1924      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00081112  B12B 059E               1925      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00081116  6100 100A               1926      BSR     LAB_ADD         * add FAC2 to FAC1
0008111A  6100 1306               1927      BSR     LAB_PFAC            * pack FAC1 into variable (Lvarpl)
0008111E                          1928  LAB_INCT
0008111E  6100 0524               1929      BSR     LAB_GBYT            * scan memory
00081122  0C00 002C               1930      CMPI.b  #$2C,d0         * compare with ","
00081126  67BC                    1931      BEQ.s       LAB_17B8            * continue if "," (another variable to do)
00081128                          1932  
00081128  544F                    1933      ADDQ.w  #2,sp               * else dump sign & exponent
0008112A  4E75                    1934      RTS
0008112C                          1935  
0008112C                          1936  LAB_INCI
0008112C  4A2F 0001               1937      TST.b       1(sp)               * test sign
00081130  6604                    1938      BNE.s       LAB_DECI            * branch if DEC
00081132                          1939  
00081132  5290                    1940      ADDQ.l  #1,(a0)         * increment variable
00081134  60E8                    1941      BRA.s       LAB_INCT            * go scan for more
00081136                          1942  
00081136                          1943  LAB_DECI
00081136  5390                    1944      SUBQ.l  #1,(a0)         * decrement variable
00081138  60E4                    1945      BRA.s       LAB_INCT            * go scan for more
0008113A                          1946  
0008113A                          1947  
0008113A                          1948  *************************************************************************************
0008113A                          1949  *
0008113A                          1950  * perform LET
0008113A                          1951  
0008113A                          1952  LAB_LET
0008113A  6100 0712               1953      BSR     LAB_SVAR            * search for or create a variable
0008113E                          1954                              * return the variable address in a0
0008113E  2748 0472               1955      MOVE.l  a0,Lvarpl(a3)       * save variable address
00081142  1F2B 05B5               1956      MOVE.b  Dtypef(a3),-(sp)        * push var data type, $80=string, $40=integer,
00081146                          1957                              * $00=float
00081146  70BD                    1958      MOVEQ       #TK_EQUAL-$100,d0       * get = token
00081148  6100 04F0               1959      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
0008114C                          1960                              * start
0008114C  6100 0394               1961      BSR     LAB_EVEX            * evaluate expression
00081150  102B 05B5               1962      MOVE.b  Dtypef(a3),d0       * copy expression data type
00081154  175F 05B5               1963      MOVE.b  (sp)+,Dtypef(a3)        * pop variable data type
00081158  E318                    1964      ROL.b       #1,d0               * set carry if expression type = string
0008115A  6100 0372               1965      BSR     LAB_CKTM            * type match check, set C for string
0008115E  6700 12C2               1966      BEQ     LAB_PFAC            * if number pack FAC1 into variable Lvarpl & RET
00081162                          1967  
00081162                          1968  * string LET
00081162                          1969  
00081162                          1970  LAB_17D5
00081162  246B 0472               1971      MOVEA.l Lvarpl(a3),a2       * get pointer to variable
00081166                          1972  LAB_17D6
00081166  206B 0590               1973      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
0008116A  2250                    1974      MOVEA.l (a0),a1         * get string pointer
0008116C  B3EB 0446               1975      CMP.l       Sstorl(a3),a1       * compare string memory start with string
00081170                          1976                              * pointer
00081170  6516                    1977      BCS.s       LAB_1811            * if it was in program memory assign the value
00081172                          1978                              * and exit
00081172                          1979  
00081172  B1EB 0432               1980      CMPA.l  Sfncl(a3),a0        * compare functions start with descriptor
00081176                          1981                              * pointer
00081176  6510                    1982      BCS.s       LAB_1811            * branch if >= (string is on stack)
00081178                          1983  
00081178                          1984                              * string is variable$ make space and copy string
00081178                          1985  LAB_1810
00081178  7200                    1986      MOVEQ       #0,d1               * clear length
0008117A  3228 0004               1987      MOVE.w  4(a0),d1            * get string length
0008117E  2050                    1988      MOVEA.l (a0),a0         * get string pointer
00081180  6100 0B04               1989      BSR     LAB_20C9            * copy string
00081184  206B 0590               1990      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer back
00081188                          1991                              * clean stack & assign value to string variable
00081188                          1992  LAB_1811
00081188  B9C8                    1993      CMPA.l  a0,a4               * is string on the descriptor stack
0008118A  6602                    1994      BNE.s       LAB_1813            * skip pop if not
0008118C                          1995  
0008118C  5C4C                    1996      ADDQ.w  #$06,a4         * else update stack pointer
0008118E                          1997  LAB_1813
0008118E  24D8                    1998      MOVE.l  (a0)+,(a2)+         * save pointer to variable
00081190  3490                    1999      MOVE.w  (a0),(a2)           * save length to variable
00081192                          2000  RTS_008
00081192  4E75                    2001      RTS
00081194                          2002  
00081194                          2003  
00081194                          2004  *************************************************************************************
00081194                          2005  *
00081194                          2006  * perform GET
00081194                          2007  
00081194                          2008  LAB_GET
00081194  6100 06B8               2009      BSR     LAB_SVAR            * search for or create a variable
00081198                          2010                              * return the variable address in a0
00081198  2748 0472               2011      MOVE.l  a0,Lvarpl(a3)       * save variable address as GET variable
0008119C  4A2B 05B5               2012      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
000811A0                          2013                              * $00=float
000811A0  6B0C                    2014      BMI.s       LAB_GETS            * go get string character
000811A2                          2015  
000811A2                          2016                              * was numeric get
000811A2  6100 1DE4               2017      BSR     INGET               * get input byte
000811A6  6100 09BA               2018      BSR     LAB_1FD0            * convert d0 to unsigned byte in FAC1
000811AA  6000 1276               2019      BRA     LAB_PFAC            * pack FAC1 into variable (Lvarpl) & return
000811AE                          2020  
000811AE                          2021  LAB_GETS
000811AE  7200                    2022      MOVEQ       #$00,d1         * assume no byte
000811B0  2041                    2023      MOVE.l  d1,a0               * assume null string
000811B2  6100 1DD4               2024      BSR     INGET               * get input byte
000811B6  6408                    2025      BCC.s       LAB_NoSt            * branch if no byte received
000811B8                          2026  
000811B8  7201                    2027      MOVEQ       #$01,d1         * string is single byte
000811BA  6100 0AFC               2028      BSR     LAB_2115            * make string space d1 bytes long
000811BE                          2029                              * return a0 = pointer, other registers unchanged
000811BE                          2030  
000811BE  1080                    2031      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
000811C0                          2032  LAB_NoSt
000811C0  6100 0ADC               2033      BSR     LAB_RTST            * push string on descriptor stack
000811C4                          2034                              * a0 = pointer, d1 = length
000811C4                          2035  
000811C4  609C                    2036      BRA.s       LAB_17D5            * do string LET & return
000811C6                          2037  
000811C6                          2038  
000811C6                          2039  *************************************************************************************
000811C6                          2040  *
000811C6                          2041  * PRINT
000811C6                          2042  
000811C6                          2043  LAB_1829
000811C6  6100 00B4               2044      BSR     LAB_18C6            * print string from stack
000811CA                          2045  LAB_182C
000811CA  6100 0478               2046      BSR     LAB_GBYT            * scan memory
000811CE                          2047  
000811CE                          2048  * perform PRINT
000811CE                          2049  
000811CE                          2050  LAB_PRINT
000811CE  674A                    2051      BEQ.s       LAB_CRLF            * if nothing following just print CR/LF
000811D0                          2052  
000811D0                          2053  LAB_1831
000811D0  B03C 00A8               2054      CMP.b       #TK_TAB,d0          * compare with TAB( token
000811D4  6764                    2055      BEQ.s       LAB_18A2            * go do TAB/SPC
000811D6                          2056  
000811D6  B03C 00AC               2057      CMP.b       #TK_SPC,d0          * compare with SPC( token
000811DA  675E                    2058      BEQ.s       LAB_18A2            * go do TAB/SPC
000811DC                          2059  
000811DC  B03C 002C               2060      CMP.b       #',',d0         * compare with ","
000811E0  6740                    2061      BEQ.s       LAB_188B            * go do move to next TAB mark
000811E2                          2062  
000811E2  B03C 003B               2063      CMP.b       #';',d0         * compare with ";"
000811E6  6700 0086               2064      BEQ     LAB_18BD            * if ";" continue with PRINT processing
000811EA                          2065  
000811EA  6100 02F6               2066      BSR     LAB_EVEX            * evaluate expression
000811EE  4A2B 05B5               2067      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
000811F2                          2068                              * $00=float
000811F2  6BD2                    2069      BMI.s       LAB_1829            * branch if string
000811F4                          2070  
000811F4                          2071  ** replace the two lines above with this code
000811F4                          2072  
000811F4                          2073  **  MOVE.b  Dtypef(a3),d0       * get data type flag, $80=string, $00=numeric
000811F4                          2074  **  BMI.s       LAB_1829            * branch if string
000811F4                          2075  
000811F4  6100 13AA               2076      BSR     LAB_2970            * convert FAC1 to string
000811F8  6100 0A5E               2077      BSR     LAB_20AE            * print " terminated string to FAC1 stack
000811FC                          2078  
000811FC                          2079  * don't check fit if terminal width byte is zero
000811FC                          2080  
000811FC  7000                    2081      MOVEQ       #0,d0               * clear d0
000811FE  102B 05E6               2082      MOVE.b  TWidth(a3),d0       * get terminal width byte
00081202  670C                    2083      BEQ.s       LAB_185E            * skip check if zero
00081204                          2084  
00081204  902C 0007               2085      SUB.b       7(a4),d0            * subtract string length
00081208  902B 05E5               2086      SUB.b       TPos(a3),d0         * subtract terminal position
0008120C  6402                    2087      BCC.s       LAB_185E            * branch if less than terminal width
0008120E                          2088  
0008120E  610A                    2089      BSR.s       LAB_CRLF            * else print CR/LF
00081210                          2090  LAB_185E
00081210  616A                    2091      BSR.s       LAB_18C6            * print string from stack
00081212  60B6                    2092      BRA.s       LAB_182C            * always go continue processing line
00081214                          2093  
00081214                          2094  
00081214                          2095  *************************************************************************************
00081214                          2096  *
00081214                          2097  * CR/LF return to BASIC from BASIC input handler
00081214                          2098  * leaves a0 pointing to the buffer start
00081214                          2099  
00081214                          2100  LAB_1866
00081214  11BC 0000 1000          2101      MOVE.b  #$00,(a0,d1.w)      * null terminate input
0008121A                          2102  
0008121A                          2103  * print CR/LF
0008121A                          2104  
0008121A                          2105  LAB_CRLF
0008121A  700D                    2106      MOVEQ       #$0D,d0         * load [CR]
0008121C  6174                    2107      BSR.s       LAB_PRNA            * go print the character
0008121E  700A                    2108      MOVEQ       #$0A,d0         * load [LF]
00081220  6070                    2109      BRA.s       LAB_PRNA            * go print the character & return
00081222                          2110  
00081222                          2111  LAB_188B
00081222  142B 05E5               2112      MOVE.b  TPos(a3),d2         * get terminal position
00081226  B42B 05E7               2113      CMP.b       Iclim(a3),d2        * compare with input column limit
0008122A  6504                    2114      BCS.s       LAB_1898            * branch if less than Iclim
0008122C                          2115  
0008122C  61EC                    2116      BSR.s       LAB_CRLF            * else print CR/LF (next line)
0008122E  603E                    2117      BRA.s       LAB_18BD            * continue with PRINT processing
00081230                          2118  
00081230                          2119  LAB_1898
00081230  942B 05E2               2120      SUB.b       TabSiz(a3),d2       * subtract TAB size
00081234  64FA                    2121      BCC.s       LAB_1898            * loop if result was >= 0
00081236                          2122  
00081236  4402                    2123      NEG.b       d2              * twos complement it
00081238  6022                    2124      BRA.s       LAB_18B7            * print d2 spaces
0008123A                          2125  
0008123A                          2126                              * do TAB/SPC
0008123A                          2127  LAB_18A2
0008123A  3F00                    2128      MOVE.w  d0,-(sp)            * save token
0008123C  6100 0D6A               2129      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00081240  3400                    2130      MOVE.w  d0,d2               * copy byte
00081242  6100 0400               2131      BSR     LAB_GBYT            * get basic byte back
00081246  B03C 0029               2132      CMP.b       #$29,d0         * is next character ")"
0008124A  6600 F7B8               2133      BNE     LAB_SNER            * if not do syntax error, then warm start
0008124E                          2134  
0008124E  301F                    2135      MOVE.w  (sp)+,d0            * get token back
00081250  B03C 00A8               2136      CMP.b       #TK_TAB,d0          * was it TAB ?
00081254  6606                    2137      BNE.s       LAB_18B7            * branch if not (was SPC)
00081256                          2138  
00081256                          2139                              * calculate TAB offset
00081256  942B 05E5               2140      SUB.b       TPos(a3),d2         * subtract terminal position
0008125A  6312                    2141      BLS.s       LAB_18BD            * branch if result was <= 0
0008125C                          2142                              * can't TAB backwards or already there
0008125C                          2143  
0008125C                          2144                              * print d2.b spaces
0008125C                          2145  LAB_18B7
0008125C  7000                    2146      MOVEQ       #0,d0               * clear longword
0008125E  5300                    2147      SUBQ.b  #1,d0               * make d0 = $FF
00081260  C480                    2148      AND.l       d0,d2               * mask for byte only
00081262  670A                    2149      BEQ.s       LAB_18BD            * branch if zero
00081264                          2150  
00081264  7020                    2151      MOVEQ       #$20,d0         * load " "
00081266  5302                    2152      SUBQ.b  #1,d2               * adjust for DBF loop
00081268                          2153  LAB_18B8
00081268  6128                    2154      BSR.s       LAB_PRNA            * go print
0008126A  51CA FFFC               2155      DBF     d2,LAB_18B8         * decrement count and loop if not all done
0008126E                          2156  
0008126E                          2157                              * continue with PRINT processing
0008126E                          2158  LAB_18BD
0008126E  6100 03D2               2159      BSR     LAB_IGBY            * increment & scan memory
00081272  6600 FF5C               2160      BNE     LAB_1831            * if byte continue executing PRINT
00081276                          2161  
00081276  4E75                    2162      RTS                     * exit if nothing more to print
00081278                          2163  
00081278                          2164  
00081278                          2165  *************************************************************************************
00081278                          2166  *
00081278                          2167  * print null terminated string from a0
00081278                          2168  
00081278                          2169  LAB_18C3
00081278  6100 09DE               2170      BSR     LAB_20AE            * print terminated string to FAC1/stack
0008127C                          2171  
0008127C                          2172  * print string from stack
0008127C                          2173  
0008127C                          2174  LAB_18C6
0008127C  6100 0BCE               2175      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00081280                          2176                              * returns with d0 = length, a0 = pointer
00081280  670C                    2177      BEQ.s       RTS_009         * exit (RTS) if null string
00081282                          2178  
00081282  3200                    2179      MOVE.w  d0,d1               * copy length & set Z flag
00081284  5341                    2180      SUBQ.w  #1,d1               * -1 for BF loop
00081286                          2181  LAB_18CD
00081286  1018                    2182      MOVE.b  (a0)+,d0            * get byte from string
00081288  6108                    2183      BSR.s       LAB_PRNA            * go print the character
0008128A  51C9 FFFA               2184      DBF     d1,LAB_18CD         * decrement count and loop if not done yet
0008128E                          2185  
0008128E                          2186  RTS_009
0008128E  4E75                    2187      RTS
00081290                          2188  
00081290                          2189  
00081290                          2190  *************************************************************************************
00081290                          2191  *
00081290                          2192  * print "?" character
00081290                          2193  
00081290                          2194  LAB_18E3
00081290  703F                    2195      MOVEQ       #$3F,d0         * load "?" character
00081292                          2196  
00081292                          2197  
00081292                          2198  *************************************************************************************
00081292                          2199  *
00081292                          2200  * print character in d0, includes the null handler and infinite line length code
00081292                          2201  * changes no registers
00081292                          2202  
00081292                          2203  LAB_PRNA
00081292  2F01                    2204      MOVE.l  d1,-(sp)            * save d1
00081294  B03C 0020               2205      CMP.b       #$20,d0         * compare with " "
00081298  6528                    2206      BCS.s       LAB_18F9            * branch if less, non printing character
0008129A                          2207  
0008129A                          2208                              * don't check fit if terminal width byte is zero
0008129A  122B 05E6               2209      MOVE.b  TWidth(a3),d1       * get terminal width
0008129E  6610                    2210      BNE.s       LAB_18F0            * branch if not zero (not infinite length)
000812A0                          2211  
000812A0                          2212                              * is "infinite line" so check TAB position
000812A0  122B 05E5               2213      MOVE.b  TPos(a3),d1         * get position
000812A4  922B 05E2               2214      SUB.b       TabSiz(a3),d1       * subtract TAB size
000812A8  6614                    2215      BNE.s       LAB_18F7            * skip reset if different
000812AA                          2216  
000812AA  1741 05E5               2217      MOVE.b  d1,TPos(a3)         * else reset position
000812AE  600E                    2218      BRA.s       LAB_18F7            * go print character
000812B0                          2219  
000812B0                          2220  LAB_18F0
000812B0  B22B 05E5               2221      CMP.b       TPos(a3),d1         * compare with terminal character position
000812B4  6608                    2222      BNE.s       LAB_18F7            * branch if not at end of line
000812B6                          2223  
000812B6  2F00                    2224      MOVE.l  d0,-(sp)            * save d0
000812B8  6100 FF60               2225      BSR     LAB_CRLF            * else print CR/LF
000812BC  201F                    2226      MOVE.l  (sp)+,d0            * restore d0
000812BE                          2227  LAB_18F7
000812BE  522B 05E5               2228      ADDQ.b  #$01,TPos(a3)       * increment terminal position
000812C2                          2229  LAB_18F9
000812C2  4EAB 0412               2230      JSR     V_OUTP(a3)          * output byte via output vector
000812C6  B03C 000D               2231      CMP.b       #$0D,d0         * compare with [CR]
000812CA  6618                    2232      BNE.s       LAB_188A            * branch if not [CR]
000812CC                          2233  
000812CC                          2234                              * else print nullct nulls after the [CR]
000812CC  7200                    2235      MOVEQ       #$00,d1         * clear d1
000812CE  122B 05E4               2236      MOVE.b  Nullct(a3),d1       * get null count
000812D2  670C                    2237      BEQ.s       LAB_1886            * branch if no nulls
000812D4                          2238  
000812D4  7000                    2239      MOVEQ       #$00,d0         * load [NULL]
000812D6                          2240  LAB_1880
000812D6  4EAB 0412               2241      JSR     V_OUTP(a3)          * go print the character
000812DA  51C9 FFFA               2242      DBF     d1,LAB_1880         * decrement count and loop if not all done
000812DE                          2243  
000812DE  700D                    2244      MOVEQ       #$0D,d0         * restore the character
000812E0                          2245  LAB_1886
000812E0  1741 05E5               2246      MOVE.b  d1,TPos(a3)         * clear terminal position
000812E4                          2247  LAB_188A
000812E4  221F                    2248      MOVE.l  (sp)+,d1            * restore d1
000812E6  4E75                    2249      RTS
000812E8                          2250  
000812E8                          2251  
000812E8                          2252  *************************************************************************************
000812E8                          2253  *
000812E8                          2254  * handle bad input data
000812E8                          2255  
000812E8                          2256  LAB_1904
000812E8  2A5F                    2257      MOVEA.l (sp)+,a5            * restore execute pointer
000812EA  4A2B 05E0               2258      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
000812EE  6A0A                    2259      BPL.s       LAB_1913            * branch if INPUT (go do redo)
000812F0                          2260  
000812F0  276B 045E 0452          2261      MOVE.l  Dlinel(a3),Clinel(a3)   * save DATA line as current line
000812F6  6000 F6E0               2262      BRA     LAB_TMER            * do type mismatch error, then warm start
000812FA                          2263  
000812FA                          2264                              * mode was INPUT
000812FA                          2265  LAB_1913
000812FA  41FA 2A68               2266      LEA     LAB_REDO(pc),a0     * point to redo message
000812FE  6100 FF78               2267      BSR     LAB_18C3            * print null terminated string from memory
00081302  2A6B 045A               2268      MOVEA.l Cpntrl(a3),a5       * save continue pointer as BASIC execute pointer
00081306  4E75                    2269      RTS
00081308                          2270  
00081308                          2271  
00081308                          2272  *************************************************************************************
00081308                          2273  *
00081308                          2274  * perform INPUT
00081308                          2275  
00081308                          2276  LAB_INPUT
00081308  6100 0860               2277      BSR     LAB_CKRN            * check not direct (back here if ok)
0008130C  B03C 0022               2278      CMP.b       #'"',d0         * compare the next byte with open quote
00081310  660E                    2279      BNE.s       LAB_1934            * if no prompt string just go get the input
00081312                          2280  
00081312  6100 0306               2281      BSR     LAB_1BC1            * print "..." string
00081316  703B                    2282      MOVEQ       #';',d0         * set the search character to ";"
00081318  6100 0320               2283      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
0008131C                          2284                              * start
0008131C  6100 FF5E               2285      BSR     LAB_18C6            * print string from Sutill/Sutilh
00081320                          2286                              * finished the prompt, now read the data
00081320                          2287  LAB_1934
00081320  6100 F80C               2288      BSR     LAB_INLN            * print "? " and get BASIC input
00081324                          2289                              * return a0 pointing to the buffer start
00081324  7000                    2290      MOVEQ       #0,d0               * flag INPUT
00081326                          2291  
00081326                          2292  * if you don't want a null response to INPUT to break the program then set the nobrk
00081326                          2293  * value at the top of this file to some non zero value
00081326                          2294  
00081326                 FALSE    2295   ifne   nobrk
00081326                          2296   endc
00081326                          2297  
00081326                          2298  * if you do want a null response to INPUT to break the program then leave the nobrk
00081326                          2299  * value at the top of this file set to zero
00081326                          2300  
00081326                 TRUE     2301   ifeq   nobrk
00081326                          2302  
00081326  4A10                    2303      TST.b       (a0)                * test first byte from buffer
00081328  660A                    2304      BNE.s       LAB_1953            * branch if not null input
0008132A                          2305  
0008132A  6000 FB5E               2306      BRA     LAB_1647            * go do BREAK exit
0008132E                          2307  
0008132E                          2308   endc
0008132E                          2309  
0008132E                          2310  
0008132E                          2311  *************************************************************************************
0008132E                          2312  *
0008132E                          2313  * perform READ
0008132E                          2314  
0008132E                          2315  LAB_READ
0008132E  206B 0462               2316      MOVEA.l Dptrl(a3),a0        * get the DATA pointer
00081332  7098                    2317      MOVEQ       #$98-$100,d0        * flag READ
00081334                          2318  LAB_1953
00081334  1740 05E0               2319      MOVE.b  d0,Imode(a3)        * set input mode flag, $00=INPUT, $98=READ
00081338  2748 0466               2320      MOVE.l  a0,Rdptrl(a3)       * save READ pointer
0008133C                          2321  
0008133C                          2322                              * READ or INPUT the next variable from list
0008133C                          2323  LAB_195B
0008133C  6100 0510               2324      BSR     LAB_SVAR            * search for or create a variable
00081340                          2325                              * return the variable address in a0
00081340  2748 0472               2326      MOVE.l  a0,Lvarpl(a3)       * save variable address as LET variable
00081344  2F0D                    2327      MOVE.l  a5,-(sp)            * save BASIC execute pointer
00081346                          2328  LAB_1961
00081346  2A6B 0466               2329      MOVEA.l Rdptrl(a3),a5       * set READ pointer as BASIC execute pointer
0008134A  6100 02F8               2330      BSR     LAB_GBYT            * scan memory
0008134E  661E                    2331      BNE.s       LAB_1986            * if not null go get the value
00081350                          2332  
00081350                          2333                              * the pointer was to a null entry
00081350  4A2B 05E0               2334      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00081354  6B72                    2335      BMI.s       LAB_19DD            * branch if READ (go find the next statement)
00081356                          2336  
00081356                          2337                              * else the mode was INPUT so get more
00081356  6100 FF38               2338      BSR     LAB_18E3            * print a "?" character
0008135A  6100 F7D2               2339      BSR     LAB_INLN            * print "? " and get BASIC input
0008135E                          2340                              * return a0 pointing to the buffer start
0008135E                          2341  
0008135E                          2342  * if you don't want a null response to INPUT to break the program then set the nobrk
0008135E                          2343  * value at the top of this file to some non zero value
0008135E                          2344  
0008135E                 FALSE    2345   ifne   nobrk
0008135E                          2346   endc
0008135E                          2347  
0008135E                          2348  * if you do want a null response to INPUT to break the program then leave the nobrk
0008135E                          2349  * value at the top of this file set to zero
0008135E                          2350  
0008135E                 TRUE     2351   ifeq   nobrk
0008135E                          2352  
0008135E  4A10                    2353      TST.b       (a0)                * test the first byte from the buffer
00081360  6604                    2354      BNE.s       LAB_1984            * if not null input go handle it
00081362                          2355  
00081362  6000 FB26               2356      BRA     LAB_1647            * else go do the BREAK exit
00081366                          2357  
00081366                          2358  LAB_1984
00081366  2A48                    2359      MOVEA.l a0,a5               * set the execute pointer to the buffer
00081368  534D                    2360      SUBQ.w  #1,a5               * decrement the execute pointer
0008136A                          2361  
0008136A                          2362   endc
0008136A                          2363  
0008136A                          2364  LAB_1985
0008136A  6100 02D6               2365      BSR     LAB_IGBY            * increment & scan memory
0008136E                          2366  LAB_1986
0008136E  4A2B 05B5               2367      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00081372                          2368                              * $00=float
00081372  6A20                    2369      BPL.s       LAB_19B0            * branch if numeric
00081374                          2370  
00081374                          2371                              * else get string
00081374  1400                    2372      MOVE.b  d0,d2               * save search character
00081376  B03C 0022               2373      CMP.b       #$22,d0         * was it " ?
0008137A  6706                    2374      BEQ.s       LAB_1999            * branch if so
0008137C                          2375  
0008137C  743A                    2376      MOVEQ       #':',d2         * set new search character
0008137E  702C                    2377      MOVEQ       #',',d0         * other search character is ","
00081380  534D                    2378      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00081382                          2379  LAB_1999
00081382  524D                    2380      ADDQ.w  #1,a5               * increment BASIC execute pointer
00081384  1600                    2381      MOVE.b  d0,d3               * set second search character
00081386  204D                    2382      MOVEA.l a5,a0               * BASIC execute pointer is source
00081388                          2383  
00081388  6100 08D2               2384      BSR     LAB_20B4            * print d2/d3 terminated string to FAC1 stack
0008138C                          2385                              * d2 = Srchc, d3 = Asrch, a0 is source
0008138C  2A4A                    2386      MOVEA.l a2,a5               * copy end of string to BASIC execute pointer
0008138E  6100 FDD2               2387      BSR     LAB_17D5            * go do string LET
00081392  6010                    2388      BRA.s       LAB_19B6            * go check string terminator
00081394                          2389  
00081394                          2390                              * get numeric INPUT
00081394                          2391  LAB_19B0
00081394  1F2B 05B5               2392      MOVE.b  Dtypef(a3),-(sp)        * save variable data type
00081398  6100 1D98               2393      BSR     LAB_2887            * get FAC1 from string
0008139C  175F 05B5               2394      MOVE.b  (sp)+,Dtypef(a3)        * restore variable data type
000813A0  6100 1080               2395      BSR     LAB_PFAC            * pack FAC1 into (Lvarpl)
000813A4                          2396  LAB_19B6
000813A4  6100 029E               2397      BSR     LAB_GBYT            * scan memory
000813A8  670A                    2398      BEQ.s       LAB_19C2            * branch if null (last entry)
000813AA                          2399  
000813AA  B03C 002C               2400      CMP.b       #',',d0         * else compare with ","
000813AE  6600 FF38               2401      BNE     LAB_1904            * if not "," go handle bad input data
000813B2                          2402  
000813B2  524D                    2403      ADDQ.w  #1,a5               * else was "," so point to next chr
000813B4                          2404                              * got good input data
000813B4                          2405  LAB_19C2
000813B4  274D 0466               2406      MOVE.l  a5,Rdptrl(a3)       * save the read pointer for now
000813B8  2A5F                    2407      MOVEA.l (sp)+,a5            * restore the execute pointer
000813BA  6100 0288               2408      BSR     LAB_GBYT            * scan the memory
000813BE  6736                    2409      BEQ.s       LAB_1A03            * if null go do extra ignored message
000813C0                          2410  
000813C0  487A FF7A               2411      PEA     LAB_195B(pc)        * set return address
000813C4  6000 0272               2412      BRA     LAB_1C01            * scan for "," else do syntax error/warm start
000813C8                          2413                              * then go INPUT next variable from list
000813C8                          2414  
000813C8                          2415                              * find next DATA statement or do "Out of Data"
000813C8                          2416                              * error
000813C8                          2417  LAB_19DD
000813C8  6100 FC04               2418      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
000813CC                          2419                              * returns a0 as pointer to [:] or [EOL]
000813CC  2A48                    2420      MOVEA.l a0,a5               * add index, now = pointer to [EOL]/[EOS]
000813CE  524D                    2421      ADDQ.w  #1,a5               * pointer to next character
000813D0  B03C 003A               2422      CMP.b       #':',d0         * was it statement end?
000813D4  6712                    2423      BEQ.s       LAB_19F6            * branch if [:]
000813D6                          2424  
000813D6                          2425                              * was [EOL] so find next line
000813D6                          2426  
000813D6  320D                    2427      MOVE.w  a5,d1               * past pad byte(s)
000813D8  C27C 0001               2428      AND.w       #1,d1               * mask odd bit
000813DC  DAC1                    2429      ADD.w       d1,a5               * add pointer
000813DE  241D                    2430      MOVE.l  (a5)+,d2            * get next line pointer
000813E0  6700 F61A               2431      BEQ     LAB_ODER            * branch if end of program
000813E4                          2432  
000813E4  275D 045E               2433      MOVE.l  (a5)+,Dlinel(a3)        * save current DATA line
000813E8                          2434  LAB_19F6
000813E8  6100 025A               2435      BSR     LAB_GBYT            * scan memory
000813EC  B03C 0083               2436      CMP.b       #TK_DATA,d0         * compare with "DATA" token
000813F0  6700 FF78               2437      BEQ     LAB_1985            * was "DATA" so go do next READ
000813F4                          2438  
000813F4  60D2                    2439      BRA.s       LAB_19DD            * go find next statement if not "DATA"
000813F6                          2440  
000813F6                          2441  * end of INPUT/READ routine
000813F6                          2442  
000813F6                          2443  LAB_1A03
000813F6  206B 0466               2444      MOVEA.l Rdptrl(a3),a0       * get temp READ pointer
000813FA  4A2B 05E0               2445      TST.b       Imode(a3)           * get input mode flag, $00=INPUT, $98=READ
000813FE  6A06                    2446      BPL.s       LAB_1A0E            * branch if INPUT
00081400                          2447  
00081400  2748 0462               2448      MOVE.l  a0,Dptrl(a3)        * else save temp READ pointer as DATA pointer
00081404  4E75                    2449      RTS
00081406                          2450  
00081406                          2451                              * we were getting INPUT
00081406                          2452  LAB_1A0E
00081406  4A10                    2453      TST.b       (a0)                * test next byte
00081408  6602                    2454      BNE.s       LAB_1A1B            * error if not end of INPUT
0008140A                          2455  
0008140A  4E75                    2456      RTS
0008140C                          2457                              * user typed too much
0008140C                          2458  LAB_1A1B
0008140C  41FA 2946               2459      LEA     LAB_IMSG(pc),a0     * point to extra ignored message
00081410  6000 FE66               2460      BRA     LAB_18C3            * print null terminated string from memory & RTS
00081414                          2461  
00081414                          2462  
00081414                          2463  *************************************************************************************
00081414                          2464  *
00081414                          2465  * perform NEXT
00081414                          2466  
00081414                          2467  LAB_NEXT
00081414  6610                    2468      BNE.s       LAB_1A46            * branch if NEXT var
00081416                          2469  
00081416  584F                    2470      ADDQ.w  #4,sp               * back past return address
00081418  0C57 0081               2471      CMP.w       #TK_FOR,(sp)        * is FOR token on stack?
0008141C  6600 F5EA               2472      BNE     LAB_NFER            * if not do NEXT without FOR err/warm start
00081420                          2473  
00081420  206F 0002               2474      MOVEA.l 2(sp),a0            * get stacked FOR variable pointer
00081424  601C                    2475      BRA.s       LAB_11BD            * branch always (no variable to search for)
00081426                          2476  
00081426                          2477  * NEXT var
00081426                          2478  
00081426                          2479  LAB_1A46
00081426  6100 042A               2480      BSR     LAB_GVAR            * get variable address in a0
0008142A  584F                    2481      ADDQ.w  #4,sp               * back past return address
0008142C  303C 0081               2482      MOVE.w  #TK_FOR,d0          * set for FOR token
00081430  721C                    2483      MOVEQ       #$1C,d1         * set for FOR use size
00081432  6002                    2484      BRA.s       LAB_11A6            * enter loop for next variable search
00081434                          2485  
00081434                          2486  LAB_11A5
00081434  DFC1                    2487      ADDA.l  d1,sp               * add FOR stack use size
00081436                          2488  LAB_11A6
00081436  B057                    2489      CMP.w       (sp),d0         * is FOR token on stack?
00081438  6600 F5CE               2490      BNE     LAB_NFER            * if not found do NEXT without FOR error and
0008143C                          2491                              * warm start
0008143C                          2492  
0008143C                          2493                              * was FOR token
0008143C  B1EF 0002               2494      CMPA.l  2(sp),a0            * compare var pointer with stacked var pointer
00081440  66F2                    2495      BNE.s       LAB_11A5            * loop if no match found
00081442                          2496  
00081442                          2497  LAB_11BD
00081442  376F 0006 059C          2498      MOVE.w  6(sp),FAC2_e(a3)        * get STEP value exponent and sign
00081448  276F 0008 0598          2499      MOVE.l  8(sp),FAC2_m(a3)        * get STEP value mantissa
0008144E                          2500  
0008144E  176F 0012 05B5          2501      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type
00081454  6100 021C               2502      BSR     LAB_1C19            * check type and unpack (a0)
00081458                          2503  
00081458  176B 059D 059E          2504      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
0008145E  102B 0595               2505      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00081462  B12B 059E               2506      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00081466                          2507  
00081466  2748 0472               2508      MOVE.l  a0,Lvarpl(a3)       * save variable pointer
0008146A  6100 0CB6               2509      BSR     LAB_ADD         * add STEP value to FOR variable
0008146E  176F 0012 05B5          2510      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type (again)
00081474  6100 0FAC               2511      BSR     LAB_PFAC            * pack FAC1 into FOR variable (Lvarpl)
00081478                          2512  
00081478  376F 000C 059C          2513      MOVE.w  12(sp),FAC2_e(a3)       * get TO value exponent and sign
0008147E  276F 000E 0598          2514      MOVE.l  14(sp),FAC2_m(a3)       * get TO value mantissa
00081484                          2515  
00081484  176B 059D 059E          2516      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
0008148A  102B 0595               2517      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
0008148E  B12B 059E               2518      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00081492                          2519  
00081492  6100 1038               2520      BSR     LAB_27FA            * compare FAC1 with FAC2 (TO value)
00081496                          2521                              * returns d0=+1 if FAC1 > FAC2
00081496                          2522                              * returns d0= 0 if FAC1 = FAC2
00081496                          2523                              * returns d0=-1 if FAC1 < FAC2
00081496                          2524  
00081496  322F 0006               2525      MOVE.w  6(sp),d1            * get STEP value exponent and sign
0008149A  B141                    2526      EOR.w       d0,d1               * EOR compare result with STEP exponent and sign
0008149C                          2527  
0008149C  4A00                    2528      TST.b       d0              * test for =
0008149E  6704                    2529      BEQ.s       LAB_1A90            * branch if = (loop INcomplete)
000814A0                          2530  
000814A0  4A01                    2531      TST.b       d1              * test result
000814A2  6A0E                    2532      BPL.s       LAB_1A9B            * branch if > (loop complete)
000814A4                          2533  
000814A4                          2534                              * loop back and do it all again
000814A4                          2535  LAB_1A90
000814A4  276F 0014 0452          2536      MOVE.l  20(sp),Clinel(a3)       * reset current line
000814AA  2A6F 0018               2537      MOVE.l  24(sp),a5           * reset BASIC execute pointer
000814AE  6000 F976               2538      BRA     LAB_15C2            * go do interpreter inner loop
000814B2                          2539  
000814B2                          2540                              * loop complete so carry on
000814B2                          2541  LAB_1A9B
000814B2  DEFC 001C               2542      ADDA.w  #28,sp          * add 28 to dump FOR structure
000814B6  6100 018C               2543      BSR     LAB_GBYT            * scan memory
000814BA  B03C 002C               2544      CMP.b       #$2C,d0         * compare with ","
000814BE  6600 F966               2545      BNE     LAB_15C2            * if not "," go do interpreter inner loop
000814C2                          2546  
000814C2                          2547                              * was "," so another NEXT variable to do
000814C2  6100 017E               2548      BSR     LAB_IGBY            * else increment & scan memory
000814C6  6100 FF5E               2549      BSR     LAB_1A46            * do NEXT (var)
000814CA                          2550  
000814CA                          2551  
000814CA                          2552  *************************************************************************************
000814CA                          2553  *
000814CA                          2554  * evaluate expression & check is numeric, else do type mismatch
000814CA                          2555  
000814CA                          2556  LAB_EVNM
000814CA  6116                    2557      BSR.s       LAB_EVEX            * evaluate expression
000814CC                          2558  
000814CC                          2559  
000814CC                          2560  *************************************************************************************
000814CC                          2561  *
000814CC                          2562  * check if source is numeric, else do type mismatch
000814CC                          2563  
000814CC                          2564  LAB_CTNM
000814CC  B040                    2565      CMP.w       d0,d0               * required type is numeric so clear carry
000814CE                          2566  
000814CE                          2567  
000814CE                          2568  *************************************************************************************
000814CE                          2569  *
000814CE                          2570  * type match check, set C for string, clear C for numeric
000814CE                          2571  
000814CE                          2572  LAB_CKTM
000814CE  082B 0007 05B5          2573      BTST.b  #7,Dtypef(a3)       * test data type flag, don't change carry
000814D4  6606                    2574      BNE.s       LAB_1ABA            * branch if data type is string
000814D6                          2575  
000814D6                          2576                              * else data type was numeric
000814D6  6500 F500               2577      BCS     LAB_TMER            * if required type is string do type mismatch
000814DA                          2578                              * error
000814DA                          2579  
000814DA  4E75                    2580      RTS
000814DC                          2581                              * data type was string, now check required type
000814DC                          2582  LAB_1ABA
000814DC  6400 F4FA               2583      BCC     LAB_TMER            * if required type is numeric do type mismatch
000814E0                          2584                              * error
000814E0  4E75                    2585      RTS
000814E2                          2586  
000814E2                          2587  
000814E2                          2588  *************************************************************************************
000814E2                          2589  *
000814E2                          2590  * this routine evaluates any type of expression. first it pushes an end marker so
000814E2                          2591  * it knows when the expression has been evaluated, this is a precedence value of zero.
000814E2                          2592  * next the first value is evaluated, this can be an in line value, either numeric or
000814E2                          2593  * string, a variable or array element of any type, a function or even an expression
000814E2                          2594  * in parenthesis. this value is kept in FAC_1
000814E2                          2595  * after the value is evaluated a test is made on the next BASIC program byte, if it
000814E2                          2596  * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
000814E2                          2597  * in the comparison evaluation flag. this test loops until no more comparrison operators
000814E2                          2598  * are found or more than one of any type is found. in the last case an error is generated
000814E2                          2599  
000814E2                          2600  * evaluate expression
000814E2                          2601  
000814E2                          2602  LAB_EVEX
000814E2  534D                    2603      SUBQ.w  #1,a5               * decrement BASIC execute pointer
000814E4                          2604  LAB_EVEZ
000814E4  7200                    2605      MOVEQ       #0,d1               * clear precedence word
000814E6  1741 05B5               2606      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
000814EA                          2607                              * $00=float
000814EA  601C                    2608      BRA.s       LAB_1ACD            * enter loop
000814EC                          2609  
000814EC                          2610  * get vector, set up operator then continue evaluation
000814EC                          2611  
000814EC                          2612  LAB_1B43                        *
000814EC  41FA 22BC               2613      LEA     LAB_OPPT(pc),a0     * point to operator vector table
000814F0  3030 1002               2614      MOVE.w  2(a0,d1.w),d0       * get vector offset
000814F4  4870 0000               2615      PEA     (a0,d0.w)           * push vector
000814F8                          2616  
000814F8  2F2B 0590               2617      MOVE.l  FAC1_m(a3),-(sp)        * push FAC1 mantissa
000814FC  3F2B 0594               2618      MOVE.w  FAC1_e(a3),-(sp)        * push sign and exponent
00081500  1F2B 05E3               2619      MOVE.b  comp_f(a3),-(sp)        * push comparison evaluation flag
00081504                          2620  
00081504  3230 1000               2621      MOVE.w  (a0,d1.w),d1        * get precedence value
00081508                          2622  LAB_1ACD
00081508  3F01                    2623      MOVE.w  d1,-(sp)            * push precedence value
0008150A  6100 00E4               2624      BSR     LAB_GVAL            * get value from line
0008150E  177C 0000 05E3          2625      MOVE.b  #$00,comp_f(a3)     * clear compare function flag
00081514                          2626  LAB_1ADB
00081514  6100 012E               2627      BSR     LAB_GBYT            * scan memory
00081518                          2628  LAB_1ADE
00081518  0400 00BC               2629      SUB.b       #TK_GT,d0           * subtract token for > (lowest compare function)
0008151C  652A                    2630      BCS.s       LAB_1AFA            * branch if < TK_GT
0008151E                          2631  
0008151E  B03C 0003               2632      CMP.b       #$03,d0         * compare with ">" to "<" tokens
00081522  650A                    2633      BCS.s       LAB_1AE0            * branch if <= TK_SGN (is compare function)
00081524                          2634  
00081524  4A2B 05E3               2635      TST.b       comp_f(a3)          * test compare function flag
00081528  6660                    2636      BNE.s       LAB_1B2A            * branch if compare function
0008152A                          2637  
0008152A  6000 0086               2638      BRA     LAB_1B78            * go do functions
0008152E                          2639  
0008152E                          2640                              * was token for > = or < (d0 = 0, 1 or 2)
0008152E                          2641  LAB_1AE0
0008152E  7201                    2642      MOVEQ       #1,d1               * set to 0000 0001
00081530  E121                    2643      ASL.b       d0,d1               * 1 if >, 2 if =, 4 if <
00081532  102B 05E3               2644      MOVE.b  comp_f(a3),d0       * copy old compare function flag
00081536  B32B 05E3               2645      EOR.b       d1,comp_f(a3)       * EOR in this compare function bit
0008153A  B02B 05E3               2646      CMP.b       comp_f(a3),d0       * compare old with new compare function flag
0008153E  6400 F4C4               2647      BCC     LAB_SNER            * if new <= old comp_f do syntax error and warm
00081542                          2648                              * start, there was more than one <, = or >
00081542  6100 00FE               2649      BSR     LAB_IGBY            * increment & scan memory
00081546  60D0                    2650      BRA.s       LAB_1ADE            * go do next character
00081548                          2651  
00081548                          2652                              * token is < ">" or > "<" tokens
00081548                          2653  LAB_1AFA
00081548  4A2B 05E3               2654      TST.b       comp_f(a3)          * test compare function flag
0008154C  663C                    2655      BNE.s       LAB_1B2A            * branch if compare function
0008154E                          2656  
0008154E                          2657                              * was < TK_GT so is operator or lower
0008154E  0600 000A               2658      ADD.b   #(TK_GT-TK_PLUS),d0     * add # of operators (+ - * / ^ AND OR EOR)
00081552  645E                    2659      BCC.s       LAB_1B78            * branch if < + operator
00081554                          2660  
00081554  6608                    2661      BNE.s       LAB_1B0B            * branch if not + token
00081556                          2662  
00081556  4A2B 05B5               2663      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
0008155A                          2664                              * $00=float
0008155A  6B00 087C               2665      BMI     LAB_224D            * type is string & token was +
0008155E                          2666  
0008155E                          2667  LAB_1B0B
0008155E  7200                    2668      MOVEQ       #0,d1               * clear longword
00081560  D000                    2669      ADD.b       d0,d0               * *2
00081562  D000                    2670      ADD.b       d0,d0               * *4
00081564  1200                    2671      MOVE.b  d0,d1               * copy to index
00081566                          2672  LAB_1B13
00081566  301F                    2673      MOVE.w  (sp)+,d0            * pull previous precedence
00081568  41FA 2240               2674      LEA     LAB_OPPT(pc),a0     * set pointer to operator table
0008156C  B070 1000               2675      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00081570  6446                    2676      BCC.s       LAB_1B7D            * branch if previous precedence (d0) >=
00081572                          2677  
00081572  6100 FF58               2678      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00081576                          2679  LAB_1B1C
00081576  3F00                    2680      MOVE.w  d0,-(sp)            * save precedence
00081578                          2681  LAB_1B1D
00081578  6100 FF72               2682      BSR     LAB_1B43            * get vector, set-up operator and continue
0008157C                          2683                              * evaluation
0008157C  301F                    2684      MOVE.w  (sp)+,d0            * restore precedence
0008157E  222B 05D8               2685      MOVE.l  prstk(a3),d1        * get stacked function pointer
00081582  6A22                    2686      BPL.s       LAB_1B3C            * branch if stacked values
00081584                          2687  
00081584  3000                    2688      MOVE.w  d0,d0               * copy precedence (set flags)
00081586  672E                    2689      BEQ.s       LAB_1B7B            * exit if done
00081588                          2690  
00081588  603C                    2691      BRA.s       LAB_1B86            * else pop FAC2 & return (do function)
0008158A                          2692  
0008158A                          2693                              * was compare function (< = >)
0008158A                          2694  LAB_1B2A
0008158A  102B 05B5               2695      MOVE.b  Dtypef(a3),d0       * get data type flag
0008158E  122B 05E3               2696      MOVE.b  comp_f(a3),d1       * get compare function flag
00081592  D000                    2697      ADD.b       d0,d0               * string bit flag into X bit
00081594  D301                    2698      ADDX.b  d1,d1               * shift compare function flag
00081596                          2699  
00081596  177C 0000 05B5          2700      MOVE.b  #0,Dtypef(a3)       * clear data type flag, $00=float
0008159C  1741 05E3               2701      MOVE.b  d1,comp_f(a3)       * save new compare function flag
000815A0  534D                    2702      SUBQ.w  #1,a5               * decrement BASIC execute pointer
000815A2  7230                    2703      MOVEQ       #(TK_LT-TK_PLUS)*4,d1   * set offset to last operator entry
000815A4  60C0                    2704      BRA.s       LAB_1B13            * branch always
000815A6                          2705  
000815A6                          2706  LAB_1B3C
000815A6  41FA 2202               2707      LEA     LAB_OPPT(pc),a0     * point to function vector table
000815AA  B070 1000               2708      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
000815AE  6416                    2709      BCC.s       LAB_1B86            * branch if d0 >=, pop FAC2 & return
000815B0                          2710  
000815B0  60C4                    2711      BRA.s       LAB_1B1C            * branch always
000815B2                          2712  
000815B2                          2713  * do functions
000815B2                          2714  
000815B2                          2715  LAB_1B78
000815B2  72FF                    2716      MOVEQ       #-1,d1          * flag all done
000815B4  301F                    2717      MOVE.w  (sp)+,d0            * pull precedence word
000815B6                          2718  LAB_1B7B
000815B6  6732                    2719      BEQ.s       LAB_1B9D            * exit if done
000815B8                          2720  
000815B8                          2721  LAB_1B7D
000815B8  B07C 0064               2722      CMP.w       #$64,d0         * compare previous precedence with $64
000815BC  6704                    2723      BEQ.s       LAB_1B84            * branch if was $64 (< function can be string)
000815BE                          2724  
000815BE  6100 FF0C               2725      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
000815C2                          2726  LAB_1B84
000815C2  2741 05D8               2727      MOVE.l  d1,prstk(a3)        * save current operator index
000815C6                          2728  
000815C6                          2729                              * pop FAC2 & return
000815C6                          2730  LAB_1B86
000815C6  101F                    2731      MOVE.b  (sp)+,d0            * pop comparison evaluation flag
000815C8  1200                    2732      MOVE.b  d0,d1               * copy comparison evaluation flag
000815CA  E208                    2733      LSR.b       #1,d0               * shift out comparison evaluation lowest bit
000815CC  1740 05E1               2734      MOVE.b  d0,Cflag(a3)        * save comparison evaluation flag
000815D0  375F 059C               2735      MOVE.w  (sp)+,FAC2_e(a3)        * pop exponent and sign
000815D4  275F 0598               2736      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
000815D8  176B 059D 059E          2737      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign
000815DE  102B 0595               2738      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
000815E2  B12B 059E               2739      EOR.b       d0,FAC_sc(a3)       * EOR FAC1 sign and set sign compare
000815E6                          2740  
000815E6  E209                    2741      LSR.b       #1,d1               * type bit into X and C
000815E8  4E75                    2742      RTS
000815EA                          2743  
000815EA                          2744  LAB_1B9D
000815EA  102B 0594               2745      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
000815EE  4E75                    2746      RTS
000815F0                          2747  
000815F0                          2748  
000815F0                          2749  *************************************************************************************
000815F0                          2750  *
000815F0                          2751  * get a value from the BASIC line
000815F0                          2752  
000815F0                          2753  LAB_GVAL
000815F0  6150                    2754      BSR.s       LAB_IGBY            * increment & scan memory
000815F2  6500 1B3E               2755      BCS     LAB_2887            * if numeric get FAC1 from string & return
000815F6                          2756  
000815F6  4A00                    2757      TST.b       d0              * test byte
000815F8  6B00 008E               2758      BMI     LAB_1BD0            * if -ve go test token values
000815FC                          2759  
000815FC                          2760                              * else it is either a string, number, variable
000815FC                          2761                              * or (<expr>)
000815FC  B03C 0024               2762      CMP.b       #'$',d0         * compare with "$"
00081600  6700 1B30               2763      BEQ     LAB_2887            * if "$" get hex number from string & return
00081604                          2764  
00081604  B03C 0025               2765      CMP.b       #'%',d0         * else compare with "%"
00081608  6700 1B28               2766      BEQ     LAB_2887            * if "%" get binary number from string & return
0008160C                          2767  
0008160C  B03C 002E               2768      CMP.b       #$2E,d0         * compare with "."
00081610  6700 1B20               2769      BEQ     LAB_2887            * if so get FAC1 from string and return
00081614                          2770                              * (e.g. .123)
00081614                          2771  
00081614                          2772                              * wasn't a number so ...
00081614  B03C 0022               2773      CMP.b       #$22,d0         * compare with "
00081618  660C                    2774      BNE.s       LAB_1BF3            * if not open quote it must be a variable or
0008161A                          2775                              * open bracket
0008161A                          2776  
0008161A                          2777                              * was open quote so get the enclosed string
0008161A                          2778  
0008161A                          2779  * print "..." string to string stack
0008161A                          2780  
0008161A                          2781  LAB_1BC1
0008161A  101D                    2782      MOVE.b  (a5)+,d0            * increment BASIC execute pointer (past ")
0008161C                          2783                              * fastest/shortest method
0008161C  204D                    2784      MOVEA.l a5,a0               * copy basic execute pointer (string start)
0008161E  6100 0638               2785      BSR     LAB_20AE            * print " terminated string to stack
00081622  2A4A                    2786      MOVEA.l a2,a5               * restore BASIC execute pointer from temp
00081624  4E75                    2787      RTS
00081626                          2788  
00081626                          2789  * get value from line .. continued
00081626                          2790                              * wasn't any sort of number so ...
00081626                          2791  LAB_1BF3
00081626  B03C 0028               2792      CMP.b       #'(',d0         * compare with "("
0008162A  6642                    2793      BNE.s       LAB_1C18            * if not "(" get (var) and return value in FAC1
0008162C                          2794                              * and $ flag
0008162C                          2795  
0008162C                          2796  
0008162C                          2797  *************************************************************************************
0008162C                          2798  *
0008162C                          2799  * evaluate expression within parentheses
0008162C                          2800  
0008162C                          2801  LAB_1BF7
0008162C  6100 FEB6               2802      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00081630                          2803  
00081630                          2804  
00081630                          2805  *************************************************************************************
00081630                          2806  *
00081630                          2807  * all the 'scan for' routines return the character after the sought character
00081630                          2808  
00081630                          2809  * scan for ")", else do syntax error, then warm start
00081630                          2810  
00081630                          2811  LAB_1BFB
00081630  7029                    2812      MOVEQ       #$29,d0         * load d0 with ")"
00081632  6006                    2813      BRA.s       LAB_SCCA
00081634                          2814  
00081634                          2815  
00081634                          2816  *************************************************************************************
00081634                          2817  *
00081634                          2818  * scan for "," and get byte, else do Syntax error then warm start
00081634                          2819  
00081634                          2820  LAB_SCGB
00081634  487A 0976               2821      PEA     LAB_GTBY(pc)        * return address is to get byte parameter
00081638                          2822  
00081638                          2823  
00081638                          2824  *************************************************************************************
00081638                          2825  *
00081638                          2826  * scan for ",", else do syntax error, then warm start
00081638                          2827  
00081638                          2828  LAB_1C01
00081638  702C                    2829      MOVEQ       #$2C,d0         * load d0 with ","
0008163A                          2830  
0008163A                          2831  
0008163A                          2832  *************************************************************************************
0008163A                          2833  *
0008163A                          2834  * scan for CHR$(d0) , else do syntax error, then warm start
0008163A                          2835  
0008163A                          2836  LAB_SCCA
0008163A  B01D                    2837      CMP.b       (a5)+,d0            * check next byte is = d0
0008163C  6706                    2838      BEQ.s       LAB_GBYT            * if so go get next
0008163E                          2839  
0008163E  6000 F3C4               2840      BRA     LAB_SNER            * else do syntax error/warm start
00081642                          2841  
00081642                          2842  
00081642                          2843  *************************************************************************************
00081642                          2844  *
00081642                          2845  * BASIC increment and scan memory routine
00081642                          2846  
00081642                          2847  LAB_IGBY
00081642  101D                    2848      MOVE.b  (a5)+,d0            * get byte & increment pointer
00081644                          2849  
00081644                          2850  * scan memory routine, exit with Cb = 1 if numeric character
00081644                          2851  * also skips any spaces encountered
00081644                          2852  
00081644                          2853  LAB_GBYT
00081644  1015                    2854      MOVE.b  (a5),d0         * get byte
00081646                          2855  
00081646  B03C 0020               2856      CMP.b       #$20,d0         * compare with " "
0008164A  67F6                    2857      BEQ.s       LAB_IGBY            * if " " go do next
0008164C                          2858  
0008164C                          2859  * test current BASIC byte, exit with Cb = 1 if numeric character
0008164C                          2860  
0008164C  B03C 00A9               2861      CMP.b       #TK_ELSE,d0         * compare with the token for ELSE
00081650  640C                    2862      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00081652                          2863  
00081652  B03C 003A               2864      CMP.b       #$3A,d0         * compare with ":"
00081656  6406                    2865      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00081658                          2866  
00081658  7CD0                    2867      MOVEQ       #$D0,d6         * set -"0"
0008165A  D006                    2868      ADD.b       d6,d0               * add -"0"
0008165C  9006                    2869      SUB.b       d6,d0               * subtract -"0"
0008165E                          2870  RTS_001                     * carry set if byte = "0"-"9"
0008165E  4E75                    2871      RTS
00081660                          2872  
00081660                          2873  
00081660                          2874  *************************************************************************************
00081660                          2875  *
00081660                          2876  * set-up for - operator
00081660                          2877  
00081660                          2878  LAB_1C11
00081660  6100 FE6A               2879      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00081664  7228                    2880      MOVEQ   #(TK_GT-TK_PLUS)*4,d1       * set offset from base to - operator
00081666                          2881  LAB_1C13
00081666  4FEF 0004               2882      LEA     4(sp),sp            * dump GVAL return address
0008166A  6000 FF0C               2883      BRA     LAB_1B1D            * continue evaluating expression
0008166E                          2884  
0008166E                          2885  
0008166E                          2886  *************************************************************************************
0008166E                          2887  *
0008166E                          2888  * variable name set-up
0008166E                          2889  * get (var), return value in FAC_1 & data type flag
0008166E                          2890  
0008166E                          2891  LAB_1C18
0008166E  6100 01E2               2892      BSR     LAB_GVAR            * get variable address in a0
00081672                          2893  
00081672                          2894  * if you want a non existant variable to return a null value then set the novar
00081672                          2895  * value at the top of this file to some non zero value
00081672                          2896  
00081672                 FALSE    2897   ifne   novar
00081672                          2898   endc
00081672                          2899  
00081672                          2900  * return existing variable value
00081672                          2901  
00081672                          2902  LAB_1C19
00081672  4A2B 05B5               2903      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00081676                          2904                              * $00=float
00081676  6700 0D8E               2905      BEQ     LAB_UFAC            * if float unpack memory (a0) into FAC1 and
0008167A                          2906                              * return
0008167A                          2907  
0008167A  6A06                    2908      BPL.s       LAB_1C1A            * if integer unpack memory (a0) into FAC1
0008167C                          2909                              * and return
0008167C                          2910  
0008167C  2748 0590               2911      MOVE.l  a0,FAC1_m(a3)       * else save descriptor pointer in FAC1
00081680  4E75                    2912      RTS
00081682                          2913  
00081682                          2914  LAB_1C1A
00081682  2010                    2915      MOVE.l  (a0),d0         * get integer value
00081684  6000 04BC               2916      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00081688                          2917  
00081688                          2918  
00081688                          2919  *************************************************************************************
00081688                          2920  *
00081688                          2921  * get value from line .. continued
00081688                          2922  * do tokens
00081688                          2923  
00081688                          2924  LAB_1BD0
00081688  B03C 00B3               2925      CMP.b       #TK_MINUS,d0        * compare with token for -
0008168C  67D2                    2926      BEQ.s       LAB_1C11            * branch if - token (do set-up for - operator)
0008168E                          2927  
0008168E                          2928                              * wasn't -123 so ...
0008168E  B03C 00B2               2929      CMP.b       #TK_PLUS,d0         * compare with token for +
00081692  6700 FF5C               2930      BEQ     LAB_GVAL            * branch if + token (+n = n so ignore leading +)
00081696                          2931  
00081696  B03C 00AE               2932      CMP.b       #TK_NOT,d0          * compare with token for NOT
0008169A  6606                    2933      BNE.s       LAB_1BE7            * branch if not token for NOT
0008169C                          2934  
0008169C                          2935                              * was NOT token
0008169C  323C 002C               2936      MOVE.w  #(TK_EQUAL-TK_PLUS)*4,d1    * offset to NOT function
000816A0  60C4                    2937      BRA.s       LAB_1C13            * do set-up for function then execute
000816A2                          2938  
000816A2                          2939                              * wasn't +, - or NOT so ...
000816A2                          2940  LAB_1BE7
000816A2  B03C 00AB               2941      CMP.b       #TK_FN,d0           * compare with token for FN
000816A6  6700 0514               2942      BEQ     LAB_201E            * if FN go evaluate FNx
000816AA                          2943  
000816AA                          2944                              * wasn't +, -, NOT or FN so ...
000816AA  0400 00BF               2945      SUB.b       #TK_SGN,d0          * compare with token for SGN & normalise
000816AE  6500 F354               2946      BCS     LAB_SNER            * if < SGN token then do syntax error
000816B2                          2947  
000816B2                          2948  * get value from line .. continued
000816B2                          2949  * only functions left so set up function references
000816B2                          2950  
000816B2                          2951  * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
000816B2                          2952  * to process function calls. now the function vector is computed and pushed on the stack
000816B2                          2953  * and the preprocess offset is read. if the preprocess offset is non zero then the vector
000816B2                          2954  * is calculated and the routine called, if not this routine just does RTS. whichever
000816B2                          2955  * happens the RTS at the end of this routine, or the preprocess routine calls, the
000816B2                          2956  * function code
000816B2                          2957  
000816B2                          2958  * this also removes some less than elegant code that was used to bypass type checking
000816B2                          2959  * for functions that returned strings
000816B2                          2960  
000816B2  C07C 007F               2961      AND.w       #$7F,d0         * mask byte
000816B6  D040                    2962      ADD.w       d0,d0               * *2 (2 bytes per function offset)
000816B8                          2963  
000816B8  41FA 20A4               2964      LEA     LAB_FTBL(pc),a0     * pointer to functions vector table
000816BC  3230 0000               2965      MOVE.w  (a0,d0.w),d1        * get function vector offset
000816C0  4870 1000               2966      PEA     (a0,d1.w)           * push function vector
000816C4                          2967  
000816C4  41FA 204C               2968      LEA     LAB_FTPP(pc),a0     * pointer to functions preprocess vector table
000816C8  3030 0000               2969      MOVE.w  (a0,d0.w),d0        * get function preprocess vector offset
000816CC  6712                    2970      BEQ.s       LAB_1C2A            * no preprocess vector so go do function
000816CE                          2971  
000816CE  41F0 0000               2972      LEA     (a0,d0.w),a0        * get function preprocess vector
000816D2  4ED0                    2973      JMP     (a0)                * go do preprocess routine then function
000816D4                          2974  
000816D4                          2975  
000816D4                          2976  *************************************************************************************
000816D4                          2977  *
000816D4                          2978  * process string expression in parenthesis
000816D4                          2979  
000816D4                          2980  LAB_PPFS
000816D4  6100 FF56               2981      BSR     LAB_1BF7            * process expression in parenthesis
000816D8  4A2B 05B5               2982      TST.b       Dtypef(a3)          * test data type
000816DC  6A00 F2FA               2983      BPL     LAB_TMER            * if numeric do Type missmatch Error/warm start
000816E0                          2984  
000816E0                          2985  LAB_1C2A
000816E0  4E75                    2986      RTS                     * else do function
000816E2                          2987  
000816E2                          2988  
000816E2                          2989  *************************************************************************************
000816E2                          2990  *
000816E2                          2991  * process numeric expression in parenthesis
000816E2                          2992  
000816E2                          2993  LAB_PPFN
000816E2  6100 FF48               2994      BSR     LAB_1BF7            * process expression in parenthesis
000816E6  4A2B 05B5               2995      TST.b       Dtypef(a3)          * test data type
000816EA  6B00 F2EC               2996      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
000816EE                          2997  
000816EE  4E75                    2998      RTS                     * else do function
000816F0                          2999  
000816F0                          3000  
000816F0                          3001  *************************************************************************************
000816F0                          3002  *
000816F0                          3003  * set numeric data type and increment BASIC execute pointer
000816F0                          3004  
000816F0                          3005  LAB_PPBI
000816F0  177C 0000 05B5          3006      MOVE.b  #$00,Dtypef(a3)     * clear data type flag, $00=float
000816F6  101D                    3007      MOVE.b  (a5)+,d0            * get next BASIC byte
000816F8  4E75                    3008      RTS                     * do function
000816FA                          3009  
000816FA                          3010  
000816FA                          3011  *************************************************************************************
000816FA                          3012  *
000816FA                          3013  * process string for LEFT$, RIGHT$ or MID$
000816FA                          3014  
000816FA                          3015  LAB_LRMS
000816FA  6100 FDE8               3016      BSR     LAB_EVEZ            * evaluate (should be string) expression
000816FE  4A2B 05B5               3017      TST.b       Dtypef(a3)          * test data type flag
00081702  6A00 F2D4               3018      BPL     LAB_TMER            * if type is not string do type mismatch error
00081706                          3019  
00081706  141D                    3020      MOVE.b  (a5)+,d2            * get BASIC byte
00081708  B43C 002C               3021      CMP.b       #',',d2         * compare with comma
0008170C  6600 F2F6               3022      BNE     LAB_SNER            * if not "," go do syntax error/warm start
00081710                          3023  
00081710  2F2B 0590               3024      MOVE.l  FAC1_m(a3),-(sp)        * save descriptor pointer
00081714  6100 08AA               3025      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00081718  205F                    3026      MOVEA.l (sp)+,a0            * restore descriptor pointer
0008171A  4E75                    3027      RTS                     * do function
0008171C                          3028  
0008171C                          3029  
0008171C                          3030  *************************************************************************************
0008171C                          3031  *
0008171C                          3032  * process numeric expression(s) for BIN$ or HEX$
0008171C                          3033  
0008171C                          3034  LAB_BHSS
0008171C  6100 FDC6               3035      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00081720  4A2B 05B5               3036      TST.b       Dtypef(a3)          * test data type
00081724  6B00 F2B2               3037      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00081728                          3038  
00081728  6100 0DCE               3039      BSR     LAB_2831            * convert FAC1 floating to fixed
0008172C                          3040                              * result in d0 and Itemp
0008172C  7200                    3041      MOVEQ       #0,d1               * set default to no leading "0"s
0008172E  141D                    3042      MOVE.b  (a5)+,d2            * get BASIC byte
00081730  B43C 002C               3043      CMP.b       #',',d2         * compare with comma
00081734  660C                    3044      BNE.s       LAB_BHCB            * if not "," go check close bracket
00081736                          3045  
00081736  2F00                    3046      MOVE.l  d0,-(sp)            * copy number to stack
00081738  6100 0872               3047      BSR     LAB_GTBY            * get byte value
0008173C  2200                    3048      MOVE.l  d0,d1               * copy leading 0s #
0008173E  201F                    3049      MOVE.l  (sp)+,d0            * restore number from stack
00081740  141D                    3050      MOVE.b  (a5)+,d2            * get BASIC byte
00081742                          3051  LAB_BHCB
00081742  B43C 0029               3052      CMP.b       #')',d2         * compare with close bracket
00081746  6600 F2BC               3053      BNE     LAB_SNER            * if not ")" do Syntax Error/warm start
0008174A                          3054  
0008174A  4E75                    3055      RTS                     * go do function
0008174C                          3056  
0008174C                          3057  
0008174C                          3058  *************************************************************************************
0008174C                          3059  *
0008174C                          3060  * perform EOR
0008174C                          3061  
0008174C                          3062  LAB_EOR
0008174C  6116                    3063      BSR.s       GetFirst            * get two values for OR, AND or EOR
0008174E                          3064                              * first in d0, and Itemp, second in d2
0008174E  B580                    3065      EOR.l       d2,d0               * EOR values
00081750  6000 03F0               3066      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00081754                          3067  
00081754                          3068  
00081754                          3069  *************************************************************************************
00081754                          3070  *
00081754                          3071  * perform OR
00081754                          3072  
00081754                          3073  LAB_OR
00081754  610E                    3074      BSR.s       GetFirst            * get two values for OR, AND or EOR
00081756                          3075                              * first in d0, and Itemp, second in d2
00081756  8082                    3076      OR.l        d2,d0               * do OR
00081758  6000 03E8               3077      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
0008175C                          3078  
0008175C                          3079  
0008175C                          3080  *************************************************************************************
0008175C                          3081  *
0008175C                          3082  * perform AND
0008175C                          3083  
0008175C                          3084  LAB_AND
0008175C  6106                    3085      BSR.s       GetFirst            * get two values for OR, AND or EOR
0008175E                          3086                              * first in d0, and Itemp, second in d2
0008175E  C082                    3087      AND.l       d2,d0               * do AND
00081760  6000 03E0               3088      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00081764                          3089  
00081764                          3090  
00081764                          3091  *************************************************************************************
00081764                          3092  *
00081764                          3093  * get two values for OR, AND, EOR
00081764                          3094  * first in d0, second in d2
00081764                          3095  
00081764                          3096  GetFirst
00081764  6100 0228               3097      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00081768                          3098                              * result in d0 and Itemp
00081768  2400                    3099      MOVE.l  d0,d2               * copy second value
0008176A  6100 0CF4               3100      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
0008176E                          3101                              * expression
0008176E  6000 021E               3102      BRA     LAB_EVIR            * evaluate integer expression (no sign check)
00081772                          3103                              * result in d0 and Itemp & return
00081772                          3104  
00081772                          3105  
00081772                          3106  *************************************************************************************
00081772                          3107  *
00081772                          3108  * perform NOT
00081772                          3109  
00081772                          3110  LAB_EQUAL
00081772  6100 021A               3111      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00081776                          3112                              * result in d0 and Itemp
00081776  4680                    3113      NOT.l       d0              * bitwise invert
00081778  6000 03C8               3114      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
0008177C                          3115  
0008177C                          3116  
0008177C                          3117  *************************************************************************************
0008177C                          3118  *
0008177C                          3119  * perform comparisons
0008177C                          3120  * do < compare
0008177C                          3121  
0008177C                          3122  LAB_LTHAN
0008177C  6100 FD50               3123      BSR     LAB_CKTM            * type match check, set C for string
00081780  6506                    3124      BCS.s       LAB_1CAE            * branch if string
00081782                          3125  
00081782                          3126                              * do numeric < compare
00081782  6100 0D48               3127      BSR     LAB_27FA            * compare FAC1 with FAC2
00081786                          3128                              * returns d0=+1 if FAC1 > FAC2
00081786                          3129                              * returns d0= 0 if FAC1 = FAC2
00081786                          3130                              * returns d0=-1 if FAC1 < FAC2
00081786  6042                    3131      BRA.s       LAB_1CF2            * process result
00081788                          3132  
00081788                          3133                              * do string < compare
00081788                          3134  LAB_1CAE
00081788  177C 0000 05B5          3135      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
0008178E                          3136                              * $00=float
0008178E  6100 06BC               3137      BSR     LAB_22B6            * pop string off descriptor stack, or from top
00081792                          3138                              * of string space returns d0 = length,
00081792                          3139                              * a0 = pointer
00081792  2248                    3140      MOVEA.l a0,a1               * copy string 2 pointer
00081794  2200                    3141      MOVE.l  d0,d1               * copy string 2 length
00081796  206B 0598               3142      MOVEA.l FAC2_m(a3),a0       * get string 1 descriptor pointer
0008179A  6100 06B4               3143      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
0008179E                          3144                              * d0 = length, a0 = pointer
0008179E  2400                    3145      MOVE.l  d0,d2               * copy length
000817A0  6604                    3146      BNE.s       LAB_1CB5            * branch if not null string
000817A2                          3147  
000817A2  4A81                    3148      TST.l       d1              * test if string 2 is null also
000817A4  6724                    3149      BEQ.s       LAB_1CF2            * if so do string 1 = string 2
000817A6                          3150  
000817A6                          3151  LAB_1CB5
000817A6  9481                    3152      SUB.l       d1,d2               * subtract string 2 length
000817A8  670C                    3153      BEQ.s       LAB_1CD5            * branch if strings = length
000817AA                          3154  
000817AA  6504                    3155      BCS.s       LAB_1CD4            * branch if string 1 < string 2
000817AC                          3156  
000817AC  70FF                    3157      MOVEQ       #-1,d0          * set for string 1 > string 2
000817AE  6008                    3158      BRA.s       LAB_1CD6            * go do character comapare
000817B0                          3159  
000817B0                          3160  LAB_1CD4
000817B0  2200                    3161      MOVE.l  d0,d1               * string 1 length is compare length
000817B2  7001                    3162      MOVEQ       #1,d0               * and set for string 1 < string 2
000817B4  6002                    3163      BRA.s       LAB_1CD6            * go do character comapare
000817B6                          3164  
000817B6                          3165  LAB_1CD5
000817B6  2002                    3166      MOVE.l  d2,d0               * set for string 1 = string 2
000817B8                          3167  LAB_1CD6
000817B8  5381                    3168      SUBQ.l  #1,d1               * adjust length for DBcc loop
000817BA                          3169  
000817BA                          3170                              * d1 is length to compare, d0 is <=> for length
000817BA                          3171                              * a0 is string 1 pointer, a1 is string 2 pointer
000817BA                          3172  LAB_1CE6
000817BA  B308                    3173      CMPM.b  (a0)+,(a1)+         * compare string bytes (1 with 2)
000817BC  56C9 FFFC               3174      DBNE        d1,LAB_1CE6         * loop if same and not end yet
000817C0                          3175  
000817C0  6708                    3176      BEQ.s       LAB_1CF2            * if = to here, then go use length compare
000817C2                          3177  
000817C2  6404                    3178      BCC.s       LAB_1CDB            * else branch if string 1 > string 2
000817C4                          3179  
000817C4  70FF                    3180      MOVEQ       #-1,d0          * else set for string 1 < string 2
000817C6  6002                    3181      BRA.s       LAB_1CF2            * go set result
000817C8                          3182  
000817C8                          3183  LAB_1CDB
000817C8  7001                    3184      MOVEQ       #1,d0               * and set for string 1 > string 2
000817CA                          3185  
000817CA                          3186  LAB_1CF2
000817CA  5200                    3187      ADDQ.b  #1,d0               * make result 0, 1 or 2
000817CC  1200                    3188      MOVE.b  d0,d1               * copy to d1
000817CE  7001                    3189      MOVEQ       #1,d0               * set d0 longword
000817D0  E338                    3190      ROL.b       d1,d0               * make 1, 2 or 4 (result = flag bit)
000817D2  C02B 05E1               3191      AND.b       Cflag(a3),d0        * AND with comparison evaluation flag
000817D6  6700 0CDC               3192      BEQ     LAB_27DB            * exit if not a wanted result (i.e. false)
000817DA                          3193  
000817DA  70FF                    3194      MOVEQ       #-1,d0          * else set -1 (true)
000817DC  6000 0CD6               3195      BRA     LAB_27DB            * save d0 as integer & return
000817E0                          3196  
000817E0                          3197  
000817E0                          3198  LAB_1CFE
000817E0  6100 FE56               3199      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
000817E4                          3200  
000817E4                          3201  
000817E4                          3202  *************************************************************************************
000817E4                          3203  *
000817E4                          3204  * perform DIM
000817E4                          3205  
000817E4                          3206  LAB_DIM
000817E4  72FF                    3207      MOVEQ       #-1,d1          * set "DIM" flag
000817E6  6170                    3208      BSR.s       LAB_1D10            * search for or dimension a variable
000817E8  6100 FE5A               3209      BSR     LAB_GBYT            * scan memory
000817EC  66F2                    3210      BNE.s       LAB_1CFE            * loop and scan for "," if not null
000817EE                          3211  
000817EE  4E75                    3212      RTS
000817F0                          3213  
000817F0                          3214  
000817F0                          3215  *************************************************************************************
000817F0                          3216  *
000817F0                          3217  * perform << (left shift)
000817F0                          3218  
000817F0                          3219  LAB_LSHIFT
000817F0  612E                    3220      BSR.s       GetPair         * get an integer and byte pair
000817F2                          3221                              * byte is in d2, integer is in d0 and Itemp
000817F2  6708                    3222      BEQ.s       NoShift         * branch if byte zero
000817F4                          3223  
000817F4  B43C 0020               3224      CMP.b       #$20,d2         * compare bit count with 32d
000817F8  6420                    3225      BCC.s       TooBig          * branch if >=
000817FA                          3226  
000817FA  E5A0                    3227      ASL.l       d2,d0               * shift longword
000817FC                          3228  NoShift
000817FC  6000 0344               3229      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00081800                          3230  
00081800                          3231  
00081800                          3232  *************************************************************************************
00081800                          3233  *
00081800                          3234  * perform >> (right shift)
00081800                          3235  
00081800                          3236  LAB_RSHIFT
00081800  611E                    3237      BSR.s       GetPair         * get an integer and byte pair
00081802                          3238                              * byte is in d2, integer is in d0 and Itemp
00081802  67F8                    3239      BEQ.s       NoShift         * branch if byte zero
00081804                          3240  
00081804  B43C 0020               3241      CMP.b       #$20,d2         * compare bit count with 32d
00081808  650A                    3242      BCS.s       Not2Big         * branch if >= (return shift)
0008180A                          3243  
0008180A  4A80                    3244      TST.l       d0              * test sign bit
0008180C  6A0C                    3245      BPL.s       TooBig          * branch if +ve
0008180E                          3246  
0008180E  70FF                    3247      MOVEQ       #-1,d0          * set longword
00081810  6000 0330               3248      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00081814                          3249  
00081814                          3250  Not2Big
00081814  E4A0                    3251      ASR.l       d2,d0               * shift longword
00081816  6000 032A               3252      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
0008181A                          3253  
0008181A                          3254  TooBig
0008181A  7000                    3255      MOVEQ       #0,d0               * clear longword
0008181C  6000 0324               3256      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00081820                          3257  
00081820                          3258  
00081820                          3259  *************************************************************************************
00081820                          3260  *
00081820                          3261  * get an integer and byte pair
00081820                          3262  * byte is in d2, integer is in d0 and Itemp
00081820                          3263  
00081820                          3264  GetPair
00081820  6100 078E               3265      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00081824                          3266                              * Itemp
00081824  1400                    3267      MOVE.b  d0,d2               * save it
00081826  6100 0C38               3268      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
0008182A                          3269                              * expression
0008182A  6100 0162               3270      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
0008182E                          3271                              * result in d0 and Itemp
0008182E  4A02                    3272      TST.b       d2              * test byte value
00081830  4E75                    3273      RTS
00081832                          3274  
00081832                          3275  
00081832                          3276  *************************************************************************************
00081832                          3277  *
00081832                          3278  * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
00081832                          3279  
00081832                          3280  LAB_CASC
00081832  B03C 0061               3281      CMP.b       #$61,d0         * compare with "a"
00081836  6410                    3282      BCC.s       LAB_1D83            * if >="a" go check =<"z"
00081838                          3283  
00081838                          3284  
00081838                          3285  *************************************************************************************
00081838                          3286  *
00081838                          3287  * check alpha upper case, return C=0 if<"A" or >"Z"
00081838                          3288  
00081838                          3289  LAB_CAUC
00081838  B03C 0041               3290      CMP.b       #$41,d0         * compare with "A"
0008183C  6404                    3291      BCC.s       LAB_1D8A            * if >="A" go check =<"Z"
0008183E                          3292  
0008183E  8040                    3293      OR      d0,d0               * make C=0
00081840  4E75                    3294      RTS
00081842                          3295  
00081842                          3296  LAB_1D8A
00081842  B03C 005B               3297      CMP.b       #$5B,d0         * compare with "Z"+1
00081846                          3298                              * carry set if byte<="Z"
00081846  4E75                    3299      RTS
00081848                          3300  
00081848                          3301  LAB_1D83
00081848  B03C 007B               3302      CMP.b       #$7B,d0         * compare with "z"+1
0008184C                          3303                              * carry set if byte<="z"
0008184C  4E75                    3304      RTS
0008184E                          3305  
0008184E                          3306  
0008184E                          3307  *************************************************************************************
0008184E                          3308  *
0008184E                          3309  * search for or create variable. this is used to automatically create a variable if
0008184E                          3310  * it is not found. any routines that need to create the variable call LAB_GVAR via
0008184E                          3311  * this point and error generation is supressed and the variable will be created
0008184E                          3312  *
0008184E                          3313  * return pointer to variable in Cvaral and a0
0008184E                          3314  * set data type to variable type
0008184E                          3315  
0008184E                          3316  LAB_SVAR
0008184E  6102                    3317      BSR.s       LAB_GVAR            * search for variable
00081850                          3318  LAB_FVAR
00081850  4E75                    3319      RTS
00081852                          3320  
00081852                          3321  
00081852                          3322  *************************************************************************************
00081852                          3323  *
00081852                          3324  * search for variable. if this routine is called from anywhere but the above call and
00081852                          3325  * the variable searched for does not exist then an error will be returned
00081852                          3326  *
00081852                          3327  * DIM flag is in d1.b
00081852                          3328  * return pointer to variable in Cvaral and a0
00081852                          3329  * set data type to variable type
00081852                          3330  
00081852                          3331  LAB_GVAR
00081852  7200                    3332      MOVEQ       #$00,d1         * set DIM flag = $00
00081854  6100 FDEE               3333      BSR     LAB_GBYT            * scan memory (1st character)
00081858                          3334  LAB_1D10
00081858  1741 05B4               3335      MOVE.b  d1,Defdim(a3)       * save DIM flag
0008185C                          3336  
0008185C                          3337  * search for FN name entry point
0008185C                          3338  
0008185C                          3339  LAB_1D12
0008185C  61D4                    3340      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
0008185E  6400 F1A4               3341      BCC     LAB_SNER            * if not, syntax error then warm start
00081862                          3342  
00081862                          3343                              * it is a variable name so ...
00081862  7200                    3344      MOVEQ       #$0,d1          * set index for name byte
00081864  41EB 046A               3345      LEA     Varname(a3),a0      * pointer to variable name
00081868  2081                    3346      MOVE.l  d1,(a0)         * clear the variable name
0008186A  1741 05B5               3347      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
0008186E                          3348                              * $00=float
0008186E                          3349  
0008186E                          3350  LAB_1D2D
0008186E  B27C 0004               3351      CMP.w       #$04,d1         * done all significant characters?
00081872  6406                    3352      BCC.s       LAB_1D2E            * if so go ignore any more
00081874                          3353  
00081874  1180 1000               3354      MOVE.b  d0,(a0,d1.w)        * save the character
00081878  5241                    3355      ADDQ.w  #1,d1               * increment index
0008187A                          3356  LAB_1D2E
0008187A  6100 FDC6               3357      BSR     LAB_IGBY            * increment & scan memory (next character)
0008187E  65EE                    3358      BCS.s       LAB_1D2D            * branch if character = "0"-"9" (ok)
00081880                          3359  
00081880                          3360                              * character wasn't "0" to "9" so ...
00081880  61B0                    3361      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00081882  65EA                    3362      BCS.s       LAB_1D2D            * branch if = "A"-"Z" (ok)
00081884                          3363  
00081884                          3364                              * check if string variable
00081884  B03C 0024               3365      CMP.b       #'$',d0         * compare with "$"
00081888  660C                    3366      BNE.s       LAB_1D44            * branch if not string
0008188A                          3367  
0008188A                          3368                              * type is string
0008188A  002B 0080 046B          3369      OR.b        #$80,Varname+1(a3)  * set top bit of 2nd character, indicate string
00081890  6100 FDB0               3370      BSR     LAB_IGBY            * increment & scan memory
00081894  6010                    3371      BRA.s       LAB_1D45            * skip integer check
00081896                          3372  
00081896                          3373                              * check if integer variable
00081896                          3374  LAB_1D44
00081896  B03C 0026               3375      CMP.b       #'&',d0         * compare with "&"
0008189A  660A                    3376      BNE.s       LAB_1D45            * branch if not integer
0008189C                          3377  
0008189C                          3378                              * type is integer
0008189C  002B 0080 046C          3379      OR.b        #$80,Varname+2(a3)  * set top bit of 3rd character, indicate integer
000818A2  6100 FD9E               3380      BSR     LAB_IGBY            * increment & scan memory
000818A6                          3381  
000818A6                          3382  * after we have determined the variable type we need to determine
000818A6                          3383  * if it's an array of type
000818A6                          3384  
000818A6                          3385                              * gets here with character after var name in d0
000818A6                          3386  LAB_1D45
000818A6  4A2B 05DF               3387      TST.b       Sufnxf(a3)          * test function name flag
000818AA  670E                    3388      BEQ.s       LAB_1D48            * if not FN or FN variable continue
000818AC                          3389  
000818AC  6A14                    3390      BPL.s       LAB_1D49            * if FN variable go find or create it
000818AE                          3391  
000818AE                          3392                              * else was FN name
000818AE  202B 046A               3393      MOVE.l  Varname(a3),d0      * get whole function name
000818B2  7208                    3394      MOVEQ       #8,d1               * set step to next function size -4
000818B4  41EB 0432               3395      LEA     Sfncl(a3),a0        * get pointer to start of functions
000818B8  601C                    3396      BRA.s       LAB_1D4B            * go find function
000818BA                          3397  
000818BA                          3398  LAB_1D48
000818BA  0400 0028               3399      SUB.b       #'(',d0         * subtract "("
000818BE  6700 00F4               3400      BEQ     LAB_1E17            * if "(" go find, or make, array
000818C2                          3401  
000818C2                          3402  * either find or create var
000818C2                          3403  * var name (1st four characters only!) is in Varname
000818C2                          3404  
000818C2                          3405                              * variable name wasn't var( .. so look for
000818C2                          3406                              * plain variable
000818C2                          3407  LAB_1D49
000818C2  202B 046A               3408      MOVE.l  Varname(a3),d0      * get whole variable name
000818C6                          3409  LAB_1D4A
000818C6  7204                    3410      MOVEQ       #4,d1               * set step to next variable size -4
000818C8  41EB 0436               3411      LEA     Svarl(a3),a0        * get pointer to start of variables
000818CC                          3412  
000818CC  0800 0017               3413      BTST.l  #23,d0          * test if string name
000818D0  6704                    3414      BEQ.s       LAB_1D4B            * branch if not
000818D2                          3415  
000818D2  5441                    3416      ADDQ.w  #2,d1               * 6 bytes per string entry
000818D4  5848                    3417      ADDQ.w  #(Sstrl-Svarl),a0       * move to string area
000818D6                          3418  
000818D6                          3419  LAB_1D4B
000818D6  2268 0004               3420      MOVEA.l 4(a0),a1            * get end address
000818DA  2050                    3421      MOVEA.l (a0),a0         * get start address
000818DC  6006                    3422      BRA.s       LAB_1D5E            * enter loop at exit check
000818DE                          3423  
000818DE                          3424  LAB_1D5D
000818DE  B098                    3425      CMP.l       (a0)+,d0            * compare this variable with name
000818E0  6776                    3426      BEQ.s       LAB_1DD7            * branch if match (found var)
000818E2                          3427  
000818E2  D1C1                    3428      ADDA.l  d1,a0               * add offset to next variable
000818E4                          3429  LAB_1D5E
000818E4  B1C9                    3430      CMPA.l  a1,a0               * compare address with variable space end
000818E6  66F6                    3431      BNE.s       LAB_1D5D            * if not end go check next
000818E8                          3432  
000818E8  4A2B 05DF               3433      TST.b       Sufnxf(a3)          * is it a function or function variable
000818EC  660A                    3434      BNE.s       LAB_1D94            * if was go do DEF or function variable
000818EE                          3435  
000818EE                          3436                              * reached end of variable mem without match
000818EE                          3437                              * ... so create new variable, possibly
000818EE                          3438  
000818EE  45FA FF60               3439      LEA     LAB_FVAR(pc),a2     * get the address of the create if doesn't
000818F2                          3440                              * exist call to LAB_GVAR
000818F2  B5D7                    3441      CMPA.l  (sp),a2         * compare the return address with expected
000818F4  6600 F0CA               3442      BNE     LAB_UVER            * if not create go do error or return null
000818F8                          3443  
000818F8                          3444  * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
000818F8                          3445  
000818F8                          3446  LAB_1D94
000818F8  082B 0000 05DF          3447      BTST.b  #0,Sufnxf(a3)       * test function search flag
000818FE  6600 F0C8               3448      BNE     LAB_UFER            * if not doing DEF then go do undefined
00081902                          3449                              * function error
00081902                          3450  
00081902                          3451                              * else create new variable/function
00081902                          3452  LAB_1D98
00081902  246B 0442               3453      MOVEA.l Earryl(a3),a2       * get end of block to move
00081906  240A                    3454      MOVE.l  a2,d2               * copy end of block to move
00081908  9489                    3455      SUB.l       a1,d2               * calculate block to move size
0008190A                          3456  
0008190A  204A                    3457      MOVEA.l a2,a0               * copy end of block to move
0008190C  5881                    3458      ADDQ.l  #4,d1               * space for one variable/function + name
0008190E  D5C1                    3459      ADDA.l  d1,a2               * add space for one variable/function
00081910  274A 0442               3460      MOVE.l  a2,Earryl(a3)       * set new array mem end
00081914  E28A                    3461      LSR.l       #1,d2               * /2 for word copy
00081916  6712                    3462      BEQ.s       LAB_1DAF            * skip move if zero length block
00081918                          3463  
00081918  5382                    3464      SUBQ.l  #1,d2               * -1 for DFB loop
0008191A  4842                    3465      SWAP        d2              * swap high word to low word
0008191C                          3466  LAB_1DAC
0008191C  4842                    3467      SWAP        d2              * swap high word to low word
0008191E                          3468  LAB_1DAE
0008191E  3520                    3469      MOVE.w  -(a0),-(a2)         * copy word
00081920  51CA FFFC               3470      DBF     d2,LAB_1DAE         * loop until done
00081924                          3471  
00081924  4842                    3472      SWAP        d2              * swap high word to low word
00081926  51CA FFF4               3473      DBF     d2,LAB_1DAC         * decrement high count and loop until done
0008192A                          3474  
0008192A                          3475  * get here after creating either a function, variable or string
0008192A                          3476  * if function set variables start, string start, array start
0008192A                          3477  * if variable set string start, array start
0008192A                          3478  * if string set array start
0008192A                          3479  
0008192A                          3480  LAB_1DAF
0008192A  4A2B 05DF               3481      TST.b       Sufnxf(a3)          * was it function
0008192E  6B08                    3482      BMI.s       LAB_1DB0            * branch if was FN
00081930                          3483  
00081930  0800 0017               3484      BTST.l  #23,d0          * was it string
00081934  660A                    3485      BNE.s       LAB_1DB2            * branch if string
00081936                          3486  
00081936  6004                    3487      BRA.s       LAB_1DB1            * branch if was plain variable
00081938                          3488  
00081938                          3489  LAB_1DB0
00081938  D3AB 0436               3490      ADD.l       d1,Svarl(a3)        * set new variable memory start
0008193C                          3491  LAB_1DB1
0008193C  D3AB 043A               3492      ADD.l       d1,Sstrl(a3)        * set new start of strings
00081940                          3493  LAB_1DB2
00081940  D3AB 043E               3494      ADD.l       d1,Sarryl(a3)       * set new array memory start
00081944  20C0                    3495      MOVE.l  d0,(a0)+            * save variable/function name
00081946  20BC 00000000           3496      MOVE.l  #$00,(a0)           * initialise variable
0008194C  0800 0017               3497      BTST.l  #23,d0          * was it string
00081950  6706                    3498      BEQ.s       LAB_1DD7            * branch if not string
00081952                          3499  
00081952  317C 0000 0004          3500      MOVE.w  #$00,4(a0)          * else initialise string length
00081958                          3501  
00081958                          3502                              * found a match for var ((Vrschl) = ptr)
00081958                          3503  LAB_1DD7
00081958  2200                    3504      MOVE.l  d0,d1               * ........ $....... &....... ........
0008195A  D281                    3505      ADD.l       d1,d1               * .......$ .......& ........ .......0
0008195C  4841                    3506      SWAP        d1              * ........ .......0 .......$ .......&
0008195E  E219                    3507      ROR.b       #1,d1               * ........ .......0 .......$ &.......
00081960  E249                    3508      LSR.w       #1,d1               * ........ .......0 0....... $&......
00081962  C23C 00C0               3509      AND.b       #$C0,d1         * mask the type bits
00081966  1741 05B5               3510      MOVE.b  d1,Dtypef(a3)       * save the data type
0008196A                          3511  
0008196A  177C 0000 05DF          3512      MOVE.b  #$00,Sufnxf(a3)     * clear FN flag byte
00081970                          3513  
00081970                          3514  * if you want a non existant variable to return a null value then set the novar
00081970                          3515  * value at the top of this file to some non zero value
00081970                          3516  
00081970                 FALSE    3517   ifne   novar
00081970                          3518   endc
00081970                          3519  
00081970  4E75                    3520      RTS
00081972                          3521  
00081972                          3522  
00081972                          3523  *************************************************************************************
00081972                          3524  *
00081972                          3525  * set-up array pointer, d0, to first element in array
00081972                          3526  * set d0 to (a0)+2*(Dimcnt)+$0A
00081972                          3527  
00081972                          3528  LAB_1DE6
00081972  7005                    3529      MOVEQ       #5,d0               * set d0 to 5 (*2 = 10, later)
00081974  D02B 05DB               3530      ADD.b       Dimcnt(a3),d0       * add # of dimensions (1, 2 or 3)
00081978  D080                    3531      ADD.l       d0,d0               * *2 (bytes per dimension size)
0008197A  D088                    3532      ADD.l       a0,d0               * add array start pointer
0008197C  4E75                    3533      RTS
0008197E                          3534  
0008197E                          3535  
0008197E                          3536  *************************************************************************************
0008197E                          3537  *
0008197E                          3538  * evaluate unsigned integer expression
0008197E                          3539  
0008197E                          3540  LAB_EVIN
0008197E  6100 FCC2               3541      BSR     LAB_IGBY            * increment & scan memory
00081982  6100 FB46               3542      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00081986                          3543                              * else do type mismatch
00081986                          3544  
00081986                          3545  
00081986                          3546  *************************************************************************************
00081986                          3547  *
00081986                          3548  * evaluate positive integer expression, result in d0 and Itemp
00081986                          3549  
00081986                          3550  LAB_EVPI
00081986  4A2B 0595               3551      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
0008198A  6B00 F06C               3552      BMI     LAB_FCER            * do function call error if -ve
0008198E                          3553  
0008198E                          3554  
0008198E                          3555  *************************************************************************************
0008198E                          3556  *
0008198E                          3557  * evaluate integer expression, no sign check
0008198E                          3558  * result in d0 and Itemp, exit with flags set correctly
0008198E                          3559  
0008198E                          3560  LAB_EVIR
0008198E  0C2B 00A0 0594          3561      CMPI.b  #$A0,FAC1_e(a3)     * compare exponent with exponent = 2^32 (n>2^31)
00081994  6500 0B62               3562      BCS     LAB_2831            * convert FAC1 floating to fixed
00081998                          3563                              * result in d0 and Itemp
00081998  6600 F05E               3564      BNE     LAB_FCER            * if > do function call error, then warm start
0008199C                          3565  
0008199C  4A2B 0595               3566      TST.b       FAC1_s(a3)          * test sign of FAC1
000819A0  6A00 0B56               3567      BPL     LAB_2831            * if +ve then ok
000819A4                          3568  
000819A4  202B 0590               3569      MOVE.l  FAC1_m(a3),d0       * get mantissa
000819A8  4480                    3570      NEG.l       d0              * do -d0
000819AA  6800 F04C               3571      BVC     LAB_FCER            * if not $80000000 do FC error, then warm start
000819AE                          3572  
000819AE  2740 042A               3573      MOVE.l  d0,Itemp(a3)        * else just set it
000819B2  4E75                    3574      RTS
000819B4                          3575  
000819B4                          3576  
000819B4                          3577  *************************************************************************************
000819B4                          3578  *
000819B4                          3579  * find or make array
000819B4                          3580  
000819B4                          3581  LAB_1E17
000819B4  3F2B 05B4               3582      MOVE.w  Defdim(a3),-(sp)        * get DIM flag and data type flag (word in mem)
000819B8  7200                    3583      MOVEQ       #0,d1               * clear dimensions count
000819BA                          3584  
000819BA                          3585  * now get the array dimension(s) and stack it (them) before the data type and DIM flag
000819BA                          3586  
000819BA                          3587  LAB_1E1F
000819BA  3F01                    3588      MOVE.w  d1,-(sp)            * save dimensions count
000819BC  2F2B 046A               3589      MOVE.l  Varname(a3),-(sp)       * save variable name
000819C0  61BC                    3590      BSR.s       LAB_EVIN            * evaluate integer expression
000819C2                          3591  
000819C2  4840                    3592      SWAP        d0              * swap high word to low word
000819C4  4A40                    3593      TST.w       d0              * test swapped high word
000819C6  6600 F020               3594      BNE     LAB_ABER            * if too big do array bounds error
000819CA                          3595  
000819CA  275F 046A               3596      MOVE.l  (sp)+,Varname(a3)       * restore variable name
000819CE  321F                    3597      MOVE.w  (sp)+,d1            * restore dimensions count
000819D0  301F                    3598      MOVE.w  (sp)+,d0            * restore DIM and data type flags
000819D2  3F2B 042C               3599      MOVE.w  Itemp+2(a3),-(sp)       * stack this dimension size
000819D6  3F00                    3600      MOVE.w  d0,-(sp)            * save DIM and data type flags
000819D8  5241                    3601      ADDQ.w  #1,d1               * increment dimensions count
000819DA  6100 FC68               3602      BSR     LAB_GBYT            * scan memory
000819DE  B03C 002C               3603      CMP.b       #$2C,d0         * compare with ","
000819E2  67D6                    3604      BEQ.s       LAB_1E1F            * if found go do next dimension
000819E4                          3605  
000819E4  1741 05DB               3606      MOVE.b  d1,Dimcnt(a3)       * store dimensions count
000819E8  6100 FC46               3607      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
000819EC  375F 05B4               3608      MOVE.w  (sp)+,Defdim(a3)        * restore DIM and data type flags (word in mem)
000819F0  206B 043E               3609      MOVEA.l Sarryl(a3),a0       * get array mem start
000819F4                          3610  
000819F4                          3611  * now check to see if we are at the end of array memory (we would be if there were
000819F4                          3612  * no arrays).
000819F4                          3613  
000819F4                          3614  LAB_1E5C
000819F4  2748 05AC               3615      MOVE.l  a0,Astrtl(a3)       * save as array start pointer
000819F8  B1EB 0442               3616      CMPA.l  Earryl(a3),a0       * compare with array mem end
000819FC  672E                    3617      BEQ.s       LAB_1EA1            * go build array if not found
000819FE                          3618  
000819FE                          3619                              * search for array
000819FE  2010                    3620      MOVE.l  (a0),d0         * get this array name
00081A00  B0AB 046A               3621      CMP.l       Varname(a3),d0      * compare with array name
00081A04  670A                    3622      BEQ.s       LAB_1E8D            * array found so branch
00081A06                          3623  
00081A06                          3624                              * no match
00081A06  2068 0004               3625      MOVEA.l 4(a0),a0            * get this array size
00081A0A  D1EB 05AC               3626      ADDA.l  Astrtl(a3),a0       * add to array start pointer
00081A0E  60E4                    3627      BRA.s       LAB_1E5C            * go check next array
00081A10                          3628  
00081A10                          3629                              * found array, are we trying to dimension it?
00081A10                          3630  LAB_1E8D
00081A10  4A2B 05B4               3631      TST.b       Defdim(a3)          * are we trying to dimension it?
00081A14  6600 EFCE               3632      BNE     LAB_DDER            * if so do double dimension error/warm start
00081A18                          3633  
00081A18                          3634  * found the array and we're not dimensioning it so we must find an element in it
00081A18                          3635  
00081A18  6100 FF58               3636      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00081A1C                          3637                              * in the array
00081A1C  5048                    3638      ADDQ.w  #8,a0               * index to dimension count
00081A1E  3018                    3639      MOVE.w  (a0)+,d0            * get no of dimensions
00081A20  B02B 05DB               3640      CMP.b       Dimcnt(a3),d0       * compare with dimensions count
00081A24  6700 0094               3641      BEQ     LAB_1F28            * found array so go get element
00081A28                          3642  
00081A28  6000 EF8E               3643      BRA     LAB_WDER            * else wrong so do "Wrong dimensions" error
00081A2C                          3644  
00081A2C                          3645                              * array not found, so possibly build it
00081A2C                          3646  LAB_1EA1
00081A2C  4A2B 05B4               3647      TST.b       Defdim(a3)          * test the default DIM flag
00081A30  6700 EF8A               3648      BEQ     LAB_UDER            * if default flag is clear then we are not
00081A34                          3649                              * explicitly dimensioning an array so go
00081A34                          3650                              * do an "Undimensioned array" error
00081A34                          3651  
00081A34  6100 FF3C               3652      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00081A38                          3653                              * in the array
00081A38  202B 046A               3654      MOVE.l  Varname(a3),d0      * get array name
00081A3C  20C0                    3655      MOVE.l  d0,(a0)+            * save array name
00081A3E  7204                    3656      MOVEQ       #4,d1               * set 4 bytes per element
00081A40  0800 0017               3657      BTST.l  #23,d0          * test if string array
00081A44  6702                    3658      BEQ.s       LAB_1EDF            * branch if not string
00081A46                          3659  
00081A46  7206                    3660      MOVEQ       #6,d1               * else 6 bytes per element
00081A48                          3661  LAB_1EDF
00081A48  2741 05A8               3662      MOVE.l  d1,Asptl(a3)        * set array data size (bytes per element)
00081A4C  122B 05DB               3663      MOVE.b  Dimcnt(a3),d1       * get dimensions count
00081A50  5848                    3664      ADDQ.w  #4,a0               * skip the array size now (don't know it yet!)
00081A52  30C1                    3665      MOVE.w  d1,(a0)+            * set array's dimensions count
00081A54                          3666  
00081A54                          3667  * now calculate the array data space size
00081A54                          3668  
00081A54                          3669  LAB_1EC0
00081A54                          3670  
00081A54                          3671  * If you want arrays to dimension themselves by default then comment out the test
00081A54                          3672  * above and uncomment the next three code lines and the label LAB_1ED0
00081A54                          3673  
00081A54                          3674  *   MOVE.w  #$0A,d1         * set default dimension value, allow 0 to 9
00081A54                          3675  *   TST.b       Defdim(a3)          * test default DIM flag
00081A54                          3676  *   BNE.s       LAB_1ED0            * branch if b6 of Defdim is clear
00081A54                          3677  
00081A54  321F                    3678      MOVE.w  (sp)+,d1            * get dimension size
00081A56                          3679  *LAB_1ED0
00081A56  30C1                    3680      MOVE.w  d1,(a0)+            * save to array header
00081A58  6100 00AE               3681      BSR     LAB_1F7C            * do this dimension size+1 * array size
00081A5C                          3682                              * (d1+1)*(Asptl), result in d0
00081A5C  2740 05A8               3683      MOVE.l  d0,Asptl(a3)        * save array data size
00081A60  532B 05DB               3684      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00081A64  66EE                    3685      BNE.s       LAB_1EC0            * loop while not = 0
00081A66                          3686  
00081A66  D1EB 05A8               3687      ADDA.l  Asptl(a3),a0        * add size to first element address
00081A6A  6500 EF84               3688      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00081A6E                          3689  
00081A6E  B1EB 0446               3690      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00081A72  650C                    3691      BCS.s       LAB_1ED6            * branch if less (is ok)
00081A74                          3692  
00081A74  6100 028E               3693      BSR     LAB_GARB            * do garbage collection routine
00081A78  B1EB 0446               3694      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00081A7C  6400 EF72               3695      BCC     LAB_OMER            * if Sstorl <= a0 do "Out of memory"
00081A80                          3696                              * error then warm start
00081A80                          3697  
00081A80                          3698  LAB_1ED6                        * ok exit, carry set
00081A80  2748 0442               3699      MOVE.l  a0,Earryl(a3)       * save array mem end
00081A84  7000                    3700      MOVEQ       #0,d0               * zero d0
00081A86  222B 05A8               3701      MOVE.l  Asptl(a3),d1        * get size in bytes
00081A8A  E289                    3702      LSR.l       #1,d1               * /2 for word fill (may be odd # words)
00081A8C  5341                    3703      SUBQ.w  #1,d1               * adjust for DBF loop
00081A8E                          3704  LAB_1ED8
00081A8E  3100                    3705      MOVE.w  d0,-(a0)            * decrement pointer and clear word
00081A90  51C9 FFFC               3706      DBF     d1,LAB_1ED8         * decrement & loop until low word done
00081A94                          3707  
00081A94  4841                    3708      SWAP        d1              * swap words
00081A96  4A41                    3709      TST.w       d1              * test high word
00081A98  6706                    3710      BEQ.s       LAB_1F07            * exit if done
00081A9A                          3711  
00081A9A  5341                    3712      SUBQ.w  #1,d1               * decrement low (high) word
00081A9C  4841                    3713      SWAP        d1              * swap back
00081A9E  60EE                    3714      BRA.s       LAB_1ED8            * go do a whole block
00081AA0                          3715  
00081AA0                          3716  * now we need to calculate the array size by doing Earryl - Astrtl
00081AA0                          3717  
00081AA0                          3718  LAB_1F07
00081AA0  206B 05AC               3719      MOVEA.l Astrtl(a3),a0       * get for calculation and as pointer
00081AA4  202B 0442               3720      MOVE.l  Earryl(a3),d0       * get array memory end
00081AA8  9088                    3721      SUB.l       a0,d0               * calculate array size
00081AAA  2140 0004               3722      MOVE.l  d0,4(a0)            * save size to array
00081AAE  4A2B 05B4               3723      TST.b       Defdim(a3)          * test default DIM flag
00081AB2  6652                    3724      BNE.s       RTS_011         * exit (RET) if this was a DIM command
00081AB4                          3725  
00081AB4                          3726                              * else, find element
00081AB4  5048                    3727      ADDQ.w  #8,a0               * index to dimension count
00081AB6  3758 05DB               3728      MOVE.w  (a0)+,Dimcnt(a3)        * get array's dimension count
00081ABA                          3729  
00081ABA                          3730  * we have found, or built, the array. now we need to find the element
00081ABA                          3731  
00081ABA                          3732  LAB_1F28
00081ABA  7000                    3733      MOVEQ       #0,d0               * clear first result
00081ABC  2740 05A8               3734      MOVE.l  d0,Asptl(a3)        * clear array data pointer
00081AC0                          3735  
00081AC0                          3736  * compare nth dimension bound (a0) with nth index (sp)+
00081AC0                          3737  * if greater do array bounds error
00081AC0                          3738  
00081AC0                          3739  LAB_1F2C
00081AC0  3218                    3740      MOVE.w  (a0)+,d1            * get nth dimension bound
00081AC2  B257                    3741      CMP.w       (sp),d1         * compare nth index with nth dimension bound
00081AC4  6500 EF22               3742      BCS     LAB_ABER            * if d1 less or = do array bounds error
00081AC8                          3743  
00081AC8                          3744  * now do pointer = pointer * nth dimension + nth index
00081AC8                          3745  
00081AC8  4A80                    3746      TST.l       d0              * test pointer
00081ACA  6702                    3747      BEQ.s       LAB_1F5A            * skip multiply if last result = null
00081ACC                          3748  
00081ACC  613A                    3749      BSR.s       LAB_1F7C            * do this dimension size+1 * array size
00081ACE                          3750  LAB_1F5A
00081ACE  7200                    3751      MOVEQ       #0,d1               * clear longword
00081AD0  321F                    3752      MOVE.w  (sp)+,d1            * get nth dimension index
00081AD2  D081                    3753      ADD.l       d1,d0               * add index to size
00081AD4  2740 05A8               3754      MOVE.l  d0,Asptl(a3)        * save array data pointer
00081AD8                          3755  
00081AD8  532B 05DB               3756      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00081ADC  66E2                    3757      BNE.s       LAB_1F2C            * loop if dimensions still to do
00081ADE                          3758  
00081ADE  177C 0000 05B5          3759      MOVE.b  #0,Dtypef(a3)       * set data type to float
00081AE4  7203                    3760      MOVEQ       #3,d1               * set for numeric array
00081AE6  4A2B 046B               3761      TST.b       Varname+1(a3)       * test if string array
00081AEA  6A0A                    3762      BPL.s       LAB_1F6A            * branch if not string
00081AEC                          3763  
00081AEC  7205                    3764      MOVEQ       #5,d1               * else set for string array
00081AEE  177C 0080 05B5          3765      MOVE.b  #$80,Dtypef(a3)     * and set data type to string
00081AF4  600C                    3766      BRA.s       LAB_1F6B            * skip integer test
00081AF6                          3767  
00081AF6                          3768  LAB_1F6A
00081AF6  4A2B 046C               3769      TST.b       Varname+2(a3)       * test if integer array
00081AFA  6A06                    3770      BPL.s       LAB_1F6B            * branch if not integer
00081AFC                          3771  
00081AFC  177C 0040 05B5          3772      MOVE.b  #$40,Dtypef(a3)     * else set data type to integer
00081B02                          3773  LAB_1F6B
00081B02  6104                    3774      BSR.s       LAB_1F7C            * do element size (d1) * array size (Asptl)
00081B04  D1C0                    3775      ADDA.l  d0,a0               * add array data start pointer
00081B06                          3776  RTS_011
00081B06  4E75                    3777      RTS
00081B08                          3778  
00081B08                          3779  
00081B08                          3780  *************************************************************************************
00081B08                          3781  *
00081B08                          3782  * do this dimension size (d1) * array data size (Asptl)
00081B08                          3783  
00081B08                          3784  * do a 16 x 32 bit multiply
00081B08                          3785  * d1 holds the 16 bit multiplier
00081B08                          3786  * Asptl holds the 32 bit multiplicand
00081B08                          3787  
00081B08                          3788  * d0    bbbb  bbbb
00081B08                          3789  * d1    0000  aaaa
00081B08                          3790  *   ----------
00081B08                          3791  * d0    rrrr  rrrr
00081B08                          3792  
00081B08                          3793  LAB_1F7C
00081B08  202B 05A8               3794      MOVE.l  Asptl(a3),d0        * get result
00081B0C  2400                    3795      MOVE.l  d0,d2               * copy it
00081B0E  4842                    3796      SWAP        d2              * shift high word to low word
00081B10  C0C1                    3797      MULU.w  d1,d0               * d1 * low word = low result
00081B12  C4C1                    3798      MULU.w  d1,d2               * d1 * high word = high result
00081B14  4842                    3799      SWAP        d2              * align words for test
00081B16  4A42                    3800      TST.w       d2              * must be zero
00081B18  6600 EED6               3801      BNE     LAB_OMER            * if overflow go do "Out of memory" error
00081B1C                          3802  
00081B1C  D082                    3803      ADD.l       d2,d0               * calculate result
00081B1E  6500 EED0               3804      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00081B22                          3805  
00081B22  D0AB 05A8               3806      ADD.l       Asptl(a3),d0        * add original
00081B26  6500 EEC8               3807      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00081B2A                          3808  
00081B2A  4E75                    3809      RTS
00081B2C                          3810  
00081B2C                          3811  
00081B2C                          3812  *************************************************************************************
00081B2C                          3813  *
00081B2C                          3814  * perform FRE()
00081B2C                          3815  
00081B2C                          3816  LAB_FRE
00081B2C  4A2B 05B5               3817      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00081B30                          3818                              * $00=float
00081B30  6A04                    3819      BPL.s       LAB_1FB4            * branch if numeric
00081B32                          3820  
00081B32  6100 0318               3821      BSR     LAB_22B6            * pop string off descriptor stack, or from
00081B36                          3822                              * top of string space, returns d0 = length,
00081B36                          3823                              * a0 = pointer
00081B36                          3824  
00081B36                          3825                              * FRE(n) was numeric so do this
00081B36                          3826  LAB_1FB4
00081B36  6100 01CC               3827      BSR     LAB_GARB            * go do garbage collection
00081B3A  202B 0446               3828      MOVE.l  Sstorl(a3),d0       * get bottom of string space
00081B3E  90AB 0442               3829      SUB.l       Earryl(a3),d0       * subtract array mem end
00081B42                          3830  
00081B42                          3831  
00081B42                          3832  *************************************************************************************
00081B42                          3833  *
00081B42                          3834  * convert d0 to signed longword in FAC1
00081B42                          3835  
00081B42                          3836  LAB_AYFC
00081B42  177C 0000 05B5          3837      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00081B48                          3838                              * $00=float
00081B48  377C A000 0594          3839      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent and clear sign (b7)
00081B4E  2740 0590               3840      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00081B52  6A00 063E               3841      BPL     LAB_24D0            * convert if +ve
00081B56                          3842  
00081B56  003C 0001               3843      ORI.b       #1,CCR          * else set carry
00081B5A  6000 0636               3844      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00081B5E                          3845  
00081B5E                          3846  
00081B5E                          3847  *************************************************************************************
00081B5E                          3848  *
00081B5E                          3849  * remember if the line length is zero (infinite line) then POS(n) will return
00081B5E                          3850  * position MOD tabsize
00081B5E                          3851  
00081B5E                          3852  * perform POS()
00081B5E                          3853  
00081B5E                          3854  LAB_POS
00081B5E  102B 05E5               3855      MOVE.b  TPos(a3),d0         * get terminal position
00081B62                          3856  
00081B62                          3857  * convert d0 to unsigned byte in FAC1
00081B62                          3858  
00081B62                          3859  LAB_1FD0
00081B62  C0BC 000000FF           3860      AND.l       #$FF,d0         * clear high bits
00081B68  60D8                    3861      BRA.s       LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00081B6A                          3862  
00081B6A                          3863  * check not direct (used by DEF and INPUT)
00081B6A                          3864  
00081B6A                          3865  LAB_CKRN
00081B6A  4A2B 0452               3866      TST.b       Clinel(a3)          * test current line #
00081B6E  6B00 EE6C               3867      BMI     LAB_IDER            * if -ve go do illegal direct error then warm
00081B72                          3868                              * start
00081B72                          3869  
00081B72  4E75                    3870      RTS                     * can continue so return
00081B74                          3871  
00081B74                          3872  
00081B74                          3873  *************************************************************************************
00081B74                          3874  *
00081B74                          3875  * perform DEF
00081B74                          3876  
00081B74                          3877  LAB_DEF
00081B74  70AB                    3878      MOVEQ       #TK_FN-$100,d0      * get FN token
00081B76  6100 FAC2               3879      BSR     LAB_SCCA            * scan for CHR$(d0), else syntax error and
00081B7A                          3880                              * warm start
00081B7A                          3881                              * return character after d0
00081B7A  177C 0080 05DF          3882      MOVE.b  #$80,Sufnxf(a3)     * set FN flag bit
00081B80  6100 FCDA               3883      BSR     LAB_1D12            * get FN name
00081B84  2748 05B0               3884      MOVE.l  a0,func_l(a3)       * save function pointer
00081B88                          3885  
00081B88  61E0                    3886      BSR.s       LAB_CKRN            * check not direct (back here if ok)
00081B8A  0C1D 0028               3887      CMP.b       #$28,(a5)+          * check next byte is "(" and increment
00081B8E  6600 EE74               3888      BNE     LAB_SNER            * else do syntax error/warm start
00081B92                          3889  
00081B92  177C 007E 05DF          3890      MOVE.b  #$7E,Sufnxf(a3)     * set FN variable flag bits
00081B98  6100 FCB4               3891      BSR     LAB_SVAR            * search for or create a variable
00081B9C                          3892                              * return the variable address in a0
00081B9C  6100 FA92               3893      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00081BA0  70BD                    3894      MOVEQ       #TK_EQUAL-$100,d0       * = token
00081BA2  6100 FA96               3895      BSR     LAB_SCCA            * scan for CHR$(A), else syntax error/warm start
00081BA6                          3896                              * return character after d0
00081BA6  2F2B 046A               3897      MOVE.l  Varname(a3),-(sp)       * push current variable name
00081BAA  2F0D                    3898      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00081BAC  6100 F41A               3899      BSR     LAB_DATA            * go perform DATA, find end of DEF FN statement
00081BB0  206B 05B0               3900      MOVEA.l func_l(a3),a0       * get the function pointer
00081BB4  209F                    3901      MOVE.l  (sp)+,(a0)          * save BASIC execute pointer to function
00081BB6  215F 0004               3902      MOVE.l  (sp)+,4(a0)         * save current variable name to function
00081BBA  4E75                    3903      RTS
00081BBC                          3904  
00081BBC                          3905  
00081BBC                          3906  *************************************************************************************
00081BBC                          3907  *
00081BBC                          3908  * evaluate FNx
00081BBC                          3909  
00081BBC                          3910  LAB_201E
00081BBC  177C 0081 05DF          3911      MOVE.b  #$81,Sufnxf(a3)     * set FN flag (find not create)
00081BC2  6100 FA7E               3912      BSR     LAB_IGBY            * increment & scan memory
00081BC6  6100 FC94               3913      BSR     LAB_1D12            * get FN name
00081BCA  1F2B 05B5               3914      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function type)
00081BCE  2F08                    3915      MOVE.l  a0,-(sp)            * push function pointer
00081BD0  0C15 0028               3916      CMP.b       #$28,(a5)           * check next byte is "(", no increment
00081BD4  6600 EE2E               3917      BNE     LAB_SNER            * else do syntax error/warm start
00081BD8                          3918  
00081BD8  6100 FA52               3919      BSR     LAB_1BF7            * evaluate expression within parentheses
00081BDC  205F                    3920      MOVEA.l (sp)+,a0            * pop function pointer
00081BDE  2748 05B0               3921      MOVE.l  a0,func_l(a3)       * set function pointer
00081BE2  1F2B 05B5               3922      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function expression type)
00081BE6                          3923  
00081BE6  2028 0004               3924      MOVE.l  4(a0),d0            * get function variable name
00081BEA  6100 FCDA               3925      BSR     LAB_1D4A            * go find function variable (already created)
00081BEE                          3926  
00081BEE                          3927                              * now check type match for variable
00081BEE  101F                    3928      MOVE.b  (sp)+,d0            * pop data type flag (function expression type)
00081BF0  E318                    3929      ROL.b       #1,d0               * set carry if type = string
00081BF2  6100 F8DA               3930      BSR     LAB_CKTM            * type match check, set C for string
00081BF6                          3931  
00081BF6                          3932                              * now stack the function variable value before
00081BF6                          3933                              * use
00081BF6  6712                    3934      BEQ.s       LAB_2043            * branch if not string
00081BF8                          3935  
00081BF8  43EB 0476               3936      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00081BFC  B9C9                    3937      CMPA.l  a1,a4               * compare string stack pointer with max+1
00081BFE  6700 EDD0               3938      BEQ     LAB_SCER            * if no space on the stack go do string too
00081C02                          3939                              * complex error
00081C02                          3940  
00081C02  3928 0004               3941      MOVE.w  4(a0),-(a4)         * string length on descriptor stack
00081C06  2910                    3942      MOVE.l  (a0),-(a4)          * string address on stack
00081C08  6002                    3943      BRA.s       LAB_204S            * skip var push
00081C0A                          3944  
00081C0A                          3945  LAB_2043
00081C0A  2F10                    3946      MOVE.l  (a0),-(sp)          * push variable
00081C0C                          3947  LAB_204S
00081C0C  2F08                    3948      MOVE.l  a0,-(sp)            * push variable address
00081C0E  1F2B 05B5               3949      MOVE.b  Dtypef(a3),-(sp)        * push variable data type
00081C12                          3950  
00081C12  6132                    3951      BSR.s       LAB_2045            * pack function expression value into (a0)
00081C14                          3952                              * (function variable)
00081C14  2F0D                    3953      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00081C16  206B 05B0               3954      MOVEA.l func_l(a3),a0       * get function pointer
00081C1A  2A50                    3955      MOVEA.l (a0),a5         * save function execute ptr as BASIC execute ptr
00081C1C  6100 F8C4               3956      BSR     LAB_EVEX            * evaluate expression
00081C20  6100 FA22               3957      BSR     LAB_GBYT            * scan memory
00081C24  6600 EDDE               3958      BNE     LAB_SNER            * if not [EOL] or [EOS] do syntax error and
00081C28                          3959                              * warm start
00081C28                          3960  
00081C28  2A5F                    3961      MOVE.l  (sp)+,a5            * restore BASIC execute pointer
00081C2A                          3962  
00081C2A                          3963  * restore variable from stack and test data type
00081C2A                          3964  
00081C2A  101F                    3965      MOVE.b  (sp)+,d0            * pull variable data type
00081C2C  205F                    3966      MOVEA.l (sp)+,a0            * pull variable address
00081C2E  4A00                    3967      TST.b       d0              * test variable data type
00081C30  6A08                    3968      BPL.s       LAB_204T            * branch if not string
00081C32                          3969  
00081C32  209C                    3970      MOVE.l  (a4)+,(a0)          * string address from descriptor stack
00081C34  315C 0004               3971      MOVE.w  (a4)+,4(a0)         * string length from descriptor stack
00081C38  6002                    3972      BRA.s       LAB_2044            * skip variable pull
00081C3A                          3973  
00081C3A                          3974  LAB_204T
00081C3A  209F                    3975      MOVE.l  (sp)+,(a0)          * restore variable from stack
00081C3C                          3976  LAB_2044
00081C3C  101F                    3977      MOVE.b  (sp)+,d0            * pop data type flag (function type)
00081C3E  E318                    3978      ROL.b       #1,d0               * set carry if type = string
00081C40  6100 F88C               3979      BSR     LAB_CKTM            * type match check, set C for string
00081C44  4E75                    3980      RTS
00081C46                          3981  
00081C46                          3982  LAB_2045
00081C46  4A2B 05B5               3983      TST.b       Dtypef(a3)          * test data type
00081C4A  6A00 07EE               3984      BPL     LAB_2778            * if numeric pack FAC1 into variable (a0)
00081C4E                          3985                              * and return
00081C4E                          3986  
00081C4E  2448                    3987      MOVEA.l a0,a2               * copy variable pointer
00081C50  6000 F514               3988      BRA     LAB_17D6            * go do string LET & return
00081C54                          3989  
00081C54                          3990  
00081C54                          3991  
00081C54                          3992  *************************************************************************************
00081C54                          3993  *
00081C54                          3994  * perform STR$()
00081C54                          3995  
00081C54                          3996  LAB_STRS
00081C54  6100 094A               3997      BSR     LAB_2970            * convert FAC1 to string
00081C58                          3998  
00081C58                          3999  * scan, set up string
00081C58                          4000  * print " terminated string to FAC1 stack
00081C58                          4001  
00081C58                          4002  LAB_20AE
00081C58  7422                    4003      MOVEQ       #$22,d2         * set Srchc character (terminator 1)
00081C5A  3602                    4004      MOVE.w  d2,d3               * set Asrch character (terminator 2)
00081C5C                          4005  
00081C5C                          4006  * print d2/d3 terminated string to FAC1 stack
00081C5C                          4007  * d2 = Srchc, d3 = Asrch, a0 is source
00081C5C                          4008  * a6 is temp
00081C5C                          4009  
00081C5C                          4010  LAB_20B4
00081C5C  7200                    4011      MOVEQ       #0,d1               * clear longword
00081C5E  5341                    4012      SUBQ.w  #1,d1               * set length to -1
00081C60  2448                    4013      MOVEA.l a0,a2               * copy start to calculate end
00081C62                          4014  LAB_20BE
00081C62  5241                    4015      ADDQ.w  #1,d1               * increment length
00081C64  1030 1000               4016      MOVE.b  (a0,d1.w),d0        * get byte from string
00081C68  6710                    4017      BEQ.s       LAB_20D0            * exit loop if null byte [EOS]
00081C6A                          4018  
00081C6A  B002                    4019      CMP.b       d2,d0               * compare with search character (terminator 1)
00081C6C  6704                    4020      BEQ.s       LAB_20CB            * branch if terminator
00081C6E                          4021  
00081C6E  B003                    4022      CMP.b       d3,d0               * compare with terminator 2
00081C70  66F0                    4023      BNE.s       LAB_20BE            * loop if not terminator 2 (or null string)
00081C72                          4024  
00081C72                          4025  LAB_20CB
00081C72  B03C 0022               4026      CMP.b       #$22,d0         * compare with "
00081C76  6602                    4027      BNE.s       LAB_20D0            * branch if not "
00081C78                          4028  
00081C78  524A                    4029      ADDQ.w  #1,a2               * else increment string start (skip " at end)
00081C7A                          4030  LAB_20D0
00081C7A  D5C1                    4031      ADDA.l  d1,a2               * add longowrd length to make string end+1
00081C7C                          4032  
00081C7C  B1CB                    4033      CMPA.l  a3,a0               * is string in ram
00081C7E  651E                    4034      BCS.s       LAB_RTST            * if not go push descriptor on stack & exit
00081C80                          4035                              * (could be message string from ROM)
00081C80                          4036  
00081C80  B1EB 042E               4037      CMPA.l  Smeml(a3),a0        * is string in utility ram
00081C84  6418                    4038      BCC.s       LAB_RTST            * if not go push descriptor on stack & exit
00081C86                          4039                              * (is in string or program space)
00081C86                          4040  
00081C86                          4041                              * (else) copy string to string memory
00081C86                          4042  LAB_20C9
00081C86  2248                    4043      MOVEA.l a0,a1               * copy descriptor pointer
00081C88  2001                    4044      MOVE.l  d1,d0               * copy longword length
00081C8A  6604                    4045      BNE.s       LAB_20D8            * branch if not null string
00081C8C                          4046  
00081C8C  2041                    4047      MOVEA.l d1,a0               * make null pointer
00081C8E  600E                    4048      BRA.s       LAB_RTST            * go push descriptor on stack & exit
00081C90                          4049  
00081C90                          4050  LAB_20D8
00081C90  6126                    4051      BSR.s       LAB_2115            * make string space d1 bytes long
00081C92  D1C1                    4052      ADDA.l  d1,a0               * new string end
00081C94  D3C1                    4053      ADDA.l  d1,a1               * old string end
00081C96  5340                    4054      SUBQ.w  #1,d0               * -1 for DBF loop
00081C98                          4055  LAB_20E0
00081C98  1121                    4056      MOVE.b  -(a1),-(a0)         * copy byte (source can be odd aligned)
00081C9A  51C8 FFFC               4057      DBF     d0,LAB_20E0         * loop until done
00081C9E                          4058  
00081C9E                          4059  
00081C9E                          4060  
00081C9E                          4061  *************************************************************************************
00081C9E                          4062  *
00081C9E                          4063  * check for space on descriptor stack then ...
00081C9E                          4064  * put string address and length on descriptor stack & update stack pointers
00081C9E                          4065  * start is in a0, length is in d1
00081C9E                          4066  
00081C9E                          4067  LAB_RTST
00081C9E  43EB 0476               4068      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00081CA2  B9C9                    4069      CMPA.l  a1,a4               * compare string stack pointer with max+1
00081CA4  6700 ED2A               4070      BEQ     LAB_SCER            * if no space on string stack ..
00081CA8                          4071                              * .. go do 'string too complex' error
00081CA8                          4072  
00081CA8                          4073                              * push string & update pointers
00081CA8  3901                    4074      MOVE.w  d1,-(a4)            * string length on descriptor stack
00081CAA  2908                    4075      MOVE.l  a0,-(a4)            * string address on stack
00081CAC  274C 0590               4076      MOVE.l  a4,FAC1_m(a3)       * string descriptor pointer in FAC1
00081CB0  177C 0080 05B5          4077      MOVE.b  #$80,Dtypef(a3)     * save data type flag, $80=string
00081CB6  4E75                    4078      RTS
00081CB8                          4079  
00081CB8                          4080  
00081CB8                          4081  *************************************************************************************
00081CB8                          4082  *
00081CB8                          4083  * build descriptor a0/d1
00081CB8                          4084  * make space in string memory for string d1.w long
00081CB8                          4085  * return pointer in a0/Sutill
00081CB8                          4086  
00081CB8                          4087  LAB_2115
00081CB8  4A41                    4088      TST.w       d1              * test length
00081CBA  672E                    4089      BEQ.s       LAB_2128            * branch if user wants null string
00081CBC                          4090  
00081CBC                          4091                              * make space for string d1 long
00081CBC  2F00                    4092      MOVE.l  d0,-(sp)            * save d0
00081CBE  7000                    4093      MOVEQ       #0,d0               * clear longword
00081CC0  1740 05DE               4094      MOVE.b  d0,Gclctd(a3)       * clear garbage collected flag (b7)
00081CC4  7001                    4095      MOVEQ       #1,d0               * +1 to possibly round up
00081CC6  C041                    4096      AND.w       d1,d0               * mask odd bit
00081CC8  D041                    4097      ADD.w       d1,d0               * ensure d0 is even length
00081CCA  6404                    4098      BCC.s       LAB_2117            * branch if no overflow
00081CCC                          4099  
00081CCC  7001                    4100      MOVEQ       #1,d0               * set to allocate 65536 bytes
00081CCE  4840                    4101      SWAP        d0              * makes $00010000
00081CD0                          4102  LAB_2117
00081CD0  206B 0446               4103      MOVEA.l Sstorl(a3),a0       * get bottom of string space
00081CD4  91C0                    4104      SUBA.l  d0,a0               * subtract string length
00081CD6  B1EB 0442               4105      CMPA.l  Earryl(a3),a0       * compare with top of array space
00081CDA  6512                    4106      BCS.s       LAB_2137            * if less do out of memory error
00081CDC                          4107  
00081CDC  2748 0446               4108      MOVE.l  a0,Sstorl(a3)       * save bottom of string space
00081CE0  2748 044E               4109      MOVE.l  a0,Sutill(a3)       * save string utility pointer
00081CE4  201F                    4110      MOVE.l  (sp)+,d0            * restore d0
00081CE6  4A41                    4111      TST.w       d1              * set flags on length
00081CE8  4E75                    4112      RTS
00081CEA                          4113  
00081CEA                          4114  LAB_2128
00081CEA  3041                    4115      MOVEA.w d1,a0               * make null pointer
00081CEC  4E75                    4116      RTS
00081CEE                          4117  
00081CEE                          4118  LAB_2137
00081CEE  4A2B 05DE               4119      TST.b       Gclctd(a3)          * get garbage collected flag
00081CF2  6B00 ECFC               4120      BMI     LAB_OMER            * do "Out of memory" error, then warm start
00081CF6                          4121  
00081CF6  2F09                    4122      MOVE.l  a1,-(sp)            * save a1
00081CF8  610A                    4123      BSR.s       LAB_GARB            * else go do garbage collection
00081CFA  225F                    4124      MOVEA.l (sp)+,a1            * restore a1
00081CFC  177C 0080 05DE          4125      MOVE.b  #$80,Gclctd(a3)     * set garbage collected flag
00081D02  60CC                    4126      BRA.s       LAB_2117            * go try again
00081D04                          4127  
00081D04                          4128  
00081D04                          4129  *************************************************************************************
00081D04                          4130  *
00081D04                          4131  * garbage collection routine
00081D04                          4132  
00081D04                          4133  LAB_GARB
00081D04  48E7 E0E0               4134      MOVEM.l d0-d2/a0-a2,-(sp)       * save registers
00081D08  276B 044A 0446          4135      MOVE.l  Ememl(a3),Sstorl(a3)    * start with no strings
00081D0E                          4136  
00081D0E                          4137                              * re-run routine from last ending
00081D0E                          4138  LAB_214B
00081D0E  222B 0442               4139      MOVE.l  Earryl(a3),d1       * set highest uncollected string so far
00081D12  7000                    4140      MOVEQ       #0,d0               * clear longword
00081D14  2240                    4141      MOVEA.l d0,a1               * clear string to move pointer
00081D16  206B 043A               4142      MOVEA.l Sstrl(a3),a0        * set pointer to start of strings
00081D1A  41E8 0004               4143      LEA     4(a0),a0            * index to string pointer
00081D1E  246B 043E               4144      MOVEA.l Sarryl(a3),a2       * set end pointer to start of arrays (end of
00081D22                          4145                              * strings)
00081D22  6008                    4146      BRA.s       LAB_2176            * branch into loop at end loop test
00081D24                          4147  
00081D24                          4148  LAB_2161
00081D24  6100 0084               4149      BSR     LAB_2206            * test and set if this is the highest string
00081D28  41E8 000A               4150      LEA     10(a0),a0           * increment to next string
00081D2C                          4151  LAB_2176
00081D2C  B1CA                    4152      CMPA.l  a2,a0               * compare end of area with pointer
00081D2E  65F4                    4153      BCS.s       LAB_2161            * go do next if not at end
00081D30                          4154  
00081D30                          4155  * done strings, now do arrays.
00081D30                          4156  
00081D30  41E8 FFFC               4157      LEA     -4(a0),a0           * decrement pointer to start of arrays
00081D34  246B 0442               4158      MOVEA.l Earryl(a3),a2       * set end pointer to end of arrays
00081D38  6024                    4159      BRA.s       LAB_218F            * branch into loop at end loop test
00081D3A                          4160  
00081D3A                          4161  LAB_217E
00081D3A  2428 0004               4162      MOVE.l  4(a0),d2            * get array size
00081D3E  D488                    4163      ADD.l       a0,d2               * makes start of next array
00081D40                          4164  
00081D40  2010                    4165      MOVE.l  (a0),d0         * get array name
00081D42  0800 0017               4166      BTST        #23,d0          * test string flag
00081D46  6714                    4167      BEQ.s       LAB_218B            * branch if not string
00081D48                          4168  
00081D48  3028 0008               4169      MOVE.w  8(a0),d0            * get # of dimensions
00081D4C  D040                    4170      ADD.w       d0,d0               * *2
00081D4E  D0C0                    4171      ADDA.w  d0,a0               * add to skip dimension size(s)
00081D50  41E8 000A               4172      LEA     10(a0),a0           * increment to first element
00081D54                          4173  LAB_2183
00081D54  6154                    4174      BSR.s       LAB_2206            * test and set if this is the highest string
00081D56  5C48                    4175      ADDQ.w  #6,a0               * increment to next element
00081D58  B1C2                    4176      CMPA.l  d2,a0               * compare with start of next array
00081D5A  66F8                    4177      BNE.s       LAB_2183            * go do next if not at end of array
00081D5C                          4178  
00081D5C                          4179  LAB_218B
00081D5C  2042                    4180      MOVEA.l d2,a0               * pointer to next array
00081D5E                          4181  LAB_218F
00081D5E  B5C8                    4182      CMPA.l  a0,a2               * compare pointer with array end
00081D60  66D8                    4183      BNE.s       LAB_217E            * go do next if not at end
00081D62                          4184  
00081D62                          4185  * done arrays and variables, now just the descriptor stack to do
00081D62                          4186  
00081D62  204C                    4187      MOVEA.l a4,a0               * get descriptor stack pointer
00081D64  45EB 048E               4188      LEA     des_sk(a3),a2       * set end pointer to end of stack
00081D68  6006                    4189      BRA.s       LAB_21C4            * branch into loop at end loop test
00081D6A                          4190  
00081D6A                          4191  LAB_21C2
00081D6A  613E                    4192      BSR.s       LAB_2206            * test and set if this is the highest string
00081D6C  41E8 0006               4193      LEA     6(a0),a0            * increment to next string
00081D70                          4194  LAB_21C4
00081D70  B5C8                    4195      CMPA.l  a0,a2               * compare pointer with stack end
00081D72  66F6                    4196      BNE.s       LAB_21C2            * go do next if not at end
00081D74                          4197  
00081D74                          4198  * descriptor search complete, now either exit or set-up and move string
00081D74                          4199  
00081D74  2009                    4200      MOVE.l  a1,d0               * set the flags (a1 is move string)
00081D76  672C                    4201      BEQ.s       LAB_21D1            * go tidy up and exit if no move
00081D78                          4202  
00081D78  2051                    4203      MOVEA.l (a1),a0         * a0 is now string start
00081D7A  7200                    4204      MOVEQ       #0,d1               * clear d1
00081D7C  3229 0004               4205      MOVE.w  4(a1),d1            * d1 is string length
00081D80  5281                    4206      ADDQ.l  #1,d1               * +1
00081D82  C23C 00FE               4207      AND.b       #$FE,d1         * make even length
00081D86  D1C1                    4208      ADDA.l  d1,a0               * pointer is now to string end+1
00081D88  246B 0446               4209      MOVEA.l Sstorl(a3),a2       * is destination end+1
00081D8C  B1CA                    4210      CMPA.l  a2,a0               * does the string need moving
00081D8E  670C                    4211      BEQ.s       LAB_2240            * branch if not
00081D90                          4212  
00081D90  E289                    4213      LSR.l       #1,d1               * word move so do /2
00081D92  5341                    4214      SUBQ.w  #1,d1               * -1 for DBF loop
00081D94                          4215  LAB_2216
00081D94  3520                    4216      MOVE.w  -(a0),-(a2)         * copy word
00081D96  51C9 FFFC               4217      DBF     d1,LAB_2216         * loop until done
00081D9A                          4218  
00081D9A  228A                    4219      MOVE.l  a2,(a1)         * save new string start
00081D9C                          4220  LAB_2240
00081D9C  2751 0446               4221      MOVE.l  (a1),Sstorl(a3)     * string start is new string mem start
00081DA0  6000 FF6C               4222      BRA     LAB_214B            * re-run routine from last ending
00081DA4                          4223                              * (but don't collect this string)
00081DA4                          4224  
00081DA4                          4225  LAB_21D1
00081DA4  4CDF 0707               4226      MOVEM.l (sp)+,d0-d2/a0-a2       * restore registers
00081DA8  4E75                    4227      RTS
00081DAA                          4228  
00081DAA                          4229  * test and set if this is the highest string
00081DAA                          4230  
00081DAA                          4231  LAB_2206
00081DAA  2010                    4232      MOVE.l  (a0),d0         * get this string pointer
00081DAC  6728                    4233      BEQ.s       RTS_012         * exit if null string
00081DAE                          4234  
00081DAE  B280                    4235      CMP.l       d0,d1               * compare with highest uncollected string so far
00081DB0  6424                    4236      BCC.s       RTS_012         * exit if <= with highest so far
00081DB2                          4237  
00081DB2  B0AB 0446               4238      CMP.l       Sstorl(a3),d0       * compare with bottom of string space
00081DB6  641E                    4239      BCC.s       RTS_012         * exit if >= bottom of string space
00081DB8                          4240  
00081DB8  70FF                    4241      MOVEQ       #-1,d0          * d0 = $FFFFFFFF
00081DBA  3028 0004               4242      MOVE.w  4(a0),d0            * d0 is string length
00081DBE  4440                    4243      NEG.w       d0              * make -ve
00081DC0  C03C 00FE               4244      AND.b       #$FE,d0         * make -ve even length
00081DC4  D0AB 0446               4245      ADD.l       Sstorl(a3),d0       * add string store to -ve length
00081DC8  B090                    4246      CMP.l       (a0),d0         * compare with string address
00081DCA  6706                    4247      BEQ.s       LAB_2212            * if = go move string store pointer down
00081DCC                          4248  
00081DCC  2210                    4249      MOVE.l  (a0),d1         * highest = current
00081DCE  2248                    4250      MOVEA.l a0,a1               * string to move = current
00081DD0  4E75                    4251      RTS
00081DD2                          4252  
00081DD2                          4253  LAB_2212
00081DD2  2740 0446               4254      MOVE.l  d0,Sstorl(a3)       * set new string store start
00081DD6                          4255  RTS_012
00081DD6  4E75                    4256      RTS
00081DD8                          4257  
00081DD8                          4258  
00081DD8                          4259  *************************************************************************************
00081DD8                          4260  *
00081DD8                          4261  * concatenate - add strings
00081DD8                          4262  * string descriptor 1 is in FAC1_m, string 2 is in line
00081DD8                          4263  
00081DD8                          4264  LAB_224D
00081DD8  487A F73A               4265      PEA     LAB_1ADB(pc)        * continue evaluation after concatenate
00081DDC  2F2B 0590               4266      MOVE.l  FAC1_m(a3),-(sp)        * stack descriptor pointer for string 1
00081DE0                          4267  
00081DE0  6100 F80E               4268      BSR     LAB_GVAL            * get value from line
00081DE4  4A2B 05B5               4269      TST.b       Dtypef(a3)          * test data type flag
00081DE8  6A00 EBEE               4270      BPL     LAB_TMER            * if type is not string do type mismatch error
00081DEC                          4271  
00081DEC  205F                    4272      MOVEA.l (sp)+,a0            * restore descriptor pointer for string 1
00081DEE                          4273  
00081DEE                          4274  *************************************************************************************
00081DEE                          4275  *
00081DEE                          4276  * concatenate
00081DEE                          4277  * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
00081DEE                          4278  
00081DEE                          4279  LAB_224E
00081DEE  226B 0590               4280      MOVEA.l FAC1_m(a3),a1       * copy descriptor pointer 2
00081DF2  3228 0004               4281      MOVE.w  4(a0),d1            * get length 1
00081DF6  D269 0004               4282      ADD.w       4(a1),d1            * add length 2
00081DFA  6500 EBD8               4283      BCS     LAB_SLER            * if overflow go do 'string too long' error
00081DFE                          4284  
00081DFE  2F08                    4285      MOVE.l  a0,-(sp)            * save descriptor pointer 1
00081E00  6100 FEB6               4286      BSR     LAB_2115            * make space d1 bytes long
00081E04  2748 0598               4287      MOVE.l  a0,FAC2_m(a3)       * save new string start pointer
00081E08  2057                    4288      MOVEA.l (sp),a0         * copy descriptor pointer 1 from stack
00081E0A  3028 0004               4289      MOVE.w  4(a0),d0            * get length
00081E0E  2050                    4290      MOVEA.l (a0),a0         * get string pointer
00081E10  6120                    4291      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00081E12                          4292                              * return with a0 = pointer, d1 = length
00081E12                          4293  
00081E12  206B 0590               4294      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer for string 2
00081E16  6138                    4295      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00081E18                          4296                              * a0 = pointer, d0 = length
00081E18  6118                    4297      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00081E1A                          4298                              * return with a0 = pointer, d1 = length
00081E1A                          4299  
00081E1A  205F                    4300      MOVEA.l (sp)+,a0            * get descriptor pointer for string 1
00081E1C  6132                    4301      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00081E1E                          4302                              * d0 = length, a0 = pointer
00081E1E                          4303  
00081E1E  206B 0598               4304      MOVEA.l FAC2_m(a3),a0       * retreive the result string pointer
00081E22  2208                    4305      MOVE.l  a0,d1               * copy the result string pointer
00081E24  6700 FE78               4306      BEQ     LAB_RTST            * if it is a null string just return it
00081E28                          4307                              * a0 = pointer, d1 = length
00081E28                          4308  
00081E28  4481                    4309      NEG.l       d1              * else make the start pointer negative
00081E2A  D2AB 044E               4310      ADD.l       Sutill(a3),d1       * add the end pointert to give the length
00081E2E  6000 FE6E               4311      BRA     LAB_RTST            * push string on descriptor stack
00081E32                          4312                              * a0 = pointer, d1 = length
00081E32                          4313  
00081E32                          4314  
00081E32                          4315  *************************************************************************************
00081E32                          4316  *
00081E32                          4317  * copy string d0 bytes long from a0 to Sutill
00081E32                          4318  * return with a0 = pointer, d1 = length
00081E32                          4319  
00081E32                          4320  LAB_229E
00081E32  3200                    4321      MOVE.w  d0,d1               * copy and check length
00081E34  6714                    4322      BEQ.s       RTS_013         * skip copy if null
00081E36                          4323  
00081E36  226B 044E               4324      MOVEA.l Sutill(a3),a1       * get destination pointer
00081E3A  2F09                    4325      MOVE.l  a1,-(sp)            * save destination string pointer
00081E3C  5340                    4326      SUBQ.w  #1,d0               * subtract for DBF loop
00081E3E                          4327  LAB_22A0
00081E3E  12D8                    4328      MOVE.b  (a0)+,(a1)+         * copy byte
00081E40  51C8 FFFC               4329      DBF     d0,LAB_22A0         * loop if not done
00081E44                          4330  
00081E44  2749 044E               4331      MOVE.l  a1,Sutill(a3)       * update Sutill to end of copied string
00081E48  205F                    4332      MOVEA.l (sp)+,a0            * restore destination string pointer
00081E4A                          4333  RTS_013
00081E4A  4E75                    4334      RTS
00081E4C                          4335  
00081E4C                          4336  
00081E4C                          4337  *************************************************************************************
00081E4C                          4338  *
00081E4C                          4339  * pop string off descriptor stack, or from top of string space
00081E4C                          4340  * returns with d0.l = length, a0 = pointer
00081E4C                          4341  
00081E4C                          4342  LAB_22B6
00081E4C  206B 0590               4343      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00081E50                          4344  
00081E50                          4345  
00081E50                          4346  *************************************************************************************
00081E50                          4347  *
00081E50                          4348  * pop (a0) descriptor off stack or from string space
00081E50                          4349  * returns with d0.l = length, a0 = pointer
00081E50                          4350  
00081E50                          4351  LAB_22BA
00081E50  48E7 4040               4352      MOVEM.l a1/d1,-(sp)         * save other regs
00081E54  B9C8                    4353      CMPA.l  a0,a4               * is string on the descriptor stack
00081E56  6602                    4354      BNE.s       LAB_22BD            * skip pop if not
00081E58                          4355  
00081E58  5C4C                    4356      ADDQ.w  #$06,a4         * else update stack pointer
00081E5A                          4357  LAB_22BD
00081E5A  7000                    4358      MOVEQ       #0,d0               * clear string length longword
00081E5C  2258                    4359      MOVEA.l (a0)+,a1            * get string address
00081E5E  3018                    4360      MOVE.w  (a0)+,d0            * get string length
00081E60                          4361  
00081E60  B9C8                    4362      CMPA.l  a0,a4               * was it on the descriptor stack
00081E62  6610                    4363      BNE.s       LAB_22E6            * branch if it wasn't
00081E64                          4364  
00081E64  B3EB 0446               4365      CMPA.l  Sstorl(a3),a1       * compare string address with bottom of string
00081E68                          4366                              * space
00081E68  660A                    4367      BNE.s       LAB_22E6            * branch if <>
00081E6A                          4368  
00081E6A  7201                    4369      MOVEQ       #1,d1               * mask for odd bit
00081E6C  C240                    4370      AND.w       d0,d1               * AND length
00081E6E  D280                    4371      ADD.l       d0,d1               * make it fit word aligned length
00081E70                          4372  
00081E70  D3AB 0446               4373      ADD.l       d1,Sstorl(a3)       * add to bottom of string space
00081E74                          4374  LAB_22E6
00081E74  2049                    4375      MOVEA.l a1,a0               * copy to a0
00081E76  4CDF 0202               4376      MOVEM.l (sp)+,a1/d1         * restore other regs
00081E7A  4A80                    4377      TST.l       d0              * set flags on length
00081E7C  4E75                    4378      RTS
00081E7E                          4379  
00081E7E                          4380  
00081E7E                          4381  *************************************************************************************
00081E7E                          4382  *
00081E7E                          4383  * perform CHR$()
00081E7E                          4384  
00081E7E                          4385  LAB_CHRS
00081E7E  6100 0130               4386      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00081E82                          4387                              * Itemp
00081E82                          4388  LAB_MKCHR
00081E82  7201                    4389      MOVEQ       #1,d1               * string is single byte
00081E84  6100 FE32               4390      BSR     LAB_2115            * make string space d1 bytes long
00081E88                          4391                              * return a0/Sutill = pointer, others unchanged
00081E88  1080                    4392      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00081E8A  6000 FE12               4393      BRA     LAB_RTST            * push string on descriptor stack
00081E8E                          4394                              * a0 = pointer, d1 = length
00081E8E                          4395  
00081E8E                          4396  
00081E8E                          4397  *************************************************************************************
00081E8E                          4398  *
00081E8E                          4399  * perform LEFT$()
00081E8E                          4400  
00081E8E                          4401  * enter with a0 is descriptor, d0 & Itemp is word 1
00081E8E                          4402  
00081E8E                          4403  LAB_LEFT
00081E8E  C141                    4404      EXG     d0,d1               * word in d1
00081E90  6100 F79E               4405      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00081E94                          4406  
00081E94  4A81                    4407      TST.l       d1              * test returned length
00081E96  6722                    4408      BEQ.s       LAB_231C            * branch if null return
00081E98                          4409  
00081E98  7000                    4410      MOVEQ       #0,d0               * clear start offset
00081E9A  B268 0004               4411      CMP.w       4(a0),d1            * compare word parameter with string length
00081E9E  651A                    4412      BCS.s       LAB_231C            * branch if string length > word parameter
00081EA0                          4413  
00081EA0  6014                    4414      BRA.s       LAB_2317            * go copy whole string
00081EA2                          4415  
00081EA2                          4416  
00081EA2                          4417  *************************************************************************************
00081EA2                          4418  *
00081EA2                          4419  * perform RIGHT$()
00081EA2                          4420  
00081EA2                          4421  * enter with a0 is descriptor, d0 & Itemp is word 1
00081EA2                          4422  
00081EA2                          4423  LAB_RIGHT
00081EA2  C141                    4424      EXG     d0,d1               * word in d1
00081EA4  6100 F78A               4425      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00081EA8                          4426  
00081EA8  4A81                    4427      TST.l       d1              * test returned length
00081EAA  670E                    4428      BEQ.s       LAB_231C            * branch if null return
00081EAC                          4429  
00081EAC  3028 0004               4430      MOVE.w  4(a0),d0            * get string length
00081EB0  9081                    4431      SUB.l       d1,d0               * subtract word
00081EB2  6406                    4432      BCC.s       LAB_231C            * branch if string length > word parameter
00081EB4                          4433  
00081EB4                          4434                              * else copy whole string
00081EB4                          4435  LAB_2316
00081EB4  7000                    4436      MOVEQ       #0,d0               * clear start offset
00081EB6                          4437  LAB_2317
00081EB6  3228 0004               4438      MOVE.w  4(a0),d1            * else make parameter = length
00081EBA                          4439  
00081EBA                          4440  * get here with ...
00081EBA                          4441  *   a0 - points to descriptor
00081EBA                          4442  *   d0 - is offset from string start
00081EBA                          4443  *   d1 - is required string length
00081EBA                          4444  
00081EBA                          4445  LAB_231C
00081EBA  2248                    4446      MOVEA.l a0,a1               * save string descriptor pointer
00081EBC  6100 FDFA               4447      BSR     LAB_2115            * make string space d1 bytes long
00081EC0                          4448                              * return a0/Sutill = pointer, others unchanged
00081EC0  2049                    4449      MOVEA.l a1,a0               * restore string descriptor pointer
00081EC2  2F00                    4450      MOVE.l  d0,-(sp)            * save start offset (longword)
00081EC4  618A                    4451      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00081EC6                          4452                              * d0 = length, a0 = pointer
00081EC6  D1DF                    4453      ADDA.l  (sp)+,a0            * adjust pointer to start of wanted string
00081EC8  3001                    4454      MOVE.w  d1,d0               * length to d0
00081ECA  6100 FF66               4455      BSR     LAB_229E            * store string d0 bytes long from (a0) to
00081ECE                          4456                              * (Sutill) return with a0 = pointer,
00081ECE                          4457                              * d1 = length
00081ECE  6000 FDCE               4458      BRA     LAB_RTST            * push string on descriptor stack
00081ED2                          4459                              * a0 = pointer, d1 = length
00081ED2                          4460  
00081ED2                          4461  
00081ED2                          4462  *************************************************************************************
00081ED2                          4463  *
00081ED2                          4464  * perform MID$()
00081ED2                          4465  
00081ED2                          4466  * enter with a0 is descriptor, d0 & Itemp is word 1
00081ED2                          4467  
00081ED2                          4468  LAB_MIDS
00081ED2  7E00                    4469      MOVEQ       #0,d7               * clear longword
00081ED4  5347                    4470      SUBQ.w  #1,d7               * set default length = 65535
00081ED6  2F00                    4471      MOVE.l  d0,-(sp)            * save word 1
00081ED8  6100 F76A               4472      BSR     LAB_GBYT            * scan memory
00081EDC  B03C 002C               4473      CMP.b       #',',d0         * was it ","
00081EE0  660C                    4474      BNE.s       LAB_2358            * branch if not "," (skip second byte get)
00081EE2                          4475  
00081EE2  101D                    4476      MOVE.b  (a5)+,d0            * increment pointer past ","
00081EE4  2F08                    4477      MOVE.l  a0,-(sp)            * save descriptor pointer
00081EE6  6100 00D8               4478      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00081EEA  205F                    4479      MOVEA.l (sp)+,a0            * restore descriptor pointer
00081EEC  2E00                    4480      MOVE.l  d0,d7               * copy length
00081EEE                          4481  LAB_2358
00081EEE  6100 F740               4482      BSR     LAB_1BFB            * scan for ")", else do syntax error then warm
00081EF2                          4483                              * start
00081EF2  201F                    4484      MOVE.l  (sp)+,d0            * restore word 1
00081EF4  7200                    4485      MOVEQ       #0,d1               * null length
00081EF6  5380                    4486      SUBQ.l  #1,d0               * decrement start index (word 1)
00081EF8  6B00 EAFE               4487      BMI     LAB_FCER            * if was null do function call error then warm
00081EFC                          4488                              * start
00081EFC                          4489  
00081EFC  B068 0004               4490      CMP.w       4(a0),d0            * compare string length with start index
00081F00  64B8                    4491      BCC.s       LAB_231C            * if start not in string do null string (d1=0)
00081F02                          4492  
00081F02  2207                    4493      MOVE.l  d7,d1               * get length back
00081F04  DE40                    4494      ADD.w       d0,d7               * d7 now = MID$() end
00081F06  6506                    4495      BCS.s       LAB_2368            * already too long so do RIGHT$ equivalent
00081F08                          4496  
00081F08  BE68 0004               4497      CMP.w       4(a0),d7            * compare string length with start index+length
00081F0C  65AC                    4498      BCS.s       LAB_231C            * if end in string go do string
00081F0E                          4499  
00081F0E                          4500  LAB_2368
00081F0E  3228 0004               4501      MOVE.w  4(a0),d1            * get string length
00081F12  9240                    4502      SUB.w       d0,d1               * subtract start offset
00081F14  60A4                    4503      BRA.s       LAB_231C            * go do string (effectively RIGHT$)
00081F16                          4504  
00081F16                          4505  
00081F16                          4506  *************************************************************************************
00081F16                          4507  *
00081F16                          4508  * perform LCASE$()
00081F16                          4509  
00081F16                          4510  LAB_LCASE
00081F16  6100 FF34               4511      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00081F1A                          4512                              * returns with d0 = length, a0 = pointer
00081F1A  2200                    4513      MOVE.l  d0,d1               * copy the string length
00081F1C  6756                    4514      BEQ.s       NoString            * if null go return a null string
00081F1E                          4515  
00081F1E                          4516  * else copy and change the string
00081F1E                          4517  
00081F1E  2248                    4518      MOVEA.l a0,a1               * copy the string address
00081F20  6100 FD96               4519      BSR     LAB_2115            * make a string space d1 bytes long
00081F24  D1C1                    4520      ADDA.l  d1,a0               * new string end
00081F26  D3C1                    4521      ADDA.l  d1,a1               * old string end
00081F28  3401                    4522      MOVE.w  d1,d2               * copy length for loop
00081F2A  5342                    4523      SUBQ.w  #1,d2               * -1 for DBF loop
00081F2C                          4524  LC_loop
00081F2C  1021                    4525      MOVE.b  -(a1),d0            * get byte from string
00081F2E                          4526  
00081F2E  B03C 005B               4527      CMP.b       #$5B,d0         * compare with "Z"+1
00081F32  640A                    4528      BCC.s       NoUcase         * if > "Z" skip change
00081F34                          4529  
00081F34  B03C 0041               4530      CMP.b       #$41,d0         * compare with "A"
00081F38  6504                    4531      BCS.s       NoUcase         * if < "A" skip change
00081F3A                          4532  
00081F3A  0000 0020               4533      ORI.b       #$20,d0         * convert upper case to lower case
00081F3E                          4534  NoUcase
00081F3E  1100                    4535      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00081F40  51CA FFEA               4536      DBF     d2,LC_loop          * decrement and loop if not all done
00081F44                          4537  
00081F44  602E                    4538      BRA.s       NoString            * tidy up & exit (branch always)
00081F46                          4539  
00081F46                          4540  
00081F46                          4541  *************************************************************************************
00081F46                          4542  *
00081F46                          4543  * perform UCASE$()
00081F46                          4544  
00081F46                          4545  LAB_UCASE
00081F46  6100 FF04               4546      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00081F4A                          4547                              * returns with d0 = length, a0 = pointer
00081F4A  2200                    4548      MOVE.l  d0,d1               * copy the string length
00081F4C  6726                    4549      BEQ.s       NoString            * if null go return a null string
00081F4E                          4550  
00081F4E                          4551  * else copy and change the string
00081F4E                          4552  
00081F4E  2248                    4553      MOVEA.l a0,a1               * copy the string address
00081F50  6100 FD66               4554      BSR     LAB_2115            * make a string space d1 bytes long
00081F54  D1C1                    4555      ADDA.l  d1,a0               * new string end
00081F56  D3C1                    4556      ADDA.l  d1,a1               * old string end
00081F58  3401                    4557      MOVE.w  d1,d2               * copy length for loop
00081F5A  5342                    4558      SUBQ.w  #1,d2               * -1 for DBF loop
00081F5C                          4559  UC_loop
00081F5C  1021                    4560      MOVE.b  -(a1),d0            * get a byte from the string
00081F5E                          4561  
00081F5E  B03C 0061               4562      CMP.b       #$61,d0         * compare with "a"
00081F62  650A                    4563      BCS.s       NoLcase         * if < "a" skip change
00081F64                          4564  
00081F64  B03C 007B               4565      CMP.b       #$7B,d0         * compare with "z"+1
00081F68  6404                    4566      BCC.s       NoLcase         * if > "z" skip change
00081F6A                          4567  
00081F6A  0200 00DF               4568      ANDI.b  #$DF,d0         * convert lower case to upper case
00081F6E                          4569  NoLcase
00081F6E  1100                    4570      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00081F70  51CA FFEA               4571      DBF     d2,UC_loop          * decrement and loop if not all done
00081F74                          4572  
00081F74                          4573  NoString
00081F74  6000 FD28               4574      BRA     LAB_RTST            * push string on descriptor stack
00081F78                          4575                              * a0 = pointer, d1 = length
00081F78                          4576  
00081F78                          4577  
00081F78                          4578  *************************************************************************************
00081F78                          4579  *
00081F78                          4580  * perform SADD()
00081F78                          4581  
00081F78                          4582  LAB_SADD
00081F78  101D                    4583      MOVE.b  (a5)+,d0            * increment pointer
00081F7A  6100 F8D6               4584      BSR     LAB_GVAR            * get variable address in a0
00081F7E  6100 F6B0               4585      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00081F82  4A2B 05B5               4586      TST.b       Dtypef(a3)          * test data type flag
00081F86  6A00 EA50               4587      BPL     LAB_TMER            * if numeric do Type missmatch Error
00081F8A                          4588  
00081F8A                          4589  * if you want a non existant variable to return a null value then set the novar
00081F8A                          4590  * value at the top of this file to some non zero value
00081F8A                          4591  
00081F8A                 FALSE    4592   ifne   novar
00081F8A                          4593   endc
00081F8A                          4594  
00081F8A  2010                    4595      MOVE.l  (a0),d0         * get string address
00081F8C  6000 FBB4               4596      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00081F90                          4597  
00081F90                          4598  
00081F90                          4599  *************************************************************************************
00081F90                          4600  *
00081F90                          4601  * perform LEN()
00081F90                          4602  
00081F90                          4603  LAB_LENS
00081F90  487A FBB0               4604      PEA     LAB_AYFC(pc)        * set return address to convert d0 to signed
00081F94                          4605                              * longword in FAC1
00081F94  6000 FEB6               4606      BRA     LAB_22B6            * pop string off descriptor stack or from memory
00081F98                          4607                              * returns with d0 = length, a0 = pointer
00081F98                          4608  
00081F98                          4609  
00081F98                          4610  *************************************************************************************
00081F98                          4611  *
00081F98                          4612  * perform ASC()
00081F98                          4613  
00081F98                          4614  LAB_ASC
00081F98  6100 FEB2               4615      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00081F9C                          4616                              * returns with d0 = length, a0 = pointer
00081F9C  4A40                    4617      TST.w       d0              * test length
00081F9E  6700 EA58               4618      BEQ     LAB_FCER            * if null do function call error then warm start
00081FA2                          4619  
00081FA2  1010                    4620      MOVE.b  (a0),d0         * get first character byte
00081FA4  6000 FBBC               4621      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00081FA8                          4622  
00081FA8                          4623  
00081FA8                          4624  *************************************************************************************
00081FA8                          4625  *
00081FA8                          4626  * increment and get byte, result in d0 and Itemp
00081FA8                          4627  
00081FA8                          4628  LAB_SGBY
00081FA8  6100 F698               4629      BSR     LAB_IGBY            * increment & scan memory
00081FAC                          4630  
00081FAC                          4631  
00081FAC                          4632  *************************************************************************************
00081FAC                          4633  *
00081FAC                          4634  * get byte parameter, result in d0 and Itemp
00081FAC                          4635  
00081FAC                          4636  LAB_GTBY
00081FAC  6100 F51C               4637      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00081FB0                          4638                              * else do type mismatch
00081FB0                          4639  
00081FB0                          4640  
00081FB0                          4641  *************************************************************************************
00081FB0                          4642  *
00081FB0                          4643  * evaluate byte expression, result in d0 and Itemp
00081FB0                          4644  
00081FB0                          4645  LAB_EVBY
00081FB0  6100 F9D4               4646      BSR     LAB_EVPI            * evaluate positive integer expression
00081FB4                          4647                              * result in d0 and Itemp
00081FB4  7280                    4648      MOVEQ       #$80,d1         * set mask/2
00081FB6  D281                    4649      ADD.l       d1,d1               * =$FFFFFF00
00081FB8  C280                    4650      AND.l       d0,d1               * check top 24 bits
00081FBA  6600 EA3C               4651      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00081FBE                          4652  
00081FBE  4E75                    4653      RTS
00081FC0                          4654  
00081FC0                          4655  
00081FC0                          4656  *************************************************************************************
00081FC0                          4657  *
00081FC0                          4658  * get word parameter, result in d0 and Itemp
00081FC0                          4659  
00081FC0                          4660  LAB_GTWO
00081FC0  6100 F508               4661      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00081FC4                          4662                              * else do type mismatch
00081FC4  6100 F9C0               4663      BSR     LAB_EVPI            * evaluate positive integer expression
00081FC8                          4664                              * result in d0 and Itemp
00081FC8  4840                    4665      SWAP        d0              * copy high word to low word
00081FCA  4A40                    4666      TST.w       d0              * set flags
00081FCC  6600 EA2A               4667      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00081FD0                          4668  
00081FD0  4840                    4669      SWAP        d0              * copy high word to low word
00081FD2  4E75                    4670      RTS
00081FD4                          4671  
00081FD4                          4672  
00081FD4                          4673  *************************************************************************************
00081FD4                          4674  *
00081FD4                          4675  * perform VAL()
00081FD4                          4676  
00081FD4                          4677  LAB_VAL
00081FD4  6100 FE76               4678      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00081FD8                          4679                              * returns with d0 = length, a0 = pointer
00081FD8  6722                    4680      BEQ.s       LAB_VALZ            * string was null so set result = $00
00081FDA                          4681                              * clear FAC1 exponent & sign & return
00081FDA                          4682  
00081FDA  2C4D                    4683      MOVEA.l a5,a6               * save BASIC execute pointer
00081FDC  2A48                    4684      MOVEA.l a0,a5               * copy string pointer to execute pointer
00081FDE  D1C0                    4685      ADDA.l  d0,a0               * string end+1
00081FE0  1010                    4686      MOVE.b  (a0),d0         * get byte from string+1
00081FE2  3F00                    4687      MOVE.w  d0,-(sp)            * save it
00081FE4  2F08                    4688      MOVE.l  a0,-(sp)            * save address
00081FE6  10BC 0000               4689      MOVE.b  #0,(a0)         * null terminate string
00081FEA  6100 F658               4690      BSR     LAB_GBYT            * scan memory
00081FEE  6100 1142               4691      BSR     LAB_2887            * get FAC1 from string
00081FF2  205F                    4692      MOVEA.l (sp)+,a0            * restore pointer
00081FF4  301F                    4693      MOVE.w  (sp)+,d0            * pop byte
00081FF6  1080                    4694      MOVE.b  d0,(a0)         * restore to memory
00081FF8  2A4E                    4695      MOVEA.l a6,a5               * restore BASIC execute pointer
00081FFA  4E75                    4696      RTS
00081FFC                          4697  
00081FFC                          4698  LAB_VALZ
00081FFC  3740 0594               4699      MOVE.w  d0,FAC1_e(a3)       * clear FAC1 exponent & sign
00082000  4E75                    4700      RTS
00082002                          4701  
00082002                          4702  
00082002                          4703  *************************************************************************************
00082002                          4704  *
00082002                          4705  * get two parameters for POKE or WAIT, first parameter in a0, second in d0
00082002                          4706  
00082002                          4707  LAB_GADB
00082002  6100 F4C6               4708      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00082006                          4709                              * else do type mismatch
00082006  6100 F986               4710      BSR     LAB_EVIR            * evaluate integer expression
0008200A                          4711                              * (does FC error not OF error if out of range)
0008200A  2F00                    4712      MOVE.l  d0,-(sp)            * copy to stack
0008200C  6100 F62A               4713      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00082010  619A                    4714      BSR.s       LAB_GTBY            * get byte parameter, result in d0 and Itemp
00082012  205F                    4715      MOVEA.l (sp)+,a0            * pull address
00082014  4E75                    4716      RTS
00082016                          4717  
00082016                          4718  
00082016                          4719  *************************************************************************************
00082016                          4720  *
00082016                          4721  * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
00082016                          4722  
00082016                          4723  LAB_GADW
00082016  611E                    4724      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00082018                          4725                              * address returned in d0 and on the stack
00082018  6100 F61E               4726      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
0008201C  6100 F4AC               4727      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00082020                          4728                              * else do type mismatch
00082020  6100 F96C               4729      BSR     LAB_EVIR            * evaluate integer expression
00082024                          4730                              * result in d0 and Itemp
00082024  4840                    4731      SWAP        d0              * swap words
00082026  4A40                    4732      TST.w       d0              * test high word
00082028  6706                    4733      BEQ.s       LAB_XGADW           * exit if null
0008202A                          4734  
0008202A  5240                    4735      ADDQ.w  #1,d0               * increment word
0008202C  6600 E9CA               4736      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00082030                          4737  
00082030                          4738  LAB_XGADW
00082030  4840                    4739      SWAP        d0              * swap words back
00082032  205F                    4740      MOVEA.l (sp)+,a0            * pull address
00082034  4E75                    4741      RTS
00082036                          4742  
00082036                          4743  
00082036                          4744  *************************************************************************************
00082036                          4745  *
00082036                          4746  * get even address (for word or longword memory actions)
00082036                          4747  * address returned in d0 and on the stack
00082036                          4748  * does address error if the address is odd
00082036                          4749  
00082036                          4750  LAB_GEAD
00082036  6100 F492               4751      BSR     LAB_EVNM            * evaluate expression & check is numeric,
0008203A                          4752                              * else do type mismatch
0008203A  6100 F952               4753      BSR     LAB_EVIR            * evaluate integer expression
0008203E                          4754                              * (does FC error not OF error if out of range)
0008203E  0800 0000               4755      BTST        #0,d0               * test low bit of longword
00082042  6600 E970               4756      BNE     LAB_ADER            * if address is odd do address error/warm start
00082046                          4757  
00082046  2057                    4758      MOVEA.l (sp),a0         * copy return address
00082048  2E80                    4759      MOVE.l  d0,(sp)         * even address on stack
0008204A  4ED0                    4760      JMP     (a0)                * effectively RTS
0008204C                          4761  
0008204C                          4762  
0008204C                          4763  *************************************************************************************
0008204C                          4764  *
0008204C                          4765  * perform PEEK()
0008204C                          4766  
0008204C                          4767  LAB_PEEK
0008204C  6100 F940               4768      BSR     LAB_EVIR            * evaluate integer expression
00082050                          4769                              * (does FC error not OF error if out of range)
00082050  2040                    4770      MOVEA.l d0,a0               * copy to address register
00082052  1010                    4771      MOVE.b  (a0),d0         * get byte
00082054  6000 FB0C               4772      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00082058                          4773  
00082058                          4774  
00082058                          4775  *************************************************************************************
00082058                          4776  *
00082058                          4777  * perform POKE
00082058                          4778  
00082058                          4779  LAB_POKE
00082058  61A8                    4780      BSR.s       LAB_GADB            * get two parameters for POKE or WAIT
0008205A                          4781                              * first parameter in a0, second in d0
0008205A  1080                    4782      MOVE.b  d0,(a0)         * put byte in memory
0008205C  4E75                    4783      RTS
0008205E                          4784  
0008205E                          4785  
0008205E                          4786  *************************************************************************************
0008205E                          4787  *
0008205E                          4788  * perform DEEK()
0008205E                          4789  
0008205E                          4790  LAB_DEEK
0008205E  6100 F92E               4791      BSR     LAB_EVIR            * evaluate integer expression
00082062                          4792                              * (does FC error not OF error if out of range)
00082062  E208                    4793      LSR.b       #1,d0               * shift bit 0 to carry
00082064  6500 E94E               4794      BCS     LAB_ADER            * if address is odd do address error/warm start
00082068                          4795  
00082068  D000                    4796      ADD.b       d0,d0               * shift byte back
0008206A  C188                    4797      EXG     d0,a0               * copy to address register
0008206C  7000                    4798      MOVEQ       #0,d0               * clear top bits
0008206E  3010                    4799      MOVE.w  (a0),d0         * get word
00082070  6000 FAD0               4800      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00082074                          4801  
00082074                          4802  
00082074                          4803  *************************************************************************************
00082074                          4804  *
00082074                          4805  * perform LEEK()
00082074                          4806  
00082074                          4807  LAB_LEEK
00082074  6100 F918               4808      BSR     LAB_EVIR            * evaluate integer expression
00082078                          4809                              * (does FC error not OF error if out of range)
00082078  E208                    4810      LSR.b       #1,d0               * shift bit 0 to carry
0008207A  6500 E938               4811      BCS     LAB_ADER            * if address is odd do address error/warm start
0008207E                          4812  
0008207E  D000                    4813      ADD.b       d0,d0               * shift byte back
00082080  C188                    4814      EXG     d0,a0               * copy to address register
00082082  2010                    4815      MOVE.l  (a0),d0         * get longword
00082084  6000 FABC               4816      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00082088                          4817  
00082088                          4818  
00082088                          4819  *************************************************************************************
00082088                          4820  *
00082088                          4821  * perform DOKE
00082088                          4822  
00082088                          4823  LAB_DOKE
00082088  618C                    4824      BSR.s       LAB_GADW            * get two parameters for DOKE or WAIT
0008208A                          4825                              * first parameter in a0, second in d0
0008208A  3080                    4826      MOVE.w  d0,(a0)         * put word in memory
0008208C  4E75                    4827      RTS
0008208E                          4828  
0008208E                          4829  
0008208E                          4830  *************************************************************************************
0008208E                          4831  *
0008208E                          4832  * perform LOKE
0008208E                          4833  
0008208E                          4834  LAB_LOKE
0008208E  61A6                    4835      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00082090                          4836                              * address returned in d0 and on the stack
00082090  6100 F5A6               4837      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00082094  6100 F434               4838      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00082098                          4839                              * else do type mismatch
00082098  6100 F8F4               4840      BSR     LAB_EVIR            * evaluate integer value (no sign check)
0008209C  205F                    4841      MOVEA.l (sp)+,a0            * pull address
0008209E  2080                    4842      MOVE.l  d0,(a0)         * put longword in memory
000820A0                          4843  RTS_015
000820A0  4E75                    4844      RTS
000820A2                          4845  
000820A2                          4846  
000820A2                          4847  *************************************************************************************
000820A2                          4848  *
000820A2                          4849  * perform SWAP
000820A2                          4850  
000820A2                          4851  LAB_SWAP
000820A2  6100 F7AE               4852      BSR     LAB_GVAR            * get variable 1 address in a0
000820A6  2F08                    4853      MOVE.l  a0,-(sp)            * save variable 1 address
000820A8  182B 05B5               4854      MOVE.b  Dtypef(a3),d4       * copy variable 1 data type, $80=string,
000820AC                          4855                              * $40=inetger, $00=float
000820AC                          4856  
000820AC  6100 F58A               4857      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
000820B0  6100 F7A0               4858      BSR     LAB_GVAR            * get variable 2 address in a0
000820B4  245F                    4859      MOVEA.l (sp)+,a2            * restore variable 1 address
000820B6  B82B 05B5               4860      CMP.b       Dtypef(a3),d4       * compare variable 1 data type with variable 2
000820BA                          4861                              * data type
000820BA  6600 E91C               4862      BNE     LAB_TMER            * if not both the same type do "Type mismatch"
000820BE                          4863                              * error then warm start
000820BE                          4864  
000820BE                          4865  * if you do want a non existant variable to return an error then leave the novar
000820BE                          4866  * value at the top of this file set to zero
000820BE                          4867  
000820BE                 TRUE     4868   ifeq   novar
000820BE                          4869  
000820BE  2010                    4870      MOVE.l  (a0),d0         * get variable 2
000820C0  20D2                    4871      MOVE.l  (a2),(a0)+          * copy variable 1 to variable 2
000820C2  24C0                    4872      MOVE.l  d0,(a2)+            * save variable 2 to variable 1
000820C4                          4873  
000820C4  4A04                    4874      TST.b       d4              * check data type
000820C6  6AD8                    4875      BPL.s       RTS_015         * exit if not string
000820C8                          4876  
000820C8  3010                    4877      MOVE.w  (a0),d0         * get string 2 length
000820CA  3092                    4878      MOVE.w  (a2),(a0)           * copy string 1 length to string 2 length
000820CC  3480                    4879      MOVE.w  d0,(a2)         * save string 2 length to string 1 length
000820CE                          4880  
000820CE                          4881   endc
000820CE                          4882  
000820CE                          4883  
000820CE                          4884  * if you want a non existant variable to return a null value then set the novar
000820CE                          4885  * value at the top of this file to some non zero value
000820CE                          4886  
000820CE                 FALSE    4887   ifne   novar
000820CE                          4888                              * value get
000820CE                          4889                              * value get and the new value save
000820CE                          4890                              * new length save
000820CE                          4891                              * new value save
000820CE                          4892   endc
000820CE                          4893  
000820CE  4E75                    4894      RTS
000820D0                          4895  
000820D0                          4896  
000820D0                          4897  *************************************************************************************
000820D0                          4898  *
000820D0                          4899  * perform USR
000820D0                          4900  
000820D0                          4901  LAB_USR
000820D0  4EAB 0406               4902      JSR     Usrjmp(a3)          * do user vector
000820D4  6000 F55A               4903      BRA     LAB_1BFB            * scan for ")", else do syntax error/warm start
000820D8                          4904  
000820D8                          4905  
000820D8                          4906  *************************************************************************************
000820D8                          4907  *
000820D8                          4908  * perform LOAD
000820D8                          4909  
000820D8                          4910  LAB_LOAD
000820D8  4EEB 0418               4911      JMP     V_LOAD(a3)          * do load vector
000820DC                          4912  
000820DC                          4913  
000820DC                          4914  *************************************************************************************
000820DC                          4915  *
000820DC                          4916  * perform SAVE
000820DC                          4917  
000820DC                          4918  LAB_SAVE
000820DC  4EEB 041E               4919      JMP     V_SAVE(a3)          * do save vector
000820E0                          4920  
000820E0                          4921  
000820E0                          4922  *************************************************************************************
000820E0                          4923  *
000820E0                          4924  * perform CALL
000820E0                          4925  
000820E0                          4926  LAB_CALL
000820E0  487A F562               4927      PEA     LAB_GBYT(pc)        * put return address on stack
000820E4  6100 FF50               4928      BSR     LAB_GEAD            * get even address for word/long memory actions
000820E8                          4929                              * address returned in d0 and on the stack
000820E8  4E75                    4930      RTS                     * effectively calls the routine
000820EA                          4931  
000820EA                          4932  * if the called routine exits correctly then it will return via the get byte routine.
000820EA                          4933  * this will then get the next byte for the interpreter and return
000820EA                          4934  
000820EA                          4935  
000820EA                          4936  *************************************************************************************
000820EA                          4937  *
000820EA                          4938  * perform WAIT
000820EA                          4939  
000820EA                          4940  LAB_WAIT
000820EA  6100 FF16               4941      BSR     LAB_GADB            * get two parameters for POKE or WAIT
000820EE                          4942                              * first parameter in a0, second in d0
000820EE  2F08                    4943      MOVE.l  a0,-(sp)            * save address
000820F0  3F00                    4944      MOVE.w  d0,-(sp)            * save byte
000820F2  7400                    4945      MOVEQ       #0,d2               * clear mask
000820F4  6100 F54E               4946      BSR     LAB_GBYT            * scan memory
000820F8  6706                    4947      BEQ.s       LAB_2441            * skip if no third argument
000820FA                          4948  
000820FA  6100 F538               4949      BSR     LAB_SCGB            * scan for "," & get byte,
000820FE                          4950                              * else do syntax error/warm start
000820FE  2400                    4951      MOVE.l  d0,d2               * copy mask
00082100                          4952  LAB_2441
00082100  321F                    4953      MOVE.w  (sp)+,d1            * get byte
00082102  205F                    4954      MOVEA.l (sp)+,a0            * get address
00082104                          4955  LAB_2445
00082104  1010                    4956      MOVE.b  (a0),d0         * read memory byte
00082106  B500                    4957      EOR.b       d2,d0               * EOR with second argument (mask)
00082108  C001                    4958      AND.b       d1,d0               * AND with first argument (byte)
0008210A  67F8                    4959      BEQ.s       LAB_2445            * loop if result is zero
0008210C                          4960  
0008210C  4E75                    4961      RTS
0008210E                          4962  
0008210E                          4963  
0008210E                          4964  *************************************************************************************
0008210E                          4965  *
0008210E                          4966  * perform subtraction, FAC1 from FAC2
0008210E                          4967  
0008210E                          4968  LAB_SUBTRACT
0008210E  0A2B 0080 0595          4969      EORI.b  #$80,FAC1_s(a3)     * complement FAC1 sign
00082114  176B 059D 059E          4970      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign byte
0008211A                          4971  
0008211A  102B 0595               4972      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign byte
0008211E  B12B 059E               4973      EOR.b       d0,FAC_sc(a3)       * EOR with FAC2 sign
00082122                          4974  
00082122                          4975  
00082122                          4976  *************************************************************************************
00082122                          4977  *
00082122                          4978  * add FAC2 to FAC1
00082122                          4979  
00082122                          4980  LAB_ADD
00082122  102B 0594               4981      MOVE.b  FAC1_e(a3),d0       * get exponent
00082126  6700 0338               4982      BEQ     LAB_279B            * FAC1 was zero so copy FAC2 to FAC1 & return
0008212A                          4983  
0008212A                          4984                              * FAC1 is non zero
0008212A  41EB 0598               4985      LEA     FAC2_m(a3),a0       * set pointer1 to FAC2 mantissa
0008212E  102B 059C               4986      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00082132  6746                    4987      BEQ.s       RTS_016         * exit if zero
00082134                          4988  
00082134  902B 0594               4989      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00082138  6722                    4990      BEQ.s       LAB_24A8            * branch if = (go add mantissa)
0008213A                          4991  
0008213A  650A                    4992      BCS.s       LAB_249C            * branch if FAC2 < FAC1
0008213C                          4993  
0008213C                          4994                              * FAC2 > FAC1
0008213C  376B 059C 0594          4995      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy sign and exponent of FAC2
00082142  4400                    4996      NEG.b       d0              * negate exponent difference (make diff -ve)
00082144  5148                    4997      SUBQ.w  #8,a0               * pointer1 to FAC1
00082146                          4998  
00082146                          4999  LAB_249C
00082146  4400                    5000      NEG.b       d0              * negate exponent difference (make diff +ve)
00082148  2F01                    5001      MOVE.l  d1,-(sp)            * save d1
0008214A  B03C 0020               5002      CMP.b       #32,d0          * compare exponent diff with 32
0008214E  6D04                    5003      BLT.s       LAB_2467            * branch if range >= 32
00082150                          5004  
00082150  7200                    5005      MOVEQ       #0,d1               * clear d1
00082152  6004                    5006      BRA.s       LAB_2468            * go clear smaller mantissa
00082154                          5007  
00082154                          5008  LAB_2467
00082154  2210                    5009      MOVE.l  (a0),d1         * get FACx mantissa
00082156  E0A9                    5010      LSR.l       d0,d1               * shift d0 times right
00082158                          5011  LAB_2468
00082158  2081                    5012      MOVE.l  d1,(a0)         * save it back
0008215A  221F                    5013      MOVE.l  (sp)+,d1            * restore d1
0008215C                          5014  
0008215C                          5015                              * exponents are equal now do mantissa add or
0008215C                          5016                              * subtract
0008215C                          5017  LAB_24A8
0008215C  4A2B 059E               5018      TST.b       FAC_sc(a3)          * test sign compare (FAC1 EOR FAC2)
00082160  6B1A                    5019      BMI.s       LAB_24F8            * if <> go do subtract
00082162                          5020  
00082162  202B 0598               5021      MOVE.l  FAC2_m(a3),d0       * get FAC2 mantissa
00082166  D0AB 0590               5022      ADD.l       FAC1_m(a3),d0       * add FAC1 mantissa
0008216A  640A                    5023      BCC.s       LAB_24F7            * save and exit if no carry (FAC1 is normal)
0008216C                          5024  
0008216C  E290                    5025      ROXR.l  #1,d0               * else shift carry back into mantissa
0008216E  522B 0594               5026      ADDQ.b  #1,FAC1_e(a3)       * increment FAC1 exponent
00082172  6500 E880               5027      BCS     LAB_OFER            * if carry do overflow error & warm start
00082176                          5028  
00082176                          5029  LAB_24F7
00082176  2740 0590               5030      MOVE.l  d0,FAC1_m(a3)       * save mantissa
0008217A                          5031  RTS_016
0008217A  4E75                    5032      RTS
0008217C                          5033                              * signs are different
0008217C                          5034  LAB_24F8
0008217C  43EB 0590               5035      LEA     FAC1_m(a3),a1       * pointer 2 to FAC1
00082180  B3C8                    5036      CMPA.l  a0,a1               * compare pointers
00082182  6602                    5037      BNE.s       LAB_24B4            * branch if <>
00082184                          5038  
00082184  5049                    5039      ADDQ.w  #8,a1               * else pointer2 to FAC2
00082186                          5040  
00082186                          5041                              * take smaller from bigger (take sign of bigger)
00082186                          5042  LAB_24B4
00082186  2011                    5043      MOVE.l  (a1),d0         * get larger mantissa
00082188  2210                    5044      MOVE.l  (a0),d1         * get smaller mantissa
0008218A  2740 0590               5045      MOVE.l  d0,FAC1_m(a3)       * save larger mantissa
0008218E  93AB 0590               5046      SUB.l       d1,FAC1_m(a3)       * subtract smaller
00082192                          5047  
00082192                          5048  
00082192                          5049  *************************************************************************************
00082192                          5050  *
00082192                          5051  * do +/- (carry is sign) & normalise FAC1
00082192                          5052  
00082192                          5053  LAB_24D0
00082192  640A                    5054      BCC.s       LAB_24D5            * branch if result is +ve
00082194                          5055  
00082194                          5056                              * erk! subtract is the wrong way round so
00082194                          5057                              * negate everything
00082194  0A2B 00FF 0595          5058      EORI.b  #$FF,FAC1_s(a3)     * complement FAC1 sign
0008219A  44AB 0590               5059      NEG.l       FAC1_m(a3)          * negate FAC1 mantissa
0008219E                          5060  
0008219E                          5061  
0008219E                          5062  *************************************************************************************
0008219E                          5063  *
0008219E                          5064  * normalise FAC1
0008219E                          5065  
0008219E                          5066  LAB_24D5
0008219E  202B 0590               5067      MOVE.l  FAC1_m(a3),d0       * get mantissa
000821A2  6B2E                    5068      BMI.s       LAB_24DA            * mantissa is normal so just exit
000821A4                          5069  
000821A4  6606                    5070      BNE.s       LAB_24D9            * mantissa is not zero so go normalise FAC1
000821A6                          5071  
000821A6  3740 0594               5072      MOVE.w  d0,FAC1_e(a3)       * else make FAC1 = +zero
000821AA  4E75                    5073      RTS
000821AC                          5074  
000821AC                          5075  LAB_24D9
000821AC  2F01                    5076      MOVE.l  d1,-(sp)            * save d1
000821AE  2200                    5077      MOVE.l  d0,d1               * mantissa to d1
000821B0  7000                    5078      MOVEQ       #0,d0               * clear d0
000821B2  102B 0594               5079      MOVE.b  FAC1_e(a3),d0       * get exponent byte
000821B6  6714                    5080      BEQ.s       LAB_24D8            * if exponent is zero then clean up and exit
000821B8                          5081  LAB_24D6
000821B8  D281                    5082      ADD.l       d1,d1               * shift mantissa, ADD is quicker for a single
000821BA                          5083                              * shift
000821BA  5BC8 FFFC               5084      DBMI        d0,LAB_24D6         * decrement exponent and loop if mantissa and
000821BE                          5085                              * exponent +ve
000821BE                          5086  
000821BE  4A40                    5087      TST.w       d0              * test exponent
000821C0  670A                    5088      BEQ.s       LAB_24D8            * if exponent is zero make FAC1 zero
000821C2                          5089  
000821C2  6A02                    5090      BPL.s       LAB_24D7            * if exponent is >zero go save FAC1
000821C4                          5091  
000821C4  7001                    5092      MOVEQ       #1,d0               * else set for zero after correction
000821C6                          5093  LAB_24D7
000821C6  5300                    5094      SUBQ.b  #1,d0               * adjust exponent for loop
000821C8  2741 0590               5095      MOVE.l  d1,FAC1_m(a3)       * save normalised mantissa
000821CC                          5096  LAB_24D8
000821CC  221F                    5097      MOVE.l  (sp)+,d1            * restore d1
000821CE  1740 0594               5098      MOVE.b  d0,FAC1_e(a3)       * save corrected exponent
000821D2                          5099  LAB_24DA
000821D2  4E75                    5100      RTS
000821D4                          5101  
000821D4                          5102  
000821D4                          5103  *************************************************************************************
000821D4                          5104  *
000821D4                          5105  * perform LOG()
000821D4                          5106  
000821D4                          5107  LAB_LOG
000821D4  4A2B 0595               5108      TST.b       FAC1_s(a3)          * test sign
000821D8  6B00 E81E               5109      BMI     LAB_FCER            * if -ve do function call error/warm start
000821DC                          5110  
000821DC  7E00                    5111      MOVEQ       #0,d7               * clear d7
000821DE  1747 059E               5112      MOVE.b  d7,FAC_sc(a3)       * clear sign compare
000821E2  1E2B 0594               5113      MOVE.b  FAC1_e(a3),d7       * get exponent
000821E6  6700 E810               5114      BEQ     LAB_FCER            * if 0 do function call error/warm start
000821EA                          5115  
000821EA  0487 00000081           5116      SUB.l       #$81,d7         * normalise exponent
000821F0  177C 0081 0594          5117      MOVE.b  #$81,FAC1_e(a3)     * force a value between 1 and 2
000821F6  2C2B 0590               5118      MOVE.l  FAC1_m(a3),d6       * copy mantissa
000821FA                          5119  
000821FA  277C 80000000 0598      5120      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00082202  377C 8100 059C          5121      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00082208  6100 FF18               5122      BSR     LAB_ADD         * find arg+1
0008220C  7000                    5123      MOVEQ       #0,d0               * setup for calc skip
0008220E  3740 059C               5124      MOVE.w  d0,FAC2_e(a3)       * set FAC1 for zero result
00082212  DC86                    5125      ADD.l       d6,d6               * shift 1 bit out
00082214  2746 0598               5126      MOVE.l  d6,FAC2_m(a3)       * put back FAC2
00082218  6758                    5127      BEQ.s       LAB_LONN            * if 0 skip calculation
0008221A                          5128  
0008221A  377C 8000 059C          5129      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for .5
00082220  6100 0130               5130      BSR     LAB_DIVIDE          * do (arg-1)/(arg+1)
00082224  4A2B 0594               5131      TST.b       FAC1_e(a3)          * test exponent
00082228  6748                    5132      BEQ.s       LAB_LONN            * if 0 skip calculation
0008222A                          5133  
0008222A  122B 0594               5134      MOVE.b  FAC1_e(a3),d1       * get exponent
0008222E  0401 0082               5135      SUB.b       #$82,d1         * normalise and two integer bits
00082232  4401                    5136      NEG.b       d1              * negate for shift
00082234                          5137  **  CMP.b       #$1F,d1         * will mantissa vanish?
00082234                          5138  **  BGT.s       LAB_dunno           * if so do ???
00082234                          5139  
00082234  202B 0590               5140      MOVE.l  FAC1_m(a3),d0       * get mantissa
00082238  E2A8                    5141      LSR.l       d1,d0               * shift in two integer bits
0008223A                          5142  
0008223A                          5143  * d0 = arg
0008223A                          5144  * d0 = x, d1 = y
0008223A                          5145  * d2 = x1, d3 = y1
0008223A                          5146  * d4 = shift count
0008223A                          5147  * d5 = loop count
0008223A                          5148  * d6 = z
0008223A                          5149  * a0 = table pointer
0008223A                          5150  
0008223A  7C00                    5151      MOVEQ       #0,d6               * z = 0
0008223C  223C 40000000           5152      MOVE.l  #1<<30,d1           * y = 1
00082242  41FA 13FE               5153      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic tangent table
00082246  7A1E                    5154      MOVEQ       #30,d5          * loop 31 times
00082248  7801                    5155      MOVEQ       #1,d4               * set shift count
0008224A  6006                    5156      BRA.s       LAB_LOCC            * entry point for loop
0008224C                          5157  
0008224C                          5158  LAB_LAAD
0008224C  E8A2                    5159      ASR.l       d4,d2               * x1 >> i
0008224E  9282                    5160      SUB.l       d2,d1               * y = y - x1
00082250  DC90                    5161      ADD.l       (a0),d6         * z = z + tanh(i)
00082252                          5162  LAB_LOCC
00082252  2400                    5163      MOVE.l  d0,d2               * x1 = x
00082254  2601                    5164      MOVE.l  d1,d3               * y1 = Y
00082256  E8A3                    5165      ASR.l       d4,d3               * y1 >> i
00082258  6402                    5166      BCC.s       LAB_LOLP
0008225A                          5167  
0008225A  5283                    5168      ADDQ.l  #1,d3
0008225C                          5169  LAB_LOLP
0008225C  9083                    5170      SUB.l       d3,d0               * x = x - y1
0008225E  6AEC                    5171      BPL.s       LAB_LAAD            * branch if > 0
00082260                          5172  
00082260  2002                    5173      MOVE.l  d2,d0               * get x back
00082262  5848                    5174      ADDQ.w  #4,a0               * next entry
00082264  5284                    5175      ADDQ.l  #1,d4               * next i
00082266  E28B                    5176      LSR.l       #1,d3               * /2
00082268  6704                    5177      BEQ.s       LAB_LOCX            * branch y1 = 0
0008226A                          5178  
0008226A  51CD FFF0               5179      DBF     d5,LAB_LOLP         * decrement and loop if not done
0008226E                          5180  
0008226E                          5181                              * now sort out the result
0008226E                          5182  LAB_LOCX
0008226E  DC86                    5183      ADD.l       d6,d6               * *2
00082270  2006                    5184      MOVE.l  d6,d0               * setup for d7 = 0
00082272                          5185  LAB_LONN
00082272  2800                    5186      MOVE.l  d0,d4               * save cordic result
00082274  7A00                    5187      MOVEQ       #0,d5               * set default exponent sign
00082276  4A87                    5188      TST.l       d7              * check original exponent sign
00082278  6716                    5189      BEQ.s       LAB_LOXO            * branch if original was 0
0008227A                          5190  
0008227A  6A04                    5191      BPL.s       LAB_LOXP            * branch if was +ve
0008227C                          5192  
0008227C  4487                    5193      NEG.l       d7              * make original exponent +ve
0008227E  7A80                    5194      MOVEQ       #$80-$100,d5        * make sign -ve
00082280                          5195  LAB_LOXP
00082280  1745 0595               5196      MOVE.b  d5,FAC1_s(a3)       * save original exponent sign
00082284  4847                    5197      SWAP        d7              * 16 bit shift
00082286  E18F                    5198      LSL.l       #8,d7               * easy first part
00082288  7A88                    5199      MOVEQ       #$88-$100,d5        * start with byte
0008228A                          5200  LAB_LONE
0008228A  5385                    5201      SUBQ.l  #1,d5               * decrement exponent
0008228C  DE87                    5202      ADD.l       d7,d7               * shift mantissa
0008228E  6AFA                    5203      BPL.s       LAB_LONE            * loop if not normal
00082290                          5204  
00082290                          5205  LAB_LOXO
00082290  2747 0590               5206      MOVE.l  d7,FAC1_m(a3)       * save original exponent as mantissa
00082294  1745 0594               5207      MOVE.b  d5,FAC1_e(a3)       * save exponent for this
00082298  277C B17217F8 0598      5208      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
000822A0  377C 8000 059C          5209      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
000822A6  176B 0595 059E          5210      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
000822AC  6118                    5211      BSR.s       LAB_MULTIPLY        * do multiply
000822AE  2744 0598               5212      MOVE.l  d4,FAC2_m(a3)       * save cordic result
000822B2  6710                    5213      BEQ.s       LAB_LOWZ            * branch if zero
000822B4                          5214  
000822B4  377C 8200 059C          5215      MOVE.w  #$8200,FAC2_e(a3)       * set exponent & sign
000822BA  176B 0595 059E          5216      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * clear sign compare
000822C0  6100 FE60               5217      BSR     LAB_ADD         * and add for final result
000822C4                          5218  
000822C4                          5219  LAB_LOWZ
000822C4  4E75                    5220      RTS
000822C6                          5221  
000822C6                          5222  
000822C6                          5223  *************************************************************************************
000822C6                          5224  *
000822C6                          5225  * multiply FAC1 by FAC2
000822C6                          5226  
000822C6                          5227  LAB_MULTIPLY
000822C6  48E7 F800               5228      MOVEM.l d0-d4,-(sp)         * save registers
000822CA  4A2B 0594               5229      TST.b       FAC1_e(a3)          * test FAC1 exponent
000822CE  6776                    5230      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
000822D0                          5231  
000822D0  102B 059C               5232      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
000822D4  6770                    5233      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
000822D6                          5234  
000822D6  176B 059E 0595          5235      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare becomes sign
000822DC                          5236  
000822DC  D02B 0594               5237      ADD.b       FAC1_e(a3),d0       * multiply exponents by adding
000822E0  640A                    5238      BCC.s       LAB_MNOC            * branch if no carry
000822E2                          5239  
000822E2  0400 0080               5240      SUB.b       #$80,d0         * normalise result
000822E6  6400 E70C               5241      BCC     LAB_OFER            * if no carry do overflow
000822EA                          5242  
000822EA  6006                    5243      BRA.s       LAB_MADD            * branch
000822EC                          5244  
000822EC                          5245                              * no carry for exponent add
000822EC                          5246  LAB_MNOC
000822EC  0400 0080               5247      SUB.b       #$80,d0         * normalise result
000822F0  6554                    5248      BCS.s       LAB_MUUF            * return zero if underflow
000822F2                          5249  
000822F2                          5250  LAB_MADD
000822F2  1740 0594               5251      MOVE.b  d0,FAC1_e(a3)       * save exponent
000822F6                          5252  
000822F6                          5253                              * d1 (FAC1) x d2 (FAC2)
000822F6  222B 0590               5254      MOVE.l  FAC1_m(a3),d1       * get FAC1 mantissa
000822FA  242B 0598               5255      MOVE.l  FAC2_m(a3),d2       * get FAC2 mantissa
000822FE                          5256  
000822FE  3801                    5257      MOVE.w  d1,d4               * copy low word FAC1
00082300  2001                    5258      MOVE.l  d1,d0               * copy long word FAC1
00082302  4840                    5259      SWAP        d0              * high word FAC1 to low word FAC1
00082304  3600                    5260      MOVE.w  d0,d3               * copy high word FAC1
00082306                          5261  
00082306  C2C2                    5262      MULU        d2,d1               * low word FAC2 x low word FAC1
00082308  C0C2                    5263      MULU        d2,d0               * low word FAC2 x high word FAC1
0008230A  4842                    5264      SWAP        d2              * high word FAC2 to low word FAC2
0008230C  C8C2                    5265      MULU        d2,d4               * high word FAC2 x low word FAC1
0008230E  C6C2                    5266      MULU        d2,d3               * high word FAC2 x high word FAC1
00082310                          5267  
00082310                          5268  * done multiply, now add partial products
00082310                          5269  
00082310                          5270  *           d1 =                    aaaa  ----  FAC2_L x FAC1_L
00082310                          5271  *           d0 =                bbbb  aaaa      FAC2_L x FAC1_H
00082310                          5272  *           d4 =                bbbb  aaaa      FAC2_H x FAC1_L
00082310                          5273  *           d3 =            cccc  bbbb          FAC2_H x FAC1_H
00082310                          5274  *           product =       mmmm  mmmm
00082310                          5275  
00082310  0681 00008000           5276      ADD.L       #$8000,d1           * round up lowest word
00082316  4241                    5277      CLR.w       d1              * clear low word, don't need it
00082318  4841                    5278      SWAP        d1              * align high word
0008231A  D280                    5279      ADD.l       d0,d1               * add FAC2_L x FAC1_H (can't be carry)
0008231C                          5280  LAB_MUF1
0008231C  D284                    5281      ADD.l       d4,d1               * now add intermediate (FAC2_H x FAC1_L)
0008231E  6406                    5282      BCC.s       LAB_MUF2            * branch if no carry
00082320                          5283  
00082320  0683 00010000           5284      ADD.l       #$10000,d3          * else correct result
00082326                          5285  LAB_MUF2
00082326  0681 00008000           5286      ADD.l       #$8000,d1           * round up low word
0008232C  4241                    5287      CLR.w       d1              * clear low word
0008232E  4841                    5288      SWAP        d1              * align for final add
00082330  D283                    5289      ADD.l       d3,d1               * add FAC2_H x FAC1_H, result
00082332  6B08                    5290      BMI.s       LAB_MUF3            * branch if normalisation not needed
00082334                          5291  
00082334  D281                    5292      ADD.l       d1,d1               * shift mantissa
00082336  532B 0594               5293      SUBQ.b  #1,FAC1_e(a3)       * adjust exponent
0008233A  670A                    5294      BEQ.s       LAB_MUUF            * branch if underflow
0008233C                          5295  
0008233C                          5296  LAB_MUF3
0008233C  2741 0590               5297      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00082340                          5298  LAB_MUEX
00082340  4CDF 001F               5299      MOVEM.l (sp)+,d0-d4         * restore registers
00082344  4E75                    5300      RTS
00082346                          5301                              * either zero or underflow result
00082346                          5302  LAB_MUUF
00082346  7000                    5303      MOVEQ       #0,d0               * quick clear
00082348  2740 0590               5304      MOVE.l  d0,FAC1_m(a3)       * clear mantissa
0008234C  3740 0594               5305      MOVE.w  d0,FAC1_e(a3)       * clear sign and exponent
00082350  60EE                    5306      BRA.s       LAB_MUEX            * restore regs & exit
00082352                          5307  
00082352                          5308  
00082352                          5309  *************************************************************************************
00082352                          5310  *
00082352                          5311  * do FAC2/FAC1, result in FAC1
00082352                          5312  * fast hardware divide version
00082352                          5313  
00082352                          5314  LAB_DIVIDE
00082352  2F07                    5315      MOVE.l  d7,-(sp)            * save d7
00082354  7000                    5316      MOVEQ       #0,d0               * clear FAC2 exponent
00082356  2400                    5317      MOVE.l  d0,d2               * clear FAC1 exponent
00082358                          5318  
00082358  142B 0594               5319      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
0008235C  6700 E682               5320      BEQ     LAB_DZER            * if zero go do /0 error
00082360                          5321  
00082360  102B 059C               5322      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00082364  6766                    5323      BEQ.s       LAB_DIV0            * if zero return zero
00082366                          5324  
00082366  9042                    5325      SUB.w       d2,d0               * get result exponent by subtracting
00082368  0640 0080               5326      ADD.w       #$80,d0         * correct 16 bit exponent result
0008236C                          5327  
0008236C  176B 059E 0595          5328      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare is result sign
00082372                          5329  
00082372                          5330  * now to do 32/32 bit mantissa divide
00082372                          5331  
00082372  422B 059F               5332      CLR.b       flag(a3)            * clear 'flag' byte
00082376  262B 0590               5333      MOVE.l  FAC1_m(a3),d3       * get FAC1 mantissa
0008237A  282B 0598               5334      MOVE.l  FAC2_m(a3),d4       * get FAC2 mantissa
0008237E  B883                    5335      CMP.l       d3,d4               * compare FAC2 with FAC1 mantissa
00082380  6744                    5336      BEQ.s       LAB_MAN1            * set mantissa result = 1 if equal
00082382                          5337  
00082382  6506                    5338      BCS.s       AC1gtAC2            * branch if FAC1 > FAC2
00082384                          5339  
00082384  9883                    5340      SUB.l       d3,d4               * subtract FAC1 from FAC2, result now must be <1
00082386  562B 059F               5341      ADDQ.b  #3,flag(a3)         * FAC2>FAC1 so set 'flag' byte
0008238A                          5342  AC1gtAC2
0008238A  6146                    5343      BSR.s       LAB_32_16           * do 32/16 divide
0008238C  4841                    5344      SWAP        d1              * move 16 bit result to high word
0008238E  2802                    5345      MOVE.l  d2,d4               * copy remainder longword
00082390  6142                    5346      BSR.s       LAB_3216            * do 32/16 divide again (skip copy d4 to d2)
00082392  84C5                    5347      DIVU.w  d5,d2               * now divide remainder to make guard word
00082394  1E2B 059F               5348      MOVE.b  flag(a3),d7         * now normalise, get flag byte back
00082398  6708                    5349      BEQ.s       LAB_DIVX            * skip add if null
0008239A                          5350  
0008239A                          5351  * else result was >1 so we need to add 1 to result mantissa and adjust exponent
0008239A                          5352  
0008239A  E20F                    5353      LSR.b       #1,d7               * shift 1 into eXtend
0008239C  E291                    5354      ROXR.l  #1,d1               * shift extend result >>
0008239E  E252                    5355      ROXR.w  #1,d2               * shift extend guard word >>
000823A0  5200                    5356      ADDQ.b  #1,d0               * adjust exponent
000823A2                          5357  
000823A2                          5358  * now round result to 32 bits
000823A2                          5359  
000823A2                          5360  LAB_DIVX
000823A2  D442                    5361      ADD.w       d2,d2               * guard bit into eXtend bit
000823A4  6408                    5362      BCC.s       L_DIVRND            * branch if guard=0
000823A6                          5363  
000823A6  5281                    5364      ADDQ.l  #1,d1               * add guard to mantissa
000823A8  6404                    5365      BCC.s       L_DIVRND            * branch if no overflow
000823AA                          5366  
000823AA                          5367  LAB_SET1
000823AA  E291                    5368      ROXR.l  #1,d1               * shift extend result >>
000823AC  5240                    5369      ADDQ.w  #1,d0               * adjust exponent
000823AE                          5370  
000823AE                          5371                              * test for over/under flow
000823AE                          5372  L_DIVRND
000823AE  3600                    5373      MOVE.w  d0,d3               * copy exponent
000823B0  6B1A                    5374      BMI.s       LAB_DIV0            * if -ve return zero
000823B2                          5375  
000823B2  0243 FF00               5376      ANDI.w  #$FF00,d3           * mask word high byte
000823B6  6600 E63C               5377      BNE     LAB_OFER            * branch if overflow
000823BA                          5378  
000823BA                          5379                              * move result into FAC1
000823BA                          5380  LAB_XDIV
000823BA  2E1F                    5381      MOVE.l  (sp)+,d7            * restore d7
000823BC  1740 0594               5382      MOVE.b  d0,FAC1_e(a3)       * save result exponent
000823C0  2741 0590               5383      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
000823C4  4E75                    5384      RTS
000823C6                          5385  
000823C6                          5386  * FAC1 mantissa = FAC2 mantissa so set result mantissa
000823C6                          5387  
000823C6                          5388  LAB_MAN1
000823C6  7201                    5389      MOVEQ       #1,d1               * set bit
000823C8  E2A9                    5390      LSR.l       d1,d1               * bit into eXtend
000823CA  60DE                    5391      BRA.s       LAB_SET1            * set mantissa, adjust exponent and exit
000823CC                          5392  
000823CC                          5393  * result is zero
000823CC                          5394  
000823CC                          5395  LAB_DIV0
000823CC  7000                    5396      MOVEQ       #0,d0               * zero exponent & sign
000823CE  2200                    5397      MOVE.l  d0,d1               * zero mantissa
000823D0  60E8                    5398      BRA     LAB_XDIV            * exit divide
000823D2                          5399  
000823D2                          5400  * divide 16 bits into 32, AB/Ex
000823D2                          5401  *
000823D2                          5402  * d4            AAAA    BBBB            * 32 bit numerator
000823D2                          5403  * d3            EEEE    xxxx            * 16 bit denominator
000823D2                          5404  *
000823D2                          5405  * returns -
000823D2                          5406  *
000823D2                          5407  * d1            xxxx    DDDD            * 16 bit result
000823D2                          5408  * d2                HHHH    IIII        * 32 bit remainder
000823D2                          5409  
000823D2                          5410  LAB_32_16
000823D2  2404                    5411      MOVE.l  d4,d2               * copy FAC2 mantissa        (AB)
000823D4                          5412  LAB_3216
000823D4  2A03                    5413      MOVE.l  d3,d5               * copy FAC1 mantissa        (EF)
000823D6  4245                    5414      CLR.w       d5              * clear low word d1     (Ex)
000823D8  4845                    5415      SWAP        d5              * swap high word to low word    (xE)
000823DA                          5416  
000823DA                          5417  * d3            EEEE    FFFF            * denominator copy
000823DA                          5418  * d5        0000    EEEE                * denominator high word
000823DA                          5419  * d2            AAAA    BBBB            * numerator copy
000823DA                          5420  * d4            AAAA    BBBB            * numerator
000823DA                          5421  
000823DA  88C5                    5422      DIVU.w  d5,d4               * do FAC2/FAC1 high word    (AB/E)
000823DC  6802                    5423      BVC.s       LAB_LT_1            * if no overflow DIV was ok
000823DE                          5424  
000823DE  78FF                    5425      MOVEQ       #-1,d4          * else set default value
000823E0                          5426  
000823E0                          5427  * done the divide, now check the result, we have ...
000823E0                          5428  
000823E0                          5429  * d3            EEEE    FFFF            * denominator copy
000823E0                          5430  * d5        0000    EEEE                * denominator high word
000823E0                          5431  * d2            AAAA    BBBB            * numerator copy
000823E0                          5432  * d4            MMMM    DDDD            * result MOD and DIV
000823E0                          5433  
000823E0                          5434  LAB_LT_1
000823E0  3C04                    5435      MOVE.w  d4,d6               * copy 16 bit result
000823E2  3204                    5436      MOVE.w  d4,d1               * copy 16 bit result again
000823E4                          5437  
000823E4                          5438  * we now have ..
000823E4                          5439  * d3            EEEE    FFFF            * denominator copy
000823E4                          5440  * d5        0000    EEEE                * denominator high word
000823E4                          5441  * d6            xxxx  DDDD          * result DIV copy
000823E4                          5442  * d1            xxxx  DDDD          * result DIV copy
000823E4                          5443  * d2            AAAA    BBBB            * numerator copy
000823E4                          5444  * d4            MMMM    DDDD            * result MOD and DIV
000823E4                          5445  
000823E4                          5446  * now multiply out 32 bit denominator by 16 bit result
000823E4                          5447  * QRS = AB*D
000823E4                          5448  
000823E4  CCC3                    5449      MULU.w  d3,d6               * FFFF * DDDD =       rrrr  SSSS
000823E6  C8C5                    5450      MULU.w  d5,d4               * EEEE * DDDD = QQQQ  rrrr
000823E8                          5451  
000823E8                          5452  * we now have ..
000823E8                          5453  * d3            EEEE    FFFF            * denominator copy
000823E8                          5454  * d5        0000    EEEE                * denominator high word
000823E8                          5455  * d6                rrrr  SSSS      * 48 bit result partial low
000823E8                          5456  * d1            xxxx  DDDD          * result DIV copy
000823E8                          5457  * d2            AAAA    BBBB            * numerator copy
000823E8                          5458  * d4            QQQQ    rrrr            * 48 bit result partial
000823E8                          5459  
000823E8  3E06                    5460      MOVE.w  d6,d7               * copy low word of low multiply
000823EA                          5461  
000823EA                          5462  * d7                xxxx    SSSS        * 48 bit result partial low
000823EA                          5463  
000823EA  4246                    5464      CLR.w       d6              * clear low word of low multiply
000823EC  4846                    5465      SWAP        d6              * high word of low multiply to low word
000823EE                          5466  
000823EE                          5467  * d6            0000    rrrr            * high word of 48 bit result partial low
000823EE                          5468  
000823EE  D886                    5469      ADD.l       d6,d4
000823F0                          5470  
000823F0                          5471  * d4            QQQQ    RRRR            * 48 bit result partial high longword
000823F0                          5472  
000823F0  7C00                    5473      MOVEQ       #0,d6               * clear to extend numerator to 48 bits
000823F2                          5474  
000823F2                          5475  * now do GHI = AB0 - QRS (which is the remainder)
000823F2                          5476  
000823F2  9C47                    5477      SUB.w       d7,d6               * low word subtract
000823F4                          5478  
000823F4                          5479  * d6                xxxx    IIII        * remainder low word
000823F4                          5480  
000823F4  9584                    5481      SUBX.l  d4,d2               * high longword subtract
000823F6                          5482  
000823F6                          5483  * d2            GGGG    HHHH            * remainder high longword
000823F6                          5484  
000823F6                          5485  * now if we got the divide correct then the remainder high longword will be +ve
000823F6                          5486  
000823F6  6A08                    5487      BPL.s       L_DDIV          * branch if result is ok (<needed)
000823F8                          5488  
000823F8                          5489  * remainder was -ve so DDDD is too big
000823F8                          5490  
000823F8                          5491  LAB_REMM
000823F8  5341                    5492      SUBQ.w  #1,d1               * adjust DDDD
000823FA                          5493  
000823FA                          5494  * d3                xxxx    FFFF        * denominator copy
000823FA                          5495  * d6                xxxx    IIII        * remainder low word
000823FA                          5496  
000823FA  DC43                    5497      ADD.w       d3,d6               * add EF*1 low remainder low word
000823FC                          5498  
000823FC                          5499  * d5            0000    EEEE            * denominator high word
000823FC                          5500  * d2            GGGG    HHHH            * remainder high longword
000823FC                          5501  
000823FC  D585                    5502      ADDX.l  d5,d2               * add extend EF*1 to remainder high longword
000823FE  6BF8                    5503      BMI.s       LAB_REMM            * loop if result still too big
00082400                          5504  
00082400                          5505  * all done and result correct or <
00082400                          5506  
00082400                          5507  L_DDIV
00082400  4842                    5508      SWAP        d2              * remainder mid word to high word
00082402                          5509  
00082402                          5510  * d2            HHHH    GGGG            * (high word /should/ be $0000)
00082402                          5511  
00082402  3406                    5512      MOVE.w  d6,d2               * remainder in high word
00082404                          5513  
00082404                          5514  * d2                HHHH    IIII        * now is 32 bit remainder
00082404                          5515  * d1            xxxx    DDDD            * 16 bit result
00082404                          5516  
00082404  4E75                    5517      RTS
00082406                          5518  
00082406                          5519  
00082406                          5520  *************************************************************************************
00082406                          5521  *
00082406                          5522  * unpack memory (a0) into FAC1
00082406                          5523  
00082406                          5524  LAB_UFAC
00082406  2010                    5525      MOVE.l  (a0),d0         * get packed value
00082408  4840                    5526      SWAP        d0              * exponent and sign into least significant word
0008240A  3740 0594               5527      MOVE.w  d0,FAC1_e(a3)       * save exponent and sign
0008240E  6708                    5528      BEQ.s       LAB_NB1T            * branch if exponent (and the rest) zero
00082410                          5529  
00082410  807C 0080               5530      OR.w        #$80,d0         * set MSb
00082414  4840                    5531      SWAP        d0              * word order back to normal
00082416  E180                    5532      ASL.l       #8,d0               * shift exponent & clear guard byte
00082418                          5533  LAB_NB1T
00082418  2740 0590               5534      MOVE.l  d0,FAC1_m(a3)       * move into FAC1
0008241C                          5535  
0008241C  102B 0594               5536      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00082420  4E75                    5537      RTS
00082422                          5538  
00082422                          5539  
00082422                          5540  *************************************************************************************
00082422                          5541  *
00082422                          5542  * set numeric variable, pack FAC1 into Lvarpl
00082422                          5543  
00082422                          5544  LAB_PFAC
00082422  2F08                    5545      MOVE.l  a0,-(sp)            * save pointer
00082424  206B 0472               5546      MOVEA.l Lvarpl(a3),a0       * get destination pointer
00082428  082B 0006 05B5          5547      BTST        #6,Dtypef(a3)       * test data type
0008242E  670C                    5548      BEQ.s       LAB_277C            * branch if floating
00082430                          5549  
00082430  6100 00C6               5550      BSR     LAB_2831            * convert FAC1 floating to fixed
00082434                          5551                              * result in d0 and Itemp
00082434  2080                    5552      MOVE.l  d0,(a0)         * save in var
00082436  205F                    5553      MOVE.l  (sp)+,a0            * restore pointer
00082438  4E75                    5554      RTS
0008243A                          5555  
0008243A                          5556  
0008243A                          5557  *************************************************************************************
0008243A                          5558  *
0008243A                          5559  * normalise round and pack FAC1 into (a0)
0008243A                          5560  
0008243A                          5561  LAB_2778
0008243A  2F08                    5562      MOVE.l  a0,-(sp)            * save pointer
0008243C                          5563  LAB_277C
0008243C  6100 FD60               5564      BSR     LAB_24D5            * normalise FAC1
00082440  612C                    5565      BSR.s       LAB_27BA            * round FAC1
00082442  202B 0590               5566      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00082446  E098                    5567      ROR.l       #8,d0               * align 24/32 bit mantissa
00082448  4840                    5568      SWAP        d0              * exponent/sign into 0-15
0008244A  C07C 007F               5569      AND.w       #$7F,d0         * clear exponent and sign bit
0008244E  022B 0080 0595          5570      ANDI.b  #$80,FAC1_s(a3)     * clear non sign bits in sign
00082454  806B 0594               5571      OR.w        FAC1_e(a3),d0       * OR in exponent and sign
00082458  4840                    5572      SWAP        d0              * move exponent and sign back to 16-31
0008245A  2080                    5573      MOVE.l  d0,(a0)         * store in destination
0008245C  205F                    5574      MOVE.l  (sp)+,a0            * restore pointer
0008245E  4E75                    5575      RTS
00082460                          5576  
00082460                          5577  
00082460                          5578  *************************************************************************************
00082460                          5579  *
00082460                          5580  * copy FAC2 to FAC1
00082460                          5581  
00082460                          5582  LAB_279B
00082460  376B 059C 0594          5583      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy exponent & sign
00082466  276B 0598 0590          5584      MOVE.l  FAC2_m(a3),FAC1_m(a3)   * copy mantissa
0008246C  4E75                    5585      RTS
0008246E                          5586  
0008246E                          5587  
0008246E                          5588  *************************************************************************************
0008246E                          5589  *
0008246E                          5590  * round FAC1
0008246E                          5591  
0008246E                          5592  LAB_27BA
0008246E  102B 0594               5593      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00082472  6720                    5594      BEQ.s       LAB_27C4            * branch if zero
00082474                          5595  
00082474  202B 0590               5596      MOVE.l  FAC1_m(a3),d0       * get FAC1
00082478  0680 00000080           5597      ADD.l       #$80,d0         * round to 24 bit
0008247E  640A                    5598      BCC.s       LAB_27C3            * branch if no overflow
00082480                          5599  
00082480  E290                    5600      ROXR.l  #1,d0               * shift FAC1 mantissa
00082482  522B 0594               5601      ADDQ.b  #1,FAC1_e(a3)       * correct exponent
00082486  6500 E56C               5602      BCS     LAB_OFER            * if carry do overflow error & warm start
0008248A                          5603  
0008248A                          5604  LAB_27C3
0008248A  C03C 0000               5605      AND.b       #$00,d0         * clear guard byte
0008248E  2740 0590               5606      MOVE.l  d0,FAC1_m(a3)       * save back to FAC1
00082492  4E75                    5607      RTS
00082494                          5608  
00082494                          5609  LAB_27C4
00082494  1740 0595               5610      MOVE.b  d0,FAC1_s(a3)       * make zero always +ve
00082498                          5611  RTS_017
00082498  4E75                    5612      RTS
0008249A                          5613  
0008249A                          5614  
0008249A                          5615  *************************************************************************************
0008249A                          5616  *
0008249A                          5617  * get FAC1 sign
0008249A                          5618  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
0008249A                          5619  
0008249A                          5620  LAB_27CA
0008249A  7000                    5621      MOVEQ       #0,d0               * clear d0
0008249C  102B 0594               5622      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
000824A0  67F6                    5623      BEQ.s       RTS_017         * exit if zero (already correct SGN(0)=0)
000824A2                          5624  
000824A2                          5625  
000824A2                          5626  *************************************************************************************
000824A2                          5627  *
000824A2                          5628  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
000824A2                          5629  * no = 0 check
000824A2                          5630  
000824A2                          5631  LAB_27CE
000824A2  102B 0595               5632      MOVE.b  FAC1_s(a3),d0       * else get FAC1 sign (b7)
000824A6                          5633  
000824A6                          5634  
000824A6                          5635  *************************************************************************************
000824A6                          5636  *
000824A6                          5637  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
000824A6                          5638  * no = 0 check, sign in d0
000824A6                          5639  
000824A6                          5640  LAB_27D0
000824A6  4880                    5641      EXT.w       d0              * make word
000824A8  48C0                    5642      EXT.l       d0              * make longword
000824AA  E080                    5643      ASR.l       #8,d0               * move sign bit through byte to carry
000824AC  65EA                    5644      BCS.s       RTS_017         * exit if carry set
000824AE                          5645  
000824AE  7001                    5646      MOVEQ       #1,d0               * set result for +ve sign
000824B0  4E75                    5647      RTS
000824B2                          5648  
000824B2                          5649  
000824B2                          5650  *************************************************************************************
000824B2                          5651  *
000824B2                          5652  * perform SGN()
000824B2                          5653  
000824B2                          5654  LAB_SGN
000824B2  61E6                    5655      BSR.s       LAB_27CA            * get FAC1 sign
000824B4                          5656                              * return d0=-1/-ve d0=+1/+ve
000824B4                          5657  
000824B4                          5658  
000824B4                          5659  *************************************************************************************
000824B4                          5660  *
000824B4                          5661  * save d0 as integer longword
000824B4                          5662  
000824B4                          5663  LAB_27DB
000824B4  2740 0590               5664      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
000824B8  377C A000 0594          5665      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent & sign
000824BE  D080                    5666      ADD.l       d0,d0               * top bit into carry
000824C0  6000 FCD0               5667      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
000824C4                          5668  
000824C4                          5669  
000824C4                          5670  *************************************************************************************
000824C4                          5671  *
000824C4                          5672  * perform ABS()
000824C4                          5673  
000824C4                          5674  LAB_ABS
000824C4  177C 0000 0595          5675      MOVE.b  #0,FAC1_s(a3)       * clear FAC1 sign
000824CA  4E75                    5676      RTS
000824CC                          5677  
000824CC                          5678  
000824CC                          5679  *************************************************************************************
000824CC                          5680  *
000824CC                          5681  * compare FAC1 with FAC2
000824CC                          5682  * returns d0=+1 Cb=0 if FAC1 > FAC2
000824CC                          5683  * returns d0= 0 Cb=0 if FAC1 = FAC2
000824CC                          5684  * returns d0=-1 Cb=1 if FAC1 < FAC2
000824CC                          5685  
000824CC                          5686  LAB_27FA
000824CC  122B 059C               5687      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
000824D0  67C8                    5688      BEQ.s       LAB_27CA            * branch if FAC2 exponent=0 & get FAC1 sign
000824D2                          5689                              * d0=-1,C=1/-ve d0=+1,C=0/+ve
000824D2                          5690  
000824D2  102B 059E               5691      MOVE.b  FAC_sc(a3),d0       * get FAC sign compare
000824D6  6BCA                    5692      BMI.s       LAB_27CE            * if signs <> do return d0=-1,C=1/-ve
000824D8                          5693                              * d0=+1,C=0/+ve & return
000824D8                          5694  
000824D8  102B 0595               5695      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
000824DC  B22B 0594               5696      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
000824E0  660A                    5697      BNE.s       LAB_2828            * branch if different
000824E2                          5698  
000824E2  222B 0598               5699      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
000824E6  B2AB 0590               5700      CMP.l       FAC1_m(a3),d1       * compare mantissas
000824EA  6708                    5701      BEQ.s       LAB_282F            * exit if mantissas equal
000824EC                          5702  
000824EC                          5703  * gets here if number <> FAC1
000824EC                          5704  
000824EC                          5705  LAB_2828
000824EC  65B8                    5706      BCS.s       LAB_27D0            * if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
000824EE                          5707                              * C=0/+ve
000824EE                          5708  
000824EE  0A00 0080               5709      EORI.b  #$80,d0         * else toggle FAC1 sign
000824F2                          5710  LAB_282E
000824F2  60B2                    5711      BRA.s       LAB_27D0            * return d0=-1,C=1/-ve d0=+1,C=0/+ve
000824F4                          5712  
000824F4                          5713  LAB_282F
000824F4  7000                    5714      MOVEQ       #0,d0               * clear result
000824F6  4E75                    5715      RTS
000824F8                          5716  
000824F8                          5717  
000824F8                          5718  *************************************************************************************
000824F8                          5719  *
000824F8                          5720  * convert FAC1 floating to fixed
000824F8                          5721  * result in d0 and Itemp, sets flags correctly
000824F8                          5722  
000824F8                          5723  LAB_2831
000824F8  202B 0590               5724      MOVE.l  FAC1_m(a3),d0       * copy mantissa
000824FC  6730                    5725      BEQ.s       LAB_284J            * branch if mantissa = 0
000824FE                          5726  
000824FE  2F01                    5727      MOVE.l  d1,-(sp)            * save d1
00082500  72A0                    5728      MOVEQ       #$A0,d1         * set for no floating bits
00082502  922B 0594               5729      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent
00082506  6500 E4EC               5730      BCS     LAB_OFER            * do overflow if too big
0008250A                          5731  
0008250A  660E                    5732      BNE.s       LAB_284G            * branch if exponent was not $A0
0008250C                          5733  
0008250C  4A2B 0595               5734      TST.b       FAC1_s(a3)          * test FAC1 sign
00082510  6A1A                    5735      BPL.s       LAB_284H            * branch if FAC1 +ve
00082512                          5736  
00082512  4480                    5737      NEG.l       d0
00082514  6916                    5738      BVS.s       LAB_284H            * branch if was $80000000
00082516                          5739  
00082516  6000 E4DC               5740      BRA     LAB_OFER            * do overflow if too big
0008251A                          5741  
0008251A                          5742  LAB_284G
0008251A  B23C 0020               5743      CMP.b       #$20,d1         * compare with minimum result for integer
0008251E  6502                    5744      BCS.s       LAB_284L            * if < minimum just do shift
00082520                          5745  
00082520  7000                    5746      MOVEQ       #0,d0               * else return zero
00082522                          5747  LAB_284L
00082522  E2A8                    5748      LSR.l       d1,d0               * shift integer
00082524                          5749  
00082524  4A2B 0595               5750      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00082528  6A02                    5751      BPL.s       LAB_284H            * branch if FAC1 +ve
0008252A                          5752  
0008252A  4480                    5753      NEG.l       d0              * negate integer value
0008252C                          5754  LAB_284H
0008252C  221F                    5755      MOVE.l  (sp)+,d1            * restore d1
0008252E                          5756  LAB_284J
0008252E  2740 042A               5757      MOVE.l  d0,Itemp(a3)        * save result to Itemp
00082532  4E75                    5758      RTS
00082534                          5759  
00082534                          5760  
00082534                          5761  *************************************************************************************
00082534                          5762  *
00082534                          5763  * perform INT()
00082534                          5764  
00082534                          5765  LAB_INT
00082534  70A0                    5766      MOVEQ       #$A0,d0         * set for no floating bits
00082536  902B 0594               5767      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
0008253A  6310                    5768      BLS.s       LAB_IRTS            * exit if exponent >= $A0
0008253C                          5769                              * (too big for fraction part!)
0008253C                          5770  
0008253C  B03C 0020               5771      CMP.b       #$20,d0         * compare with minimum result for integer
00082540  6400 025E               5772      BCC     LAB_POZE            * if >= minimum go return 0
00082544                          5773                              * (too small for integer part!)
00082544                          5774  
00082544  72FF                    5775      MOVEQ       #-1,d1          * set integer mask
00082546  E1A1                    5776      ASL.l       d0,d1               * shift mask [8+2*d0]
00082548  C3AB 0590               5777      AND.l       d1,FAC1_m(a3)       * mask mantissa
0008254C                          5778  LAB_IRTS
0008254C  4E75                    5779      RTS
0008254E                          5780  
0008254E                          5781  
0008254E                          5782  *************************************************************************************
0008254E                          5783  *
0008254E                          5784  * print " in line [LINE #]"
0008254E                          5785  
0008254E                          5786  LAB_2953
0008254E  41FA 17FA               5787      LEA     LAB_LMSG(pc),a0     * point to " in line " message
00082552  6100 ED24               5788      BSR     LAB_18C3            * print null terminated string
00082556                          5789  
00082556                          5790                              * Print Basic line #
00082556  202B 0452               5791      MOVE.l  Clinel(a3),d0       * get current line
0008255A                          5792  
0008255A                          5793  
0008255A                          5794  *************************************************************************************
0008255A                          5795  *
0008255A                          5796  * print d0 as unsigned integer
0008255A                          5797  
0008255A                          5798  LAB_295E
0008255A  43FA 0DE8               5799      LEA     Bin2dec(pc),a1      * get table address
0008255E  7200                    5800      MOVEQ       #0,d1               * table index
00082560  41EB 05CC               5801      LEA     Usdss(a3),a0        * output string start
00082564  2401                    5802      MOVE.l  d1,d2               * output string index
00082566                          5803  LAB_2967
00082566  2631 1000               5804      MOVE.l  (a1,d1.w),d3        * get table value
0008256A  6714                    5805      BEQ.s       LAB_2969            * exit if end marker
0008256C                          5806  
0008256C  782F                    5807      MOVEQ       #'0'-1,d4           * set character to "0"-1
0008256E                          5808  LAB_2968
0008256E  5244                    5809      ADDQ.w  #1,d4               * next numeric character
00082570  9083                    5810      SUB.l       d3,d0               * subtract table value
00082572  6AFA                    5811      BPL.s       LAB_2968            * not overdone so loop
00082574                          5812  
00082574  D083                    5813      ADD.l       d3,d0               * correct value
00082576  1184 2000               5814      MOVE.b  d4,(a0,d2.w)        * character out to string
0008257A  5841                    5815      ADDQ.w  #4,d1               * increment table pointer
0008257C  5242                    5816      ADDQ.w  #1,d2               * increment output string pointer
0008257E  60E6                    5817      BRA.s       LAB_2967            * loop
00082580                          5818  
00082580                          5819  LAB_2969
00082580  0600 0030               5820      ADD.b       #'0',d0         * make last character
00082584  1180 2000               5821      MOVE.b  d0,(a0,d2.w)        * character out to string
00082588  5348                    5822      SUBQ.w  #1,a0               * decrement a0 (allow simple loop)
0008258A                          5823  
0008258A                          5824                              * now find non zero start of string
0008258A                          5825  LAB_296A
0008258A  5248                    5826      ADDQ.w  #1,a0               * increment a0 (this will never carry to b16)
0008258C  43EB 05D5               5827      LEA     BHsend-1(a3),a1     * get string end
00082590  B1C9                    5828      CMPA.l  a1,a0               * are we at end
00082592  6700 ECE4               5829      BEQ     LAB_18C3            * if so print null terminated string and RETURN
00082596                          5830  
00082596  0C10 0030               5831      CMPI.b  #'0',(a0)           * is character "0" ?
0008259A  67EE                    5832      BEQ.s       LAB_296A            * loop if so
0008259C                          5833  
0008259C  6000 ECDA               5834      BRA     LAB_18C3            * print null terminated string from memory & RET
000825A0                          5835  
000825A0                          5836  
000825A0                          5837  *************************************************************************************
000825A0                          5838  *
000825A0                          5839  * convert FAC1 to ASCII string result in (a0)
000825A0                          5840  * STR$() function enters here
000825A0                          5841  
000825A0                          5842  * now outputs 7 significant digits
000825A0                          5843  
000825A0                          5844  * d0 is character out
000825A0                          5845  * d1 is save index
000825A0                          5846  * d2 is gash
000825A0                          5847  
000825A0                          5848  * a0 is output string pointer
000825A0                          5849  
000825A0                          5850  LAB_2970
000825A0  43EB 05C6               5851      LEA     Decss(a3),a1        * set output string start
000825A4                          5852  
000825A4  7420                    5853      MOVEQ       #' ',d2         * character = " ", assume +ve
000825A6  08AB 0007 0595          5854      BCLR.b  #7,FAC1_s(a3)       * test and clear FAC1 sign (b7)
000825AC  6702                    5855      BEQ.s       LAB_2978            * branch if +ve
000825AE                          5856  
000825AE  742D                    5857      MOVEQ       #'-',d2         * else character = "-"
000825B0                          5858  LAB_2978
000825B0  1282                    5859      MOVE.b  d2,(a1)         * save the sign character
000825B2  142B 0594               5860      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
000825B6  6608                    5861      BNE.s       LAB_2989            * branch if FAC1<>0
000825B8                          5862  
000825B8                          5863                              * exponent was $00 so FAC1 is 0
000825B8  7030                    5864      MOVEQ       #'0',d0         * set character = "0"
000825BA  7201                    5865      MOVEQ       #1,d1               * set output string index
000825BC  6000 01A4               5866      BRA     LAB_2A89            * save last character, [EOT] & exit
000825C0                          5867  
000825C0                          5868                              * FAC1 is some non zero value
000825C0                          5869  LAB_2989
000825C0  177C 0000 05AC          5870      MOVE.b  #0,numexp(a3)       * clear number exponent count
000825C6  B43C 0081               5871      CMP.b       #$81,d2         * compare FAC1 exponent with $81 (>1.00000)
000825CA                          5872  
000825CA  6448                    5873      BCC.s       LAB_299C            * branch if FAC1=>1
000825CC                          5874  
000825CC                          5875                              * else FAC1 < 1
000825CC  277C 98968000 0598      5876      MOVE.l  #$98968000,FAC2_m(a3)   * 10000000 mantissa
000825D4  377C 9800 059C          5877      MOVE.w  #$9800,FAC2_e(a3)       * 10000000 exponent & sign
000825DA  176B 0595 059E          5878      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make FAC1 sign sign compare
000825E0  6100 FCE4               5879      BSR     LAB_MULTIPLY        * do FAC2*FAC1
000825E4                          5880  
000825E4  177C 00F9 05AC          5881      MOVE.b  #$F9,numexp(a3)     * set number exponent count (-7)
000825EA  6028                    5882      BRA.s       LAB_299C            * go test for fit
000825EC                          5883  
000825EC                          5884  LAB_29B9
000825EC  376B 0594 059C          5885      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
000825F2  276B 0590 0598          5886      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
000825F8  176B 0595 059E          5887      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * save FAC1_s as sign compare
000825FE                          5888  
000825FE  277C CCCCCCCD 0590      5889      MOVE.l  #$CCCCCCCD,FAC1_m(a3)   * 1/10 mantissa
00082606  377C 7D00 0594          5890      MOVE.w  #$7D00,FAC1_e(a3)       * 1/10 exponent & sign
0008260C  6100 FCB8               5891      BSR     LAB_MULTIPLY        * do FAC2*FAC1, effectively divide by 10 but
00082610                          5892                              * faster
00082610                          5893  
00082610  522B 05AC               5894      ADDQ.b  #1,numexp(a3)       * increment number exponent count
00082614                          5895  LAB_299C
00082614  277C 98967F70 0598      5896      MOVE.l  #$98967F70,FAC2_m(a3)   * 9999999.4375 mantissa
0008261C  377C 9800 059C          5897      MOVE.w  #$9800,FAC2_e(a3)       * 9999999.4375 exponent & sign
00082622                          5898                              * (max before scientific notation)
00082622  6100 014C               5899      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00082626                          5900                              * returns d0=+1 C=0 if FAC1 > FAC2
00082626                          5901                              * returns d0= 0 C=0 if FAC1 = FAC2
00082626                          5902                              * returns d0=-1 C=1 if FAC1 < FAC2
00082626  62C4                    5903      BHI.s       LAB_29B9            * go do /10 if FAC1 > 9999999.4375
00082628                          5904  
00082628  6750                    5905      BEQ.s       LAB_29C3            * branch if FAC1 = 9999999.4375
0008262A                          5906  
0008262A                          5907                              * FAC1 < 9999999.4375
0008262A  277C F423F800 0598      5908      MOVE.l  #$F423F800,FAC2_m(a3)   * set mantissa for 999999.5
00082632  377C 9400 059C          5909      MOVE.w  #$9400,FAC2_e(a3)       * set exponent for 999999.5
00082638                          5910  
00082638  41EB 0590               5911      LEA     FAC1_m(a3),a0       * set pointer for x10
0008263C                          5912  LAB_29A7
0008263C  6100 0132               5913      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00082640                          5914                              * returns d0=+1 C=0 if FAC1 > FAC2
00082640                          5915                              * returns d0= 0 C=0 if FAC1 = FAC2
00082640                          5916                              * returns d0=-1 C=1 if FAC1 < FAC2
00082640  6220                    5917      BHI.s       LAB_29C0            * branch if FAC1 > 99999.9375,no decimal places
00082642                          5918  
00082642                          5919                              * FAC1 <= 999999.5 so do x 10
00082642  2010                    5920      MOVE.l  (a0),d0         * get FAC1 mantissa
00082644  1228 0004               5921      MOVE.b  4(a0),d1            * get FAC1 exponent
00082648  2400                    5922      MOVE.l  d0,d2               * copy it
0008264A  E488                    5923      LSR.l       #2,d0               * /4
0008264C  D082                    5924      ADD.l       d2,d0               * add FAC1 (x1.125)
0008264E  6404                    5925      BCC.s       LAB_29B7            * branch if no carry
00082650                          5926  
00082650  E290                    5927      ROXR.l  #1,d0               * shift carry back in
00082652  5201                    5928      ADDQ.b  #1,d1               * increment exponent (never overflows)
00082654                          5929  LAB_29B7
00082654  5601                    5930      ADDQ.b  #3,d1               * correct exponent ( 8 x 1.125 = 10 )
00082656                          5931                              * (never overflows)
00082656  2080                    5932      MOVE.l  d0,(a0)         * save new mantissa
00082658  1141 0004               5933      MOVE.b  d1,4(a0)            * save new exponent
0008265C  532B 05AC               5934      SUBQ.b  #1,numexp(a3)       * decrement number exponent count
00082660  60DA                    5935      BRA.s       LAB_29A7            * go test again
00082662                          5936  
00082662                          5937                              * now we have just the digits to do
00082662                          5938  LAB_29C0
00082662  277C 80000000 0598      5939      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 0.5
0008266A  377C 8000 059C          5940      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for 0.5
00082670  176B 0595 059E          5941      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00082676  6100 FAAA               5942      BSR     LAB_ADD         * add the 0.5 to FAC1 (round FAC1)
0008267A                          5943  
0008267A                          5944  LAB_29C3
0008267A  6100 FE7C               5945      BSR     LAB_2831            * convert FAC1 floating to fixed
0008267E                          5946                              * result in d0 and Itemp
0008267E  7401                    5947      MOVEQ       #$01,d2         * set default digits before dp = 1
00082680  102B 05AC               5948      MOVE.b  numexp(a3),d0       * get number exponent count
00082684  5000                    5949      ADD.b       #8,d0               * allow 7 digits before point
00082686  6B0C                    5950      BMI.s       LAB_29D9            * if -ve then 1 digit before dp
00082688                          5951  
00082688  B03C 0009               5952      CMP.b       #$09,d0         * d0>=9 if n>=1E7
0008268C  6406                    5953      BCC.s       LAB_29D9            * branch if >= $09
0008268E                          5954  
0008268E                          5955                              * < $08
0008268E  5300                    5956      SUBQ.b  #1,d0               * take 1 from digit count
00082690  1400                    5957      MOVE.b  d0,d2               * copy byte
00082692  7002                    5958      MOVEQ       #$02,d0         * set exponent adjust
00082694                          5959  LAB_29D9
00082694  7200                    5960      MOVEQ       #0,d1               * set output string index
00082696  5500                    5961      SUBQ.b  #2,d0               * -2
00082698  1740 05AD               5962      MOVE.b  d0,expcnt(a3)       * save exponent adjust
0008269C  1742 05AC               5963      MOVE.b  d2,numexp(a3)       * save digits before dp count
000826A0  1002                    5964      MOVE.b  d2,d0               * copy digits before dp count
000826A2  6702                    5965      BEQ.s       LAB_29E4            * branch if no digits before dp
000826A4                          5966  
000826A4  6A14                    5967      BPL.s       LAB_29F7            * branch if digits before dp
000826A6                          5968  
000826A6                          5969  LAB_29E4
000826A6  5281                    5970      ADDQ.l  #1,d1               * increment index
000826A8  13BC 002E 1000          5971      MOVE.b  #'.',(a1,d1.w)      * save to output string
000826AE                          5972  
000826AE  4A02                    5973      TST.b       d2              * test digits before dp count
000826B0  6708                    5974      BEQ.s       LAB_29F7            * branch if no digits before dp
000826B2                          5975  
000826B2  5281                    5976      ADDQ.l  #1,d1               * increment index
000826B4  13BC 0030 1000          5977      MOVE.b  #'0',(a1,d1.w)      * save to output string
000826BA                          5978  LAB_29F7
000826BA  7400                    5979      MOVEQ       #0,d2               * clear index (point to 1,000,000)
000826BC  7080                    5980      MOVEQ       #$80-$100,d0        * set output character
000826BE                          5981  LAB_29FB
000826BE  41FA 111E               5982      LEA     LAB_2A9A(pc),a0     * get base of table
000826C2  2630 2000               5983      MOVE.l  (a0,d2.w),d3        * get table value
000826C6                          5984  LAB_29FD
000826C6  5200                    5985      ADDQ.b  #1,d0               * increment output character
000826C8  D7AB 042A               5986      ADD.l       d3,Itemp(a3)        * add to (now fixed) mantissa
000826CC  0800 0007               5987      BTST        #7,d0               * set test sense (z flag only)
000826D0  6504                    5988      BCS.s       LAB_2A18            * did carry so has wrapped past zero
000826D2                          5989  
000826D2  67F2                    5990      BEQ.s       LAB_29FD            * no wrap and +ve test so try again
000826D4                          5991  
000826D4  6002                    5992      BRA.s       LAB_2A1A            * found this digit
000826D6                          5993  
000826D6                          5994  LAB_2A18
000826D6  66EE                    5995      BNE.s       LAB_29FD            * wrap and -ve test so try again
000826D8                          5996  
000826D8                          5997  LAB_2A1A
000826D8  6406                    5998      BCC.s       LAB_2A21            * branch if +ve test result
000826DA                          5999  
000826DA  4400                    6000      NEG.b       d0              * negate the digit number
000826DC  0600 000B               6001      ADD.b       #$0B,d0         * and subtract from 11 decimal
000826E0                          6002  LAB_2A21
000826E0  0600 002F               6003      ADD.b       #$2F,d0         * add "0"-1 to result
000826E4  5842                    6004      ADDQ.w  #4,d2               * increment index to next less power of ten
000826E6  5241                    6005      ADDQ.w  #1,d1               * increment output string index
000826E8  1600                    6006      MOVE.b  d0,d3               * copy character to d3
000826EA  C63C 007F               6007      AND.b       #$7F,d3         * mask out top bit
000826EE  1383 1000               6008      MOVE.b  d3,(a1,d1.w)        * save to output string
000826F2  532B 05AC               6009      SUB.b       #1,numexp(a3)       * decrement # of characters before the dp
000826F6  6608                    6010      BNE.s       LAB_2A3B            * branch if still characters to do
000826F8                          6011  
000826F8                          6012                              * else output the point
000826F8  5281                    6013      ADDQ.l  #1,d1               * increment index
000826FA  13BC 002E 1000          6014      MOVE.b  #'.',(a1,d1.w)      * save to output string
00082700                          6015  LAB_2A3B
00082700  C03C 0080               6016      AND.b       #$80,d0         * mask test sense bit
00082704  0A00 0080               6017      EORI.b  #$80,d0         * invert it
00082708  B43C 001C               6018      CMP.b       #LAB_2A9B-LAB_2A9A,d2   * compare table index with max+4
0008270C  66B0                    6019      BNE.s       LAB_29FB            * loop if not max
0008270E                          6020  
0008270E                          6021                              * now remove trailing zeroes
0008270E                          6022  LAB_2A4B
0008270E  1031 1000               6023      MOVE.b  (a1,d1.w),d0        * get character from output string
00082712  5381                    6024      SUBQ.l  #1,d1               * decrement output string index
00082714  B03C 0030               6025      CMP.b       #'0',d0         * compare with "0"
00082718  67F4                    6026      BEQ.s       LAB_2A4B            * loop until non "0" character found
0008271A                          6027  
0008271A  B03C 002E               6028      CMP.b       #'.',d0         * compare with "."
0008271E  6702                    6029      BEQ.s       LAB_2A58            * branch if was dp
00082720                          6030  
00082720                          6031                              * else restore last character
00082720  5281                    6032      ADDQ.l  #1,d1               * increment output string index
00082722                          6033  LAB_2A58
00082722  13BC 002B 1002          6034      MOVE.b  #'+',2(a1,d1.w)     * save character "+" to output string
00082728  4A2B 05AD               6035      TST.b       expcnt(a3)          * test exponent count
0008272C  6738                    6036      BEQ.s       LAB_2A8C            * if zero go set null terminator & exit
0008272E                          6037  
0008272E                          6038                              * exponent isn't zero so write exponent
0008272E  6A0A                    6039      BPL.s       LAB_2A68            * branch if exponent count +ve
00082730                          6040  
00082730  13BC 002D 1002          6041      MOVE.b  #'-',2(a1,d1.w)     * save character "-" to output string
00082736  442B 05AD               6042      NEG.b       expcnt(a3)          * convert -ve to +ve
0008273A                          6043  LAB_2A68
0008273A  13BC 0045 1001          6044      MOVE.b  #'E',1(a1,d1.w)     * save character "E" to output string
00082740  142B 05AD               6045      MOVE.b  expcnt(a3),d2       * get exponent count
00082744  702F                    6046      MOVEQ       #$2F,d0         * one less than "0" character
00082746                          6047  LAB_2A74
00082746  5200                    6048      ADDQ.b  #1,d0               * increment 10's character
00082748  0402 000A               6049      SUB.b       #$0A,d2         * subtract 10 from exponent count
0008274C  64F8                    6050      BCC.s       LAB_2A74            * loop while still >= 0
0008274E                          6051  
0008274E  0602 003A               6052      ADD.b       #$3A,d2         * add character ":", $30+$0A, result is 10-value
00082752  1380 1003               6053      MOVE.b  d0,3(a1,d1.w)       * save 10's character to output string
00082756  1382 1004               6054      MOVE.b  d2,4(a1,d1.w)       * save 1's character to output string
0008275A  13BC 0000 1005          6055      MOVE.b  #0,5(a1,d1.w)       * save null terminator after last character
00082760  600A                    6056      BRA.s       LAB_2A91            * go set string pointer (a0) and exit
00082762                          6057  
00082762                          6058  LAB_2A89
00082762  1380 1000               6059      MOVE.b  d0,(a1,d1.w)        * save last character to output string
00082766                          6060  LAB_2A8C
00082766  13BC 0000 1001          6061      MOVE.b  #0,1(a1,d1.w)       * save null terminator after last character
0008276C                          6062  LAB_2A91
0008276C  2049                    6063      MOVEA.l a1,a0               * set result string pointer (a0)
0008276E  4E75                    6064      RTS
00082770                          6065  
00082770                          6066  
00082770                          6067  *************************************************************************************
00082770                          6068  *
00082770                          6069  * fast compare FAC1 with FAC2
00082770                          6070  * assumes both are +ve and FAC2>0
00082770                          6071  * returns d0=+1 C=0 if FAC1 > FAC2
00082770                          6072  * returns d0= 0 C=0 if FAC1 = FAC2
00082770                          6073  * returns d0=-1 C=1 if FAC1 < FAC2
00082770                          6074  
00082770                          6075  LAB_27F0
00082770  7000                    6076      MOVEQ       #0,d0               * set for FAC1 = FAC2
00082772  122B 059C               6077      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00082776  B22B 0594               6078      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
0008277A  660A                    6079      BNE.s       LAB_27F1            * branch if different
0008277C                          6080  
0008277C  222B 0598               6081      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00082780  B2AB 0590               6082      CMP.l       FAC1_m(a3),d1       * compare mantissas
00082784  6708                    6083      BEQ.s       LAB_27F3            * exit if mantissas equal
00082786                          6084  
00082786                          6085  LAB_27F1
00082786  6504                    6086      BCS.s       LAB_27F2            * if FAC1 > FAC2 return d0=+1,C=0
00082788                          6087  
00082788  5380                    6088      SUBQ.l  #1,d0               * else FAC1 < FAC2 return d0=-1,C=1
0008278A  4E75                    6089      RTS
0008278C                          6090  
0008278C                          6091  LAB_27F2
0008278C  5280                    6092      ADDQ.l  #1,d0
0008278E                          6093  LAB_27F3
0008278E  4E75                    6094      RTS
00082790                          6095  
00082790                          6096  
00082790                          6097  *************************************************************************************
00082790                          6098  *
00082790                          6099  * make FAC1 = 1
00082790                          6100  
00082790                          6101  LAB_POON
00082790  277C 80000000 0590      6102      MOVE.l  #$80000000,FAC1_m(a3)   * 1 mantissa
00082798  377C 8100 0594          6103      MOVE.w  #$8100,FAC1_e(a3)       * 1 exonent & sign
0008279E  4E75                    6104      RTS
000827A0                          6105  
000827A0                          6106  
000827A0                          6107  *************************************************************************************
000827A0                          6108  *
000827A0                          6109  * make FAC1 = 0
000827A0                          6110  
000827A0                          6111  LAB_POZE
000827A0  7000                    6112      MOVEQ       #0,d0               * clear longword
000827A2  2740 0590               6113      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
000827A6  3740 0594               6114      MOVE.w  d0,FAC1_e(a3)       * 0 exonent & sign
000827AA  4E75                    6115      RTS
000827AC                          6116  
000827AC                          6117  
000827AC                          6118  *************************************************************************************
000827AC                          6119  *
000827AC                          6120  * perform power function
000827AC                          6121  * the number is in FAC2, the power is in FAC1
000827AC                          6122  * no longer trashes Itemp
000827AC                          6123  
000827AC                          6124  LAB_POWER
000827AC  4A2B 0594               6125      TST.b       FAC1_e(a3)          * test power
000827B0  67DE                    6126      BEQ.s       LAB_POON            * if zero go return 1
000827B2                          6127  
000827B2  4A2B 059C               6128      TST.b       FAC2_e(a3)          * test number
000827B6  67E8                    6129      BEQ.s       LAB_POZE            * if zero go return 0
000827B8                          6130  
000827B8  1F2B 059D               6131      MOVE.b  FAC2_s(a3),-(sp)        * save number sign
000827BC  6A20                    6132      BPL.s       LAB_POWP            * power of positive number
000827BE                          6133  
000827BE  7200                    6134      MOVEQ       #0,d1               * clear d1
000827C0  1741 059D               6135      MOVE.b  d1,FAC2_s(a3)       * make sign +ve
000827C4                          6136  
000827C4                          6137                              * number sign was -ve and can only be raised to
000827C4                          6138                              * an integer power which gives an x +j0 result,
000827C4                          6139                              * else do 'function call' error
000827C4  122B 0594               6140      MOVE.b  FAC1_e(a3),d1       * get power exponent
000827C8  0441 0080               6141      SUB.w       #$80,d1         * normalise to .5
000827CC  6300 E22A               6142      BLS     LAB_FCER            * if 0<power<1 then do 'function call' error
000827D0                          6143  
000827D0                          6144                              * now shift all the integer bits out
000827D0  202B 0590               6145      MOVE.l  FAC1_m(a3),d0       * get power mantissa
000827D4  E3A0                    6146      ASL.l       d1,d0               * shift mantissa
000827D6  6600 E220               6147      BNE     LAB_FCER            * if power<>INT(power) then do 'function call'
000827DA                          6148                              * error
000827DA                          6149  
000827DA  6502                    6150      BCS.s       LAB_POWP            * if integer value odd then leave result -ve
000827DC                          6151  
000827DC  1E80                    6152      MOVE.b  d0,(sp)         * save result sign +ve
000827DE                          6153  LAB_POWP
000827DE  2F2B 0590               6154      MOVE.l  FAC1_m(a3),-(sp)        * save power mantissa
000827E2  3F2B 0594               6155      MOVE.w  FAC1_e(a3),-(sp)        * save power sign & exponent
000827E6                          6156  
000827E6  6100 FC78               6157      BSR     LAB_279B            * copy number to FAC1
000827EA  6100 F9E8               6158      BSR     LAB_LOG         * find log of number
000827EE                          6159  
000827EE  301F                    6160      MOVE.w  (sp)+,d0            * get power sign & exponent
000827F0  275F 0598               6161      MOVE.l  (sp)+,FAC2_m(a3)        * get power mantissa
000827F4  3740 059C               6162      MOVE.w  d0,FAC2_e(a3)       * save sign & exponent to FAC2
000827F8  1740 059E               6163      MOVE.b  d0,FAC_sc(a3)       * save sign as sign compare
000827FC  102B 0595               6164      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00082800  B12B 059E               6165      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00082804                          6166  
00082804  6100 FAC0               6167      BSR     LAB_MULTIPLY        * multiply by power
00082808  6158                    6168      BSR.s       LAB_EXP         * find exponential
0008280A  175F 0595               6169      MOVE.b  (sp)+,FAC1_s(a3)        * restore number sign
0008280E  4E75                    6170      RTS
00082810                          6171  
00082810                          6172  
00082810                          6173  *************************************************************************************
00082810                          6174  *
00082810                          6175  * do - FAC1
00082810                          6176  
00082810                          6177  LAB_GTHAN
00082810  4A2B 0594               6178      TST.b       FAC1_e(a3)          * test for non zero FAC1
00082814  6706                    6179      BEQ.s       RTS_020         * branch if null
00082816                          6180  
00082816  0A2B 0080 0595          6181      EORI.b  #$80,FAC1_s(a3)     * (else) toggle FAC1 sign bit
0008281C                          6182  RTS_020
0008281C  4E75                    6183      RTS
0008281E                          6184  
0008281E                          6185  
0008281E                          6186  *************************************************************************************
0008281E                          6187  *
0008281E                          6188                              * return +1
0008281E                          6189  LAB_EX1
0008281E  277C 80000000 0590      6190      MOVE.l  #$80000000,FAC1_m(a3)   * +1 mantissa
00082826  377C 8100 0594          6191      MOVE.w  #$8100,FAC1_e(a3)       * +1 sign & exponent
0008282C  4E75                    6192      RTS
0008282E                          6193                              * do over/under flow
0008282E                          6194  LAB_EXOU
0008282E  4A2B 0595               6195      TST.b       FAC1_s(a3)          * test sign
00082832  6A00 E1C0               6196      BPL     LAB_OFER            * was +ve so do overflow error
00082836                          6197  
00082836                          6198                              * else underflow so return zero
00082836  7000                    6199      MOVEQ       #0,d0               * clear longword
00082838  2740 0590               6200      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
0008283C  3740 0594               6201      MOVE.w  d0,FAC1_e(a3)       * 0 sign & exponent
00082840  4E75                    6202      RTS
00082842                          6203                              * fraction was zero so do 2^n
00082842                          6204  LAB_EXOF
00082842  277C 80000000 0590      6205      MOVE.l  #$80000000,FAC1_m(a3)   * +n mantissa
0008284A  177C 0000 0595          6206      MOVE.b  #0,FAC1_s(a3)       * clear sign
00082850  4A2B 05B4               6207      TST.b       cosout(a3)          * test sign flag
00082854  6A02                    6208      BPL.s       LAB_EXOL            * branch if +ve
00082856                          6209  
00082856  4481                    6210      NEG.l       d1              * else do 1/2^n
00082858                          6211  LAB_EXOL
00082858  0601 0081               6212      ADD.b       #$81,d1         * adjust exponent
0008285C  1741 0594               6213      MOVE.b  d1,FAC1_e(a3)       * save exponent
00082860  4E75                    6214      RTS
00082862                          6215  
00082862                          6216  * perform EXP() (x^e)
00082862                          6217  * valid input range is -88 to +88
00082862                          6218  
00082862                          6219  LAB_EXP
00082862  102B 0594               6220      MOVE.b  FAC1_e(a3),d0       * get exponent
00082866  67B6                    6221      BEQ.s       LAB_EX1         * return 1 for zero in
00082868                          6222  
00082868  B03C 0064               6223      CMP.b       #$64,d0         * compare exponent with min
0008286C  65B0                    6224      BCS.s       LAB_EX1         * if smaller just return 1
0008286E                          6225  
0008286E                          6226  **  MOVEM.l d1-d6/a0,-(sp)      * save the registers
0008286E  177C 0000 05B4          6227      MOVE.b  #0,cosout(a3)       * flag +ve number
00082874  222B 0590               6228      MOVE.l  FAC1_m(a3),d1       * get mantissa
00082878  B03C 0087               6229      CMP.b       #$87,d0         * compare exponent with max
0008287C  62B0                    6230      BHI.s       LAB_EXOU            * go do over/under flow if greater
0008287E                          6231  
0008287E  6608                    6232      BNE.s       LAB_EXCM            * branch if less
00082880                          6233  
00082880                          6234                              * else is 2^7
00082880  B2BC B00F33C7           6235      CMP.l       #$B00F33C7,d1       * compare mantissa with n*2^7 max
00082886  64A6                    6236      BCC.s       LAB_EXOU            * if => go over/underflow
00082888                          6237  
00082888                          6238  LAB_EXCM
00082888  4A2B 0595               6239      TST.b       FAC1_s(a3)          * test sign
0008288C  6A0C                    6240      BPL.s       LAB_EXPS            * branch if arg +ve
0008288E                          6241  
0008288E  177C 00FF 05B4          6242      MOVE.b  #$FF,cosout(a3)     * flag -ve number
00082894  177C 0000 0595          6243      MOVE.b  #0,FAC1_s(a3)       * take absolute value
0008289A                          6244  LAB_EXPS
0008289A                          6245                              * now do n/LOG(2)
0008289A  277C B8AA3B29 0598      6246      MOVE.l  #$B8AA3B29,FAC2_m(a3)   * 1/LOG(2) mantissa
000828A2  377C 8100 059C          6247      MOVE.w  #$8100,FAC2_e(a3)       * 1/LOG(2) exponent & sign
000828A8  177C 0000 059E          6248      MOVE.b  #0,FAC_sc(a3)       * we know they're both +ve
000828AE  6100 FA16               6249      BSR     LAB_MULTIPLY        * effectively divide by log(2)
000828B2                          6250  
000828B2                          6251                              * max here is +/- 127
000828B2                          6252                              * now separate integer and fraction
000828B2  177C 0000 05D9          6253      MOVE.b  #0,tpower(a3)       * clear exponent add byte
000828B8  1A2B 0594               6254      MOVE.b  FAC1_e(a3),d5       * get exponent
000828BC  0405 0080               6255      SUB.b       #$80,d5         * normalise
000828C0  6324                    6256      BLS.s       LAB_ESML            * branch if < 1 (d5 is 0 or -ve)
000828C2                          6257  
000828C2                          6258                              * result is > 1
000828C2  202B 0590               6259      MOVE.l  FAC1_m(a3),d0       * get mantissa
000828C6  2200                    6260      MOVE.l  d0,d1               * copy it
000828C8  2C05                    6261      MOVE.l  d5,d6               * copy normalised exponent
000828CA                          6262  
000828CA  4446                    6263      NEG.w       d6              * make -ve
000828CC  0646 0020               6264      ADD.w       #32,d6          * is now 32-d6
000828D0  ECA9                    6265      LSR.l       d6,d1               * just integer bits
000828D2  1741 05D9               6266      MOVE.b  d1,tpower(a3)       * set exponent add byte
000828D6                          6267  
000828D6  EBA8                    6268      LSL.l       d5,d0               * shift out integer bits
000828D8  6700 FF68               6269      BEQ     LAB_EXOF            * fraction is zero so do 2^n
000828DC                          6270  
000828DC  2740 0590               6271      MOVE.l  d0,FAC1_m(a3)       * fraction to FAC1
000828E0  377C 8000 0594          6272      MOVE.w  #$8000,FAC1_e(a3)       * set exponent & sign
000828E6                          6273  
000828E6                          6274                              * multiple was < 1
000828E6                          6275  LAB_ESML
000828E6  277C B17217F8 0598      6276      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
000828EE  377C 8000 059C          6277      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
000828F4  177C 0000 059E          6278      MOVE.b  #0,FAC_sc(a3)       * clear sign compare
000828FA  6100 F9CA               6279      BSR     LAB_MULTIPLY        * multiply by log(2)
000828FE                          6280  
000828FE  202B 0590               6281      MOVE.l  FAC1_m(a3),d0       * get mantissa
00082902  1A2B 0594               6282      MOVE.b  FAC1_e(a3),d5       * get exponent
00082906  0445 0082               6283      SUB.w       #$82,d5         * normalise and -2 (result is -1 to -30)
0008290A  4445                    6284      NEG.w       d5              * make +ve
0008290C  EAA8                    6285      LSR.l       d5,d0               * shift for 2 integer bits
0008290E                          6286  
0008290E                          6287  * d0 = arg
0008290E                          6288  * d6 = x, d1 = y
0008290E                          6289  * d2 = x1, d3 = y1
0008290E                          6290  * d4 = shift count
0008290E                          6291  * d5 = loop count
0008290E                          6292                              * now do cordic set-up
0008290E  7200                    6293      MOVEQ       #0,d1               * y = 0
00082910  2C3C 26A3D110           6294      MOVE.l  #KFCTSEED,d6        * x = 1 with jkh inverse factored out
00082916  41FA 0D2A               6295      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic arctan table
0008291A  7800                    6296      MOVEQ       #0,d4               * clear shift count
0008291C                          6297   
0008291C                          6298                              * cordic loop, shifts 4 and 13 (and 39
0008291C                          6299                              * if it went that far) need to be repeated
0008291C  7A03                    6300      MOVEQ       #3,d5               * 4 loops
0008291E  6136                    6301      BSR.s       LAB_EXCC            * do loops 1 through 4
00082920  5948                    6302      SUBQ.w  #4,a0               * do table entry again
00082922  5384                    6303      SUBQ.l  #1,d4               * do shift count again
00082924  7A09                    6304      MOVEQ       #9,d5               * 10 loops
00082926  612E                    6305      BSR.s       LAB_EXCC            * do loops 4 (again) through 13
00082928  5948                    6306      SUBQ.w  #4,a0               * do table entry again
0008292A  5384                    6307      SUBQ.l  #1,d4               * do shift count again
0008292C  7A12                    6308      MOVEQ       #18,d5          * 19 loops
0008292E  6126                    6309      BSR.s       LAB_EXCC            * do loops 13 (again) through 31
00082930                          6310   
00082930                          6311                              * now get the result
00082930  4A2B 05B4               6312      TST.b       cosout(a3)          * test sign flag
00082934  6A06                    6313      BPL.s       LAB_EXPL            * branch if +ve
00082936                          6314  
00082936  4481                    6315      NEG.l       d1              * do -y
00082938  442B 05D9               6316      NEG.b       tpower(a3)          * do -exp
0008293C                          6317  LAB_EXPL
0008293C  7083                    6318      MOVEQ       #$83-$100,d0        * set exponent
0008293E  DC81                    6319      ADD.l       d1,d6               * y = y +/- x
00082940  6B06                    6320      BMI.s       LAB_EXRN            * branch if result normal
00082942                          6321  
00082942                          6322  LAB_EXNN
00082942  5380                    6323      SUBQ.l  #1,d0               * decrement exponent
00082944  DC86                    6324      ADD.l       d6,d6               * shift mantissa
00082946  6AFA                    6325      BPL.s       LAB_EXNN            * loop if not normal
00082948                          6326  
00082948                          6327  LAB_EXRN
00082948  2746 0590               6328      MOVE.l  d6,FAC1_m(a3)       * save exponent result
0008294C  D02B 05D9               6329      ADD.b       tpower(a3),d0       * add integer part
00082950  1740 0594               6330      MOVE.b  d0,FAC1_e(a3)       * save exponent
00082954                          6331  **  MOVEM.l (sp)+,d1-d6/a0      * restore registers
00082954  4E75                    6332      RTS
00082956                          6333   
00082956                          6334                              * cordic loop
00082956                          6335  LAB_EXCC
00082956  5284                    6336      ADDQ.l  #1,d4               * increment shift count
00082958  2406                    6337      MOVE.l  d6,d2               * x1 = x
0008295A  E8A2                    6338      ASR.l       d4,d2               * x1 >> n
0008295C  2601                    6339      MOVE.l  d1,d3               * y1 = y
0008295E  E8A3                    6340      ASR.l       d4,d3               * y1 >> n
00082960  4A80                    6341      TST.l       d0              * test arg
00082962  6B0C                    6342      BMI.s       LAB_EXAD            * branch if -ve
00082964                          6343  
00082964  D282                    6344      ADD.l       d2,d1               * y = y + x1
00082966  DC83                    6345      ADD.l       d3,d6               * x = x + y1
00082968  9098                    6346      SUB.l       (a0)+,d0            * arg = arg - atnh(a0)
0008296A  51CD FFEA               6347      DBF     d5,LAB_EXCC         * decrement and loop if not done
0008296E                          6348  
0008296E  4E75                    6349      RTS
00082970                          6350  
00082970                          6351  LAB_EXAD
00082970  9282                    6352      SUB.l       d2,d1               * y = y - x1
00082972  9C83                    6353      SUB.l       d3,d6               * x = x + y1
00082974  D098                    6354      ADD.l       (a0)+,d0            * arg = arg + atnh(a0)
00082976  51CD FFDE               6355      DBF     d5,LAB_EXCC         * decrement and loop if not done
0008297A                          6356  
0008297A  4E75                    6357      RTS
0008297C                          6358  
0008297C                          6359  
0008297C                          6360  *************************************************************************************
0008297C                          6361  *
0008297C                          6362  * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
0008297C                          6363  * to get 19th next number in sequence after seed n. This version of the PRNG uses
0008297C                          6364  * the Galois method and a sample of 65536 bytes produced gives the following values.
0008297C                          6365  
0008297C                          6366  * Entropy = 7.997442 bits per byte
0008297C                          6367  * Optimum compression would reduce these 65536 bytes by 0 percent
0008297C                          6368  
0008297C                          6369  * Chi square distribution for 65536 samples is 232.01, and
0008297C                          6370  * randomly would exceed this value 75.00 percent of the time
0008297C                          6371  
0008297C                          6372  * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
0008297C                          6373  * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
0008297C                          6374  * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
0008297C                          6375  
0008297C                          6376  LAB_RND
0008297C  4A2B 0594               6377      TST.b       FAC1_e(a3)          * get FAC1 exponent
00082980  6708                    6378      BEQ.s       NextPRN         * do next random number if zero
00082982                          6379  
00082982                          6380                              * else get seed into random number store
00082982  41EB 05A0               6381      LEA     PRNlword(a3),a0     * set PRNG pointer
00082986  6100 FAB2               6382      BSR     LAB_2778            * pack FAC1 into (a0)
0008298A                          6383  NextPRN
0008298A  72AF                    6384      MOVEQ       #$AF-$100,d1        * set EOR value
0008298C  7412                    6385      MOVEQ       #18,d2          * do this 19 times
0008298E  202B 05A0               6386      MOVE.l  PRNlword(a3),d0     * get current
00082992                          6387  Ninc0
00082992  D080                    6388      ADD.l       d0,d0               * shift left 1 bit
00082994  6402                    6389      BCC.s       Ninc1               * branch if bit 32 not set
00082996                          6390  
00082996  B300                    6391      EOR.b       d1,d0               * do Galois LFSR feedback
00082998                          6392  Ninc1
00082998  51CA FFF8               6393      DBF     d2,Ninc0            * loop
0008299C                          6394  
0008299C  2740 05A0               6395      MOVE.l  d0,PRNlword(a3)     * save back to seed word
000829A0  2740 0590               6396      MOVE.l  d0,FAC1_m(a3)       * copy to FAC1 mantissa
000829A4  377C 8000 0594          6397      MOVE.w  #$8000,FAC1_e(a3)       * set the exponent and clear the sign
000829AA  6000 F7F2               6398      BRA     LAB_24D5            * normalise FAC1 & return
000829AE                          6399  
000829AE                          6400  
000829AE                          6401  *************************************************************************************
000829AE                          6402  *
000829AE                          6403  * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
000829AE                          6404  * x = angle in radians
000829AE                          6405  
000829AE                          6406  LAB_TAN
000829AE  6138                    6407      BSR.s       LAB_SIN         * go do SIN/COS cordic compute
000829B0  376B 0594 059C          6408      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
000829B6  276B 0590 0598          6409      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
000829BC  2741 0590               6410      MOVE.l  d1,FAC1_m(a3)       * get COS(x) mantissa
000829C0  1743 0594               6411      MOVE.b  d3,FAC1_e(a3)       * get COS(x) exponent
000829C4  6700 E02E               6412      BEQ     LAB_OFER            * do overflow if COS = 0
000829C8                          6413  
000829C8  6100 F7D4               6414      BSR     LAB_24D5            * normalise FAC1
000829CC  6000 F984               6415      BRA     LAB_DIVIDE          * do FAC2/FAC1 and return, FAC_sc set by SIN
000829D0                          6416                              * COS calculation
000829D0                          6417  
000829D0                          6418  
000829D0                          6419  *************************************************************************************
000829D0                          6420  *
000829D0                          6421  * cordic SIN(x), COS(x) routine
000829D0                          6422  * x = angle in radians
000829D0                          6423  
000829D0                          6424  LAB_COS
000829D0  277C C90FDAA3 0598      6425      MOVE.l  #$C90FDAA3,FAC2_m(a3)   * pi/2 mantissa (LSB is rounded up so
000829D8                          6426                              * COS(PI/2)=0)
000829D8  377C 8100 059C          6427      MOVE.w  #$8100,FAC2_e(a3)       * pi/2 exponent and sign
000829DE  176B 0595 059E          6428      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
000829E4  6100 F73C               6429      BSR     LAB_ADD         * add FAC2 to FAC1, adjust for COS(x)
000829E8                          6430  
000829E8                          6431  
000829E8                          6432  *************************************************************************************
000829E8                          6433  *
000829E8                          6434  * SIN/COS cordic calculator
000829E8                          6435  
000829E8                          6436  LAB_SIN
000829E8  177C 0000 05B4          6437      MOVE.b  #0,cosout(a3)       * set needed result
000829EE                          6438  
000829EE  277C A2F9836F 0598      6439      MOVE.l  #$A2F9836F,FAC2_m(a3)   * 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
000829F6  377C 7F00 059C          6440      MOVE.w  #$7F00,FAC2_e(a3)       * 1/pi exponent & sign
000829FC  176B 0595 059E          6441      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00082A02  6100 F8C2               6442      BSR     LAB_MULTIPLY        * multiply by 1/pi
00082A06                          6443  
00082A06  102B 0594               6444      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00082A0A  671C                    6445      BEQ.s       LAB_SCZE            * branch if zero
00082A0C                          6446  
00082A0C  41FA 0B34               6447      LEA     TAB_SNCO(pc),a0     * get pointer to constants table
00082A10  2C2B 0590               6448      MOVE.l  FAC1_m(a3),d6       * get FAC1 mantissa
00082A14  5300                    6449      SUBQ.b  #1,d0               * 2 radians in 360 degrees so /2
00082A16  6710                    6450      BEQ.s       LAB_SCZE            * branch if zero
00082A18                          6451  
00082A18  0400 0080               6452      SUB.b       #$80,d0         * normalise exponent
00082A1C  6B18                    6453      BMI.s       LAB_SCL0            * branch if < 1
00082A1E                          6454  
00082A1E                          6455                              * X is > 1
00082A1E  B03C 0020               6456      CMP.b       #$20,d0         * is it >= 2^32
00082A22  6404                    6457      BCC.s       LAB_SCZE            * may as well do zero
00082A24                          6458  
00082A24  E1AE                    6459      LSL.l       d0,d6               * shift out integer part bits
00082A26  6618                    6460      BNE.s       LAB_CORD            * if fraction go test quadrant and adjust
00082A28                          6461  
00082A28                          6462                              * else no fraction so do zero
00082A28                          6463  LAB_SCZE
00082A28  7481                    6464      MOVEQ       #$81-$100,d2        * set exponent for 1.0
00082A2A  7600                    6465      MOVEQ       #0,d3               * set exponent for 0.0
00082A2C  203C 80000000           6466      MOVE.l  #$80000000,d0       * mantissa for 1.0
00082A32  2203                    6467      MOVE.l  d3,d1               * mantissa for 0.0
00082A34  6062                    6468      BRA.s       outloop         * go output it
00082A36                          6469  
00082A36                          6470                              * x is < 1
00082A36                          6471  LAB_SCL0
00082A36  4400                    6472      NEG.b       d0              * make +ve
00082A38  B03C 001E               6473      CMP.b       #$1E,d0         * is it <= 2^-30
00082A3C  64EA                    6474      BCC.s       LAB_SCZE            * may as well do zero
00082A3E                          6475  
00082A3E  E0AE                    6476      LSR.l       d0,d6               * shift out <= 2^-32 bits
00082A40                          6477  
00082A40                          6478  * cordic calculator, argument in d6
00082A40                          6479  * table pointer in a0, returns in d0-d3
00082A40                          6480  
00082A40                          6481  LAB_CORD
00082A40  176B 0595 059E          6482      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * copy as sign compare for TAN
00082A46  DC86                    6483      ADD.l       d6,d6               * shift 0.5 bit into carry
00082A48  6406                    6484      BCC.s       LAB_LTPF            * branch if less than 0.5
00082A4A                          6485  
00082A4A  0A2B 00FF 0595          6486      EORI.b  #$FF,FAC1_s(a3)     * toggle result sign
00082A50                          6487  LAB_LTPF
00082A50  DC86                    6488      ADD.l       d6,d6               * shift 0.25 bit into carry
00082A52  640C                    6489      BCC.s       LAB_LTPT            * branch if less than 0.25
00082A54                          6490  
00082A54  0A2B 00FF 05B4          6491      EORI.b  #$FF,cosout(a3)     * toggle needed result
00082A5A  0A2B 00FF 059E          6492      EORI.b  #$FF,FAC_sc(a3)     * toggle sign compare for TAN
00082A60                          6493  
00082A60                          6494  LAB_LTPT
00082A60  E48E                    6495      LSR.l       #2,d6               * shift the bits back (clear integer bits)
00082A62  67C4                    6496      BEQ.s       LAB_SCZE            * no fraction so go do zero
00082A64                          6497  
00082A64                          6498                              * set start values
00082A64  7A01                    6499      MOVEQ       #1,d5               * set bit count
00082A66  2028 FFFC               6500      MOVE.l  -4(a0),d0           * get multiply constant (1st itteration d0)
00082A6A  2200                    6501      MOVE.l  d0,d1               * 1st itteration d1
00082A6C  9C98                    6502      SUB.l       (a0)+,d6            * 1st always +ve so do 1st step
00082A6E  6008                    6503      BRA.s       mainloop            * jump into routine
00082A70                          6504  
00082A70                          6505  subloop
00082A70  9C98                    6506      SUB.l       (a0)+,d6            * z = z - arctan(i)/2pi
00082A72  9083                    6507      SUB.l       d3,d0               * x = x - y1
00082A74  D282                    6508      ADD.l       d2,d1               * y = y + x1
00082A76  6012                    6509      BRA.s       nexta               * back to main loop
00082A78                          6510  
00082A78                          6511  mainloop
00082A78  2400                    6512      MOVE.l  d0,d2               * x1 = x
00082A7A  EAA2                    6513      ASR.l       d5,d2               * / (2 ^ i)
00082A7C  2601                    6514      MOVE.l  d1,d3               * y1 = y
00082A7E  EAA3                    6515      ASR.l       d5,d3               * / (2 ^ i)
00082A80  4A86                    6516      TST.l       d6              * test sign (is 2^0 bit)
00082A82  6AEC                    6517      BPL.s       subloop         * go do subtract if > 1
00082A84                          6518  
00082A84  DC98                    6519      ADD.l       (a0)+,d6            * z = z + arctan(i)/2pi
00082A86  D083                    6520      ADD.l       d3,d0               * x = x + y1
00082A88  9282                    6521      SUB.l       d2,d1               * y = y + x1
00082A8A                          6522  nexta
00082A8A  5285                    6523      ADDQ.l  #1,d5               * i = i + 1
00082A8C  BABC 0000001E           6524      CMP.l       #$1E,d5         * check end condition
00082A92  66E4                    6525      BNE.s       mainloop            * loop if not all done
00082A94                          6526  
00082A94                          6527                              * now untangle output value
00082A94  7481                    6528      MOVEQ       #$81-$100,d2        * set exponent for 0 to .99 rec.
00082A96  2602                    6529      MOVE.l  d2,d3               * copy it for cos output
00082A98                          6530  outloop
00082A98  4A2B 05B4               6531      TST.b       cosout(a3)          * did we want cos output?
00082A9C  6B04                    6532      BMI.s       subexit         * if so skip
00082A9E                          6533  
00082A9E  C141                    6534      EXG     d0,d1               * swap SIN and COS mantissas
00082AA0  C543                    6535      EXG     d2,d3               * swap SIN and COS exponents
00082AA2                          6536  subexit
00082AA2  2740 0590               6537      MOVE.l  d0,FAC1_m(a3)       * set result mantissa
00082AA6  1742 0594               6538      MOVE.b  d2,FAC1_e(a3)       * set result exponent
00082AAA  6000 F6F2               6539      BRA     LAB_24D5            * normalise FAC1 & return
00082AAE                          6540  
00082AAE                          6541  
00082AAE                          6542  
00082AAE                          6543  *************************************************************************************
00082AAE                          6544  *
00082AAE                          6545  * perform ATN()
00082AAE                          6546  
00082AAE                          6547  LAB_ATN
00082AAE  102B 0594               6548      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00082AB2  6700 00AA               6549      BEQ     RTS_021         * ATN(0) = 0 so skip calculation
00082AB6                          6550  
00082AB6  177C 0000 05B4          6551      MOVE.b  #0,cosout(a3)       * set result needed
00082ABC  B03C 0081               6552      CMP.b       #$81,d0         * compare exponent with 1
00082AC0  6528                    6553      BCS.s       LAB_ATLE            * branch if n<1
00082AC2                          6554  
00082AC2  6608                    6555      BNE.s       LAB_ATGO            * branch if n>1
00082AC4                          6556  
00082AC4  202B 0590               6557      MOVE.l  FAC1_m(a3),d0       * get mantissa
00082AC8  D080                    6558      ADD.l       d0,d0               * shift left
00082ACA  671E                    6559      BEQ.s       LAB_ATLE            * branch if n=1
00082ACC                          6560  
00082ACC                          6561  LAB_ATGO
00082ACC  277C 80000000 0598      6562      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00082AD4  377C 8100 059C          6563      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00082ADA  176B 0595 059E          6564      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00082AE0  6100 F870               6565      BSR     LAB_DIVIDE          * do 1/n
00082AE4  177C 00FF 05B4          6566      MOVE.b  #$FF,cosout(a3)     * set inverse result needed
00082AEA                          6567  LAB_ATLE
00082AEA  202B 0590               6568      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00082AEE  7282                    6569      MOVEQ       #$82,d1         * set to correct exponent
00082AF0  922B 0594               6570      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent (always <= 1)
00082AF4  E2A8                    6571      LSR.l       d1,d0               * shift in two integer part bits
00082AF6  41FA 0ACA               6572      LEA     TAB_ATNC(pc),a0     * get pointer to arctan table
00082AFA  7C00                    6573      MOVEQ       #0,d6               * Z = 0
00082AFC  223C 40000000           6574      MOVE.l  #1<<30,d1           * y = 1
00082B02  7A1D                    6575      MOVEQ       #29,d5          * loop 30 times
00082B04  7801                    6576      MOVEQ       #1,d4               * shift counter
00082B06  6006                    6577      BRA.s       LAB_ATCD            * enter loop
00082B08                          6578  
00082B08                          6579  LAB_ATNP
00082B08  E8A2                    6580      ASR.l       d4,d2               * x1 / 2^i
00082B0A  D282                    6581      ADD.l       d2,d1               * y = y + x1
00082B0C  DC90                    6582      ADD.l       (a0),d6         * z = z + atn(i)
00082B0E                          6583  LAB_ATCD
00082B0E  2400                    6584      MOVE.l  d0,d2               * x1 = x
00082B10  2601                    6585      MOVE.l  d1,d3               * y1 = y
00082B12  E8A3                    6586      ASR.l       d4,d3               * y1 / 2^i
00082B14                          6587  LAB_CATN
00082B14  9083                    6588      SUB.l       d3,d0               * x = x - y1
00082B16  6AF0                    6589      BPL.s       LAB_ATNP            * branch if x >= 0
00082B18                          6590  
00082B18  2002                    6591      MOVE.l  d2,d0               * else get x back
00082B1A  5848                    6592      ADDQ.w  #4,a0               * increment pointer
00082B1C  5284                    6593      ADDQ.l  #1,d4               * increment i
00082B1E  E283                    6594      ASR.l       #1,d3               * y1 / 2^i
00082B20  51CD FFF2               6595      DBF     d5,LAB_CATN         * decrement and loop if not done
00082B24                          6596  
00082B24  177C 0082 0594          6597      MOVE.b  #$82,FAC1_e(a3)     * set new exponent
00082B2A  2746 0590               6598      MOVE.l  d6,FAC1_m(a3)       * save mantissa
00082B2E  6100 F66E               6599      BSR     LAB_24D5            * normalise FAC1
00082B32                          6600  
00082B32  4A2B 05B4               6601      TST.b       cosout(a3)          * was it > 1 ?
00082B36  6A26                    6602      BPL.s       RTS_021         * branch if not
00082B38                          6603  
00082B38  1E2B 0595               6604      MOVE.b  FAC1_s(a3),d7       * get sign
00082B3C  177C 0000 0595          6605      MOVE.b  #0,FAC1_s(a3)       * clear sign
00082B42  277C C90FDAA2 0598      6606      MOVE.l  #$C90FDAA2,FAC2_m(a3)   * set -(pi/2)
00082B4A  377C 8180 059C          6607      MOVE.w  #$8180,FAC2_e(a3)       * set exponent and sign
00082B50  177C 00FF 059E          6608      MOVE.b  #$FF,FAC_sc(a3)     * set sign compare
00082B56  6100 F5CA               6609      BSR     LAB_ADD         * perform addition, FAC2 to FAC1
00082B5A  1747 0595               6610      MOVE.b  d7,FAC1_s(a3)       * restore sign
00082B5E                          6611  RTS_021
00082B5E  4E75                    6612      RTS
00082B60                          6613  
00082B60                          6614  
00082B60                          6615  *************************************************************************************
00082B60                          6616  *
00082B60                          6617  * perform BITSET
00082B60                          6618  
00082B60                          6619  LAB_BITSET
00082B60  6100 F4A0               6620      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00082B64                          6621                              * first parameter in a0, second in d0
00082B64  B03C 0008               6622      CMP.b       #$08,d0         * only 0 to 7 are allowed
00082B68  6400 DE8E               6623      BCC     LAB_FCER            * branch if > 7
00082B6C                          6624  
00082B6C  01D0                    6625      BSET        d0,(a0)         * set bit
00082B6E  4E75                    6626      RTS
00082B70                          6627  
00082B70                          6628  
00082B70                          6629  *************************************************************************************
00082B70                          6630  *
00082B70                          6631  * perform BITCLR
00082B70                          6632  
00082B70                          6633  LAB_BITCLR
00082B70  6100 F490               6634      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00082B74                          6635                              * first parameter in a0, second in d0
00082B74  B03C 0008               6636      CMP.b       #$08,d0         * only 0 to 7 are allowed
00082B78  6400 DE7E               6637      BCC     LAB_FCER            * branch if > 7
00082B7C                          6638  
00082B7C  0190                    6639      BCLR        d0,(a0)         * clear bit
00082B7E  4E75                    6640      RTS
00082B80                          6641  
00082B80                          6642  
00082B80                          6643  *************************************************************************************
00082B80                          6644  *
00082B80                          6645  * perform BITTST()
00082B80                          6646  
00082B80                          6647  LAB_BTST
00082B80  101D                    6648      MOVE.b  (a5)+,d0            * increment BASIC pointer
00082B82  6100 F47E               6649      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00082B86                          6650                              * first parameter in a0, second in d0
00082B86  B03C 0008               6651      CMP.b       #$08,d0         * only 0 to 7 are allowed
00082B8A  6400 DE6C               6652      BCC     LAB_FCER            * branch if > 7
00082B8E                          6653  
00082B8E  2200                    6654      MOVE.l  d0,d1               * copy bit # to test
00082B90  6100 EAB2               6655      BSR     LAB_GBYT            * get next BASIC byte
00082B94  B03C 0029               6656      CMP.b       #')',d0         * is next character ")"
00082B98  6600 DE6A               6657      BNE     LAB_SNER            * if not ")" go do syntax error, then warm start
00082B9C                          6658  
00082B9C  6100 EAA4               6659      BSR     LAB_IGBY            * update execute pointer (to character past ")")
00082BA0  7000                    6660      MOVEQ       #0,d0               * set the result as zero
00082BA2  0310                    6661      BTST        d1,(a0)         * test bit
00082BA4  6700 F90E               6662      BEQ     LAB_27DB            * branch if zero (already correct)
00082BA8                          6663  
00082BA8  70FF                    6664      MOVEQ       #-1,d0          * set for -1 result
00082BAA  6000 F908               6665      BRA     LAB_27DB            * go do SGN tail
00082BAE                          6666  
00082BAE                          6667  
00082BAE                          6668  *************************************************************************************
00082BAE                          6669  *
00082BAE                          6670  * perform USING$()
00082BAE                          6671  
00082BAE  =00000000               6672  fsd EQU  0                  *   (sp) format string descriptor pointer
00082BAE  =00000004               6673  fsti    EQU  4                  *  4(sp) format string this index
00082BAE  =00000006               6674  fsli    EQU  6                  *  6(sp) format string last index
00082BAE  =00000008               6675  fsdpi   EQU  8                  *  8(sp) format string decimal point index
00082BAE  =0000000A               6676  fsdc    EQU 10                  * 10(sp) format string decimal characters
00082BAE  =00000008               6677  fend    EQU 12-4                    *  x(sp) end-4, fsd is popped by itself
00082BAE                          6678  
00082BAE  =00000023               6679  ofchr   EQU '#'                 * the overflow character
00082BAE                          6680  
00082BAE                          6681  LAB_USINGS
00082BAE  4A2B 05B5               6682      TST.b       Dtypef(a3)          * test data type, $80=string
00082BB2  6A00 DDFC               6683      BPL     LAB_FOER            * if not string type go do format error
00082BB6                          6684  
00082BB6  246B 0590               6685      MOVEA.l FAC1_m(a3),a2       * get the format string descriptor pointer
00082BBA  3E2A 0004               6686      MOVE.w  4(a2),d7            * get the format string length
00082BBE  6700 DDF0               6687      BEQ     LAB_FOER            * if null string go do format error
00082BC2                          6688  
00082BC2                          6689  * clear the format string values
00082BC2                          6690  
00082BC2  7000                    6691      MOVEQ       #0,d0               * clear d0
00082BC4  3F00                    6692      MOVE.w  d0,-(sp)            * clear the format string decimal characters
00082BC6  3F00                    6693      MOVE.w  d0,-(sp)            * clear the format string decimal point index
00082BC8  3F00                    6694      MOVE.w  d0,-(sp)            * clear the format string last index
00082BCA  3F00                    6695      MOVE.w  d0,-(sp)            * clear the format string this index
00082BCC  2F0A                    6696      MOVE.l  a2,-(sp)            * save the format string descriptor pointer
00082BCE                          6697  
00082BCE                          6698  * make a null return string for the first string add
00082BCE                          6699  
00082BCE  7200                    6700      MOVEQ       #0,d1               * make a null string
00082BD0  2041                    6701      MOVEA.l d1,a0               * with a null pointer
00082BD2  6100 F0CA               6702      BSR     LAB_RTST            * push a string on the descriptor stack
00082BD6                          6703                              * a0 = pointer, d1 = length
00082BD6                          6704  
00082BD6                          6705  * do the USING$() function next value
00082BD6                          6706  
00082BD6  101D                    6707      MOVE.b  (a5)+,d0            * get the next BASIC byte
00082BD8                          6708  LAB_U002
00082BD8  B03C 002C               6709      CMP.b       #',',d0         * compare with comma
00082BDC  6600 DE26               6710      BNE     LAB_SNER            * if not "," go do syntax error
00082BE0                          6711  
00082BE0  6100 028E               6712      BSR     LAB_ProcFo          * process the format string
00082BE4  4A02                    6713      TST.b       d2              * test the special characters flag
00082BE6  6700 DDC8               6714      BEQ     LAB_FOER            * if no special characters go do format error
00082BEA                          6715  
00082BEA  6100 E8F6               6716      BSR     LAB_EVEX            * evaluate the expression
00082BEE  4A2B 05B5               6717      TST.b       Dtypef(a3)          * test the data type
00082BF2  6B00 DDE4               6718      BMI     LAB_TMER            * if string type go do type missmatch error
00082BF6                          6719  
00082BF6  4A2B 0594               6720      TST.b       FAC1_e(a3)          * test FAC1 exponent
00082BFA  6732                    6721      BEQ.s       LAB_U004            * if FAC1 = 0 skip the rounding
00082BFC                          6722  
00082BFC  322F 000A               6723      MOVE.w  fsdc(sp),d1         * get the format string decimal character count
00082C00  B27C 0008               6724      CMP.w       #8,d1               * compare the fraction digit count with 8
00082C04  6428                    6725      BCC.s       LAB_U004            * if >= 8 skip the rounding
00082C06                          6726  
00082C06  3001                    6727      MOVE.w  d1,d0               * else copy the fraction digit count
00082C08  D241                    6728      ADD.w       d1,d1               * * 2
00082C0A  D240                    6729      ADD.w       d0,d1               * * 3
00082C0C  D241                    6730      ADD.w       d1,d1               * * 6
00082C0E  41FA 0844               6731      LEA     LAB_P_10(pc),a0     * get the rounding table base
00082C12  2770 1002 0598          6732      MOVE.l  2(a0,d1.w),FAC2_m(a3)   * get the rounding mantissa
00082C18  3030 1000               6733      MOVE.w  (a0,d1.w),d0        * get the rounding exponent
00082C1C  0440 0100               6734      SUB.w       #$100,d0            * effectively divide the mantissa by 2
00082C20  3740 059C               6735      MOVE.w  d0,FAC2_e(a3)       * save the rounding exponent
00082C24  177C 0000 059E          6736      MOVE.b  #$00,FAC_sc(a3)     * clear the sign compare
00082C2A  6100 F4F6               6737      BSR     LAB_ADD         * round the value to n places
00082C2E                          6738  LAB_U004
00082C2E  6100 F970               6739      BSR     LAB_2970            * convert FAC1 to string - not on stack
00082C32                          6740  
00082C32  6100 01FE               6741      BSR     LAB_DupFmt          * duplicate the processed format string section
00082C36                          6742                              * returns length in d1, pointer in a0
00082C36                          6743  
00082C36                          6744  * process the number string, length in d6, decimal point index in d2
00082C36                          6745  
00082C36  45EB 05C6               6746      LEA     Decss(a3),a2        * set the number string start
00082C3A  7C00                    6747      MOVEQ       #0,d6               * clear the number string index
00082C3C  782E                    6748      MOVEQ       #'.',d4         * set the decimal point character
00082C3E                          6749  LAB_U005
00082C3E  3406                    6750      MOVE.w  d6,d2               * save the index to flag the decimal point
00082C40                          6751  LAB_U006
00082C40  5246                    6752      ADDQ.w  #1,d6               * increment the number string index
00082C42  1032 6000               6753      MOVE.b  (a2,d6.w),d0        * get a number string character
00082C46  677A                    6754      BEQ.s       LAB_U010            * if null then number complete
00082C48                          6755  
00082C48  B03C 0045               6756      CMP.b       #'E',d0         * compare the character with an "E"
00082C4C  6706                    6757      BEQ.s       LAB_U008            * was sx[.x]Esxx so go handle sci notation
00082C4E                          6758  
00082C4E  B004                    6759      CMP.b       d4,d0               * compare the character with "."
00082C50  66EE                    6760      BNE.s       LAB_U006            * if not decimal point go get the next digit
00082C52                          6761  
00082C52  60EA                    6762      BRA.s       LAB_U005            * go save the index and get the next digit
00082C54                          6763  
00082C54                          6764  * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
00082C54                          6765  
00082C54                          6766  LAB_U008
00082C54  3606                    6767      MOVE.w  d6,d3               * copy the index to the "E"
00082C56  5343                    6768      SUBQ.w  #1,d3               * -1 gives the last digit index
00082C58                          6769  
00082C58  5246                    6770      ADDQ.w  #1,d6               * increment the index to the exponent sign
00082C5A  1032 6000               6771      MOVE.b  (a2,d6.w),d0        * get the exponent sign character
00082C5E  B03C 002D               6772      CMP.b       #'-',d0         * compare the exponent sign with "-"
00082C62  6600 DD94               6773      BNE     LAB_FCER            * if it wasn't sx[.x]E-xx go do function
00082C66                          6774                              * call error
00082C66                          6775  
00082C66                          6776  * found an sx[.x]E-xx number so check the exponent magnitude
00082C66                          6777  
00082C66  5246                    6778      ADDQ.w  #1,d6               * increment the index to the exponent 10s
00082C68  1032 6000               6779      MOVE.b  (a2,d6.w),d0        * get the exponent 10s character
00082C6C  B03C 0030               6780      CMP.b       #'0',d0         * compare the exponent 10s with "0"
00082C70  6704                    6781      BEQ.s       LAB_U009            * if it was sx[.x]E-0x go get the exponent
00082C72                          6782                              * 1s character
00082C72                          6783  
00082C72  700A                    6784      MOVEQ       #10,d0          * else start writing at index 10
00082C74  6008                    6785      BRA.s       LAB_U00A            * go copy the digits
00082C76                          6786  
00082C76                          6787  * found an sx[.x]E-0x number so get the exponent magnitude
00082C76                          6788  
00082C76                          6789  LAB_U009
00082C76  5246                    6790      ADDQ.w  #1,d6               * increment the index to the exponent 1s
00082C78  700F                    6791      MOVEQ       #$0F,d0         * set the mask for the exponent 1s digit
00082C7A  C032 6000               6792      AND.b       (a2,d6.w),d0        * get and convert the exponent 1s digit
00082C7E                          6793  LAB_U00A
00082C7E  3403                    6794      MOVE.w  d3,d2               * copy the number last digit index
00082C80  0C42 0001               6795      CMPI.w  #1,d2               * is the number of the form sxE-0x
00082C84  6602                    6796      BNE.s       LAB_U00B            * if it is sx.xE-0x skip the increment
00082C86                          6797  
00082C86                          6798                              * else make room for the decimal point
00082C86  5242                    6799      ADDQ.w  #1,d2               * add 1 to the write index
00082C88                          6800  LAB_U00B
00082C88  D440                    6801      ADD.w       d0,d2               * add the exponent 1s to the write index
00082C8A  700A                    6802      MOVEQ       #10,d0          * set the maximum write index
00082C8C  9042                    6803      SUB.w       d2,d0               * compare the index with the maximum
00082C8E  6E0C                    6804      BGT.s       LAB_U00C            * if the index < the maximum continue
00082C90                          6805  
00082C90  D440                    6806      ADD.w       d0,d2               * else set the index to the maximum
00082C92  D640                    6807      ADD.w       d0,d3               * adjust the read index
00082C94  0C43 0001               6808      CMPI.w  #1,d3               * compare the adjusted index with 1
00082C98  6E02                    6809      BGT.s       LAB_U00C            * if > 1 continue
00082C9A                          6810  
00082C9A  7600                    6811      MOVEQ       #0,d3               * else allow for the decimal point
00082C9C                          6812  LAB_U00C
00082C9C  3C02                    6813      MOVE.w      d2,d6               * copy the write index as the number
00082C9E                          6814                              * string length
00082C9E  7000                    6815      MOVEQ       #0,d0               * clear d0 to null terminate the number
00082CA0                          6816                              * string
00082CA0                          6817  LAB_U00D
00082CA0  1580 2000               6818      MOVE.b  d0,(a2,d2.w)        * save the character to the number string
00082CA4  5342                    6819      SUBQ.w  #1,d2               * decrement the number write index
00082CA6  0C42 0001               6820      CMPI.w  #1,d2               * compare the number write index with 1
00082CAA  6712                    6821      BEQ.s       LAB_U00F            * if at the decimal point go save it
00082CAC                          6822  
00082CAC                          6823                              * else write a digit to the number string
00082CAC  7030                    6824      MOVEQ       #'0',d0         * default to "0"
00082CAE  4A43                    6825      TST.w       d3              * test the number read index
00082CB0  67EE                    6826      BEQ.s       LAB_U00D            * if zero just go save the "0"
00082CB2                          6827  
00082CB2                          6828  LAB_U00E
00082CB2  1032 3000               6829      MOVE.b  (a2,d3.w),d0        * read the next number digit
00082CB6  5343                    6830      SUBQ.w  #1,d3               * decrement the read index
00082CB8  B004                    6831      CMP.b       d4,d0               * compare the digit with "."
00082CBA  66E4                    6832      BNE.s       LAB_U00D            * if not "." go save the digit
00082CBC                          6833  
00082CBC  60F4                    6834      BRA.s       LAB_U00E            * else go get the next digit
00082CBE                          6835  
00082CBE                          6836  LAB_U00F
00082CBE  1584 2000               6837      MOVE.b  d4,(a2,d2.w)        * save the decimal point
00082CC2                          6838  LAB_U010
00082CC2  4A42                    6839      TST.w       d2              * test the number string decimal point index
00082CC4  6602                    6840      BNE.s       LAB_U014            * if dp present skip the reset
00082CC6                          6841  
00082CC6  3406                    6842      MOVE.w  d6,d2               * make the decimal point index = the length
00082CC8                          6843  
00082CC8                          6844  * copy the fractional digit characters from the number string
00082CC8                          6845  
00082CC8                          6846  LAB_U014
00082CC8  3602                    6847      MOVE.w  d2,d3               * copy the number string decimal point index
00082CCA  5243                    6848      ADDQ.w  #1,d3               * increment the number string index
00082CCC  382F 0008               6849      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00082CD0                          6850  LAB_U018
00082CD0  5244                    6851      ADDQ.w  #1,d4               * increment the new format string index
00082CD2  B244                    6852      CMP.w       d4,d1               * compare it with the new format string length
00082CD4  6322                    6853      BLS.s       LAB_U022            * if done the fraction digits go do integer
00082CD6                          6854  
00082CD6  1030 4000               6855      MOVE.b  (a0,d4.w),d0        * get a new format string character
00082CDA  B03C 0025               6856      CMP.b       #'%',d0         * compare it with "%"
00082CDE  6706                    6857      BEQ.s       LAB_U01C            * if "%" go copy a number character
00082CE0                          6858  
00082CE0  B03C 0023               6859      CMP.b       #'#',d0         * compare it with "#"
00082CE4  66EA                    6860      BNE.s       LAB_U018            * if not "#" go do the next new format character
00082CE6                          6861  
00082CE6                          6862  LAB_U01C
00082CE6  7030                    6863      MOVEQ       #'0',d0         * default to "0" character
00082CE8  BC43                    6864      CMP.w       d3,d6               * compare the number string index with length
00082CEA  6306                    6865      BLS.s       LAB_U020            * if there skip the character get
00082CEC                          6866  
00082CEC  1032 3000               6867      MOVE.b  (a2,d3.w),d0        * get a character from the number string
00082CF0  5243                    6868      ADDQ.w  #1,d3               * increment the number string index
00082CF2                          6869  LAB_U020
00082CF2  1180 4000               6870      MOVE.b  d0,(a0,d4.w)        * save the number character to the new format
00082CF6                          6871                              * string
00082CF6  60D8                    6872      BRA.s       LAB_U018            * go do the next new format character
00082CF8                          6873  
00082CF8                          6874  * now copy the integer digit characters from the number string
00082CF8                          6875  
00082CF8                          6876  LAB_U022
00082CF8  7C00                    6877      MOVEQ       #0,d6               * clear the sign done flag
00082CFA  7A00                    6878      MOVEQ       #0,d5               * clear the sign present flag
00082CFC  5342                    6879      SUBQ.w  #1,d2               * decrement the number string index
00082CFE  6608                    6880      BNE.s       LAB_U026            * if not now at sign continue
00082D00                          6881  
00082D00  7401                    6882      MOVEQ       #1,d2               * increment the number string index
00082D02  15BC 0030 2000          6883      MOVE.b  #'0',(a2,d2.w)      * replace the point with a zero
00082D08                          6884  LAB_U026
00082D08  382F 0008               6885      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00082D0C  B244                    6886      CMP.w       d4,d1               * compare it with the new format string length
00082D0E  6402                    6887      BCC.s       LAB_U02A            * if within the string go use the index
00082D10                          6888  
00082D10  3801                    6889      MOVE.w  d1,d4               * else set the index to the end of the string
00082D12                          6890  LAB_U02A
00082D12  5344                    6891      SUBQ.w  #1,d4               * decrement the new format string index
00082D14  6B62                    6892      BMI.s       LAB_U03E            * if all done go test for any overflow
00082D16                          6893  
00082D16  1030 4000               6894      MOVE.b  (a0,d4.w),d0        * else get a new format string character
00082D1A                          6895  
00082D1A  7E30                    6896      MOVEQ       #'0',d7         * default to "0" character
00082D1C  B03C 0025               6897      CMP.b       #'%',d0         * compare it with "%"
00082D20  6708                    6898      BEQ.s       LAB_U02B            * if "%" go copy a number character
00082D22                          6899  
00082D22  7E20                    6900      MOVEQ       #' ',d7         * default to " " character
00082D24  B03C 0023               6901      CMP.b       #'#',d0         * compare it with "#"
00082D28  6606                    6902      BNE.s       LAB_U02C            * if not "#" go try ","
00082D2A                          6903  
00082D2A                          6904  LAB_U02B
00082D2A  4A42                    6905      TST.w       d2              * test the number string index
00082D2C  6634                    6906      BNE.s       LAB_U036            * if not at the sign go get a number character
00082D2E                          6907  
00082D2E  6042                    6908      BRA.s       LAB_U03C            * else go save the default character
00082D30                          6909  
00082D30                          6910  LAB_U02C
00082D30  B03C 002C               6911      CMP.b       #',',d0         * compare it with ","
00082D34  6610                    6912      BNE.s       LAB_U030            * if not "," go try the sign characters
00082D36                          6913  
00082D36  4A42                    6914      TST.w       d2              * test the number string index
00082D38  6608                    6915      BNE.s       LAB_U02E            * if not at the sign keep the ","
00082D3A                          6916  
00082D3A  0C30 0025 40FF          6917      CMP.b       #'%',-1(a0,d4.w)        * else compare the next format string character
00082D40                          6918                              * with "%"
00082D40  6630                    6919      BNE.s       LAB_U03C            * if not "%" keep the default character
00082D42                          6920  
00082D42                          6921  LAB_U02E
00082D42  1E00                    6922      MOVE.b  d0,d7               * else use the "," character
00082D44  602C                    6923      BRA.s       LAB_U03C            * go save the character to the string
00082D46                          6924  
00082D46                          6925  LAB_U030
00082D46  B03C 002D               6926      CMP.b       #'-',d0         * compare it with "-"
00082D4A  6710                    6927      BEQ.s       LAB_U034            * if "-" go do the sign character
00082D4C                          6928  
00082D4C  B03C 002B               6929      CMP.b       #'+',d0         * compare it with "+"
00082D50  66C0                    6930      BNE.s       LAB_U02A            * if not "+" go do the next new format character
00082D52                          6931  
00082D52  0C12 002D               6932      CMP.b       #'-',(a2)           * compare the sign character with "-"
00082D56  6704                    6933      BEQ.s       LAB_U034            * if "-" don't change the sign character
00082D58                          6934  
00082D58  14BC 002B               6935      MOVE.b  #'+',(a2)           * else make the sign character "+"
00082D5C                          6936  LAB_U034
00082D5C  1A00                    6937      MOVE.b  d0,d5               * set the sign present flag
00082D5E  4A42                    6938      TST.w       d2              * test the number string index
00082D60  6708                    6939      BEQ.s       LAB_U038            * if at the sign keep the default character
00082D62                          6940  
00082D62                          6941  LAB_U036
00082D62  1E32 2000               6942      MOVE.b  (a2,d2.w),d7        * else get a character from the number string
00082D66  5342                    6943      SUBQ.w  #1,d2               * decrement the number string index
00082D68  6008                    6944      BRA.s       LAB_U03C            * go save the character
00082D6A                          6945  
00082D6A                          6946  LAB_U038
00082D6A  4A06                    6947      TST.b       d6              * test the sign done flag
00082D6C  6604                    6948      BNE.s       LAB_U03C            * if the sign has been done go use the space
00082D6E                          6949                              * character
00082D6E                          6950  
00082D6E  1E12                    6951      MOVE.b  (a2),d7         * else get the sign character
00082D70  1C07                    6952      MOVE.b  d7,d6               * flag that the sign has been done
00082D72                          6953  LAB_U03C
00082D72  1187 4000               6954      MOVE.b  d7,(a0,d4.w)        * save the number character to the new format
00082D76                          6955                              * string
00082D76  609A                    6956      BRA.s       LAB_U02A            * go do the next new format character
00082D78                          6957  
00082D78                          6958  * test for overflow conditions
00082D78                          6959  
00082D78                          6960  LAB_U03E
00082D78  4A42                    6961      TST.w       d2              * test the number string index
00082D7A  6614                    6962      BNE.s       LAB_U040            * if all the digits aren't done go output
00082D7C                          6963                              * an overflow indication
00082D7C                          6964  
00082D7C                          6965  * test for sign overflows
00082D7C                          6966  
00082D7C  4A05                    6967      TST.b       d5              * test the sign present flag
00082D7E  6754                    6968      BEQ.s       LAB_U04A            * if no sign present go add the string
00082D80                          6969  
00082D80                          6970  * there was a sign in the format string
00082D80                          6971  
00082D80  4A06                    6972      TST.b       d6              * test the sign done flag
00082D82  6650                    6973      BNE.s       LAB_U04A            * if the sign is done go add the string
00082D84                          6974  
00082D84                          6975  * the sign isn't done so see if it was mandatory
00082D84                          6976  
00082D84  0C05 002B               6977      CMPI.b  #'+',d5         * compare the sign with "+"
00082D88  6706                    6978      BEQ.s       LAB_U040            * if it was "+" go output an overflow
00082D8A                          6979                              * indication
00082D8A                          6980  
00082D8A                          6981  * the sign wasn't mandatory but the number may have been negative
00082D8A                          6982  
00082D8A  0C12 002D               6983      CMP.b       #'-',(a2)           * compare the sign character with "-"
00082D8E  6644                    6984      BNE.s       LAB_U04A            * if it wasn't "-" go add the string
00082D90                          6985  
00082D90                          6986  * else the sign was "-" and a sign hasn't been output so ..
00082D90                          6987  
00082D90                          6988  * the number overflowed the format string so replace all the special format characters
00082D90                          6989  * with the overflow character
00082D90                          6990  
00082D90                          6991  LAB_U040
00082D90  7A23                    6992      MOVEQ       #ofchr,d5           * set the overflow character
00082D92  3E01                    6993      MOVE.w  d1,d7               * copy the new format string length
00082D94  5347                    6994      SUBQ.w  #1,d7               * adjust for the loop type
00082D96  3C2F 0004               6995      MOVE.w  fsti(sp),d6         * copy the new format string last index
00082D9A  5346                    6996      SUBQ.w  #1,d6               * -1 gives the last character of this string
00082D9C  6E02                    6997      BGT.s       LAB_U044            * if not zero continue
00082D9E                          6998  
00082D9E  3C07                    6999      MOVE.w  d7,d6               * else set the format string index to the end
00082DA0                          7000  LAB_U044
00082DA0  1031 6000               7001      MOVE.b  (a1,d6.w),d0        * get a character from the format string
00082DA4  0C00 0023               7002      CMPI.b  #'#',d0         * compare it with "#" special format character
00082DA8  671E                    7003      BEQ.s       LAB_U046            * if "#" go use the overflow character
00082DAA                          7004  
00082DAA  0C00 0025               7005      CMPI.b  #'%',d0         * compare it with "%" special format character
00082DAE  6718                    7006      BEQ.s       LAB_U046            * if "%" go use the overflow character
00082DB0                          7007  
00082DB0  0C00 002C               7008      CMPI.b  #',',d0         * compare it with "," special format character
00082DB4  6712                    7009      BEQ.s       LAB_U046            * if "," go use the overflow character
00082DB6                          7010  
00082DB6  0C00 002B               7011      CMPI.b  #'+',d0         * compare it with "+" special format character
00082DBA  670C                    7012      BEQ.s       LAB_U046            * if "+" go use the overflow character
00082DBC                          7013  
00082DBC  0C00 002D               7014      CMPI.b  #'-',d0         * compare it with "-" special format character
00082DC0  6706                    7015      BEQ.s       LAB_U046            * if "-" go use the overflow character
00082DC2                          7016  
00082DC2  0C00 002E               7017      CMPI.b  #'.',d0         * compare it with "." special format character
00082DC6  6602                    7018      BNE.s       LAB_U048            * if not "." skip the using overflow character
00082DC8                          7019  
00082DC8                          7020  LAB_U046
00082DC8  1005                    7021      MOVE.b  d5,d0               * use the overflow character
00082DCA                          7022  LAB_U048
00082DCA  1180 7000               7023      MOVE.b  d0,(a0,d7.w)        * save the character to the new format string
00082DCE  5346                    7024      SUBQ.w  #1,d6               * decrement the format string index
00082DD0  51CF FFCE               7025      DBF     d7,LAB_U044         * decrement the count and loop if not all done
00082DD4                          7026  
00082DD4                          7027  * add the new string to the previous string
00082DD4                          7028  
00082DD4                          7029  LAB_U04A
00082DD4  41EC 0006               7030      LEA     6(a4),a0            * get the descriptor pointer for string 1
00082DD8  274C 0590               7031      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00082DDC  6100 F010               7032      BSR     LAB_224E            * concatenate the strings
00082DE0                          7033  
00082DE0                          7034  * now check for any tail on the format string
00082DE0                          7035  
00082DE0  302F 0004               7036      MOVE.w  fsti(sp),d0         * get this index
00082DE4  6720                    7037      BEQ.s       LAB_U04C            * if at start of string skip the output
00082DE6                          7038  
00082DE6  3F40 0006               7039      MOVE.w  d0,fsli(sp)         * save this index to the last index
00082DEA  6100 0084               7040      BSR     LAB_ProcFo          * now process the format string
00082DEE  4A02                    7041      TST.b       d2              * test the special characters flag
00082DF0  6614                    7042      BNE.s       LAB_U04C            * if special characters present skip the output
00082DF2                          7043  
00082DF2                          7044  * else output the new string part
00082DF2                          7045  
00082DF2  613E                    7046      BSR.s       LAB_DupFmt          * duplicate the processed format string section
00082DF4  3F6F 0004 0006          7047      MOVE.w  fsti(sp),fsli(sp)       * copy this index to the last index
00082DFA                          7048  
00082DFA                          7049  * add the new string to the previous string
00082DFA                          7050  
00082DFA  41EC 0006               7051      LEA     6(a4),a0            * get the descriptor pointer for string 1
00082DFE  274C 0590               7052      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00082E02  6100 EFEA               7053      BSR     LAB_224E            * concatenate the strings
00082E06                          7054  
00082E06                          7055  * check for another value or end of function
00082E06                          7056  
00082E06                          7057  LAB_U04C
00082E06  101D                    7058      MOVE.b  (a5)+,d0            * get the next BASIC byte
00082E08  B03C 0029               7059      CMP.b       #')',d0         * compare with close bracket
00082E0C  6600 FDCA               7060      BNE     LAB_U002            * if not ")" go do next value
00082E10                          7061  
00082E10                          7062  * pop the result string off the descriptor stack
00082E10                          7063  
00082E10  204C                    7064      MOVEA.l a4,a0               * copy the result string descriptor pointer
00082E12  222B 0446               7065      MOVE.l  Sstorl(a3),d1       * save the bottom of string space
00082E16  6100 F038               7066      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00082E1A                          7067                              * d0 = length, a0 = pointer
00082E1A  2741 0446               7068      MOVE.l  d1,Sstorl(a3)       * restore the bottom of string space
00082E1E  2248                    7069      MOVEA.l a0,a1               * copy the string result pointer
00082E20  3200                    7070      MOVE.w  d0,d1               * copy the string result length
00082E22                          7071  
00082E22                          7072  * pop the format string off the descriptor stack
00082E22                          7073  
00082E22  205F                    7074      MOVEA.l (sp)+,a0            * pull the format string descriptor pointer
00082E24  6100 F02A               7075      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00082E28                          7076                              * d0 = length, a0 = pointer
00082E28                          7077  
00082E28  4FEF 0008               7078      LEA     fend(sp),sp         * dump the saved values
00082E2C                          7079  
00082E2C                          7080  * push the result string back on the descriptor stack and return
00082E2C                          7081  
00082E2C  2049                    7082      MOVEA.l a1,a0               * copy the result string pointer back
00082E2E  6000 EE6E               7083      BRA     LAB_RTST            * push a string on the descriptor stack and
00082E32                          7084                              * return. a0 = pointer, d1 = length
00082E32                          7085  
00082E32                          7086  
00082E32                          7087  *************************************************************************************
00082E32                          7088  *
00082E32                          7089  * duplicate the processed format string section
00082E32                          7090  
00082E32                          7091                              * make a string as long as the format string
00082E32                          7092  LAB_DupFmt
00082E32  226F 0004               7093      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00082E36  3E29 0004               7094      MOVE.w  4(a1),d7            * get the format string length
00082E3A  342F 000A               7095      MOVE.w  4+fsli(sp),d2       * get the format string last index
00082E3E  3C2F 0008               7096      MOVE.w  4+fsti(sp),d6       * get the format string this index
00082E42  3206                    7097      MOVE.w  d6,d1               * copy the format string this index
00082E44  9242                    7098      SUB.w       d2,d1               * subtract the format string last index
00082E46  6202                    7099      BHI.s       LAB_D002            * if > 0 skip the correction
00082E48                          7100  
00082E48  D247                    7101      ADD.w       d7,d1               * else add the format string length as the
00082E4A                          7102                              * correction
00082E4A                          7103  LAB_D002
00082E4A  6100 EE6C               7104      BSR     LAB_2115            * make string space d1 bytes long
00082E4E                          7105                              * return a0/Sutill = pointer, others unchanged
00082E4E                          7106  
00082E4E                          7107  * push the new string on the descriptor stack
00082E4E                          7108  
00082E4E  6100 EE4E               7109      BSR     LAB_RTST            * push a string on the descriptor stack and
00082E52                          7110                              * return. a0 = pointer, d1 = length
00082E52                          7111  
00082E52                          7112  * copy the characters from the format string
00082E52                          7113  
00082E52  226F 0004               7114      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00082E56  2251                    7115      MOVEA.l (a1),a1         * get the format string pointer
00082E58  7800                    7116      MOVEQ       #0,d4               * clear the new string index
00082E5A                          7117  LAB_D00A
00082E5A  11B1 2000 4000          7118      MOVE.b  (a1,d2.w),(a0,d4.w) * get a character from the format string and
00082E60                          7119                              * save it to the new string
00082E60  5244                    7120      ADDQ.w  #1,d4               * increment the new string index
00082E62  5242                    7121      ADDQ.w  #1,d2               * increment the format string index
00082E64  BE42                    7122      CMP.w       d2,d7               * compare the format index with the length
00082E66  6602                    7123      BNE.s       LAB_D00E            * if not there skip the reset
00082E68                          7124  
00082E68  7400                    7125      MOVEQ       #0,d2               * else reset the format string index
00082E6A                          7126  LAB_D00E
00082E6A  BC42                    7127      CMP.w       d2,d6               * compare the index with this index
00082E6C  66EC                    7128      BNE.s       LAB_D00A            * if not equal go do the next character
00082E6E                          7129  
00082E6E  4E75                    7130      RTS
00082E70                          7131  
00082E70                          7132  
00082E70                          7133  **************************************************************************************
00082E70                          7134  *
00082E70                          7135  * process the format string
00082E70                          7136  
00082E70                          7137  LAB_ProcFo
00082E70  226F 0004               7138      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00082E74  3E29 0004               7139      MOVE.w  4(a1),d7            * get the format string length
00082E78  2251                    7140      MOVEA.l (a1),a1         * get the format string pointer
00082E7A  3C2F 000A               7141      MOVE.w  4+fsli(sp),d6       * get the format string last index
00082E7E                          7142  
00082E7E  3F47 000C               7143      MOVE.w  d7,4+fsdpi(sp)      * set the format string decimal point index
00082E82                          7144  *## MOVE.w  #-1,4+fsdpi(sp)     * set the format string decimal point index
00082E82  7A00                    7145      MOVEQ       #0,d5               * no decimal point
00082E84  7600                    7146      MOVEQ       #0,d3               * no decimal characters
00082E86  7400                    7147      MOVEQ       #0,d2               * no special characters
00082E88                          7148  LAB_P004
00082E88  1031 6000               7149      MOVE.b  (a1,d6.w),d0        * get a format string byte
00082E8C                          7150  
00082E8C  B03C 002C               7151      CMP.b       #',',d0         * compare it with ","
00082E90  6742                    7152      BEQ.s       LAB_P01A            * if "," go do the next format string byte
00082E92                          7153  
00082E92  B03C 0023               7154      CMP.b       #'#',d0         * compare it with "#"
00082E96  6706                    7155      BEQ.s       LAB_P008            * if "#" go flag special characters
00082E98                          7156  
00082E98  B03C 0025               7157      CMP.b       #'%',d0         * compare it with "%"
00082E9C  6608                    7158      BNE.s       LAB_P00C            * if not "%" go try "+"
00082E9E                          7159  
00082E9E                          7160  LAB_P008
00082E9E  4A85                    7161      TST.l       d5              * test the decimal point flag
00082EA0  6A10                    7162      BPL.s       LAB_P00E            * if no point skip counting decimal characters
00082EA2                          7163  
00082EA2  5243                    7164      ADDQ.w  #1,d3               * else increment the decimal character count
00082EA4  602E                    7165      BRA.s       LAB_P01A            * go do the next character
00082EA6                          7166  
00082EA6                          7167  LAB_P00C
00082EA6  B03C 002B               7168      CMP.b       #'+',d0         * compare it with "+"
00082EAA  6706                    7169      BEQ.s       LAB_P00E            * if "+" go flag special characters
00082EAC                          7170  
00082EAC  B03C 002D               7171      CMP.b       #'-',d0         * compare it with "-"
00082EB0  6604                    7172      BNE.s       LAB_P010            * if not "-" go check decimal point
00082EB2                          7173  
00082EB2                          7174  LAB_P00E
00082EB2  8400                    7175      OR.b        d0,d2               * flag special characters
00082EB4  601E                    7176      BRA.s       LAB_P01A            * go do the next character
00082EB6                          7177  
00082EB6                          7178  LAB_P010
00082EB6  B03C 002E               7179      CMP.b       #'.',d0         * compare it with "."
00082EBA  6614                    7180      BNE.s       LAB_P018            * if not "." go check next
00082EBC                          7181  
00082EBC                          7182  * "." a decimal point
00082EBC                          7183  
00082EBC  4A85                    7184      TST.l       d5              * if there is already a decimal point
00082EBE  6B14                    7185      BMI.s       LAB_P01A            * go do the next character
00082EC0                          7186  
00082EC0  3006                    7187      MOVE.w  d6,d0               * copy the decimal point index
00082EC2  906F 000A               7188      SUB.w       4+fsli(sp),d0       * calculate it from the scan start
00082EC6  3F40 000C               7189      MOVE.w  d0,4+fsdpi(sp)      * save the decimal point index
00082ECA  7AFF                    7190      MOVEQ       #-1,d5          * flag decimal point
00082ECC  8400                    7191      OR.b        d0,d2               * flag special characters
00082ECE  6004                    7192      BRA.s       LAB_P01A            * go do the next character
00082ED0                          7193  
00082ED0                          7194  * was not a special character
00082ED0                          7195  
00082ED0                          7196  LAB_P018
00082ED0  4A02                    7197      TST.b       d2              * test if there have been special characters
00082ED2  6608                    7198      BNE.s       LAB_P01E            * if so exit the format string process
00082ED4                          7199  
00082ED4                          7200  LAB_P01A
00082ED4  5246                    7201      ADDQ.w  #1,d6               * increment the format string index
00082ED6  BE46                    7202      CMP.w       d6,d7               * compare it with the format string length
00082ED8  62AE                    7203      BHI.s       LAB_P004            * if length > index go get the next character
00082EDA                          7204  
00082EDA  7C00                    7205      MOVEQ       #0,d6               * length = index so reset the format string
00082EDC                          7206                              * index
00082EDC                          7207  LAB_P01E
00082EDC  3F46 0008               7208      MOVE.w  d6,4+fsti(sp)       * save the format string this index
00082EE0  3F43 000E               7209      MOVE.w  d3,4+fsdc(sp)       * save the format string decimal characters
00082EE4                          7210  
00082EE4  4E75                    7211      RTS
00082EE6                          7212  
00082EE6                          7213  
00082EE6                          7214  *************************************************************************************
00082EE6                          7215  *
00082EE6                          7216  * perform BIN$()
00082EE6                          7217  * # of leading 0s is in d1, the number is in d0
00082EE6                          7218  
00082EE6                          7219  LAB_BINS
00082EE6  B23C 0021               7220      CMP.b       #$21,d1         * max + 1
00082EEA  6400 DB0C               7221      BCC     LAB_FCER            * exit if too big ( > or = )
00082EEE                          7222  
00082EEE  741F                    7223      MOVEQ       #$1F,d2         * bit count-1
00082EF0  41EB 05B6               7224      LEA     Binss(a3),a0        * point to string
00082EF4  7830                    7225      MOVEQ       #$30,d4         * "0" character for ADDX
00082EF6                          7226  NextB1
00082EF6  7600                    7227      MOVEQ       #0,d3               * clear byte
00082EF8  E288                    7228      LSR.l       #1,d0               * shift bit into Xb
00082EFA  D704                    7229      ADDX.b  d4,d3               * add carry and character to zero
00082EFC  1183 2000               7230      MOVE.b  d3,(a0,d2.w)        * save character to string
00082F00  51CA FFF4               7231      DBF     d2,NextB1           * decrement and loop if not done
00082F04                          7232  
00082F04                          7233  * this is the exit code and is also used by HEX$()
00082F04                          7234  
00082F04                          7235  EndBHS
00082F04  177C 0000 05D6          7236      MOVE.b  #0,BHsend(a3)       * null terminate the string
00082F0A  4A01                    7237      TST.b       d1              * test # of characters
00082F0C  670E                    7238      BEQ.s       NextB2          * go truncate string
00082F0E                          7239  
00082F0E  4481                    7240      NEG.l       d1              * make -ve
00082F10  0681 000005D6           7241      ADD.l       #BHsend,d1          * effectively (end-length)
00082F16  41F3 1000               7242      LEA     0(a3,d1.w),a0       * effectively add (end-length) to pointer
00082F1A  600E                    7243      BRA.s       BinPr               * go print string
00082F1C                          7244  
00082F1C                          7245  * truncate string to remove leading "0"s
00082F1C                          7246  
00082F1C                          7247  NextB2
00082F1C  1010                    7248      MOVE.b  (a0),d0         * get byte
00082F1E  670A                    7249      BEQ.s       BinPr               * if null then end of string so add 1 and go
00082F20                          7250                              * print it
00082F20                          7251  
00082F20  B03C 0030               7252      CMP.b       #'0',d0         * compare with "0"
00082F24  660E                    7253      BNE.s       GoPr                * if not "0" then go print string from here
00082F26                          7254  
00082F26  5248                    7255      ADDQ.w  #1,a0               * else increment pointer
00082F28  60F2                    7256      BRA.s       NextB2          * loop always
00082F2A                          7257  
00082F2A                          7258  * make fixed length output string - ignore overflows!
00082F2A                          7259  
00082F2A                          7260  BinPr
00082F2A  43EB 05D6               7261      LEA     BHsend(a3),a1       * get string end
00082F2E  B1C9                    7262      CMPA.l  a1,a0               * are we at the string end
00082F30  6602                    7263      BNE.s       GoPr                * branch if not
00082F32                          7264  
00082F32  5348                    7265      SUBQ.w  #1,a0               * else need at least one zero
00082F34                          7266  GoPr
00082F34  6000 ED22               7267      BRA     LAB_20AE            * print " terminated string to FAC1, stack & RET
00082F38                          7268  
00082F38                          7269  
00082F38                          7270  *************************************************************************************
00082F38                          7271  *
00082F38                          7272  * perform HEX$()
00082F38                          7273  * # of leading 0s is in d1, the number is in d0
00082F38                          7274  
00082F38                          7275  LAB_HEXS
00082F38  B23C 0009               7276      CMP.b       #$09,d1         * max + 1
00082F3C  6400 DABA               7277      BCC     LAB_FCER            * exit if too big ( > or = )
00082F40                          7278  
00082F40  7407                    7279      MOVEQ       #$07,d2         * nibble count-1
00082F42  41EB 05CE               7280      LEA     Hexss(a3),a0        * point to string
00082F46  7830                    7281      MOVEQ       #$30,d4         * "0" character for ABCD
00082F48                          7282  NextH1
00082F48  1600                    7283      MOVE.b  d0,d3               * copy lowest byte
00082F4A  E898                    7284      ROR.l       #4,d0               * shift nibble into 0-3
00082F4C  C63C 000F               7285      AND.b       #$0F,d3         * just this nibble
00082F50  1A03                    7286      MOVE.b  d3,d5               * copy it
00082F52  0605 00F6               7287      ADD.b       #$F6,d5         * set extend bit
00082F56  C704                    7288      ABCD        d4,d3               * decimal add extend and character to zero
00082F58  1183 2000               7289      MOVE.b  d3,(a0,d2.w)        * save character to string
00082F5C  51CA FFEA               7290      DBF     d2,NextH1           * decrement and loop if not done
00082F60                          7291  
00082F60  60A2                    7292      BRA.s       EndBHS          * go process string
00082F62                          7293  
00082F62                          7294  
00082F62                          7295  *************************************************************************************
00082F62                          7296  *
00082F62                          7297  * ctrl-c check routine. includes limited "life" byte save for INGET routine
00082F62                          7298  
00082F62                          7299  VEC_CC
00082F62  4A2B 05E8               7300      TST.b       ccflag(a3)          * check [CTRL-C] check flag
00082F66  661E                    7301      BNE.s       RTS_022         * exit if [CTRL-C] check inhibited
00082F68                          7302  
00082F68  4EAB 040C               7303      JSR     V_INPT(a3)          * scan input device
00082F6C  640E                    7304      BCC.s       LAB_FBA0            * exit if buffer empty
00082F6E                          7305  
00082F6E  1740 05E9               7306      MOVE.b  d0,ccbyte(a3)       * save received byte
00082F72  177C 0020 05EA          7307      MOVE.b  #$20,ccnull(a3)     * set "life" timer for bytes countdown
00082F78  6000 DEF2               7308      BRA     LAB_1636            * return to BASIC
00082F7C                          7309  
00082F7C                          7310  LAB_FBA0
00082F7C  4A2B 05EA               7311      TST.b       ccnull(a3)          * get countdown byte
00082F80  6704                    7312      BEQ.s       RTS_022         * exit if finished
00082F82                          7313  
00082F82  532B 05EA               7314      SUBQ.b  #1,ccnull(a3)       * else decrement countdown
00082F86                          7315  RTS_022
00082F86  4E75                    7316      RTS
00082F88                          7317  
00082F88                          7318  
00082F88                          7319  *************************************************************************************
00082F88                          7320  *
00082F88                          7321  * get byte from input device, no waiting
00082F88                          7322  * returns with carry set if byte in A
00082F88                          7323  
00082F88                          7324  INGET
00082F88  4EAB 040C               7325      JSR     V_INPT(a3)          * call scan input device
00082F8C  650A                    7326      BCS.s       LAB_FB95            * if byte go reset timer
00082F8E                          7327  
00082F8E  102B 05EA               7328      MOVE.b  ccnull(a3),d0       * get countdown
00082F92  67F2                    7329      BEQ.s       RTS_022         * exit if empty
00082F94                          7330  
00082F94  102B 05E9               7331      MOVE.b  ccbyte(a3),d0       * get last received byte
00082F98                          7332  LAB_FB95
00082F98  177C 0000 05EA          7333      MOVE.b  #$00,ccnull(a3)     * clear timer because we got a byte
00082F9E  003C 0001               7334      ORI.b       #1,CCR          * set carry, flag we got a byte
00082FA2  4E75                    7335      RTS
00082FA4                          7336  
00082FA4                          7337  
00082FA4                          7338  *************************************************************************************
00082FA4                          7339  *
00082FA4                          7340  * perform MAX()
00082FA4                          7341  
00082FA4                          7342  LAB_MAX
00082FA4  6100 E53E               7343      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00082FA8  4A2B 05B5               7344      TST.b       Dtypef(a3)          * test data type
00082FAC  6B00 DA2A               7345      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00082FB0                          7346  
00082FB0                          7347  LAB_MAXN
00082FB0  612E                    7348      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00082FB2                          7349                              * pull FAC2 & compare with FAC1
00082FB2  64FC                    7350      BCC.s       LAB_MAXN            * branch if no swap to do
00082FB4                          7351  
00082FB4  6100 F4AA               7352      BSR     LAB_279B            * copy FAC2 to FAC1
00082FB8  60F6                    7353      BRA.s       LAB_MAXN            * go do next
00082FBA                          7354  
00082FBA                          7355  
00082FBA                          7356  *************************************************************************************
00082FBA                          7357  *
00082FBA                          7358  * perform MIN()
00082FBA                          7359  
00082FBA                          7360  LAB_MIN
00082FBA  6100 E528               7361      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00082FBE  4A2B 05B5               7362      TST.b       Dtypef(a3)          * test data type
00082FC2  6B00 DA14               7363      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00082FC6                          7364  
00082FC6                          7365  LAB_MINN
00082FC6  6118                    7366      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00082FC8                          7367                              * pull FAC2 & compare with FAC1
00082FC8  63FC                    7368      BLS.s       LAB_MINN            * branch if no swap to do
00082FCA                          7369  
00082FCA  6100 F494               7370      BSR     LAB_279B            * copy FAC2 to FAC1
00082FCE  60F6                    7371      BRA.s       LAB_MINN            * go do next (branch always)
00082FD0                          7372  
00082FD0                          7373  * exit routine. don't bother returning to the loop code
00082FD0                          7374  * check for correct exit, else so syntax error
00082FD0                          7375  
00082FD0                          7376  LAB_MMEC
00082FD0  B03C 0029               7377      CMP.b       #')',d0         * is it end of function?
00082FD4  6600 DA2E               7378      BNE     LAB_SNER            * if not do MAX MIN syntax error
00082FD8                          7379  
00082FD8  4FEF 0004               7380      LEA     4(sp),sp            * dump return address (faster)
00082FDC  6000 E664               7381      BRA     LAB_IGBY            * update BASIC execute pointer (to chr past ")")
00082FE0                          7382                              * and return
00082FE0                          7383  
00082FE0                          7384  * check for next, evaluate & return or exit
00082FE0                          7385  * this is the routine that does most of the work
00082FE0                          7386  
00082FE0                          7387  LAB_PHFA
00082FE0  6100 E662               7388      BSR     LAB_GBYT            * get next BASIC byte
00082FE4  B03C 002C               7389      CMP.b       #',',d0         * is there more ?
00082FE8  66E6                    7390      BNE.s       LAB_MMEC            * if not go do end check
00082FEA                          7391  
00082FEA  3F2B 0594               7392      MOVE.w  FAC1_e(a3),-(sp)        * push exponent and sign
00082FEE  2F2B 0590               7393      MOVE.l  FAC1_m(a3),-(sp)        * push mantissa
00082FF2                          7394  
00082FF2  6100 E4F0               7395      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00082FF6  4A2B 05B5               7396      TST.b       Dtypef(a3)          * test data type
00082FFA  6B00 D9DC               7397      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00082FFE                          7398  
00082FFE                          7399  
00082FFE                          7400                              * pop FAC2 (MAX/MIN expression so far)
00082FFE  275F 0598               7401      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00083002                          7402  
00083002  301F                    7403      MOVE.w  (sp)+,d0            * pop exponent and sign
00083004  3740 059C               7404      MOVE.w  d0,FAC2_e(a3)       * save exponent and sign
00083008  176B 0595 059E          7405      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * get FAC1 sign
0008300E  B12B 059E               7406      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00083012  6000 F4B8               7407      BRA     LAB_27FA            * compare FAC1 with FAC2 & return
00083016                          7408                              * returns d0=+1 Cb=0 if FAC1 > FAC2
00083016                          7409                              * returns d0= 0 Cb=0 if FAC1 = FAC2
00083016                          7410                              * returns d0=-1 Cb=1 if FAC1 < FAC2
00083016                          7411  
00083016                          7412  
00083016                          7413  *************************************************************************************
00083016                          7414  *
00083016                          7415  * perform WIDTH
00083016                          7416  
00083016                          7417  LAB_WDTH
00083016  B03C 002C               7418      CMP.b       #',',d0         * is next byte ","
0008301A  672C                    7419      BEQ.s       LAB_TBSZ            * if so do tab size
0008301C                          7420  
0008301C  6100 EF8E               7421      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00083020  4A00                    7422      TST.b       d0              * test result
00083022  6712                    7423      BEQ.s       LAB_NSTT            * branch if set for infinite line
00083024                          7424  
00083024  B03C 0010               7425      CMP.b       #$10,d0         * else make min width = 16d
00083028  6500 D9CE               7426      BCS     LAB_FCER            * if less do function call error & exit
0008302C                          7427  
0008302C                          7428  * this next compare ensures that we can't exit WIDTH via an error leaving the
0008302C                          7429  * tab size greater than the line length.
0008302C                          7430  
0008302C  B02B 05E2               7431      CMP.b       TabSiz(a3),d0       * compare with tab size
00083030  6404                    7432      BCC.s       LAB_NSTT            * branch if >= tab size
00083032                          7433  
00083032  1740 05E2               7434      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00083036                          7435  LAB_NSTT
00083036  1740 05E6               7436      MOVE.b  d0,TWidth(a3)       * set the terminal width
0008303A  6100 E608               7437      BSR     LAB_GBYT            * get BASIC byte back
0008303E  672C                    7438      BEQ.s       WExit               * exit if no following
00083040                          7439  
00083040  B03C 002C               7440      CMP.b       #',',d0         * else is it ","
00083044  6600 D9BE               7441      BNE     LAB_SNER            * if not do syntax error
00083048                          7442  
00083048                          7443  LAB_TBSZ
00083048  6100 EF5E               7444      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
0008304C  4A00                    7445      TST.b       d0              * test TAB size
0008304E  6B00 D9A8               7446      BMI     LAB_FCER            * if >127 do function call error & exit
00083052                          7447  
00083052  B03C 0001               7448      CMP.b       #1,d0               * compare with min-1
00083056  6500 D9A0               7449      BCS     LAB_FCER            * if <=1 do function call error & exit
0008305A                          7450  
0008305A  122B 05E6               7451      MOVE.b  TWidth(a3),d1       * set flags for width
0008305E  6708                    7452      BEQ.s       LAB_SVTB            * skip check if infinite line
00083060                          7453  
00083060  B02B 05E6               7454      CMP.b       TWidth(a3),d0       * compare TAB with width
00083064  6E00 D992               7455      BGT     LAB_FCER            * branch if too big
00083068                          7456  
00083068                          7457  LAB_SVTB
00083068  1740 05E2               7458      MOVE.b  d0,TabSiz(a3)       * save TAB size
0008306C                          7459  
0008306C                          7460  * calculate tab column limit from TAB size. The Iclim is set to the last tab
0008306C                          7461  * position on a line that still has at least one whole tab width between it
0008306C                          7462  * and the end of the line.
0008306C                          7463  
0008306C                          7464  WExit
0008306C  102B 05E6               7465      MOVE.b  TWidth(a3),d0       * get width
00083070  670A                    7466      BEQ.s       LAB_WDLP            * branch if infinite line
00083072                          7467  
00083072  B02B 05E2               7468      CMP.b       TabSiz(a3),d0       * compare with tab size
00083076  6404                    7469      BCC.s       LAB_WDLP            * branch if >= tab size
00083078                          7470  
00083078  1740 05E2               7471      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
0008307C                          7472  LAB_WDLP
0008307C  902B 05E2               7473      SUB.b       TabSiz(a3),d0       * subtract tab size
00083080  64FA                    7474      BCC.s       LAB_WDLP            * loop while no borrow
00083082                          7475  
00083082  D02B 05E2               7476      ADD.b       TabSiz(a3),d0       * add tab size back
00083086  D02B 05E2               7477      ADD.b       TabSiz(a3),d0       * add tab size back again
0008308A                          7478  
0008308A  4400                    7479      NEG.b       d0              * make -ve
0008308C  D02B 05E6               7480      ADD.b       TWidth(a3),d0       * subtract remainder from width
00083090  1740 05E7               7481      MOVE.b  d0,Iclim(a3)        * save tab column limit
00083094                          7482  RTS_023
00083094  4E75                    7483      RTS
00083096                          7484  
00083096                          7485  
00083096                          7486  *************************************************************************************
00083096                          7487  *
00083096                          7488  * perform SQR()
00083096                          7489  
00083096                          7490  * d0 is number to find the root of
00083096                          7491  * d1 is the root result
00083096                          7492  * d2 is the remainder
00083096                          7493  * d3 is a counter
00083096                          7494  * d4 is temp
00083096                          7495  
00083096                          7496  LAB_SQR
00083096  4A2B 0595               7497      TST.b       FAC1_s(a3)          * test FAC1 sign
0008309A  6B00 D95C               7498      BMI     LAB_FCER            * if -ve do function call error
0008309E                          7499  
0008309E  4A2B 0594               7500      TST.b       FAC1_e(a3)          * test exponent
000830A2  67F0                    7501      BEQ.s       RTS_023         * exit if zero
000830A4                          7502  
000830A4  48E7 7800               7503      MOVEM.l d1-d4,-(sp)         * save registers
000830A8  202B 0590               7504      MOVE.l  FAC1_m(a3),d0       * copy FAC1
000830AC  7400                    7505      MOVEQ       #0,d2               * clear remainder
000830AE  2202                    7506      MOVE.l  d2,d1               * clear root
000830B0                          7507  
000830B0  761F                    7508      MOVEQ       #$1F,d3         * $1F for DBF, 64 pairs of bits to
000830B2                          7509                              * do for a 32 bit result
000830B2  082B 0000 0594          7510      BTST        #0,FAC1_e(a3)       * test exponent odd/even
000830B8  6606                    7511      BNE.s       LAB_SQE2            * if odd only 1 shift first time
000830BA                          7512  
000830BA                          7513  LAB_SQE1
000830BA  D080                    7514      ADD.l       d0,d0               * shift highest bit of number ..
000830BC  D582                    7515      ADDX.l  d2,d2               * .. into remainder .. never overflows
000830BE  D281                    7516      ADD.l       d1,d1               * root = root * 2 .. never overflows
000830C0                          7517  LAB_SQE2
000830C0  D080                    7518      ADD.l       d0,d0               * shift highest bit of number ..
000830C2  D582                    7519      ADDX.l  d2,d2               * .. into remainder .. never overflows
000830C4                          7520  
000830C4  2801                    7521      MOVE.l  d1,d4               * copy root
000830C6  D884                    7522      ADD.l       d4,d4               * 2n
000830C8  5284                    7523      ADDQ.l  #1,d4               * 2n+1
000830CA                          7524  
000830CA  B484                    7525      CMP.l       d4,d2               * compare 2n+1 to remainder
000830CC  6504                    7526      BCS.s       LAB_SQNS            * skip sub if remainder smaller
000830CE                          7527  
000830CE  9484                    7528      SUB.l       d4,d2               * subtract temp from remainder
000830D0  5281                    7529      ADDQ.l  #1,d1               * increment root
000830D2                          7530  LAB_SQNS
000830D2  51CB FFE6               7531      DBF     d3,LAB_SQE1         * loop if not all done
000830D6                          7532  
000830D6  2741 0590               7533      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
000830DA  102B 0594               7534      MOVE.b  FAC1_e(a3),d0       * get exponent (d0 is clear here)
000830DE  0440 0080               7535      SUB.w       #$80,d0         * normalise
000830E2  E248                    7536      LSR.w       #1,d0               * /2
000830E4  6402                    7537      BCC.s       LAB_SQNA            * skip increment if carry clear
000830E6                          7538  
000830E6  5240                    7539      ADDQ.w  #1,d0               * add bit zero back in (allow for half shift)
000830E8                          7540  LAB_SQNA
000830E8  0640 0080               7541      ADD.w       #$80,d0         * re-bias to $80
000830EC  1740 0594               7542      MOVE.b  d0,FAC1_e(a3)       * save it
000830F0  4CDF 001E               7543      MOVEM.l (sp)+,d1-d4         * restore registers
000830F4  6000 F0A8               7544      BRA     LAB_24D5            * normalise FAC1 & return
000830F8                          7545  
000830F8                          7546  
000830F8                          7547  *************************************************************************************
000830F8                          7548  *
000830F8                          7549  * perform VARPTR()
000830F8                          7550  
000830F8                          7551  LAB_VARPTR
000830F8  101D                    7552      MOVE.b  (a5)+,d0            * increment pointer
000830FA                          7553  LAB_VARCALL
000830FA  6100 E756               7554      BSR     LAB_GVAR            * get variable address in a0
000830FE  6100 E530               7555      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00083102  2008                    7556      MOVE.l  a0,d0               * copy the variable address
00083104  6000 EA3C               7557      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00083108                          7558  
00083108                          7559  
00083108                          7560  *************************************************************************************
00083108                          7561  *
00083108                          7562  * perform RAMBASE
00083108                          7563  
00083108                          7564  LAB_RAM
00083108  41EB 0400               7565      LEA     ram_base(a3),a0     * get start of EhBASIC RAM
0008310C  2008                    7566      MOVE.l  a0,d0               * copy it
0008310E  6000 EA32               7567      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00083112                          7568  
00083112                          7569  
00083112                          7570  *************************************************************************************
00083112                          7571  *
00083112                          7572  * perform PI
00083112                          7573  
00083112                          7574  LAB_PI
00083112  277C C90FDAA2 0590      7575      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * pi mantissa (32 bit)
0008311A  377C 8200 0594          7576      MOVE.w  #$8200,FAC1_e(a3)       * pi exponent and sign
00083120  4E75                    7577      RTS
00083122                          7578  
00083122                          7579  
00083122                          7580  *************************************************************************************
00083122                          7581  *
00083122                          7582  * perform TWOPI
00083122                          7583  
00083122                          7584  LAB_TWOPI
00083122  277C C90FDAA2 0590      7585      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * 2pi mantissa (32 bit)
0008312A  377C 8300 0594          7586      MOVE.w  #$8300,FAC1_e(a3)       * 2pi exponent and sign
00083130  4E75                    7587      RTS
00083132                          7588  
00083132                          7589  
00083132                          7590  *************************************************************************************
00083132                          7591  *
00083132                          7592  * get ASCII string equivalent into FAC1 as integer32 or float
00083132                          7593  
00083132                          7594  * entry is with a5 pointing to the first character of the string
00083132                          7595  * exit with a5 pointing to the first character after the string
00083132                          7596  
00083132                          7597  * d0 is character
00083132                          7598  * d1 is mantissa
00083132                          7599  * d2 is partial and table mantissa
00083132                          7600  * d3 is mantissa exponent (decimal & binary)
00083132                          7601  * d4 is decimal exponent
00083132                          7602  
00083132                          7603  * get FAC1 from string
00083132                          7604  * this routine now handles hex and binary values from strings
00083132                          7605  * starting with "$" and "%" respectively
00083132                          7606  
00083132                          7607  LAB_2887
00083132  48E7 7C00               7608      MOVEM.l d1-d5,-(sp)         * save registers
00083136  7200                    7609      MOVEQ       #$00,d1         * clear temp accumulator
00083138  2601                    7610      MOVE.l  d1,d3               * set mantissa decimal exponent count
0008313A  2801                    7611      MOVE.l  d1,d4               * clear decimal exponent
0008313C  1741 0595               7612      MOVE.b  d1,FAC1_s(a3)       * clear sign byte
00083140  1741 05B5               7613      MOVE.b  d1,Dtypef(a3)       * set float data type
00083144  1741 05AF               7614      MOVE.b  d1,expneg(a3)       * clear exponent sign
00083148  6100 E4FA               7615      BSR     LAB_GBYT            * get first byte back
0008314C  653C                    7616      BCS.s       LAB_28FE            * go get floating if 1st character numeric
0008314E                          7617  
0008314E  B03C 002D               7618      CMP.b       #'-',d0         * or is it -ve number
00083152  6608                    7619      BNE.s       LAB_289A            * branch if not
00083154                          7620  
00083154  177C 00FF 0595          7621      MOVE.b  #$FF,FAC1_s(a3)     * set sign byte
0008315A  6006                    7622      BRA.s       LAB_289C            * now go scan & check for hex/bin/int
0008315C                          7623  
0008315C                          7624  LAB_289A
0008315C                          7625                              * first character wasn't numeric or -
0008315C  B03C 002B               7626      CMP.b       #'+',d0         * compare with '+'
00083160  6606                    7627      BNE.s       LAB_289D            * branch if not '+' (go check for '.'/hex/binary
00083162                          7628                              * /integer)
00083162                          7629      
00083162                          7630  LAB_289C
00083162                          7631                              * was "+" or "-" to start, so get next character
00083162  6100 E4DE               7632      BSR     LAB_IGBY            * increment & scan memory
00083166  6522                    7633      BCS.s       LAB_28FE            * branch if numeric character
00083168                          7634  
00083168                          7635  LAB_289D
00083168  B03C 002E               7636      CMP.b       #'.',d0         * else compare with '.'
0008316C  6700 0092               7637      BEQ     LAB_2904            * branch if '.'
00083170                          7638  
00083170                          7639                              * code here for hex/binary/integer numbers
00083170  B03C 0024               7640      CMP.b       #'$',d0         * compare with '$'
00083174  6700 010A               7641      BEQ     LAB_CHEX            * branch if '$'
00083178                          7642  
00083178  B03C 0025               7643      CMP.b       #'%',d0         * else compare with '%'
0008317C  6700 0164               7644      BEQ     LAB_CBIN            * branch if '%'
00083180                          7645  
00083180  6000 008C               7646      BRA     LAB_2Y01            * not #.$%& so return 0
00083184                          7647  
00083184                          7648  LAB_28FD
00083184  6100 E4BC               7649      BSR     LAB_IGBY            * get next character
00083188  646C                    7650      BCC.s       LAB_2902            * exit loop if not a digit
0008318A                          7651  
0008318A                          7652  LAB_28FE
0008318A  6100 01A8               7653      BSR     d1x10               * multiply d1 by 10 and add character
0008318E  64F4                    7654      BCC.s       LAB_28FD            * loop for more if no overflow
00083190                          7655  
00083190                          7656  LAB_28FF
00083190                          7657                              * overflowed mantissa, count 10s exponent
00083190  5283                    7658      ADDQ.l  #1,d3               * increment mantissa decimal exponent count
00083192  6100 E4AE               7659      BSR     LAB_IGBY            * get next character
00083196  65F8                    7660      BCS.s       LAB_28FF            * loop while numeric character
00083198                          7661  
00083198                          7662                              * done overflow, now flush fraction or do E
00083198  B03C 002E               7663      CMP.b       #'.',d0         * else compare with '.'
0008319C  6606                    7664      BNE.s       LAB_2901            * branch if not '.'
0008319E                          7665  
0008319E                          7666  LAB_2900
0008319E                          7667                              * flush remaining fraction digits
0008319E  6100 E4A2               7668      BSR     LAB_IGBY            * get next character
000831A2  65FA                    7669      BCS     LAB_2900            * loop while numeric character
000831A4                          7670  
000831A4                          7671  LAB_2901
000831A4                          7672                              * done number, only (possible) exponent remains
000831A4  B03C 0045               7673      CMP.b       #'E',d0         * else compare with 'E'
000831A8  6664                    7674      BNE.s       LAB_2Y01            * if not 'E' all done, go evaluate
000831AA                          7675  
000831AA                          7676                              * process exponent
000831AA  6100 E496               7677      BSR     LAB_IGBY            * get next character
000831AE  6528                    7678      BCS.s       LAB_2X04            * branch if digit
000831B0                          7679  
000831B0  B03C 002D               7680      CMP.b       #'-',d0         * or is it -ve number
000831B4  6706                    7681      BEQ.s       LAB_2X01            * branch if so
000831B6                          7682  
000831B6  B03C 00B3               7683      CMP.b       #TK_MINUS,d0        * or is it -ve number
000831BA  6608                    7684      BNE.s       LAB_2X02            * branch if not
000831BC                          7685  
000831BC                          7686  LAB_2X01
000831BC  177C 00FF 05AF          7687      MOVE.b  #$FF,expneg(a3)     * set exponent sign
000831C2  600E                    7688      BRA.s       LAB_2X03            * now go scan & check exponent
000831C4                          7689  
000831C4                          7690  LAB_2X02
000831C4  B03C 002B               7691      CMP.b       #'+',d0         * or is it +ve number
000831C8  6708                    7692      BEQ.s       LAB_2X03            * branch if so
000831CA                          7693  
000831CA  B03C 00B2               7694      CMP.b       #TK_PLUS,d0         * or is it +ve number
000831CE  6600 D834               7695      BNE     LAB_SNER            * wasn't - + TK_MINUS TK_PLUS or # so do error
000831D2                          7696  
000831D2                          7697  LAB_2X03
000831D2  6100 E46E               7698      BSR     LAB_IGBY            * get next character
000831D6  6436                    7699      BCC.s       LAB_2Y01            * if not digit all done, go evaluate
000831D8                          7700  LAB_2X04
000831D8  C8FC 000A               7701      MULU        #10,d4          * multiply decimal exponent by 10
000831DC  C0BC 000000FF           7702      AND.l       #$FF,d0         * mask character
000831E2  0400 0030               7703      SUB.b       #'0',d0         * convert to value
000831E6  D880                    7704      ADD.l       d0,d4               * add to decimal exponent
000831E8  B83C 0030               7705      CMP.b       #48,d4          * compare with decimal exponent limit+10
000831EC  6FE4                    7706      BLE.s       LAB_2X03            * loop if no overflow/underflow
000831EE                          7707  
000831EE                          7708  LAB_2X05
000831EE                          7709                              * exponent value has overflowed
000831EE  6100 E452               7710      BSR     LAB_IGBY            * get next character
000831F2  65FA                    7711      BCS.s       LAB_2X05            * loop while numeric digit
000831F4                          7712  
000831F4  6018                    7713      BRA.s       LAB_2Y01            * all done, go evaluate
000831F6                          7714  
000831F6                          7715  LAB_2902
000831F6  B03C 002E               7716      CMP.b       #'.',d0         * else compare with '.'
000831FA  6704                    7717      BEQ.s       LAB_2904            * branch if was '.'
000831FC                          7718  
000831FC  60A6                    7719      BRA.s       LAB_2901            * branch if not '.' (go check/do 'E')
000831FE                          7720  
000831FE                          7721  LAB_2903
000831FE  5383                    7722      SUBQ.l  #1,d3               * decrement mantissa decimal exponent
00083200                          7723  LAB_2904
00083200                          7724                              * was dp so get fraction part
00083200  6100 E440               7725      BSR     LAB_IGBY            * get next character
00083204  649E                    7726      BCC.s       LAB_2901            * exit loop if not a digit (go check/do 'E')
00083206                          7727  
00083206  6100 012C               7728      BSR     d1x10               * multiply d1 by 10 and add character
0008320A  64F2                    7729      BCC.s       LAB_2903            * loop for more if no overflow
0008320C                          7730  
0008320C  6090                    7731      BRA.s       LAB_2900            * else go flush remaining fraction part
0008320E                          7732  
0008320E                          7733  LAB_2Y01
0008320E                          7734                              * now evaluate result
0008320E  4A2B 05AF               7735      TST.b       expneg(a3)          * test exponent sign
00083212  6A02                    7736      BPL.s       LAB_2Y02            * branch if sign positive
00083214                          7737  
00083214  4484                    7738      NEG.l       d4              * negate decimal exponent
00083216                          7739  LAB_2Y02
00083216  D883                    7740      ADD.l       d3,d4               * add mantissa decimal exponent
00083218  7620                    7741      MOVEQ       #32,d3          * set up max binary exponent
0008321A  4A81                    7742      TST.l       d1              * test mantissa
0008321C  6752                    7743      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
0008321E                          7744  
0008321E  6B08                    7745      BMI.s       LAB_2Y04            * branch if already mormalised
00083220                          7746  
00083220  5383                    7747      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00083222                          7748  LAB_2Y03
00083222  D281                    7749      ADD.l       d1,d1               * shift mantissa
00083224  5BCB FFFC               7750      DBMI        d3,LAB_2Y03         * decrement & loop if not normalised
00083228                          7751  
00083228                          7752                              * ensure not too big or small
00083228                          7753  LAB_2Y04
00083228  B8BC 00000026           7754      CMP.l       #38,d4          * compare decimal exponent with max exponent
0008322E  6E00 D7C4               7755      BGT     LAB_OFER            * if greater do overflow error and warm start
00083232                          7756  
00083232  B8BC FFFFFFDA           7757      CMP.l       #-38,d4         * compare decimal exponent with min exponent
00083238  6D34                    7758      BLT.s       LAB_ret0            * if less just return zero
0008323A                          7759  
0008323A  4484                    7760      NEG.l       d4              * negate decimal exponent to go right way
0008323C  C9FC 0006               7761      MULS        #6,d4               * 6 bytes per entry
00083240  2F08                    7762      MOVE.l  a0,-(sp)            * save register
00083242  41FA 0210               7763      LEA     LAB_P_10(pc),a0     * point to table
00083246  1770 4000 059C          7764      MOVE.b  (a0,d4.w),FAC2_e(a3)    * copy exponent for multiply
0008324C  2770 4002 0598          7765      MOVE.l  2(a0,d4.w),FAC2_m(a3)   * copy table mantissa
00083252  205F                    7766      MOVE.l  (sp)+,a0            * restore register
00083254                          7767  
00083254  0A03 0080               7768      EORI.b  #$80,d3         * normalise input exponent
00083258  2741 0590               7769      MOVE.l  d1,FAC1_m(a3)       * save input mantissa
0008325C  1743 0594               7770      MOVE.b  d3,FAC1_e(a3)       * save input exponent
00083260  176B 0595 059E          7771      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * set sign as sign compare
00083266                          7772  
00083266  4CDF 003E               7773      MOVEM.l (sp)+,d1-d5         * restore registers
0008326A  6000 F05A               7774      BRA     LAB_MULTIPLY        * go multiply input by table
0008326E                          7775  
0008326E                          7776  LAB_ret0
0008326E  7200                    7777      MOVEQ       #0,d1               * clear mantissa
00083270                          7778  LAB_rtn0
00083270  2601                    7779      MOVE.l  d1,d3               * clear exponent
00083272  1743 0594               7780      MOVE.b  d3,FAC1_e(a3)       * save exponent
00083276  2741 0590               7781      MOVE.l  d1,FAC1_m(a3)       * save mantissa
0008327A  4CDF 003E               7782      MOVEM.l (sp)+,d1-d5         * restore registers
0008327E  4E75                    7783      RTS
00083280                          7784  
00083280                          7785  
00083280                          7786  *************************************************************************************
00083280                          7787  *
00083280                          7788  * $ for hex add-on
00083280                          7789  
00083280                          7790  * gets here if the first character was "$" for hex
00083280                          7791  * get hex number
00083280                          7792  
00083280                          7793  LAB_CHEX
00083280  177C 0040 05B5          7794      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00083286  7620                    7795      MOVEQ       #32,d3          * set up max binary exponent
00083288                          7796  LAB_CHXX
00083288  6100 E3B8               7797      BSR     LAB_IGBY            * increment & scan memory
0008328C  6514                    7798      BCS.s       LAB_ISHN            * branch if numeric character
0008328E                          7799  
0008328E  803C 0020               7800      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00083292  0400 0061               7801      SUB.b       #'a',d0         * subtract "a"
00083296  652A                    7802      BCS.s       LAB_CHX3            * exit if <"a"
00083298                          7803  
00083298  B03C 0006               7804      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
0008329C  6424                    7805      BCC.s       LAB_CHX3            * exit if >"f"
0008329E                          7806  
0008329E  0600 003A               7807      ADD.b       #$3A,d0         * convert to nibble+"0"
000832A2                          7808  LAB_ISHN
000832A2  616C                    7809      BSR.s       d1x16               * multiply d1 by 16 and add the character
000832A4  64E2                    7810      BCC.s       LAB_CHXX            * loop for more if no overflow
000832A6                          7811  
000832A6                          7812                              * overflowed mantissa, count 16s exponent
000832A6                          7813  LAB_CHX1
000832A6  5883                    7814      ADDQ.l  #4,d3               * increment mantissa exponent count
000832A8  6900 D74A               7815      BVS     LAB_OFER            * do overflow error if overflowed
000832AC                          7816  
000832AC  6100 E394               7817      BSR     LAB_IGBY            * get next character
000832B0  65F4                    7818      BCS.s       LAB_CHX1            * loop while numeric character
000832B2                          7819  
000832B2  803C 0020               7820      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
000832B6  0400 0061               7821      SUB.b       #'a',d0         * subtract "a"
000832BA  6506                    7822      BCS.s       LAB_CHX3            * exit if <"a"
000832BC                          7823  
000832BC  B03C 0006               7824      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
000832C0  65E4                    7825      BCS.s       LAB_CHX1            * loop if <="f"
000832C2                          7826  
000832C2                          7827                              * now return value
000832C2                          7828  LAB_CHX3
000832C2  4A81                    7829      TST.l       d1              * test mantissa
000832C4  67AA                    7830      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
000832C6                          7831  
000832C6  6B08                    7832      BMI.s       LAB_exxf            * branch if already mormalised
000832C8                          7833  
000832C8  5383                    7834      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
000832CA                          7835  LAB_CHX2
000832CA  D281                    7836      ADD.l       d1,d1               * shift mantissa
000832CC  5BCB FFFC               7837      DBMI        d3,LAB_CHX2         * decrement & loop if not normalised
000832D0                          7838  
000832D0                          7839  LAB_exxf
000832D0  0A03 0080               7840      EORI.b  #$80,d3         * normalise exponent
000832D4  1743 0594               7841      MOVE.b  d3,FAC1_e(a3)       * save exponent
000832D8  2741 0590               7842      MOVE.l  d1,FAC1_m(a3)       * save mantissa
000832DC  4CDF 003E               7843      MOVEM.l (sp)+,d1-d5         * restore registers
000832E0                          7844  RTS_024
000832E0  4E75                    7845      RTS
000832E2                          7846  
000832E2                          7847  
000832E2                          7848  *************************************************************************************
000832E2                          7849  *
000832E2                          7850  * % for binary add-on
000832E2                          7851  
000832E2                          7852  * gets here if the first character was "%" for binary
000832E2                          7853  * get binary number
000832E2                          7854  
000832E2                          7855  LAB_CBIN
000832E2  177C 0040 05B5          7856      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
000832E8  7620                    7857      MOVEQ       #32,d3          * set up max binary exponent
000832EA                          7858  LAB_CBXN
000832EA  6100 E356               7859      BSR     LAB_IGBY            * increment & scan memory
000832EE  64D2                    7860      BCC.s       LAB_CHX3            * if not numeric character go return value
000832F0                          7861  
000832F0  B03C 0032               7862      CMP.b       #'2',d0         * compare with "2" (max+1)
000832F4  64CC                    7863      BCC.s       LAB_CHX3            * if >="2" go return value
000832F6                          7864  
000832F6  2401                    7865      MOVE.l  d1,d2               * copy value
000832F8  6124                    7866      BSR.s       d1x02               * multiply d1 by 2 and add character
000832FA  64EE                    7867      BCC.s       LAB_CBXN            * loop for more if no overflow
000832FC                          7868  
000832FC                          7869                              * overflowed mantissa, count 2s exponent
000832FC                          7870  LAB_CBX1
000832FC  5283                    7871      ADDQ.l  #1,d3               * increment mantissa exponent count
000832FE  6900 D6F4               7872      BVS     LAB_OFER            * do overflow error if overflowed
00083302                          7873  
00083302  6100 E33E               7874      BSR     LAB_IGBY            * get next character
00083306  64BA                    7875      BCC.s       LAB_CHX3            * if not numeric character go return value
00083308                          7876  
00083308  B03C 0032               7877      CMP.b       #'2',d0         * compare with "2" (max+1)
0008330C  65EE                    7878      BCS.s       LAB_CBX1            * loop if <"2"
0008330E                          7879  
0008330E  60B2                    7880      BRA.s       LAB_CHX3            * if not numeric character go return value
00083310                          7881  
00083310                          7882  * half way decent times 16 and times 2 with overflow checks
00083310                          7883  
00083310                          7884  d1x16
00083310  2401                    7885      MOVE.l  d1,d2               * copy value
00083312  D482                    7886      ADD.l       d2,d2               * times two
00083314  65CA                    7887      BCS.s       RTS_024         * return if overflow
00083316                          7888  
00083316  D482                    7889      ADD.l       d2,d2               * times four
00083318  65C6                    7890      BCS.s       RTS_024         * return if overflow
0008331A                          7891  
0008331A  D482                    7892      ADD.l       d2,d2               * times eight
0008331C  65C2                    7893      BCS.s       RTS_024         * return if overflow
0008331E                          7894  
0008331E                          7895  d1x02
0008331E  D482                    7896      ADD.l       d2,d2               * times sixteen (ten/two)
00083320  65BE                    7897      BCS.s       RTS_024         * return if overflow
00083322                          7898  
00083322                          7899  * now add in new digit
00083322                          7900  
00083322  C0BC 000000FF           7901      AND.l       #$FF,d0         * mask character
00083328  0400 0030               7902      SUB.b       #'0',d0         * convert to value
0008332C  D480                    7903      ADD.l       d0,d2               * add to result
0008332E  65B0                    7904      BCS.s       RTS_024         * return if overflow, it should never ever do
00083330                          7905                              * this
00083330                          7906  
00083330  2202                    7907      MOVE.l  d2,d1               * copy result
00083332  4E75                    7908      RTS
00083334                          7909  
00083334                          7910  * half way decent times 10 with overflow checks
00083334                          7911  
00083334                          7912  d1x10
00083334  2401                    7913      MOVE.l  d1,d2               * copy value
00083336  D482                    7914      ADD.l       d2,d2               * times two
00083338  6508                    7915      BCS.s       RTS_025         * return if overflow
0008333A                          7916  
0008333A  D482                    7917      ADD.l       d2,d2               * times four
0008333C  6504                    7918      BCS.s       RTS_025         * return if overflow
0008333E                          7919  
0008333E  D481                    7920      ADD.l       d1,d2               * times five
00083340  64DC                    7921      BCC.s       d1x02               * do times two and add in new digit if ok
00083342                          7922  
00083342                          7923  RTS_025
00083342  4E75                    7924      RTS
00083344                          7925  
00083344                          7926  
00083344                          7927  *************************************************************************************
00083344                          7928  *
00083344                          7929  * token values needed for BASIC
00083344                          7930  
00083344  =00000080               7931  TK_END      EQU $80         * $80
00083344  =00000081               7932  TK_FOR      EQU TK_END+1        * $81
00083344  =00000082               7933  TK_NEXT     EQU TK_FOR+1        * $82
00083344  =00000083               7934  TK_DATA     EQU TK_NEXT+1       * $83
00083344  =00000084               7935  TK_INPUT        EQU TK_DATA+1       * $84
00083344  =00000085               7936  TK_DIM      EQU TK_INPUT+1      * $85
00083344  =00000086               7937  TK_READ     EQU TK_DIM+1        * $86
00083344  =00000087               7938  TK_LET      EQU TK_READ+1       * $87
00083344  =00000088               7939  TK_DEC      EQU TK_LET+1        * $88
00083344  =00000089               7940  TK_GOTO     EQU TK_DEC+1        * $89
00083344  =0000008A               7941  TK_RUN      EQU TK_GOTO+1       * $8A
00083344  =0000008B               7942  TK_IF           EQU TK_RUN+1        * $8B
00083344  =0000008C               7943  TK_RESTORE      EQU TK_IF+1         * $8C
00083344  =0000008D               7944  TK_GOSUB        EQU TK_RESTORE+1        * $8D
00083344  =0000008E               7945  TK_RETURN       EQU TK_GOSUB+1      * $8E
00083344  =0000008F               7946  TK_REM      EQU TK_RETURN+1     * $8F
00083344  =00000090               7947  TK_STOP     EQU TK_REM+1        * $90
00083344  =00000091               7948  TK_ON           EQU TK_STOP+1       * $91
00083344  =00000092               7949  TK_NULL     EQU TK_ON+1         * $92
00083344  =00000093               7950  TK_INC      EQU TK_NULL+1       * $93
00083344  =00000094               7951  TK_WAIT     EQU TK_INC+1        * $94
00083344  =00000095               7952  TK_LOAD     EQU TK_WAIT+1       * $95
00083344  =00000096               7953  TK_SAVE     EQU TK_LOAD+1       * $96
00083344  =00000097               7954  TK_DEF      EQU TK_SAVE+1       * $97
00083344  =00000098               7955  TK_POKE     EQU TK_DEF+1        * $98
00083344  =00000099               7956  TK_DOKE     EQU TK_POKE+1       * $99
00083344  =0000009A               7957  TK_LOKE     EQU TK_DOKE+1       * $9A
00083344  =0000009B               7958  TK_CALL     EQU TK_LOKE+1       * $9B
00083344  =0000009C               7959  TK_DO           EQU TK_CALL+1       * $9C
00083344  =0000009D               7960  TK_LOOP     EQU TK_DO+1         * $9D
00083344  =0000009E               7961  TK_PRINT        EQU TK_LOOP+1       * $9E
00083344  =0000009F               7962  TK_CONT     EQU TK_PRINT+1      * $9F
00083344  =000000A0               7963  TK_LIST     EQU TK_CONT+1       * $A0
00083344  =000000A1               7964  TK_CLEAR        EQU TK_LIST+1       * $A1
00083344  =000000A2               7965  TK_NEW      EQU TK_CLEAR+1      * $A2
00083344  =000000A3               7966  TK_WIDTH        EQU TK_NEW+1        * $A3
00083344  =000000A4               7967  TK_GET      EQU TK_WIDTH+1      * $A4
00083344  =000000A5               7968  TK_SWAP     EQU TK_GET+1        * $A5
00083344  =000000A6               7969  TK_BITSET       EQU TK_SWAP+1       * $A6
00083344  =000000A7               7970  TK_BITCLR       EQU TK_BITSET+1     * $A7
00083344  =000000A8               7971  TK_TAB      EQU TK_BITCLR+1     * $A8
00083344  =000000A9               7972  TK_ELSE     EQU TK_TAB+1        * $A9
00083344  =000000AA               7973  TK_TO           EQU TK_ELSE+1       * $AA
00083344  =000000AB               7974  TK_FN           EQU TK_TO+1         * $AB
00083344  =000000AC               7975  TK_SPC      EQU TK_FN+1         * $AC
00083344  =000000AD               7976  TK_THEN     EQU TK_SPC+1        * $AD
00083344  =000000AE               7977  TK_NOT      EQU TK_THEN+1       * $AE
00083344  =000000AF               7978  TK_STEP     EQU TK_NOT+1        * $AF
00083344  =000000B0               7979  TK_UNTIL        EQU TK_STEP+1       * $B0
00083344  =000000B1               7980  TK_WHILE        EQU TK_UNTIL+1      * $B1
00083344  =000000B2               7981  TK_PLUS     EQU TK_WHILE+1      * $B2
00083344  =000000B3               7982  TK_MINUS        EQU TK_PLUS+1       * $B3
00083344  =000000B4               7983  TK_MULT     EQU TK_MINUS+1      * $B4
00083344  =000000B5               7984  TK_DIV      EQU TK_MULT+1       * $B5
00083344  =000000B6               7985  TK_POWER        EQU TK_DIV+1        * $B6
00083344  =000000B7               7986  TK_AND      EQU TK_POWER+1      * $B7
00083344  =000000B8               7987  TK_EOR      EQU TK_AND+1        * $B8
00083344  =000000B9               7988  TK_OR           EQU TK_EOR+1        * $B9
00083344  =000000BA               7989  TK_RSHIFT       EQU TK_OR+1         * $BA
00083344  =000000BB               7990  TK_LSHIFT       EQU TK_RSHIFT+1     * $BB
00083344  =000000BC               7991  TK_GT           EQU TK_LSHIFT+1     * $BC
00083344  =000000BD               7992  TK_EQUAL        EQU TK_GT+1         * $BD
00083344  =000000BE               7993  TK_LT           EQU TK_EQUAL+1      * $BE
00083344  =000000BF               7994  TK_SGN      EQU TK_LT+1         * $BF
00083344  =000000C0               7995  TK_INT      EQU TK_SGN+1        * $C0
00083344  =000000C1               7996  TK_ABS      EQU TK_INT+1        * $C1
00083344  =000000C2               7997  TK_USR      EQU TK_ABS+1        * $C2
00083344  =000000C3               7998  TK_FRE      EQU TK_USR+1        * $C3
00083344  =000000C4               7999  TK_POS      EQU TK_FRE+1        * $C4
00083344  =000000C5               8000  TK_SQR      EQU TK_POS+1        * $C5
00083344  =000000C6               8001  TK_RND      EQU TK_SQR+1        * $C6
00083344  =000000C7               8002  TK_LOG      EQU TK_RND+1        * $C7
00083344  =000000C8               8003  TK_EXP      EQU TK_LOG+1        * $C8
00083344  =000000C9               8004  TK_COS      EQU TK_EXP+1        * $C9
00083344  =000000CA               8005  TK_SIN      EQU TK_COS+1        * $CA
00083344  =000000CB               8006  TK_TAN      EQU TK_SIN+1        * $CB
00083344  =000000CC               8007  TK_ATN      EQU TK_TAN+1        * $CC
00083344  =000000CD               8008  TK_PEEK     EQU TK_ATN+1        * $CD
00083344  =000000CE               8009  TK_DEEK     EQU TK_PEEK+1       * $CE
00083344  =000000CF               8010  TK_LEEK     EQU TK_DEEK+1       * $CF
00083344  =000000D0               8011  TK_LEN      EQU TK_LEEK+1       * $D0
00083344  =000000D1               8012  TK_STRS     EQU TK_LEN+1        * $D1
00083344  =000000D2               8013  TK_VAL      EQU TK_STRS+1       * $D2
00083344  =000000D3               8014  TK_ASC      EQU TK_VAL+1        * $D3
00083344  =000000D4               8015  TK_UCASES       EQU TK_ASC+1        * $D4
00083344  =000000D5               8016  TK_LCASES       EQU TK_UCASES+1     * $D5
00083344  =000000D6               8017  TK_CHRS     EQU TK_LCASES+1     * $D6
00083344  =000000D7               8018  TK_HEXS     EQU TK_CHRS+1       * $D7
00083344  =000000D8               8019  TK_BINS     EQU TK_HEXS+1       * $D8
00083344  =000000D9               8020  TK_BITTST       EQU TK_BINS+1       * $D9
00083344  =000000DA               8021  TK_MAX      EQU TK_BITTST+1     * $DA
00083344  =000000DB               8022  TK_MIN      EQU TK_MAX+1        * $DB
00083344  =000000DC               8023  TK_RAM      EQU TK_MIN+1        * $DC
00083344  =000000DD               8024  TK_PI           EQU TK_RAM+1        * $DD
00083344  =000000DE               8025  TK_TWOPI        EQU TK_PI+1         * $DE
00083344  =000000DF               8026  TK_VPTR     EQU TK_TWOPI+1      * $DF
00083344  =000000E0               8027  TK_SADD     EQU TK_VPTR+1       * $E0
00083344  =000000E1               8028  TK_LEFTS        EQU TK_SADD+1       * $E1
00083344  =000000E2               8029  TK_RIGHTS       EQU TK_LEFTS+1      * $E2
00083344  =000000E3               8030  TK_MIDS     EQU TK_RIGHTS+1     * $E3
00083344  =000000E4               8031  TK_USINGS       EQU TK_MIDS+1       * $E4
00083344                          8032  
00083344                          8033  
00083344                          8034  *************************************************************************************
00083344                          8035  *
00083344                          8036  * binary to unsigned decimal table
00083344                          8037  
00083344                          8038  Bin2dec
00083344= 3B9ACA00                8039      dc.l    $3B9ACA00               * 1000000000
00083348= 05F5E100                8040      dc.l    $05F5E100               * 100000000
0008334C= 00989680                8041      dc.l    $00989680               * 10000000
00083350= 000F4240                8042      dc.l    $000F4240               * 1000000
00083354= 000186A0                8043      dc.l    $000186A0               * 100000
00083358= 00002710                8044      dc.l    $00002710               * 10000
0008335C= 000003E8                8045      dc.l    $000003E8               * 1000
00083360= 00000064                8046      dc.l    $00000064               * 100
00083364= 0000000A                8047      dc.l    $0000000A               * 10
00083368= 00000000                8048      dc.l    $00000000               * 0 end marker
0008336C                          8049  
0008336C                          8050  LAB_RSED
0008336C= 332E3232                8051      dc.l    $332E3232               * 858665522
00083370                          8052  
00083370                          8053  * string to value exponent table
00083370                          8054  
00083370= FF00                    8055      dc.w    255<<8              * 10**38
00083372= 96769951                8056      dc.l    $96769951
00083376= FB00                    8057      dc.w    251<<8              * 10**37
00083378= F0BDC21B                8058      dc.l    $F0BDC21B
0008337C= F800                    8059      dc.w    248<<8              * 10**36
0008337E= C097CE7C                8060      dc.l    $C097CE7C
00083382= F500                    8061      dc.w    245<<8              * 10**35
00083384= 9A130B96                8062      dc.l    $9A130B96
00083388= F100                    8063      dc.w    241<<8              * 10**34
0008338A= F684DF57                8064      dc.l    $F684DF57
0008338E= EE00                    8065      dc.w    238<<8              * 10**33
00083390= C5371912                8066      dc.l    $C5371912
00083394= EB00                    8067      dc.w    235<<8              * 10**32
00083396= 9DC5ADA8                8068      dc.l    $9DC5ADA8
0008339A= E700                    8069      dc.w    231<<8              * 10**31
0008339C= FC6F7C40                8070      dc.l    $FC6F7C40
000833A0= E400                    8071      dc.w    228<<8              * 10**30
000833A2= C9F2C9CD                8072      dc.l    $C9F2C9CD
000833A6= E100                    8073      dc.w    225<<8              * 10**29
000833A8= A18F07D7                8074      dc.l    $A18F07D7
000833AC= DE00                    8075      dc.w    222<<8              * 10**28
000833AE= 813F3979                8076      dc.l    $813F3979
000833B2= DA00                    8077      dc.w    218<<8              * 10**27
000833B4= CECB8F28                8078      dc.l    $CECB8F28
000833B8= D700                    8079      dc.w    215<<8              * 10**26
000833BA= A56FA5BA                8080      dc.l    $A56FA5BA
000833BE= D400                    8081      dc.w    212<<8              * 10**25
000833C0= 84595161                8082      dc.l    $84595161
000833C4= D000                    8083      dc.w    208<<8              * 10**24
000833C6= D3C21BCF                8084      dc.l    $D3C21BCF
000833CA= CD00                    8085      dc.w    205<<8              * 10**23
000833CC= A968163F                8086      dc.l    $A968163F
000833D0= CA00                    8087      dc.w    202<<8              * 10**22
000833D2= 87867832                8088      dc.l    $87867832
000833D6= C600                    8089      dc.w    198<<8              * 10**21
000833D8= D8D726B7                8090      dc.l    $D8D726B7
000833DC= C300                    8091      dc.w    195<<8              * 10**20
000833DE= AD78EBC6                8092      dc.l    $AD78EBC6
000833E2= C000                    8093      dc.w    192<<8              * 10**19
000833E4= 8AC72305                8094      dc.l    $8AC72305
000833E8= BC00                    8095      dc.w    188<<8              * 10**18
000833EA= DE0B6B3A                8096      dc.l    $DE0B6B3A
000833EE= B900                    8097      dc.w    185<<8              * 10**17
000833F0= B1A2BC2F                8098      dc.l    $B1A2BC2F
000833F4= B600                    8099      dc.w    182<<8              * 10**16
000833F6= 8E1BC9BF                8100      dc.l    $8E1BC9BF
000833FA= B200                    8101      dc.w    178<<8              * 10**15
000833FC= E35FA932                8102      dc.l    $E35FA932
00083400= AF00                    8103      dc.w    175<<8              * 10**14
00083402= B5E620F5                8104      dc.l    $B5E620F5
00083406= AC00                    8105      dc.w    172<<8              * 10**13
00083408= 9184E72A                8106      dc.l    $9184E72A
0008340C= A800                    8107      dc.w    168<<8              * 10**12
0008340E= E8D4A510                8108      dc.l    $E8D4A510
00083412= A500                    8109      dc.w    165<<8              * 10**11
00083414= BA43B740                8110      dc.l    $BA43B740
00083418= A200                    8111      dc.w    162<<8              * 10**10
0008341A= 9502F900                8112      dc.l    $9502F900
0008341E= 9E00                    8113      dc.w    158<<8              * 10**9
00083420= EE6B2800                8114      dc.l    $EE6B2800
00083424= 9B00                    8115      dc.w    155<<8              * 10**8
00083426= BEBC2000                8116      dc.l    $BEBC2000
0008342A= 9800                    8117      dc.w    152<<8              * 10**7
0008342C= 98968000                8118      dc.l    $98968000
00083430= 9400                    8119      dc.w    148<<8              * 10**6
00083432= F4240000                8120      dc.l    $F4240000
00083436= 9100                    8121      dc.w    145<<8              * 10**5
00083438= C3500000                8122      dc.l    $C3500000
0008343C= 8E00                    8123      dc.w    142<<8              * 10**4
0008343E= 9C400000                8124      dc.l    $9C400000
00083442= 8A00                    8125      dc.w    138<<8              * 10**3
00083444= FA000000                8126      dc.l    $FA000000
00083448= 8700                    8127      dc.w    135<<8              * 10**2
0008344A= C8000000                8128      dc.l    $C8000000
0008344E= 8400                    8129      dc.w    132<<8              * 10**1
00083450= A0000000                8130      dc.l    $A0000000
00083454                          8131  LAB_P_10
00083454= 8100                    8132      dc.w    129<<8              * 10**0
00083456= 80000000                8133      dc.l    $80000000
0008345A= 7D00                    8134      dc.w    125<<8              * 10**-1
0008345C= CCCCCCCD                8135      dc.l    $CCCCCCCD
00083460= 7A00                    8136      dc.w    122<<8              * 10**-2
00083462= A3D70A3D                8137      dc.l    $A3D70A3D
00083466= 7700                    8138      dc.w    119<<8              * 10**-3
00083468= 83126E98                8139      dc.l    $83126E98
0008346C= 7300                    8140      dc.w    115<<8              * 10**-4
0008346E= D1B71759                8141      dc.l    $D1B71759
00083472= 7000                    8142      dc.w    112<<8              * 10**-5
00083474= A7C5AC47                8143      dc.l    $A7C5AC47
00083478= 6D00                    8144      dc.w    109<<8              * 10**-6
0008347A= 8637BD06                8145      dc.l    $8637BD06
0008347E= 6900                    8146      dc.w    105<<8              * 10**-7
00083480= D6BF94D6                8147      dc.l    $D6BF94D6
00083484= 6600                    8148      dc.w    102<<8              * 10**-8
00083486= ABCC7712                8149      dc.l    $ABCC7712
0008348A= 6300                    8150      dc.w    99<<8                   * 10**-9
0008348C= 89705F41                8151      dc.l    $89705F41
00083490= 5F00                    8152      dc.w    95<<8                   * 10**-10
00083492= DBE6FECF                8153      dc.l    $DBE6FECF
00083496= 5C00                    8154      dc.w    92<<8                   * 10**-11
00083498= AFEBFF0C                8155      dc.l    $AFEBFF0C
0008349C= 5900                    8156      dc.w    89<<8                   * 10**-12
0008349E= 8CBCCC09                8157      dc.l    $8CBCCC09
000834A2= 5500                    8158      dc.w    85<<8                   * 10**-13
000834A4= E12E1342                8159      dc.l    $E12E1342
000834A8= 5200                    8160      dc.w    82<<8                   * 10**-14
000834AA= B424DC35                8161      dc.l    $B424DC35
000834AE= 4F00                    8162      dc.w    79<<8                   * 10**-15
000834B0= 901D7CF7                8163      dc.l    $901D7CF7
000834B4= 4B00                    8164      dc.w    75<<8                   * 10**-16
000834B6= E69594BF                8165      dc.l    $E69594BF
000834BA= 4800                    8166      dc.w    72<<8                   * 10**-17
000834BC= B877AA32                8167      dc.l    $B877AA32
000834C0= 4500                    8168      dc.w    69<<8                   * 10**-18
000834C2= 9392EE8F                8169      dc.l    $9392EE8F
000834C6= 4100                    8170      dc.w    65<<8                   * 10**-19
000834C8= EC1E4A7E                8171      dc.l    $EC1E4A7E
000834CC= 3E00                    8172      dc.w    62<<8                   * 10**-20
000834CE= BCE50865                8173      dc.l    $BCE50865
000834D2= 3B00                    8174      dc.w    59<<8                   * 10**-21
000834D4= 971DA050                8175      dc.l    $971DA050
000834D8= 3700                    8176      dc.w    55<<8                   * 10**-22
000834DA= F1C90081                8177      dc.l    $F1C90081
000834DE= 3400                    8178      dc.w    52<<8                   * 10**-23
000834E0= C16D9A01                8179      dc.l    $C16D9A01
000834E4= 3100                    8180      dc.w    49<<8                   * 10**-24
000834E6= 9ABE14CD                8181      dc.l    $9ABE14CD
000834EA= 2D00                    8182      dc.w    45<<8                   * 10**-25
000834EC= F79687AE                8183      dc.l    $F79687AE
000834F0= 2A00                    8184      dc.w    42<<8                   * 10**-26
000834F2= C6120625                8185      dc.l    $C6120625
000834F6= 2700                    8186      dc.w    39<<8                   * 10**-27
000834F8= 9E74D1B8                8187      dc.l    $9E74D1B8
000834FC= 2300                    8188      dc.w    35<<8                   * 10**-28
000834FE= FD87B5F3                8189      dc.l    $FD87B5F3
00083502= 2000                    8190      dc.w    32<<8                   * 10**-29
00083504= CAD2F7F5                8191      dc.l    $CAD2F7F5
00083508= 1D00                    8192      dc.w    29<<8                   * 10**-30
0008350A= A2425FF7                8193      dc.l    $A2425FF7
0008350E= 1A00                    8194      dc.w    26<<8                   * 10**-31
00083510= 81CEB32C                8195      dc.l    $81CEB32C
00083514= 1600                    8196      dc.w    22<<8                   * 10**-32
00083516= CFB11EAD                8197      dc.l    $CFB11EAD
0008351A= 1300                    8198      dc.w    19<<8                   * 10**-33
0008351C= A6274BBE                8199      dc.l    $A6274BBE
00083520= 1000                    8200      dc.w    16<<8                   * 10**-34
00083522= 84EC3C98                8201      dc.l    $84EC3C98
00083526= 0C00                    8202      dc.w    12<<8                   * 10**-35
00083528= D4AD2DC0                8203      dc.l    $D4AD2DC0
0008352C= 0900                    8204      dc.w    9<<8                    * 10**-36
0008352E= AA242499                8205      dc.l    $AA242499
00083532= 0600                    8206      dc.w    6<<8                    * 10**-37
00083534= 881CEA14                8207      dc.l    $881CEA14
00083538= 0200                    8208      dc.w    2<<8                    * 10**-38
0008353A= D9C7DCED                8209      dc.l    $D9C7DCED
0008353E                          8210  
0008353E                          8211  
0008353E                          8212  *************************************************************************************
0008353E                          8213  *
0008353E                          8214  * table of constants for cordic SIN/COS/TAN calculations
0008353E                          8215  * constants are un normalised fractions and are atn(2^-i)/2pi
0008353E                          8216  
0008353E= 4DBA76D4                8217      dc.l    $4DBA76D4               * SIN/COS multiply constant
00083542                          8218  TAB_SNCO
00083542= 20000000                8219      dc.l    $20000000               * atn(2^0)/2pi
00083546= 12E4051E                8220      dc.l    $12E4051E               * atn(2^1)/2pi
0008354A= 09FB385C                8221      dc.l    $09FB385C               * atn(2^2)/2pi
0008354E= 051111D5                8222      dc.l    $051111D5               * atn(2^3)/2pi
00083552= 028B0D44                8223      dc.l    $028B0D44               * atn(2^4)/2pi
00083556= 0145D7E2                8224      dc.l    $0145D7E2               * atn(2^5)/2pi
0008355A= 00A2F61F                8225      dc.l    $00A2F61F               * atn(2^6)/2pi
0008355E= 00517C56                8226      dc.l    $00517C56               * atn(2^7)/2pi
00083562= 0028BE54                8227      dc.l    $0028BE54               * atn(2^8)/2pi
00083566= 00145F2F                8228      dc.l    $00145F2F               * atn(2^9)/2pi
0008356A= 000A2F99                8229      dc.l    $000A2F99               * atn(2^10)/2pi
0008356E= 000517CD                8230      dc.l    $000517CD               * atn(2^11)/2pi
00083572= 00028BE7                8231      dc.l    $00028BE7               * atn(2^12)/2pi
00083576= 000145F4                8232      dc.l    $000145F4               * atn(2^13)/2pi
0008357A= 0000A2FA                8233      dc.l    $0000A2FA               * atn(2^14)/2pi
0008357E= 0000517D                8234      dc.l    $0000517D               * atn(2^15)/2pi
00083582= 000028BF                8235      dc.l    $000028BF               * atn(2^16)/2pi
00083586= 00001460                8236      dc.l    $00001460               * atn(2^17)/2pi
0008358A= 00000A30                8237      dc.l    $00000A30               * atn(2^18)/2pi
0008358E= 00000518                8238      dc.l    $00000518               * atn(2^19)/2pi
00083592= 0000028C                8239      dc.l    $0000028C               * atn(2^20)/2pi
00083596= 00000146                8240      dc.l    $00000146               * atn(2^21)/2pi
0008359A= 000000A3                8241      dc.l    $000000A3               * atn(2^22)/2pi
0008359E= 00000052                8242      dc.l    $00000052               * atn(2^23)/2pi
000835A2= 00000029                8243      dc.l    $00000029               * atn(2^24)/2pi
000835A6= 00000015                8244      dc.l    $00000015               * atn(2^25)/2pi
000835AA= 0000000B                8245      dc.l    $0000000B               * atn(2^26)/2pi
000835AE= 00000006                8246      dc.l    $00000006               * atn(2^27)/2pi
000835B2= 00000003                8247      dc.l    $00000003               * atn(2^28)/2pi
000835B6= 00000002                8248      dc.l    $00000002               * atn(2^29)/2pi
000835BA= 00000001                8249      dc.l    $00000001               * atn(2^30)/2pi
000835BE= 00000001                8250      dc.l    $00000001               * atn(2^31)/2pi
000835C2                          8251  
000835C2                          8252  
000835C2                          8253  *************************************************************************************
000835C2                          8254  *
000835C2                          8255  * table of constants for cordic ATN calculation
000835C2                          8256  * constants are normalised to two integer bits and are atn(2^-i)
000835C2                          8257  
000835C2                          8258  TAB_ATNC
000835C2= 1DAC6705                8259      dc.l    $1DAC6705               * atn(2^-1)
000835C6= 0FADBAFD                8260      dc.l    $0FADBAFD               * atn(2^-2)
000835CA= 07F56EA7                8261      dc.l    $07F56EA7               * atn(2^-3)
000835CE= 03FEAB77                8262      dc.l    $03FEAB77               * atn(2^-4)
000835D2= 01FFD55C                8263      dc.l    $01FFD55C               * atn(2^-5)
000835D6= 00FFFAAB                8264      dc.l    $00FFFAAB               * atn(2^-6)
000835DA= 007FFF55                8265      dc.l    $007FFF55               * atn(2^-7)
000835DE= 003FFFEB                8266      dc.l    $003FFFEB               * atn(2^-8)
000835E2= 001FFFFD                8267      dc.l    $001FFFFD               * atn(2^-9)
000835E6= 00100000                8268      dc.l    $00100000               * atn(2^-10)
000835EA= 00080000                8269      dc.l    $00080000               * atn(2^-11)
000835EE= 00040000                8270      dc.l    $00040000               * atn(2^-12)
000835F2= 00020000                8271      dc.l    $00020000               * atn(2^-13)
000835F6= 00010000                8272      dc.l    $00010000               * atn(2^-14)
000835FA= 00008000                8273      dc.l    $00008000               * atn(2^-15)
000835FE= 00004000                8274      dc.l    $00004000               * atn(2^-16)
00083602= 00002000                8275      dc.l    $00002000               * atn(2^-17)
00083606= 00001000                8276      dc.l    $00001000               * atn(2^-18)
0008360A= 00000800                8277      dc.l    $00000800               * atn(2^-19)
0008360E= 00000400                8278      dc.l    $00000400               * atn(2^-20)
00083612= 00000200                8279      dc.l    $00000200               * atn(2^-21)
00083616= 00000100                8280      dc.l    $00000100               * atn(2^-22)
0008361A= 00000080                8281      dc.l    $00000080               * atn(2^-23)
0008361E= 00000040                8282      dc.l    $00000040               * atn(2^-24)
00083622= 00000020                8283      dc.l    $00000020               * atn(2^-25)
00083626= 00000010                8284      dc.l    $00000010               * atn(2^-26)
0008362A= 00000008                8285      dc.l    $00000008               * atn(2^-27)
0008362E= 00000004                8286      dc.l    $00000004               * atn(2^-28)
00083632= 00000002                8287      dc.l    $00000002               * atn(2^-29)
00083636= 00000001                8288      dc.l    $00000001               * atn(2^-30)
0008363A                          8289  LAB_1D96
0008363A= 00000000                8290      dc.l    $00000000               * atn(2^-31)
0008363E= 00000000                8291      dc.l    $00000000               * atn(2^-32)
00083642                          8292  
00083642                          8293  * constants are normalised to n integer bits and are tanh(2^-i)
00083642  =00000002               8294  n   equ 2
00083642                          8295  TAB_HTHET
00083642= 2327D4F4                8296      dc.l    $8C9F53D0>>n            * atnh(2^-1)    .549306144
00083646= 1058AEFA                8297      dc.l    $4162BBE8>>n            * atnh(2^-2)    .255412812
0008364A= 080AC48E                8298      dc.l    $202B1238>>n            * atnh(2^-3)
0008364E= 04015622                8299      dc.l    $10055888>>n            * atnh(2^-4)
00083652= 02002AB0                8300      dc.l    $0800AAC0>>n            * atnh(2^-5)
00083656= 01000554                8301      dc.l    $04001550>>n            * atnh(2^-6)
0008365A= 008000AA                8302      dc.l    $020002A8>>n            * atnh(2^-7)
0008365E= 00400014                8303      dc.l    $01000050>>n            * atnh(2^-8)
00083662= 00200002                8304      dc.l    $00800008>>n            * atnh(2^-9)
00083666= 00100000                8305      dc.l    $00400000>>n            * atnh(2^-10)
0008366A= 00080000                8306      dc.l    $00200000>>n            * atnh(2^-11)
0008366E= 00040000                8307      dc.l    $00100000>>n            * atnh(2^-12)
00083672= 00020000                8308      dc.l    $00080000>>n            * atnh(2^-13)
00083676= 00010000                8309      dc.l    $00040000>>n            * atnh(2^-14)
0008367A= 00008000                8310      dc.l    $00020000>>n            * atnh(2^-15)
0008367E= 00004000                8311      dc.l    $00010000>>n            * atnh(2^-16)
00083682= 00002000                8312      dc.l    $00008000>>n            * atnh(2^-17)
00083686= 00001000                8313      dc.l    $00004000>>n            * atnh(2^-18)
0008368A= 00000800                8314      dc.l    $00002000>>n            * atnh(2^-19)
0008368E= 00000400                8315      dc.l    $00001000>>n            * atnh(2^-20)
00083692= 00000200                8316      dc.l    $00000800>>n            * atnh(2^-21)
00083696= 00000100                8317      dc.l    $00000400>>n            * atnh(2^-22)
0008369A= 00000080                8318      dc.l    $00000200>>n            * atnh(2^-23)
0008369E= 00000040                8319      dc.l    $00000100>>n            * atnh(2^-24)
000836A2= 00000020                8320      dc.l    $00000080>>n            * atnh(2^-25)
000836A6= 00000010                8321      dc.l    $00000040>>n            * atnh(2^-26)
000836AA= 00000008                8322      dc.l    $00000020>>n            * atnh(2^-27)
000836AE= 00000004                8323      dc.l    $00000010>>n            * atnh(2^-28)
000836B2= 00000002                8324      dc.l    $00000008>>n            * atnh(2^-29)
000836B6= 00000001                8325      dc.l    $00000004>>n            * atnh(2^-30)
000836BA= 00000000                8326      dc.l    $00000002>>n            * atnh(2^-31)
000836BE= 00000000                8327      dc.l    $00000001>>n            * atnh(2^-32)
000836C2                          8328  
000836C2  =26A3D110               8329  KFCTSEED    equ $9A8F4441>>n        * $26A3D110
000836C2                          8330  
000836C2                          8331  
000836C2                          8332  *************************************************************************************
000836C2                          8333  *
000836C2                          8334  * command vector table
000836C2                          8335  
000836C2                          8336  LAB_CTBL
000836C2= D7B2                    8337      dc.w    LAB_END-LAB_CTBL            * END
000836C4= D6E6                    8338      dc.w    LAB_FOR-LAB_CTBL            * FOR
000836C6= DD52                    8339      dc.w    LAB_NEXT-LAB_CTBL           * NEXT
000836C8= D906                    8340      dc.w    LAB_DATA-LAB_CTBL           * DATA
000836CA= DC46                    8341      dc.w    LAB_INPUT-LAB_CTBL      * INPUT
000836CC= E122                    8342      dc.w    LAB_DIM-LAB_CTBL            * DIM
000836CE= DC6C                    8343      dc.w    LAB_READ-LAB_CTBL           * READ
000836D0= DA78                    8344      dc.w    LAB_LET-LAB_CTBL            * LET
000836D2= DA16                    8345      dc.w    LAB_DEC-LAB_CTBL            * DEC   
000836D4= D86E                    8346      dc.w    LAB_GOTO-LAB_CTBL           * GOTO
000836D6= D836                    8347      dc.w    LAB_RUN-LAB_CTBL            * RUN
000836D8= D92E                    8348      dc.w    LAB_IF-LAB_CTBL         * IF
000836DA= D7E0                    8349      dc.w    LAB_RESTORE-LAB_CTBL        * RESTORE
000836DC= D85C                    8350      dc.w    LAB_GOSUB-LAB_CTBL      * GOSUB
000836DE= D8F2                    8351      dc.w    LAB_RETURN-LAB_CTBL     * RETURN
000836E0= D99C                    8352      dc.w    LAB_REM-LAB_CTBL            * REM
000836E2= D7BA                    8353      dc.w    LAB_STOP-LAB_CTBL           * STOP
000836E4= D9A4                    8354      dc.w    LAB_ON-LAB_CTBL         * ON
000836E6= D80E                    8355      dc.w    LAB_NULL-LAB_CTBL           * NULL
000836E8= DA1C                    8356      dc.w    LAB_INC-LAB_CTBL            * INC   
000836EA= EA28                    8357      dc.w    LAB_WAIT-LAB_CTBL           * WAIT
000836EC= EA16                    8358      dc.w    LAB_LOAD-LAB_CTBL           * LOAD
000836EE= EA1A                    8359      dc.w    LAB_SAVE-LAB_CTBL           * SAVE
000836F0= E4B2                    8360      dc.w    LAB_DEF-LAB_CTBL            * DEF
000836F2= E996                    8361      dc.w    LAB_POKE-LAB_CTBL           * POKE
000836F4= E9C6                    8362      dc.w    LAB_DOKE-LAB_CTBL           * DOKE
000836F6= E9CC                    8363      dc.w    LAB_LOKE-LAB_CTBL           * LOKE
000836F8= EA1E                    8364      dc.w    LAB_CALL-LAB_CTBL           * CALL
000836FA= D84A                    8365      dc.w    LAB_DO-LAB_CTBL         * DO    
000836FC= D89C                    8366      dc.w    LAB_LOOP-LAB_CTBL           * LOOP
000836FE= DB0C                    8367      dc.w    LAB_PRINT-LAB_CTBL      * PRINT
00083700= D818                    8368      dc.w    LAB_CONT-LAB_CTBL           * CONT
00083702= D630                    8369      dc.w    LAB_LIST-LAB_CTBL           * LIST
00083704= D62C                    8370      dc.w    LAB_CLEAR-LAB_CTBL      * CLEAR
00083706= D5DC                    8371      dc.w    LAB_NEW-LAB_CTBL            * NEW
00083708= F954                    8372      dc.w    LAB_WDTH-LAB_CTBL           * WIDTH
0008370A= DAD2                    8373      dc.w    LAB_GET-LAB_CTBL            * GET
0008370C= E9E0                    8374      dc.w    LAB_SWAP-LAB_CTBL           * SWAP
0008370E= F49E                    8375      dc.w    LAB_BITSET-LAB_CTBL     * BITSET
00083710= F4AE                    8376      dc.w    LAB_BITCLR-LAB_CTBL     * BITCLR
00083712                          8377  
00083712                          8378  
00083712                          8379  *************************************************************************************
00083712                          8380  *
00083712                          8381  * function pre process routine table
00083712                          8382  
00083712                          8383  LAB_FTPP
00083712= DFD0                    8384      dc.w    LAB_PPFN-LAB_FTPP           * SGN(n)    process numeric expression in ()
00083714= DFD0                    8385      dc.w    LAB_PPFN-LAB_FTPP           * INT(n)        "
00083716= DFD0                    8386      dc.w    LAB_PPFN-LAB_FTPP           * ABS(n)        "
00083718= DDD2                    8387      dc.w    LAB_EVEZ-LAB_FTPP           * USR(x)    process any expression
0008371A= DF1A                    8388      dc.w    LAB_1BF7-LAB_FTPP           * FRE(x)    process any expression in ()
0008371C= DF1A                    8389      dc.w    LAB_1BF7-LAB_FTPP           * POS(x)        "
0008371E= DFD0                    8390      dc.w    LAB_PPFN-LAB_FTPP           * SQR(n)    process numeric expression in ()
00083720= DFD0                    8391      dc.w    LAB_PPFN-LAB_FTPP           * RND(n)        "
00083722= DFD0                    8392      dc.w    LAB_PPFN-LAB_FTPP           * LOG(n)        "
00083724= DFD0                    8393      dc.w    LAB_PPFN-LAB_FTPP           * EXP(n)        "
00083726= DFD0                    8394      dc.w    LAB_PPFN-LAB_FTPP           * COS(n)        "
00083728= DFD0                    8395      dc.w    LAB_PPFN-LAB_FTPP           * SIN(n)        "
0008372A= DFD0                    8396      dc.w    LAB_PPFN-LAB_FTPP           * TAN(n)        "
0008372C= DFD0                    8397      dc.w    LAB_PPFN-LAB_FTPP           * ATN(n)        "
0008372E= DFD0                    8398      dc.w    LAB_PPFN-LAB_FTPP           * PEEK(n)       "
00083730= DFD0                    8399      dc.w    LAB_PPFN-LAB_FTPP           * DEEK(n)       "
00083732= DFD0                    8400      dc.w    LAB_PPFN-LAB_FTPP           * LEEK(n)       "
00083734= DFC2                    8401      dc.w    LAB_PPFS-LAB_FTPP           * LEN($)    process string expression in ()
00083736= DFD0                    8402      dc.w    LAB_PPFN-LAB_FTPP           * STR$(n)   process numeric expression in ()
00083738= DFC2                    8403      dc.w    LAB_PPFS-LAB_FTPP           * VAL($)    process string expression in ()
0008373A= DFC2                    8404      dc.w    LAB_PPFS-LAB_FTPP           * ASC($)        "
0008373C= DFC2                    8405      dc.w    LAB_PPFS-LAB_FTPP           * UCASE$($)     "
0008373E= DFC2                    8406      dc.w    LAB_PPFS-LAB_FTPP           * LCASE$($)     "
00083740= DFD0                    8407      dc.w    LAB_PPFN-LAB_FTPP           * CHR$(n)   process numeric expression in ()
00083742= E00A                    8408      dc.w    LAB_BHSS-LAB_FTPP           * HEX$()    bin/hex pre process
00083744= E00A                    8409      dc.w    LAB_BHSS-LAB_FTPP           * BIN$()        "
00083746= 0000                    8410      dc.w    $0000                   * BITTST()  none
00083748= 0000                    8411      dc.w    $0000                   * MAX()     "
0008374A= 0000                    8412      dc.w    $0000                   * MIN()     "
0008374C= DFDE                    8413      dc.w    LAB_PPBI-LAB_FTPP           * RAMBASE   advance pointer
0008374E= DFDE                    8414      dc.w    LAB_PPBI-LAB_FTPP           * PI            "
00083750= DFDE                    8415      dc.w    LAB_PPBI-LAB_FTPP           * TWOPI     "
00083752= 0000                    8416      dc.w    $0000                   * VARPTR()  none
00083754= 0000                    8417      dc.w    $0000                   * SADD()        "
00083756= DFE8                    8418      dc.w    LAB_LRMS-LAB_FTPP           * LEFT$()   process string expression
00083758= DFE8                    8419      dc.w    LAB_LRMS-LAB_FTPP           * RIGHT$()      "
0008375A= DFE8                    8420      dc.w    LAB_LRMS-LAB_FTPP           * MID$()        "
0008375C= DDD2                    8421      dc.w    LAB_EVEZ-LAB_FTPP           * USING$(x) process any expression
0008375E                          8422  
0008375E                          8423  
0008375E                          8424  *************************************************************************************
0008375E                          8425  *
0008375E                          8426  * action addresses for functions
0008375E                          8427  
0008375E                          8428  LAB_FTBL
0008375E= ED54                    8429      dc.w    LAB_SGN-LAB_FTBL            * SGN()
00083760= EDD6                    8430      dc.w    LAB_INT-LAB_FTBL            * INT()
00083762= ED66                    8431      dc.w    LAB_ABS-LAB_FTBL            * ABS()
00083764= E972                    8432      dc.w    LAB_USR-LAB_FTBL            * USR()
00083766= E3CE                    8433      dc.w    LAB_FRE-LAB_FTBL            * FRE()
00083768= E400                    8434      dc.w    LAB_POS-LAB_FTBL            * POS()
0008376A= F938                    8435      dc.w    LAB_SQR-LAB_FTBL            * SQR()
0008376C= F21E                    8436      dc.w    LAB_RND-LAB_FTBL            * RND()
0008376E= EA76                    8437      dc.w    LAB_LOG-LAB_FTBL            * LOG()
00083770= F104                    8438      dc.w    LAB_EXP-LAB_FTBL            * EXP()
00083772= F272                    8439      dc.w    LAB_COS-LAB_FTBL            * COS()
00083774= F28A                    8440      dc.w    LAB_SIN-LAB_FTBL            * SIN()
00083776= F250                    8441      dc.w    LAB_TAN-LAB_FTBL            * TAN()
00083778= F350                    8442      dc.w    LAB_ATN-LAB_FTBL            * ATN()
0008377A= E8EE                    8443      dc.w    LAB_PEEK-LAB_FTBL           * PEEK()
0008377C= E900                    8444      dc.w    LAB_DEEK-LAB_FTBL           * DEEK()
0008377E= E916                    8445      dc.w    LAB_LEEK-LAB_FTBL           * LEEK()
00083780= E832                    8446      dc.w    LAB_LENS-LAB_FTBL           * LEN()
00083782= E4F6                    8447      dc.w    LAB_STRS-LAB_FTBL           * STR$()
00083784= E876                    8448      dc.w    LAB_VAL-LAB_FTBL            * VAL()
00083786= E83A                    8449      dc.w    LAB_ASC-LAB_FTBL            * ASC()
00083788= E7E8                    8450      dc.w    LAB_UCASE-LAB_FTBL      * UCASE$()
0008378A= E7B8                    8451      dc.w    LAB_LCASE-LAB_FTBL      * LCASE$()
0008378C= E720                    8452      dc.w    LAB_CHRS-LAB_FTBL           * CHR$()
0008378E= F7DA                    8453      dc.w    LAB_HEXS-LAB_FTBL           * HEX$()
00083790= F788                    8454      dc.w    LAB_BINS-LAB_FTBL           * BIN$()
00083792= F422                    8455      dc.w    LAB_BTST-LAB_FTBL           * BITTST()
00083794= F846                    8456      dc.w    LAB_MAX-LAB_FTBL            * MAX()
00083796= F85C                    8457      dc.w    LAB_MIN-LAB_FTBL            * MIN()
00083798= F9AA                    8458      dc.w    LAB_RAM-LAB_FTBL            * RAMBASE
0008379A= F9B4                    8459      dc.w    LAB_PI-LAB_FTBL         * PI
0008379C= F9C4                    8460      dc.w    LAB_TWOPI-LAB_FTBL      * TWOPI
0008379E= F99A                    8461      dc.w    LAB_VARPTR-LAB_FTBL     * VARPTR()
000837A0= E81A                    8462      dc.w    LAB_SADD-LAB_FTBL           * SADD()
000837A2= E730                    8463      dc.w    LAB_LEFT-LAB_FTBL           * LEFT$()
000837A4= E744                    8464      dc.w    LAB_RIGHT-LAB_FTBL      * RIGHT$()
000837A6= E774                    8465      dc.w    LAB_MIDS-LAB_FTBL           * MID$()
000837A8= F450                    8466      dc.w    LAB_USINGS-LAB_FTBL     * USING$()
000837AA                          8467  
000837AA                          8468  
000837AA                          8469  *************************************************************************************
000837AA                          8470  *
000837AA                          8471  * hierarchy and action addresses for operator
000837AA                          8472  
000837AA                          8473  LAB_OPPT
000837AA= 0079                    8474      dc.w    $0079                   * +
000837AC= E978                    8475      dc.w    LAB_ADD-LAB_OPPT
000837AE= 0079                    8476      dc.w    $0079                   * -
000837B0= E964                    8477      dc.w    LAB_SUBTRACT-LAB_OPPT
000837B2= 007B                    8478      dc.w    $007B                   * *
000837B4= EB1C                    8479      dc.w    LAB_MULTIPLY-LAB_OPPT
000837B6= 007B                    8480      dc.w    $007B                   * /
000837B8= EBA8                    8481      dc.w    LAB_DIVIDE-LAB_OPPT
000837BA= 007F                    8482      dc.w    $007F                   * ^
000837BC= F002                    8483      dc.w    LAB_POWER-LAB_OPPT
000837BE= 0050                    8484      dc.w    $0050                   * AND
000837C0= DFB2                    8485      dc.w    LAB_AND-LAB_OPPT
000837C2= 0046                    8486      dc.w    $0046                   * EOR
000837C4= DFA2                    8487      dc.w    LAB_EOR-LAB_OPPT
000837C6= 0046                    8488      dc.w    $0046                   * OR
000837C8= DFAA                    8489      dc.w    LAB_OR-LAB_OPPT
000837CA= 0056                    8490      dc.w    $0056                   * >>
000837CC= E056                    8491      dc.w    LAB_RSHIFT-LAB_OPPT
000837CE= 0056                    8492      dc.w    $0056                   * <<
000837D0= E046                    8493      dc.w    LAB_LSHIFT-LAB_OPPT
000837D2= 007D                    8494      dc.w    $007D                   * >
000837D4= F066                    8495      dc.w    LAB_GTHAN-LAB_OPPT      * used to evaluate -n
000837D6= 005A                    8496      dc.w    $005A                   * =
000837D8= DFC8                    8497      dc.w    LAB_EQUAL-LAB_OPPT      * used to evaluate NOT
000837DA= 0064                    8498      dc.w    $0064                   * <
000837DC= DFD2                    8499      dc.w    LAB_LTHAN-LAB_OPPT
000837DE                          8500  
000837DE                          8501  
000837DE                          8502  *************************************************************************************
000837DE                          8503  *
000837DE                          8504  * misc constants
000837DE                          8505  
000837DE                          8506  * This table is used in converting numbers to ASCII.
000837DE                          8507  * first four entries for expansion to 9.25 digits
000837DE                          8508  
000837DE                          8509  LAB_2A9A
000837DE= FFF0BDC0                8510      dc.l    $FFF0BDC0               * -1000000
000837E2= 000186A0                8511      dc.l    $000186A0               * 100000
000837E6= FFFFD8F0                8512      dc.l    $FFFFD8F0               * -10000
000837EA= 000003E8                8513      dc.l    $000003E8               * 1000
000837EE= FFFFFF9C                8514      dc.l    $FFFFFF9C               * -100
000837F2= 0000000A                8515      dc.l    $0000000A               * 10
000837F6= FFFFFFFF                8516      dc.l    $FFFFFFFF               * -1
000837FA                          8517  LAB_2A9B
000837FA                          8518  
000837FA                          8519  
000837FA                          8520  *************************************************************************************
000837FA                          8521  *
000837FA                          8522  * new keyword tables
000837FA                          8523  
000837FA                          8524  * offsets to keyword tables
000837FA                          8525  
000837FA                          8526  TAB_CHRT
000837FA= 0000                    8527      dc.w    TAB_STAR-TAB_STAR           * "*"   $2A
000837FC= 0002                    8528      dc.w    TAB_PLUS-TAB_STAR           * "+"   $2B
000837FE= FFFF                    8529      dc.w    -1                  * "," $2C no keywords
00083800= 0004                    8530      dc.w    TAB_MNUS-TAB_STAR           * "-"   $2D
00083802= FFFF                    8531      dc.w    -1                  * "." $2E no keywords
00083804= 0006                    8532      dc.w    TAB_SLAS-TAB_STAR           * "/"   $2F
00083806= FFFF                    8533      dc.w    -1                  * "0" $30 no keywords
00083808= FFFF                    8534      dc.w    -1                  * "1" $31 no keywords
0008380A= FFFF                    8535      dc.w    -1                  * "2" $32 no keywords
0008380C= FFFF                    8536      dc.w    -1                  * "3" $33 no keywords
0008380E= FFFF                    8537      dc.w    -1                  * "4" $34 no keywords
00083810= FFFF                    8538      dc.w    -1                  * "5" $35 no keywords
00083812= FFFF                    8539      dc.w    -1                  * "6" $36 no keywords
00083814= FFFF                    8540      dc.w    -1                  * "7" $37 no keywords
00083816= FFFF                    8541      dc.w    -1                  * "8" $38 no keywords
00083818= FFFF                    8542      dc.w    -1                  * "9" $39 no keywords
0008381A= FFFF                    8543      dc.w    -1                  * ";" $3A no keywords
0008381C= FFFF                    8544      dc.w    -1                  * ":" $3B no keywords
0008381E= 0008                    8545      dc.w    TAB_LESS-TAB_STAR           * "<"   $3C
00083820= 000C                    8546      dc.w    TAB_EQUL-TAB_STAR           * "="   $3D
00083822= 000E                    8547      dc.w    TAB_MORE-TAB_STAR           * ">"   $3E
00083824= 0012                    8548      dc.w    TAB_QEST-TAB_STAR           * "?"   $3F
00083826= FFFF                    8549      dc.w    -1                  * "@" $40 no keywords
00083828= 0014                    8550      dc.w    TAB_ASCA-TAB_STAR           * "A"   $41
0008382A= 0024                    8551      dc.w    TAB_ASCB-TAB_STAR           * "B"   $42
0008382C= 003D                    8552      dc.w    TAB_ASCC-TAB_STAR           * "C"   $43
0008382E= 0054                    8553      dc.w    TAB_ASCD-TAB_STAR           * "D"   $44
00083830= 006D                    8554      dc.w    TAB_ASCE-TAB_STAR           * "E"   $45
00083832= 007C                    8555      dc.w    TAB_ASCF-TAB_STAR           * "F"   $46
00083834= 0086                    8556      dc.w    TAB_ASCG-TAB_STAR           * "G"   $47
00083836= 0093                    8557      dc.w    TAB_ASCH-TAB_STAR           * "H"   $48
00083838= 0099                    8558      dc.w    TAB_ASCI-TAB_STAR           * "I"   $49
0008383A= FFFF                    8559      dc.w    -1                  * "J" $4A no keywords
0008383C= FFFF                    8560      dc.w    -1                  * "K" $4B no keywords
0008383E= 00A8                    8561      dc.w    TAB_ASCL-TAB_STAR           * "L"   $4C
00083840= 00D6                    8562      dc.w    TAB_ASCM-TAB_STAR           * "M"   $4D
00083842= 00E4                    8563      dc.w    TAB_ASCN-TAB_STAR           * "N"   $4E
00083844= 00F3                    8564      dc.w    TAB_ASCO-TAB_STAR           * "O"   $4F
00083846= 00F8                    8565      dc.w    TAB_ASCP-TAB_STAR           * "P"   $50
00083848= FFFF                    8566      dc.w    -1                  * "Q" $51 no keywords
0008384A= 010D                    8567      dc.w    TAB_ASCR-TAB_STAR           * "R"   $52
0008384C= 0137                    8568      dc.w    TAB_ASCS-TAB_STAR           * "S"   $53
0008384E= 0162                    8569      dc.w    TAB_ASCT-TAB_STAR           * "T"   $54
00083850= 0176                    8570      dc.w    TAB_ASCU-TAB_STAR           * "U"   $55
00083852= 018E                    8571      dc.w    TAB_ASCV-TAB_STAR           * "V"   $56
00083854= 019A                    8572      dc.w    TAB_ASCW-TAB_STAR           * "W"   $57
00083856= FFFF                    8573      dc.w    -1                  * "X" $58 no keywords
00083858= FFFF                    8574      dc.w    -1                  * "Y" $59 no keywords
0008385A= FFFF                    8575      dc.w    -1                  * "Z" $5A no keywords
0008385C= FFFF                    8576      dc.w    -1                  * "[" $5B no keywords
0008385E= FFFF                    8577      dc.w    -1                  * "\" $5C no keywords
00083860= FFFF                    8578      dc.w    -1                  * "]" $5D no keywords
00083862= 01A9                    8579      dc.w    TAB_POWR-TAB_STAR           * "^"   $5E
00083864                          8580  
00083864                          8581  
00083864                          8582  *************************************************************************************
00083864                          8583  *
00083864                          8584  * Table of Basic keywords for LIST command
00083864                          8585  * [byte]first character,[byte]remaining length -1
00083864                          8586  * [word]offset from table start
00083864                          8587  
00083864                          8588  LAB_KEYT
00083864= 45 01                   8589      dc.b    'E',1
00083866= 0071                    8590      dc.w    KEY_END-TAB_STAR            * END
00083868= 46 01                   8591      dc.b    'F',1
0008386A= 007C                    8592      dc.w    KEY_FOR-TAB_STAR            * FOR
0008386C= 4E 02                   8593      dc.b    'N',2
0008386E= 00E7                    8594      dc.w    KEY_NEXT-TAB_STAR           * NEXT
00083870= 44 02                   8595      dc.b    'D',2
00083872= 0054                    8596      dc.w    KEY_DATA-TAB_STAR           * DATA
00083874= 49 03                   8597      dc.b    'I',3
00083876= 009E                    8598      dc.w    KEY_INPUT-TAB_STAR      * INPUT
00083878= 44 01                   8599      dc.b    'D',1
0008387A= 0063                    8600      dc.w    KEY_DIM-TAB_STAR            * DIM
0008387C= 52 02                   8601      dc.b    'R',2
0008387E= 0114                    8602      dc.w    KEY_READ-TAB_STAR           * READ
00083880= 4C 01                   8603      dc.b    'L',1
00083882= 00BE                    8604      dc.w    KEY_LET-TAB_STAR            * LET
00083884= 44 01                   8605      dc.b    'D',1
00083886= 0058                    8606      dc.w    KEY_DEC-TAB_STAR            * DEC
00083888= 47 02                   8607      dc.b    'G',2
0008388A= 0089                    8608      dc.w    KEY_GOTO-TAB_STAR           * GOTO
0008388C= 52 01                   8609      dc.b    'R',1
0008388E= 0133                    8610      dc.w    KEY_RUN-TAB_STAR            * RUN
00083890= 49 00                   8611      dc.b    'I',0
00083892= 0099                    8612      dc.w    KEY_IF-TAB_STAR         * IF
00083894= 52 05                   8613      dc.b    'R',5
00083896= 011B                    8614      dc.w    KEY_RESTORE-TAB_STAR        * RESTORE
00083898= 47 03                   8615      dc.b    'G',3
0008389A= 008D                    8616      dc.w    KEY_GOSUB-TAB_STAR      * GOSUB
0008389C= 52 04                   8617      dc.b    'R',4
0008389E= 0122                    8618      dc.w    KEY_RETURN-TAB_STAR     * RETURN
000838A0= 52 01                   8619      dc.b    'R',1
000838A2= 0118                    8620      dc.w    KEY_REM-TAB_STAR            * REM
000838A4= 53 02                   8621      dc.b    'S',2
000838A6= 0154                    8622      dc.w    KEY_STOP-TAB_STAR           * STOP
000838A8= 4F 00                   8623      dc.b    'O',0
000838AA= 00F3                    8624      dc.w    KEY_ON-TAB_STAR         * ON
000838AC= 4E 02                   8625      dc.b    'N',2
000838AE= 00EE                    8626      dc.w    KEY_NULL-TAB_STAR           * NULL
000838B0= 49 01                   8627      dc.b    'I',1
000838B2= 009B                    8628      dc.w    KEY_INC-TAB_STAR            * INC
000838B4= 57 02                   8629      dc.b    'W',2
000838B6= 019A                    8630      dc.w    KEY_WAIT-TAB_STAR           * WAIT
000838B8= 4C 02                   8631      dc.b    'L',2
000838BA= 00C5                    8632      dc.w    KEY_LOAD-TAB_STAR           * LOAD
000838BC= 53 02                   8633      dc.b    'S',2
000838BE= 013C                    8634      dc.w    KEY_SAVE-TAB_STAR           * SAVE
000838C0= 44 01                   8635      dc.b    'D',1
000838C2= 0060                    8636      dc.w    KEY_DEF-TAB_STAR            * DEF
000838C4= 50 02                   8637      dc.b    'P',2
000838C6= 00FF                    8638      dc.w    KEY_POKE-TAB_STAR           * POKE
000838C8= 44 02                   8639      dc.b    'D',2
000838CA= 0066                    8640      dc.w    KEY_DOKE-TAB_STAR           * DOKE
000838CC= 4C 02                   8641      dc.b    'L',2
000838CE= 00CD                    8642      dc.w    KEY_LOKE-TAB_STAR           * LOKE
000838D0= 43 02                   8643      dc.b    'C',2
000838D2= 003D                    8644      dc.w    KEY_CALL-TAB_STAR           * CALL
000838D4= 44 00                   8645      dc.b    'D',0
000838D6= 006A                    8646      dc.w    KEY_DO-TAB_STAR         * DO
000838D8= 4C 02                   8647      dc.b    'L',2
000838DA= 00D1                    8648      dc.w    KEY_LOOP-TAB_STAR           * LOOP
000838DC= 50 03                   8649      dc.b    'P',3
000838DE= 0107                    8650      dc.w    KEY_PRINT-TAB_STAR      * PRINT
000838E0= 43 02                   8651      dc.b    'C',2
000838E2= 004B                    8652      dc.w    KEY_CONT-TAB_STAR           * CONT
000838E4= 4C 02                   8653      dc.b    'L',2
000838E6= 00C1                    8654      dc.w    KEY_LIST-TAB_STAR           * LIST
000838E8= 43 03                   8655      dc.b    'C',3
000838EA= 0046                    8656      dc.w    KEY_CLEAR-TAB_STAR      * CLEAR
000838EC= 4E 01                   8657      dc.b    'N',1
000838EE= 00E4                    8658      dc.w    KEY_NEW-TAB_STAR            * NEW
000838F0= 57 03                   8659      dc.b    'W',3
000838F2= 01A3                    8660      dc.w    KEY_WIDTH-TAB_STAR      * WIDTH
000838F4= 47 01                   8661      dc.b    'G',1
000838F6= 0086                    8662      dc.w    KEY_GET-TAB_STAR            * GET
000838F8= 53 02                   8663      dc.b    'S',2
000838FA= 015D                    8664      dc.w    KEY_SWAP-TAB_STAR           * SWAP
000838FC= 42 04                   8665      dc.b    'B',4
000838FE= 002F                    8666      dc.w    KEY_BITSET-TAB_STAR     * BITSET
00083900= 42 04                   8667      dc.b    'B',4
00083902= 0029                    8668      dc.w    KEY_BITCLR-TAB_STAR     * BITCLR
00083904= 54 02                   8669      dc.b    'T',2
00083906= 0162                    8670      dc.w    KEY_TAB-TAB_STAR            * TAB(
00083908= 45 02                   8671      dc.b    'E',2
0008390A= 006D                    8672      dc.w    KEY_ELSE-TAB_STAR           * ELSE
0008390C= 54 00                   8673      dc.b    'T',0
0008390E= 016E                    8674      dc.w    KEY_TO-TAB_STAR         * TO
00083910= 46 00                   8675      dc.b    'F',0
00083912= 007F                    8676      dc.w    KEY_FN-TAB_STAR         * FN
00083914= 53 02                   8677      dc.b    'S',2
00083916= 0148                    8678      dc.w    KEY_SPC-TAB_STAR            * SPC(
00083918= 54 02                   8679      dc.b    'T',2
0008391A= 016A                    8680      dc.w    KEY_THEN-TAB_STAR           * THEN
0008391C= 4E 01                   8681      dc.b    'N',1
0008391E= 00EB                    8682      dc.w    KEY_NOT-TAB_STAR            * NOT
00083920= 53 02                   8683      dc.b    'S',2
00083922= 0150                    8684      dc.w    KEY_STEP-TAB_STAR           * STEP
00083924= 55 03                   8685      dc.b    'U',3
00083926= 017D                    8686      dc.w    KEY_UNTIL-TAB_STAR      * UNTIL
00083928= 57 03                   8687      dc.b    'W',3
0008392A= 019E                    8688      dc.w    KEY_WHILE-TAB_STAR      * WHILE
0008392C                          8689  
0008392C= 2B FF                   8690      dc.b    '+',-1
0008392E= 0002                    8691      dc.w    KEY_PLUS-TAB_STAR           * +
00083930= 2D FF                   8692      dc.b    '-',-1
00083932= 0004                    8693      dc.w    KEY_MINUS-TAB_STAR      * -
00083934= 2A FF                   8694      dc.b    '*',-1
00083936= 0000                    8695      dc.w    KEY_MULT-TAB_STAR           * *
00083938= 2F FF                   8696      dc.b    '/',-1
0008393A= 0006                    8697      dc.w    KEY_DIV-TAB_STAR            * /
0008393C= 5E FF                   8698      dc.b    '^',-1
0008393E= 01A9                    8699      dc.w    KEY_POWER-TAB_STAR      * ^
00083940= 41 01                   8700      dc.b    'A',1
00083942= 0018                    8701      dc.w    KEY_AND-TAB_STAR            * AND
00083944= 45 01                   8702      dc.b    'E',1
00083946= 0074                    8703      dc.w    KEY_EOR-TAB_STAR            * EOR
00083948= 4F 00                   8704      dc.b    'O',0
0008394A= 00F5                    8705      dc.w    KEY_OR-TAB_STAR         * OR
0008394C= 3E 00                   8706      dc.b    '>',0
0008394E= 000E                    8707      dc.w    KEY_RSHIFT-TAB_STAR     * >>
00083950= 3C 00                   8708      dc.b    '<',0
00083952= 0008                    8709      dc.w    KEY_LSHIFT-TAB_STAR     * <<
00083954= 3E FF                   8710      dc.b    '>',-1
00083956= 0010                    8711      dc.w    KEY_GT-TAB_STAR         * >
00083958= 3D FF                   8712      dc.b    '=',-1
0008395A= 000C                    8713      dc.w    KEY_EQUAL-TAB_STAR      * =
0008395C= 3C FF                   8714      dc.b    '<',-1
0008395E= 000A                    8715      dc.w    KEY_LT-TAB_STAR         * <
00083960                          8716  
00083960= 53 02                   8717      dc.b    'S',2
00083962= 0140                    8718      dc.w    KEY_SGN-TAB_STAR            * SGN(
00083964= 49 02                   8719      dc.b    'I',2
00083966= 00A3                    8720      dc.w    KEY_INT-TAB_STAR            * INT(
00083968= 41 02                   8721      dc.b    'A',2
0008396A= 0014                    8722      dc.w    KEY_ABS-TAB_STAR            * ABS(
0008396C= 55 02                   8723      dc.b    'U',2
0008396E= 0189                    8724      dc.w    KEY_USR-TAB_STAR            * USR(
00083970= 46 02                   8725      dc.b    'F',2
00083972= 0081                    8726      dc.w    KEY_FRE-TAB_STAR            * FRE(
00083974= 50 02                   8727      dc.b    'P',2
00083976= 0103                    8728      dc.w    KEY_POS-TAB_STAR            * POS(
00083978= 53 02                   8729      dc.b    'S',2
0008397A= 014C                    8730      dc.w    KEY_SQR-TAB_STAR            * SQR(
0008397C= 52 02                   8731      dc.b    'R',2
0008397E= 012F                    8732      dc.w    KEY_RND-TAB_STAR            * RND(
00083980= 4C 02                   8733      dc.b    'L',2
00083982= 00C9                    8734      dc.w    KEY_LOG-TAB_STAR            * LOG(
00083984= 45 02                   8735      dc.b    'E',2
00083986= 0077                    8736      dc.w    KEY_EXP-TAB_STAR            * EXP(
00083988= 43 02                   8737      dc.b    'C',2
0008398A= 004F                    8738      dc.w    KEY_COS-TAB_STAR            * COS(
0008398C= 53 02                   8739      dc.b    'S',2
0008398E= 0144                    8740      dc.w    KEY_SIN-TAB_STAR            * SIN(
00083990= 54 02                   8741      dc.b    'T',2
00083992= 0166                    8742      dc.w    KEY_TAN-TAB_STAR            * TAN(
00083994= 41 02                   8743      dc.b    'A',2
00083996= 001F                    8744      dc.w    KEY_ATN-TAB_STAR            * ATN(
00083998= 50 03                   8745      dc.b    'P',3
0008399A= 00F8                    8746      dc.w    KEY_PEEK-TAB_STAR           * PEEK(
0008399C= 44 03                   8747      dc.b    'D',3
0008399E= 005B                    8748      dc.w    KEY_DEEK-TAB_STAR           * DEEK(
000839A0= 4C 03                   8749      dc.b    'L',3
000839A2= 00AF                    8750      dc.w    KEY_LEEK-TAB_STAR           * LEEK(
000839A4= 4C 02                   8751      dc.b    'L',2
000839A6= 00BA                    8752      dc.w    KEY_LEN-TAB_STAR            * LEN(
000839A8= 53 03                   8753      dc.b    'S',3
000839AA= 0158                    8754      dc.w    KEY_STRS-TAB_STAR           * STR$(
000839AC= 56 02                   8755      dc.b    'V',2
000839AE= 018E                    8756      dc.w    KEY_VAL-TAB_STAR            * VAL(
000839B0= 41 02                   8757      dc.b    'A',2
000839B2= 001B                    8758      dc.w    KEY_ASC-TAB_STAR            * ASC(
000839B4= 55 05                   8759      dc.b    'U',5
000839B6= 0176                    8760      dc.w    KEY_UCASES-TAB_STAR     * UCASE$(
000839B8= 4C 05                   8761      dc.b    'L',5
000839BA= 00A8                    8762      dc.w    KEY_LCASES-TAB_STAR     * LCASE$(
000839BC= 43 03                   8763      dc.b    'C',3
000839BE= 0041                    8764      dc.w    KEY_CHRS-TAB_STAR           * CHR$(
000839C0= 48 03                   8765      dc.b    'H',3
000839C2= 0093                    8766      dc.w    KEY_HEXS-TAB_STAR           * HEX$(
000839C4= 42 03                   8767      dc.b    'B',3
000839C6= 0024                    8768      dc.w    KEY_BINS-TAB_STAR           * BIN$(
000839C8= 42 05                   8769      dc.b    'B',5
000839CA= 0035                    8770      dc.w    KEY_BITTST-TAB_STAR     * BITTST(
000839CC= 4D 02                   8771      dc.b    'M',2
000839CE= 00D6                    8772      dc.w    KEY_MAX-TAB_STAR            * MAX(
000839D0= 4D 02                   8773      dc.b    'M',2
000839D2= 00DF                    8774      dc.w    KEY_MIN-TAB_STAR            * MIN(
000839D4= 52 05                   8775      dc.b    'R',5
000839D6= 010D                    8776      dc.w    KEY_RAM-TAB_STAR            * RAMBASE
000839D8= 50 00                   8777      dc.b    'P',0
000839DA= 00FD                    8778      dc.w    KEY_PI-TAB_STAR         * PI
000839DC= 54 03                   8779      dc.b    'T',3
000839DE= 0170                    8780      dc.w    KEY_TWOPI-TAB_STAR      * TWOPI
000839E0= 56 05                   8781      dc.b    'V',5
000839E2= 0192                    8782      dc.w    KEY_VPTR-TAB_STAR           * VARPTR(
000839E4= 53 03                   8783      dc.b    'S',3
000839E6= 0137                    8784      dc.w    KEY_SADD-TAB_STAR           * SADD(
000839E8= 4C 04                   8785      dc.b    'L',4
000839EA= 00B4                    8786      dc.w    KEY_LEFTS-TAB_STAR      * LEFT$(
000839EC= 52 05                   8787      dc.b    'R',5
000839EE= 0128                    8788      dc.w    KEY_RIGHTS-TAB_STAR     * RIGHT$(
000839F0= 4D 03                   8789      dc.b    'M',3
000839F2= 00DA                    8790      dc.w    KEY_MIDS-TAB_STAR           * MID$(
000839F4= 55 05                   8791      dc.b    'U',5
000839F6= 0182                    8792      dc.w    KEY_USINGS-TAB_STAR     * USING$(
000839F8                          8793  
000839F8                          8794  
000839F8                          8795  *************************************************************************************
000839F8                          8796  *
000839F8                          8797  * BASIC error messages
000839F8                          8798  
000839F8                          8799  LAB_BAER
000839F8= 0030                    8800      dc.w    LAB_NF-LAB_BAER         * $00 NEXT without FOR
000839FA= 0041                    8801      dc.w    LAB_SN-LAB_BAER         * $02 syntax
000839FC= 0048                    8802      dc.w    LAB_RG-LAB_BAER         * $04 RETURN without GOSUB
000839FE= 005D                    8803      dc.w    LAB_OD-LAB_BAER         * $06 out of data
00083A00= 0069                    8804      dc.w    LAB_FC-LAB_BAER         * $08 function call
00083A02= 0077                    8805      dc.w    LAB_OV-LAB_BAER         * $0A overflow
00083A04= 0080                    8806      dc.w    LAB_OM-LAB_BAER         * $0C out of memory
00083A06= 008E                    8807      dc.w    LAB_US-LAB_BAER         * $0E undefined statement
00083A08= 00A2                    8808      dc.w    LAB_BS-LAB_BAER         * $10 array bounds
00083A0A= 00AF                    8809      dc.w    LAB_DD-LAB_BAER         * $12 double dimension array
00083A0C= 00C0                    8810      dc.w    LAB_D0-LAB_BAER         * $14 divide by 0
00083A0E= 00CF                    8811      dc.w    LAB_ID-LAB_BAER         * $16 illegal direct
00083A10= 00DE                    8812      dc.w    LAB_TM-LAB_BAER         * $18 type mismatch
00083A12= 00EC                    8813      dc.w    LAB_LS-LAB_BAER         * $1A long string
00083A14= 00FC                    8814      dc.w    LAB_ST-LAB_BAER         * $1C string too complex
00083A16= 010F                    8815      dc.w    LAB_CN-LAB_BAER         * $1E continue error
00083A18= 011E                    8816      dc.w    LAB_UF-LAB_BAER         * $20 undefined function
00083A1A= 0131                    8817      dc.w    LAB_LD-LAB_BAER         * $22 LOOP without DO
00083A1C= 0141                    8818      dc.w    LAB_UV-LAB_BAER         * $24 undefined variable
00083A1E= 0154                    8819      dc.w    LAB_UA-LAB_BAER         * $26 undimensioned array
00083A20= 0168                    8820      dc.w    LAB_WD-LAB_BAER         * $28 wrong dimensions
00083A22= 0179                    8821      dc.w    LAB_AD-LAB_BAER         * $2A address
00083A24= 0181                    8822      dc.w    LAB_FO-LAB_BAER         * $2C format
00083A26= 0188                    8823      dc.w    LAB_NI-LAB_BAER         * $2E not implemented
00083A28                          8824  
00083A28= 4E 45 58 54 20 77 ...   8825  LAB_NF  dc.b    'NEXT without FOR',$00
00083A39= 53 79 6E 74 61 78 00    8826  LAB_SN  dc.b    'Syntax',$00
00083A40= 52 45 54 55 52 4E ...   8827  LAB_RG  dc.b    'RETURN without GOSUB',$00
00083A55= 4F 75 74 20 6F 66 ...   8828  LAB_OD  dc.b    'Out of DATA',$00
00083A61= 46 75 6E 63 74 69 ...   8829  LAB_FC  dc.b    'Function call',$00
00083A6F= 4F 76 65 72 66 6C ...   8830  LAB_OV  dc.b    'Overflow',$00
00083A78= 4F 75 74 20 6F 66 ...   8831  LAB_OM  dc.b    'Out of memory',$00
00083A86= 55 6E 64 65 66 69 ...   8832  LAB_US  dc.b    'Undefined statement',$00
00083A9A= 41 72 72 61 79 20 ...   8833  LAB_BS  dc.b    'Array bounds',$00
00083AA7= 44 6F 75 62 6C 65 ...   8834  LAB_DD  dc.b    'Double dimension',$00
00083AB8= 44 69 76 69 64 65 ...   8835  LAB_D0  dc.b    'Divide by zero',$00
00083AC7= 49 6C 6C 65 67 61 ...   8836  LAB_ID  dc.b    'Illegal direct',$00
00083AD6= 54 79 70 65 20 6D ...   8837  LAB_TM  dc.b    'Type mismatch',$00
00083AE4= 53 74 72 69 6E 67 ...   8838  LAB_LS  dc.b    'String too long',$00
00083AF4= 53 74 72 69 6E 67 ...   8839  LAB_ST  dc.b    'String too complex',$00
00083B07= 43 61 6E 27 74 20 ...   8840  LAB_CN  dc.b    'Can''t continue',$00
00083B16= 55 6E 64 65 66 69 ...   8841  LAB_UF  dc.b    'Undefined function',$00
00083B29= 4C 4F 4F 50 20 77 ...   8842  LAB_LD  dc.b    'LOOP without DO',$00
00083B39= 55 6E 64 65 66 69 ...   8843  LAB_UV  dc.b    'Undefined variable',$00
00083B4C= 55 6E 64 69 6D 65 ...   8844  LAB_UA  dc.b    'Undimensioned array',$00
00083B60= 57 72 6F 6E 67 20 ...   8845  LAB_WD  dc.b    'Wrong dimensions',$00
00083B71= 41 64 64 72 65 73 ...   8846  LAB_AD  dc.b    'Address',$00
00083B79= 46 6F 72 6D 61 74 00    8847  LAB_FO  dc.b    'Format',$00
00083B80= 4E 6F 74 20 69 6D ...   8848  LAB_NI  dc.b    'Not implemented',$00
00083B90                          8849  
00083B90                          8850  
00083B90                          8851  *************************************************************************************
00083B90                          8852  *
00083B90                          8853  * keyword table for line (un)crunching
00083B90                          8854  
00083B90                          8855  * [keyword,token
00083B90                          8856  * [keyword,token]]
00083B90                          8857  * end marker (#$00)
00083B90                          8858  
00083B90                          8859  TAB_STAR
00083B90                          8860  KEY_MULT
00083B90= B4 00                   8861      dc.b TK_MULT,$00                * *
00083B92                          8862  TAB_PLUS
00083B92                          8863  KEY_PLUS
00083B92= B2 00                   8864      dc.b TK_PLUS,$00                * +
00083B94                          8865  TAB_MNUS
00083B94                          8866  KEY_MINUS
00083B94= B3 00                   8867      dc.b TK_MINUS,$00               * -
00083B96                          8868  TAB_SLAS
00083B96                          8869  KEY_DIV
00083B96= B5 00                   8870      dc.b TK_DIV,$00             * /
00083B98                          8871  TAB_LESS
00083B98                          8872  KEY_LSHIFT
00083B98= 3C BB                   8873      dc.b    '<',TK_LSHIFT           * <<
00083B9A                          8874  KEY_LT
00083B9A= BE                      8875      dc.b TK_LT                  * <
00083B9B= 00                      8876      dc.b    $00
00083B9C                          8877  TAB_EQUL
00083B9C                          8878  KEY_EQUAL
00083B9C= BD 00                   8879      dc.b TK_EQUAL,$00               * =
00083B9E                          8880  TAB_MORE
00083B9E                          8881  KEY_RSHIFT
00083B9E= 3E BA                   8882      dc.b    '>',TK_RSHIFT           * >>
00083BA0                          8883  KEY_GT
00083BA0= BC                      8884      dc.b TK_GT                  * >
00083BA1= 00                      8885      dc.b    $00
00083BA2                          8886  TAB_QEST
00083BA2= 9E 00                   8887      dc.b TK_PRINT,$00               * ?
00083BA4                          8888  TAB_ASCA
00083BA4                          8889  KEY_ABS
00083BA4= 42 53 28 C1             8890      dc.b    'BS(',TK_ABS            * ABS(
00083BA8                          8891  KEY_AND
00083BA8= 4E 44 B7                8892      dc.b    'ND',TK_AND             * AND
00083BAB                          8893  KEY_ASC
00083BAB= 53 43 28 D3             8894      dc.b    'SC(',TK_ASC            * ASC(
00083BAF                          8895  KEY_ATN
00083BAF= 54 4E 28 CC             8896      dc.b    'TN(',TK_ATN            * ATN(
00083BB3= 00                      8897      dc.b    $00
00083BB4                          8898  TAB_ASCB
00083BB4                          8899  KEY_BINS
00083BB4= 49 4E 24 28 D8          8900      dc.b    'IN$(',TK_BINS          * BIN$(
00083BB9                          8901  KEY_BITCLR
00083BB9= 49 54 43 4C 52 A7       8902      dc.b    'ITCLR',TK_BITCLR           * BITCLR
00083BBF                          8903  KEY_BITSET
00083BBF= 49 54 53 45 54 A6       8904      dc.b    'ITSET',TK_BITSET           * BITSET
00083BC5                          8905  KEY_BITTST
00083BC5= 49 54 54 53 54 28 D9    8906      dc.b    'ITTST(',TK_BITTST      * BITTST(
00083BCC= 00                      8907      dc.b    $00
00083BCD                          8908  TAB_ASCC
00083BCD                          8909  KEY_CALL
00083BCD= 41 4C 4C 9B             8910      dc.b    'ALL',TK_CALL           * CALL
00083BD1                          8911  KEY_CHRS
00083BD1= 48 52 24 28 D6          8912      dc.b    'HR$(',TK_CHRS          * CHR$(
00083BD6                          8913  KEY_CLEAR
00083BD6= 4C 45 41 52 A1          8914      dc.b    'LEAR',TK_CLEAR         * CLEAR
00083BDB                          8915  KEY_CONT
00083BDB= 4F 4E 54 9F             8916      dc.b    'ONT',TK_CONT           * CONT
00083BDF                          8917  KEY_COS
00083BDF= 4F 53 28 C9             8918      dc.b    'OS(',TK_COS            * COS(
00083BE3= 00                      8919      dc.b    $00
00083BE4                          8920  TAB_ASCD
00083BE4                          8921  KEY_DATA
00083BE4= 41 54 41 83             8922      dc.b    'ATA',TK_DATA           * DATA
00083BE8                          8923  KEY_DEC
00083BE8= 45 43 88                8924      dc.b    'EC',TK_DEC             * DEC
00083BEB                          8925  KEY_DEEK
00083BEB= 45 45 4B 28 CE          8926      dc.b    'EEK(',TK_DEEK          * DEEK(
00083BF0                          8927  KEY_DEF
00083BF0= 45 46 97                8928      dc.b    'EF',TK_DEF             * DEF
00083BF3                          8929  KEY_DIM
00083BF3= 49 4D 85                8930      dc.b    'IM',TK_DIM             * DIM
00083BF6                          8931  KEY_DOKE
00083BF6= 4F 4B 45 99             8932      dc.b    'OKE',TK_DOKE           * DOKE
00083BFA                          8933  KEY_DO
00083BFA= 4F 9C                   8934      dc.b    'O',TK_DO               * DO
00083BFC= 00                      8935      dc.b    $00
00083BFD                          8936  TAB_ASCE
00083BFD                          8937  KEY_ELSE
00083BFD= 4C 53 45 A9             8938      dc.b    'LSE',TK_ELSE           * ELSE
00083C01                          8939  KEY_END
00083C01= 4E 44 80                8940      dc.b    'ND',TK_END             * END
00083C04                          8941  KEY_EOR
00083C04= 4F 52 B8                8942      dc.b    'OR',TK_EOR             * EOR
00083C07                          8943  KEY_EXP
00083C07= 58 50 28 C8             8944      dc.b    'XP(',TK_EXP            * EXP(
00083C0B= 00                      8945      dc.b    $00
00083C0C                          8946  TAB_ASCF
00083C0C                          8947  KEY_FOR
00083C0C= 4F 52 81                8948      dc.b    'OR',TK_FOR             * FOR
00083C0F                          8949  KEY_FN
00083C0F= 4E AB                   8950      dc.b    'N',TK_FN               * FN
00083C11                          8951  KEY_FRE
00083C11= 52 45 28 C3             8952      dc.b    'RE(',TK_FRE            * FRE(
00083C15= 00                      8953      dc.b    $00
00083C16                          8954  TAB_ASCG
00083C16                          8955  KEY_GET
00083C16= 45 54 A4                8956      dc.b    'ET',TK_GET             * GET
00083C19                          8957  KEY_GOTO
00083C19= 4F 54 4F 89             8958      dc.b    'OTO',TK_GOTO           * GOTO
00083C1D                          8959  KEY_GOSUB
00083C1D= 4F 53 55 42 8D          8960      dc.b    'OSUB',TK_GOSUB         * GOSUB
00083C22= 00                      8961      dc.b    $00
00083C23                          8962  TAB_ASCH
00083C23                          8963  KEY_HEXS
00083C23= 45 58 24 28 D7 00       8964      dc.b    'EX$(',TK_HEXS,$00      * HEX$(
00083C29                          8965  TAB_ASCI
00083C29                          8966  KEY_IF
00083C29= 46 8B                   8967      dc.b    'F',TK_IF               * IF
00083C2B                          8968  KEY_INC
00083C2B= 4E 43 93                8969      dc.b    'NC',TK_INC             * INC
00083C2E                          8970  KEY_INPUT
00083C2E= 4E 50 55 54 84          8971      dc.b    'NPUT',TK_INPUT         * INPUT
00083C33                          8972  KEY_INT
00083C33= 4E 54 28 C0             8973      dc.b    'NT(',TK_INT            * INT(
00083C37= 00                      8974      dc.b    $00
00083C38                          8975  TAB_ASCL
00083C38                          8976  KEY_LCASES
00083C38= 43 41 53 45 24 28 D5    8977      dc.b    'CASE$(',TK_LCASES      * LCASE$(
00083C3F                          8978  KEY_LEEK
00083C3F= 45 45 4B 28 CF          8979      dc.b    'EEK(',TK_LEEK          * LEEK(
00083C44                          8980  KEY_LEFTS
00083C44= 45 46 54 24 28 E1       8981      dc.b    'EFT$(',TK_LEFTS            * LEFT$(
00083C4A                          8982  KEY_LEN
00083C4A= 45 4E 28 D0             8983      dc.b    'EN(',TK_LEN            * LEN(
00083C4E                          8984  KEY_LET
00083C4E= 45 54 87                8985      dc.b    'ET',TK_LET             * LET
00083C51                          8986  KEY_LIST
00083C51= 49 53 54 A0             8987      dc.b    'IST',TK_LIST           * LIST
00083C55                          8988  KEY_LOAD
00083C55= 4F 41 44 95             8989      dc.b    'OAD',TK_LOAD           * LOAD
00083C59                          8990  KEY_LOG
00083C59= 4F 47 28 C7             8991      dc.b    'OG(',TK_LOG            * LOG(
00083C5D                          8992  KEY_LOKE
00083C5D= 4F 4B 45 9A             8993      dc.b    'OKE',TK_LOKE           * LOKE
00083C61                          8994  KEY_LOOP
00083C61= 4F 4F 50 9D             8995      dc.b    'OOP',TK_LOOP           * LOOP
00083C65= 00                      8996      dc.b    $00
00083C66                          8997  TAB_ASCM
00083C66                          8998  KEY_MAX
00083C66= 41 58 28 DA             8999      dc.b    'AX(',TK_MAX            * MAX(
00083C6A                          9000  KEY_MIDS
00083C6A= 49 44 24 28 E3          9001      dc.b    'ID$(',TK_MIDS          * MID$(
00083C6F                          9002  KEY_MIN
00083C6F= 49 4E 28 DB             9003      dc.b    'IN(',TK_MIN            * MIN(
00083C73= 00                      9004      dc.b    $00
00083C74                          9005  TAB_ASCN
00083C74                          9006  KEY_NEW
00083C74= 45 57 A2                9007      dc.b    'EW',TK_NEW             * NEW
00083C77                          9008  KEY_NEXT
00083C77= 45 58 54 82             9009      dc.b    'EXT',TK_NEXT           * NEXT
00083C7B                          9010  KEY_NOT
00083C7B= 4F 54 AE                9011      dc.b    'OT',TK_NOT             * NOT
00083C7E                          9012  KEY_NULL
00083C7E= 55 4C 4C 92             9013      dc.b    'ULL',TK_NULL           * NULL
00083C82= 00                      9014      dc.b    $00
00083C83                          9015  TAB_ASCO
00083C83                          9016  KEY_ON
00083C83= 4E 91                   9017      dc.b    'N',TK_ON               * ON
00083C85                          9018  KEY_OR
00083C85= 52 B9                   9019      dc.b    'R',TK_OR               * OR
00083C87= 00                      9020      dc.b    $00
00083C88                          9021  TAB_ASCP
00083C88                          9022  KEY_PEEK
00083C88= 45 45 4B 28 CD          9023      dc.b    'EEK(',TK_PEEK          * PEEK(
00083C8D                          9024  KEY_PI
00083C8D= 49 DD                   9025      dc.b    'I',TK_PI               * PI
00083C8F                          9026  KEY_POKE
00083C8F= 4F 4B 45 98             9027      dc.b    'OKE',TK_POKE           * POKE
00083C93                          9028  KEY_POS
00083C93= 4F 53 28 C4             9029      dc.b    'OS(',TK_POS            * POS(
00083C97                          9030  KEY_PRINT
00083C97= 52 49 4E 54 9E          9031      dc.b    'RINT',TK_PRINT         * PRINT
00083C9C= 00                      9032      dc.b    $00
00083C9D                          9033  TAB_ASCR
00083C9D                          9034  KEY_RAM
00083C9D= 41 4D 42 41 53 45 DC    9035      dc.b    'AMBASE',TK_RAM         * RAMBASE
00083CA4                          9036  KEY_READ
00083CA4= 45 41 44 86             9037      dc.b    'EAD',TK_READ           * READ
00083CA8                          9038  KEY_REM
00083CA8= 45 4D 8F                9039      dc.b    'EM',TK_REM             * REM
00083CAB                          9040  KEY_RESTORE
00083CAB= 45 53 54 4F 52 45 8C    9041      dc.b    'ESTORE',TK_RESTORE     * RESTORE
00083CB2                          9042  KEY_RETURN
00083CB2= 45 54 55 52 4E 8E       9043      dc.b    'ETURN',TK_RETURN           * RETURN
00083CB8                          9044  KEY_RIGHTS
00083CB8= 49 47 48 54 24 28 E2    9045      dc.b    'IGHT$(',TK_RIGHTS      * RIGHT$(
00083CBF                          9046  KEY_RND
00083CBF= 4E 44 28 C6             9047      dc.b    'ND(',TK_RND            * RND(
00083CC3                          9048  KEY_RUN
00083CC3= 55 4E 8A                9049      dc.b    'UN',TK_RUN             * RUN
00083CC6= 00                      9050      dc.b    $00
00083CC7                          9051  TAB_ASCS
00083CC7                          9052  KEY_SADD
00083CC7= 41 44 44 28 E0          9053      dc.b    'ADD(',TK_SADD          * SADD(
00083CCC                          9054  KEY_SAVE
00083CCC= 41 56 45 96             9055      dc.b    'AVE',TK_SAVE           * SAVE
00083CD0                          9056  KEY_SGN
00083CD0= 47 4E 28 BF             9057      dc.b    'GN(',TK_SGN            * SGN(
00083CD4                          9058  KEY_SIN
00083CD4= 49 4E 28 CA             9059      dc.b    'IN(',TK_SIN            * SIN(
00083CD8                          9060  KEY_SPC
00083CD8= 50 43 28 AC             9061      dc.b    'PC(',TK_SPC            * SPC(
00083CDC                          9062  KEY_SQR
00083CDC= 51 52 28 C5             9063      dc.b    'QR(',TK_SQR            * SQR(
00083CE0                          9064  KEY_STEP
00083CE0= 54 45 50 AF             9065      dc.b    'TEP',TK_STEP           * STEP
00083CE4                          9066  KEY_STOP
00083CE4= 54 4F 50 90             9067      dc.b    'TOP',TK_STOP           * STOP
00083CE8                          9068  KEY_STRS
00083CE8= 54 52 24 28 D1          9069      dc.b    'TR$(',TK_STRS          * STR$(
00083CED                          9070  KEY_SWAP
00083CED= 57 41 50 A5             9071      dc.b    'WAP',TK_SWAP           * SWAP
00083CF1= 00                      9072      dc.b    $00
00083CF2                          9073  TAB_ASCT
00083CF2                          9074  KEY_TAB
00083CF2= 41 42 28 A8             9075      dc.b    'AB(',TK_TAB            * TAB(
00083CF6                          9076  KEY_TAN
00083CF6= 41 4E 28 CB             9077      dc.b    'AN(',TK_TAN            * TAN
00083CFA                          9078  KEY_THEN
00083CFA= 48 45 4E AD             9079      dc.b    'HEN',TK_THEN           * THEN
00083CFE                          9080  KEY_TO
00083CFE= 4F AA                   9081      dc.b    'O',TK_TO               * TO
00083D00                          9082  KEY_TWOPI
00083D00= 57 4F 50 49 DE          9083      dc.b    'WOPI',TK_TWOPI         * TWOPI
00083D05= 00                      9084      dc.b    $00
00083D06                          9085  TAB_ASCU
00083D06                          9086  KEY_UCASES
00083D06= 43 41 53 45 24 28 D4    9087      dc.b    'CASE$(',TK_UCASES      * UCASE$(
00083D0D                          9088  KEY_UNTIL
00083D0D= 4E 54 49 4C B0          9089      dc.b    'NTIL',TK_UNTIL         * UNTIL
00083D12                          9090  KEY_USINGS
00083D12= 53 49 4E 47 24 28 E4    9091      dc.b    'SING$(',TK_USINGS      * USING$(
00083D19                          9092  KEY_USR
00083D19= 53 52 28 C2             9093      dc.b    'SR(',TK_USR            * USR(
00083D1D= 00                      9094      dc.b    $00
00083D1E                          9095  TAB_ASCV
00083D1E                          9096  KEY_VAL
00083D1E= 41 4C 28 D2             9097      dc.b    'AL(',TK_VAL            * VAL(
00083D22                          9098  KEY_VPTR
00083D22= 41 52 50 54 52 28 DF    9099      dc.b    'ARPTR(',TK_VPTR            * VARPTR(
00083D29= 00                      9100      dc.b    $00
00083D2A                          9101  TAB_ASCW
00083D2A                          9102  KEY_WAIT
00083D2A= 41 49 54 94             9103      dc.b    'AIT',TK_WAIT           * WAIT
00083D2E                          9104  KEY_WHILE
00083D2E= 48 49 4C 45 B1          9105      dc.b    'HILE',TK_WHILE         * WHILE
00083D33                          9106  KEY_WIDTH
00083D33= 49 44 54 48 A3          9107      dc.b    'IDTH',TK_WIDTH         * WIDTH
00083D38= 00                      9108      dc.b    $00
00083D39                          9109  TAB_POWR
00083D39                          9110  KEY_POWER
00083D39= B6 00                   9111      dc.b    TK_POWER,$00            * ^
00083D3B                          9112  
00083D3B                          9113  
00083D3B                          9114  *************************************************************************************
00083D3B                          9115  *
00083D3B                          9116  * just messages
00083D3B                          9117  
00083D3B                          9118  LAB_BMSG
00083D3B= 0D 0A 42 72 65 61 ...   9119      dc.b    $0D,$0A,'Break',$00
00083D43                          9120  LAB_EMSG
00083D43= 20 45 72 72 6F 72 00    9121      dc.b    ' Error',$00
00083D4A                          9122  LAB_LMSG
00083D4A= 20 69 6E 20 6C 69 ...   9123      dc.b    ' in line ',$00
00083D54                          9124  LAB_IMSG
00083D54= 45 78 74 72 61 20 ...   9125      dc.b    'Extra ignored',$0D,$0A,$00
00083D64                          9126  LAB_REDO
00083D64= 52 65 64 6F 20 66 ...   9127      dc.b    'Redo from start',$0D,$0A,$00
00083D76                          9128  LAB_RMSG
00083D76= 0D 0A 52 65 61 64 ...   9129      dc.b    $0D,$0A,'Ready',$0D,$0A,$00
00083D80                          9130  LAB_SMSG
00083D80= 20 42 79 74 65 73 ...   9131      dc.b    ' Bytes free',$0D,$0A,$0A
00083D8E= 45 6E 68 61 6E 63 ...   9132      dc.b    'Enhanced 68k BASIC Version 3.52',$0D,$0A,$00
00083DB0                          9133  
00083DB0                          9134  
00083DB0                          9135  *************************************************************************************
00083DB0                          9136  * EhBASIC keywords quick reference list                             *
00083DB0                          9137  *************************************************************************************
00083DB0                          9138  
00083DB0                          9139  * glossary
00083DB0                          9140  
00083DB0                          9141  *       <.>       required
00083DB0                          9142  *       {.|.}         one of required
00083DB0                          9143  *       [.]       optional
00083DB0                          9144  *       ...       may repeat as last
00083DB0                          9145  
00083DB0                          9146  *       any     = anything
00083DB0                          9147  *       num     = number
00083DB0                          9148  *       state       = statement
00083DB0                          9149  *       n       = positive integer
00083DB0                          9150  *       str     = string
00083DB0                          9151  *       var     = variable
00083DB0                          9152  *       nvar        = numeric variable
00083DB0                          9153  *       svar        = string variable
00083DB0                          9154  *       expr        = expression
00083DB0                          9155  *       nexpr       = numeric expression
00083DB0                          9156  *       sexpr       = string expression
00083DB0                          9157  
00083DB0                          9158  * statement separator
00083DB0                          9159  
00083DB0                          9160  * :     . [<state>] : [<state>]                     * done
00083DB0                          9161  
00083DB0                          9162  * number bases
00083DB0                          9163  
00083DB0                          9164  * %     . %<binary num>                         * done
00083DB0                          9165  * $     . $<hex num>                            * done
00083DB0                          9166  
00083DB0                          9167  * commands
00083DB0                          9168  
00083DB0                          9169  * END       . END                                   * done
00083DB0                          9170  * FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00083DB0                          9171  * NEXT  . NEXT [<nvar>[,<nvar>]...]                 * done
00083DB0                          9172  * DATA  . DATA [{num|["]str["]}[,{num|["]str["]}]...]       * done
00083DB0                          9173  * INPUT . INPUT [<">str<">;] <var>[,<var>[,<var>]...]       * done
00083DB0                          9174  * DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])            * done
00083DB0                          9175  * READ  . READ <var>[,<var>[,<var>]...]             * done
00083DB0                          9176  * LET       . [LET] <var>=<expr>                        * done
00083DB0                          9177  * DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]               * done
00083DB0                          9178  * GOTO  . GOTO <n>                              * done
00083DB0                          9179  * RUN       . RUN [<n>]                             * done
00083DB0                          9180  * IF        . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00083DB0                          9181  * RESTORE   . RESTORE [<n>]                         * done
00083DB0                          9182  * GOSUB . GOSUB <n>                             * done
00083DB0                          9183  * RETURN    . RETURN                                * done
00083DB0                          9184  * REM       . REM [<any>]                           * done
00083DB0                          9185  * STOP  . STOP                              * done
00083DB0                          9186  * ON        . ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]      * done
00083DB0                          9187  * NULL  . NULL <nexpr>                          * done
00083DB0                          9188  * INC       . INC <nvar>[,<nvar>[,<nvar>]...]               * done
00083DB0                          9189  * WAIT  . WAIT <nexpr>,<nexpr>[,<nexpr>]                * done
00083DB0                          9190  * LOAD  . LOAD [<sexpr>]                            * done for sim
00083DB0                          9191  * SAVE  . SAVE [<sexpr>][,[<n>][-<n>]]              * done for sim
00083DB0                          9192  * DEF       . DEF FN<var>(<var>)=<expr>                 * done
00083DB0                          9193  * POKE  . POKE <nexpr>,<nexpr>                      * done
00083DB0                          9194  * DOKE  . DOKE <nexpr>,<nexpr>                      * done
00083DB0                          9195  * LOKE  . LOKE <nexpr>,<nexpr>                      * done
00083DB0                          9196  * CALL  . CALL <nexpr>                          * done
00083DB0                          9197  * DO        . DO                                    * done
00083DB0                          9198  * LOOP  . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00083DB0                          9199  * PRINT . PRINT [{;|,}][<expr>][{;|,}[<expr>]...]           * done
00083DB0                          9200  * CONT  . CONT                              * done
00083DB0                          9201  * LIST  . LIST [<n>][-<n>]                      * done
00083DB0                          9202  * CLEAR . CLEAR                             * done
00083DB0                          9203  * NEW       . NEW                                   * done
00083DB0                          9204  * WIDTH . WIDTH [<n>][,<n>]                     * done
00083DB0                          9205  * GET       . GET <var>                             * done
00083DB0                          9206  * SWAP  . SWAP <var>,<var>                      * done
00083DB0                          9207  * BITSET    . BITSET <nexpr>,<nexpr>                    * done
00083DB0                          9208  * BITCLR    . BITCLR <nexpr>,<nexpr>                    * done
00083DB0                          9209  
00083DB0                          9210  * sub commands (may not start a statement)
00083DB0                          9211  
00083DB0                          9212  * TAB       . TAB(<nexpr>)                          * done
00083DB0                          9213  * ELSE  . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00083DB0                          9214  * TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00083DB0                          9215  * FN        . FN <var>(<expr>)                      * done
00083DB0                          9216  * SPC       . SPC(<nexpr>)                          * done
00083DB0                          9217  * THEN  . IF <nexpr> {THEN <{n|comm}>|GOTO <n>}         * done
00083DB0                          9218  * NOT       . NOT <nexpr>                           * done
00083DB0                          9219  * STEP  . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00083DB0                          9220  * UNTIL . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00083DB0                          9221  * WHILE . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00083DB0                          9222  
00083DB0                          9223  * operators
00083DB0                          9224  
00083DB0                          9225  * +     . [expr] + <expr>                           * done
00083DB0                          9226  * -     . [nexpr] - <nexpr>                     * done
00083DB0                          9227  * *     . <nexpr> * <nexpr>                     * done fast hardware
00083DB0                          9228  * /     . <nexpr> / <nexpr>                     * done fast hardware
00083DB0                          9229  * ^     . <nexpr> ^ <nexpr>                     * done
00083DB0                          9230  * AND       . <nexpr> AND <nexpr>                       * done
00083DB0                          9231  * EOR       . <nexpr> EOR <nexpr>                       * done
00083DB0                          9232  * OR        . <nexpr> OR <nexpr>                        * done
00083DB0                          9233  * >>        . <nexpr> >> <nexpr>                        * done
00083DB0                          9234  * <<        . <nexpr> << <nexpr>                        * done
00083DB0                          9235  
00083DB0                          9236  * compare functions
00083DB0                          9237  
00083DB0                          9238  * <     . <expr> < <expr>                           * done
00083DB0                          9239  * =     . <expr> = <expr>                           * done
00083DB0                          9240  * >     . <expr> > <expr>                           * done
00083DB0                          9241  
00083DB0                          9242  * functions
00083DB0                          9243  
00083DB0                          9244  * SGN       . SGN(<nexpr>)                          * done
00083DB0                          9245  * INT       . INT(<nexpr>)                          * done
00083DB0                          9246  * ABS       . ABS(<nexpr>)                          * done
00083DB0                          9247  * USR       . USR(<expr>)                           * done
00083DB0                          9248  * FRE       . FRE(<expr>)                           * done
00083DB0                          9249  * POS       . POS(<expr>)                           * done
00083DB0                          9250  * SQR       . SQR(<nexpr>)                          * done fast shift/sub
00083DB0                          9251  * RND       . RND(<nexpr>)                          * done 32 bit PRNG
00083DB0                          9252  * LOG       . LOG(<nexpr>)                          * done fast cordic
00083DB0                          9253  * EXP       . EXP(<nexpr>)                          * done fast cordic
00083DB0                          9254  * COS       . COS(<nexpr>)                          * done fast cordic
00083DB0                          9255  * SIN       . SIN(<nexpr>)                          * done fast cordic
00083DB0                          9256  * TAN       . TAN(<nexpr>)                          * done fast cordic
00083DB0                          9257  * ATN       . ATN(<nexpr>)                          * done fast cordic
00083DB0                          9258  * PEEK  . PEEK(<nexpr>)                         * done
00083DB0                          9259  * DEEK  . DEEK(<nexpr>)                         * done
00083DB0                          9260  * LEEK  . LEEK(<nexpr>)                         * done
00083DB0                          9261  * LEN       . LEN(<sexpr>)                          * done
00083DB0                          9262  * STR$  . STR$(<nexpr>)                         * done
00083DB0                          9263  * VAL       . VAL(<sexpr>)                          * done
00083DB0                          9264  * ASC       . ASC(<sexpr>)                          * done
00083DB0                          9265  * UCASE$    . UCASE$(<sexpr>)                           * done
00083DB0                          9266  * LCASE$    . LCASE$(<sexpr>)                           * done
00083DB0                          9267  * CHR$  . CHR$(<nexpr>)                         * done
00083DB0                          9268  * HEX$  . HEX$(<nexpr>)                         * done
00083DB0                          9269  * BIN$  . BIN$(<nexpr>)                         * done
00083DB0                          9270  * BTST  . BTST(<nexpr>,<nexpr>)                     * done
00083DB0                          9271  * MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00083DB0                          9272  * MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00083DB0                          9273  * PI        . PI                                    * done
00083DB0                          9274  * TWOPI . TWOPI                             * done
00083DB0                          9275  * VARPTR    . VARPTR(<var>)                         * done
00083DB0                          9276  * SADD  . SADD(<svar>)                          * done
00083DB0                          9277  * LEFT$ . LEFT$(<sexpr>,<nexpr>)                    * done
00083DB0                          9278  * RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                   * done
00083DB0                          9279  * MID$  . MID$(<sexpr>,<nexpr>[,<nexpr>])               * done
00083DB0                          9280  * USING$    . USING$(<sexpr>,<nexpr>[,<nexpr>]...])         * done
00083DB0                          9281  
00083DB0                          9282  
00083DB0                          9283  *************************************************************************************
00083DB0                          9284  
00083DB0                          9285      END code_start

47 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            8238A
ASPTL               5A8
ASRCH               5DA
ASTRTL              5AC
BHSEND              5D6
BIN2DEC             83344
BINPR               82F2A
BINSS               5B6
BLINEL              456
BREAKF              5DC
CCBYTE              5E9
CCFLAG              5E8
CCNULL              5EA
CFLAG               5E1
CLINEL              452
CODE_START          8085A
COMP_F              5E3
COSOUT              5B4
CPNTRL              45A
CVARAL              46E
D1X02               8331E
D1X10               83334
D1X16               83310
DECSS               5C6
DEFDIM              5B4
DES_SK              48E
DES_SK_E            476
DIMCNT              5DB
DLINEL              45E
DOCMP               80F94
DOREST              80F80
DPTRL               462
DTYPEF              5B5
EARRYL              442
EMEML               44A
ENDBHS              82F04
EXPCNT              5AD
EXPNEG              5AF
FAC1_E              594
FAC1_M              590
FAC1_S              595
FAC2_E              59C
FAC2_M              598
FAC2_S              59D
FAC_SC              59E
FEND                8
FILE_BYTE           5EB
FILE_ID             5EC
FLAG                59F
FSD                 0
FSDC                A
FSDPI               8
FSLI                6
FSTI                4
FUNC_L              5B0
GCLCTD              5DE
GETFIRST            81764
GETPAIR             81820
GOPR                82F34
HEXSS               5CE
IBUFFE              590
IBUFFS              490
ICLIM               5E7
IMODE               5E0
INGET               82F88
ITEMP               42A
KEY_ABS             83BA4
KEY_AND             83BA8
KEY_ASC             83BAB
KEY_ATN             83BAF
KEY_BINS            83BB4
KEY_BITCLR          83BB9
KEY_BITSET          83BBF
KEY_BITTST          83BC5
KEY_CALL            83BCD
KEY_CHRS            83BD1
KEY_CLEAR           83BD6
KEY_CONT            83BDB
KEY_COS             83BDF
KEY_DATA            83BE4
KEY_DEC             83BE8
KEY_DEEK            83BEB
KEY_DEF             83BF0
KEY_DIM             83BF3
KEY_DIV             83B96
KEY_DO              83BFA
KEY_DOKE            83BF6
KEY_ELSE            83BFD
KEY_END             83C01
KEY_EOR             83C04
KEY_EQUAL           83B9C
KEY_EXP             83C07
KEY_FN              83C0F
KEY_FOR             83C0C
KEY_FRE             83C11
KEY_GET             83C16
KEY_GOSUB           83C1D
KEY_GOTO            83C19
KEY_GT              83BA0
KEY_HEXS            83C23
KEY_IF              83C29
KEY_INC             83C2B
KEY_INPUT           83C2E
KEY_INT             83C33
KEY_LCASES          83C38
KEY_LEEK            83C3F
KEY_LEFTS           83C44
KEY_LEN             83C4A
KEY_LET             83C4E
KEY_LIST            83C51
KEY_LOAD            83C55
KEY_LOG             83C59
KEY_LOKE            83C5D
KEY_LOOP            83C61
KEY_LSHIFT          83B98
KEY_LT              83B9A
KEY_MAX             83C66
KEY_MIDS            83C6A
KEY_MIN             83C6F
KEY_MINUS           83B94
KEY_MULT            83B90
KEY_NEW             83C74
KEY_NEXT            83C77
KEY_NOT             83C7B
KEY_NULL            83C7E
KEY_ON              83C83
KEY_OR              83C85
KEY_PEEK            83C88
KEY_PI              83C8D
KEY_PLUS            83B92
KEY_POKE            83C8F
KEY_POS             83C93
KEY_POWER           83D39
KEY_PRINT           83C97
KEY_RAM             83C9D
KEY_READ            83CA4
KEY_REM             83CA8
KEY_RESTORE         83CAB
KEY_RETURN          83CB2
KEY_RIGHTS          83CB8
KEY_RND             83CBF
KEY_RSHIFT          83B9E
KEY_RUN             83CC3
KEY_SADD            83CC7
KEY_SAVE            83CCC
KEY_SGN             83CD0
KEY_SIN             83CD4
KEY_SPC             83CD8
KEY_SQR             83CDC
KEY_STEP            83CE0
KEY_STOP            83CE4
KEY_STRS            83CE8
KEY_SWAP            83CED
KEY_TAB             83CF2
KEY_TAN             83CF6
KEY_THEN            83CFA
KEY_TO              83CFE
KEY_TWOPI           83D00
KEY_UCASES          83D06
KEY_UNTIL           83D0D
KEY_USINGS          83D12
KEY_USR             83D19
KEY_VAL             83D1E
KEY_VPTR            83D22
KEY_WAIT            83D2A
KEY_WHILE           83D2E
KEY_WIDTH           83D33
KFCTSEED            26A3D110
LAB_11A5            81434
LAB_11A6            81436
LAB_11BD            81442
LAB_1269            80A26
LAB_1274            80A34
LAB_127D            80A3C
LAB_127E            80A4A
LAB_1295            80A5E
LAB_12AE            80A80
LAB_12B0            80A82
LAB_12E6            80AA2
LAB_12FF            80AD4
LAB_1301            80AD6
LAB_1303            80AF4
LAB_1325            80B0C
LAB_132E            80AFC
LAB_1330            80AFE
LAB_134B            80B1A
LAB_1357            80B38
LAB_1359            80B3E
LAB_1374            80B5E
LAB_1378            80B64
LAB_137F            80B70
LAB_138E            80B76
LAB_1392            80B7A
LAB_13A6            80BAE
LAB_13AC            80BB6
LAB_13C6            80BE0
LAB_13CC            80BE6
LAB_13D6            80C08
LAB_13D8            80C0E
LAB_13EA            80C1A
LAB_13EC            80C1C
LAB_13FF            80C34
LAB_1401            80C38
LAB_1408            80C44
LAB_1410            80C50
LAB_1417            80C5A
LAB_141B            80C5C
LAB_141F            80C6C
LAB_142A            80C72
LAB_142C            80C7E
LAB_145E            80C98
LAB_145F            80C8A
LAB_1463            80CA0
LAB_1477            80CAC
LAB_147A            80CB2
LAB_1480            80CCC
LAB_1491            80CD6
LAB_14BD            80D06
LAB_14C0            80D0A
LAB_14D4            80D2A
LAB_14E2            80D46
LAB_150C            80D54
LAB_1519            80D64
LAB_152E            80D70
LAB_1540            80D9C
LAB_15B3            80DFC
LAB_15C2            80E26
LAB_15D1            80E32
LAB_15DC            80E0E
LAB_15F6            80E20
LAB_15FF            80E40
LAB_1602            80E44
LAB_1624            80EC8
LAB_1629            80E68
LAB_1636            80E6C
LAB_1639            80E72
LAB_163B            80E7E
LAB_1647            80E8A
LAB_164F            80E90
LAB_16B0            80F28
LAB_16D0            80F4C
LAB_1723            80FE6
LAB_1725            80FEA
LAB_172C            80FD6
LAB_172D            80FDE
LAB_174B            81012
LAB_174E            81036
LAB_1750            8103E
LAB_1752            8104A
LAB_1754            81062
LAB_1756            8104E
LAB_176C            81080
LAB_1773            8108A
LAB_1785            810A6
LAB_1786            810D2
LAB_17B7            810E8
LAB_17B8            810E4
LAB_17D5            81162
LAB_17D6            81166
LAB_1810            81178
LAB_1811            81188
LAB_1813            8118E
LAB_1829            811C6
LAB_182C            811CA
LAB_1831            811D0
LAB_185E            81210
LAB_1866            81214
LAB_1880            812D6
LAB_1886            812E0
LAB_188A            812E4
LAB_188B            81222
LAB_1898            81230
LAB_18A2            8123A
LAB_18B7            8125C
LAB_18B8            81268
LAB_18BD            8126E
LAB_18C3            81278
LAB_18C6            8127C
LAB_18CD            81286
LAB_18E3            81290
LAB_18F0            812B0
LAB_18F7            812BE
LAB_18F9            812C2
LAB_1904            812E8
LAB_1913            812FA
LAB_1934            81320
LAB_1953            81334
LAB_195B            8133C
LAB_1961            81346
LAB_1984            81366
LAB_1985            8136A
LAB_1986            8136E
LAB_1999            81382
LAB_19B0            81394
LAB_19B6            813A4
LAB_19C2            813B4
LAB_19DD            813C8
LAB_19F6            813E8
LAB_1A03            813F6
LAB_1A0E            81406
LAB_1A1B            8140C
LAB_1A46            81426
LAB_1A90            814A4
LAB_1A9B            814B2
LAB_1ABA            814DC
LAB_1ACD            81508
LAB_1ADB            81514
LAB_1ADE            81518
LAB_1AE0            8152E
LAB_1AFA            81548
LAB_1B0B            8155E
LAB_1B13            81566
LAB_1B1C            81576
LAB_1B1D            81578
LAB_1B2A            8158A
LAB_1B3C            815A6
LAB_1B43            814EC
LAB_1B78            815B2
LAB_1B7B            815B6
LAB_1B7D            815B8
LAB_1B84            815C2
LAB_1B86            815C6
LAB_1B9D            815EA
LAB_1BC1            8161A
LAB_1BD0            81688
LAB_1BE7            816A2
LAB_1BF3            81626
LAB_1BF7            8162C
LAB_1BFB            81630
LAB_1C01            81638
LAB_1C11            81660
LAB_1C13            81666
LAB_1C18            8166E
LAB_1C19            81672
LAB_1C1A            81682
LAB_1C2A            816E0
LAB_1CAE            81788
LAB_1CB5            817A6
LAB_1CD4            817B0
LAB_1CD5            817B6
LAB_1CD6            817B8
LAB_1CDB            817C8
LAB_1CE6            817BA
LAB_1CF2            817CA
LAB_1CFE            817E0
LAB_1D10            81858
LAB_1D12            8185C
LAB_1D2D            8186E
LAB_1D2E            8187A
LAB_1D44            81896
LAB_1D45            818A6
LAB_1D48            818BA
LAB_1D49            818C2
LAB_1D4A            818C6
LAB_1D4B            818D6
LAB_1D5D            818DE
LAB_1D5E            818E4
LAB_1D83            81848
LAB_1D8A            81842
LAB_1D94            818F8
LAB_1D96            8363A
LAB_1D98            81902
LAB_1DAC            8191C
LAB_1DAE            8191E
LAB_1DAF            8192A
LAB_1DB0            81938
LAB_1DB1            8193C
LAB_1DB2            81940
LAB_1DD7            81958
LAB_1DE6            81972
LAB_1E17            819B4
LAB_1E1F            819BA
LAB_1E5C            819F4
LAB_1E8D            81A10
LAB_1EA1            81A2C
LAB_1EC0            81A54
LAB_1ED6            81A80
LAB_1ED8            81A8E
LAB_1EDF            81A48
LAB_1F07            81AA0
LAB_1F28            81ABA
LAB_1F2C            81AC0
LAB_1F5A            81ACE
LAB_1F6A            81AF6
LAB_1F6B            81B02
LAB_1F7C            81B08
LAB_1FB4            81B36
LAB_1FD0            81B62
LAB_201E            81BBC
LAB_2043            81C0A
LAB_2044            81C3C
LAB_2045            81C46
LAB_204S            81C0C
LAB_204T            81C3A
LAB_20AE            81C58
LAB_20B4            81C5C
LAB_20BE            81C62
LAB_20C9            81C86
LAB_20CB            81C72
LAB_20D0            81C7A
LAB_20D8            81C90
LAB_20E0            81C98
LAB_2115            81CB8
LAB_2117            81CD0
LAB_2128            81CEA
LAB_2137            81CEE
LAB_214B            81D0E
LAB_2161            81D24
LAB_2176            81D2C
LAB_217E            81D3A
LAB_2183            81D54
LAB_218B            81D5C
LAB_218F            81D5E
LAB_21C2            81D6A
LAB_21C4            81D70
LAB_21D1            81DA4
LAB_2206            81DAA
LAB_2212            81DD2
LAB_2216            81D94
LAB_2240            81D9C
LAB_224D            81DD8
LAB_224E            81DEE
LAB_229E            81E32
LAB_22A0            81E3E
LAB_22B6            81E4C
LAB_22BA            81E50
LAB_22BD            81E5A
LAB_22E6            81E74
LAB_2316            81EB4
LAB_2317            81EB6
LAB_231C            81EBA
LAB_2358            81EEE
LAB_2368            81F0E
LAB_2441            82100
LAB_2445            82104
LAB_2467            82154
LAB_2468            82158
LAB_249C            82146
LAB_24A8            8215C
LAB_24B4            82186
LAB_24D0            82192
LAB_24D5            8219E
LAB_24D6            821B8
LAB_24D7            821C6
LAB_24D8            821CC
LAB_24D9            821AC
LAB_24DA            821D2
LAB_24F7            82176
LAB_24F8            8217C
LAB_2778            8243A
LAB_277C            8243C
LAB_279B            82460
LAB_27BA            8246E
LAB_27C3            8248A
LAB_27C4            82494
LAB_27CA            8249A
LAB_27CE            824A2
LAB_27D0            824A6
LAB_27DB            824B4
LAB_27F0            82770
LAB_27F1            82786
LAB_27F2            8278C
LAB_27F3            8278E
LAB_27FA            824CC
LAB_2828            824EC
LAB_282E            824F2
LAB_282F            824F4
LAB_2831            824F8
LAB_284G            8251A
LAB_284H            8252C
LAB_284J            8252E
LAB_284L            82522
LAB_2887            83132
LAB_289A            8315C
LAB_289C            83162
LAB_289D            83168
LAB_28FD            83184
LAB_28FE            8318A
LAB_28FF            83190
LAB_2900            8319E
LAB_2901            831A4
LAB_2902            831F6
LAB_2903            831FE
LAB_2904            83200
LAB_2953            8254E
LAB_295E            8255A
LAB_2967            82566
LAB_2968            8256E
LAB_2969            82580
LAB_296A            8258A
LAB_2970            825A0
LAB_2978            825B0
LAB_2989            825C0
LAB_299C            82614
LAB_29A7            8263C
LAB_29B7            82654
LAB_29B9            825EC
LAB_29C0            82662
LAB_29C3            8267A
LAB_29D9            82694
LAB_29E4            826A6
LAB_29F7            826BA
LAB_29FB            826BE
LAB_29FD            826C6
LAB_2A18            826D6
LAB_2A1A            826D8
LAB_2A21            826E0
LAB_2A3B            82700
LAB_2A4B            8270E
LAB_2A58            82722
LAB_2A68            8273A
LAB_2A74            82746
LAB_2A89            82762
LAB_2A8C            82766
LAB_2A91            8276C
LAB_2A9A            837DE
LAB_2A9B            837FA
LAB_2X01            831BC
LAB_2X02            831C4
LAB_2X03            831D2
LAB_2X04            831D8
LAB_2X05            831EE
LAB_2Y01            8320E
LAB_2Y02            83216
LAB_2Y03            83222
LAB_2Y04            83228
LAB_3216            823D4
LAB_32_16           823D2
LAB_ABER            809E8
LAB_ABS             824C4
LAB_AD              83B71
LAB_ADD             82122
LAB_ADER            809B4
LAB_AND             8175C
LAB_ASC             81F98
LAB_ATCD            82B0E
LAB_ATGO            82ACC
LAB_ATLE            82AEA
LAB_ATN             82AAE
LAB_ATNP            82B08
LAB_AYFC            81B42
LAB_BAER            839F8
LAB_BHCB            81742
LAB_BHSS            8171C
LAB_BINS            82EE6
LAB_BITCLR          82B70
LAB_BITSET          82B60
LAB_BMSG            83D3B
LAB_BS              83A9A
LAB_BTST            82B80
LAB_CALL            820E0
LAB_CASC            81832
LAB_CATN            82B14
LAB_CAUC            81838
LAB_CBIN            832E2
LAB_CBX1            832FC
LAB_CBXN            832EA
LAB_CCER            809CC
LAB_CHEX            83280
LAB_CHRS            81E7E
LAB_CHX1            832A6
LAB_CHX2            832CA
LAB_CHX3            832C2
LAB_CHXX            83288
LAB_CKRN            81B6A
LAB_CKTM            814CE
LAB_CLEAR           80CEE
LAB_CN              83B07
LAB_COLD            808EE
LAB_CONT            80EDA
LAB_CORD            82A40
LAB_COS             829D0
LAB_CRLF            8121A
LAB_CTBL            836C2
LAB_CTNM            814CC
LAB_D0              83AB8
LAB_D002            82E4A
LAB_D00A            82E5A
LAB_D00E            82E6A
LAB_DATA            80FC8
LAB_DD              83AA7
LAB_DDER            809E4
LAB_DEC             810D8
LAB_DECI            81136
LAB_DEEK            8205E
LAB_DEF             81B74
LAB_DIM             817E4
LAB_DIV0            823CC
LAB_DIVIDE          82352
LAB_DIVX            823A2
LAB_DO              80F0C
LAB_DOKE            82088
LAB_DUPFMT          82E32
LAB_DZER            809E0
LAB_EMSG            83D43
LAB_END             80E74
LAB_EOR             8174C
LAB_EQUAL           81772
LAB_ESML            828E6
LAB_EVBY            81FB0
LAB_EVEX            814E2
LAB_EVEZ            814E4
LAB_EVIN            8197E
LAB_EVIR            8198E
LAB_EVNM            814CA
LAB_EVPI            81986
LAB_EX1             8281E
LAB_EXAD            82970
LAB_EXCC            82956
LAB_EXCM            82888
LAB_EXNN            82942
LAB_EXOF            82842
LAB_EXOL            82858
LAB_EXOU            8282E
LAB_EXP             82862
LAB_EXPL            8293C
LAB_EXPS            8289A
LAB_EXRN            82948
LAB_EXXF            832D0
LAB_FB95            82F98
LAB_FBA0            82F7C
LAB_FC              83A61
LAB_FCER            809F8
LAB_FO              83B79
LAB_FOER            809B0
LAB_FOR             80DA8
LAB_FRE             81B2C
LAB_FTBL            8375E
LAB_FTPP            83712
LAB_FVAR            81850
LAB_GADB            82002
LAB_GADW            82016
LAB_GARB            81D04
LAB_GBYT            81644
LAB_GEAD            82036
LAB_GET             81194
LAB_GETS            811AE
LAB_GFPN            8109A
LAB_GOSUB           80F1E
LAB_GOTO            80F30
LAB_GOTS            80F40
LAB_GSCH            80EC0
LAB_GTBY            81FAC
LAB_GTHAN           82810
LAB_GTWO            81FC0
LAB_GVAL            815F0
LAB_GVAR            81852
LAB_HEXS            82F38
LAB_ID              83AC7
LAB_IDER            809DC
LAB_IF              80FF0
LAB_IGBY            81642
LAB_IMSG            83D54
LAB_INC             810DE
LAB_INCI            8112C
LAB_INCT            8111E
LAB_INLN            80B2E
LAB_INPUT           81308
LAB_INT             82534
LAB_IRTS            8254C
LAB_ISHN            832A2
LAB_KEYT            83864
LAB_LAAD            8224C
LAB_LCASE           81F16
LAB_LD              83B29
LAB_LDER            809C4
LAB_LEEK            82074
LAB_LEFT            81E8E
LAB_LENS            81F90
LAB_LET             8113A
LAB_LIST            80CF2
LAB_LMSG            83D4A
LAB_LOAD            820D8
LAB_LOCC            82252
LAB_LOCX            8226E
LAB_LOG             821D4
LAB_LOKE            8208E
LAB_LOLP            8225C
LAB_LONE            8228A
LAB_LONN            82272
LAB_LOOP            80F5E
LAB_LOWZ            822C4
LAB_LOXO            82290
LAB_LOXP            82280
LAB_LRMS            816FA
LAB_LS              83AE4
LAB_LSHIFT          817F0
LAB_LTHAN           8177C
LAB_LTPF            82A50
LAB_LTPT            82A60
LAB_LT_1            823E0
LAB_MADD            822F2
LAB_MAN1            823C6
LAB_MAX             82FA4
LAB_MAXN            82FB0
LAB_MIDS            81ED2
LAB_MIN             82FBA
LAB_MINN            82FC6
LAB_MKCHR           81E82
LAB_MMEC            82FD0
LAB_MNOC            822EC
LAB_MUEX            82340
LAB_MUF1            8231C
LAB_MUF2            82326
LAB_MUF3            8233C
LAB_MULTIPLY        822C6
LAB_MUUF            82346
LAB_NB1T            82418
LAB_NEW             80C9E
LAB_NEXT            81414
LAB_NF              83A28
LAB_NFER            80A08
LAB_NI              83B80
LAB_NOST            811C0
LAB_NSTT            83036
LAB_NULL            80ED0
LAB_OD              83A55
LAB_ODER            809FC
LAB_OFER            809F4
LAB_OM              83A78
LAB_OMER            809F0
LAB_ON              81066
LAB_OPPT            837AA
LAB_OR              81754
LAB_OV              83A6F
LAB_P004            82E88
LAB_P008            82E9E
LAB_P00C            82EA6
LAB_P00E            82EB2
LAB_P010            82EB6
LAB_P018            82ED0
LAB_P01A            82ED4
LAB_P01E            82EDC
LAB_PEEK            8204C
LAB_PFAC            82422
LAB_PHFA            82FE0
LAB_PI              83112
LAB_POKE            82058
LAB_POON            82790
LAB_POS             81B5E
LAB_POWER           827AC
LAB_POWP            827DE
LAB_POZE            827A0
LAB_PPBI            816F0
LAB_PPFN            816E2
LAB_PPFS            816D4
LAB_PRINT           811CE
LAB_PRNA            81292
LAB_PROCFO          82E70
LAB_P_10            83454
LAB_RAM             83108
LAB_READ            8132E
LAB_REDO            83D64
LAB_REM             8105E
LAB_REMM            823F8
LAB_RESS            80EB4
LAB_RESTORE         80EA2
LAB_RET0            8326E
LAB_RETURN          80FB4
LAB_RG              83A40
LAB_RGER            80A00
LAB_RIGHT           81EA2
LAB_RMSG            83D76
LAB_RND             8297C
LAB_RSED            8336C
LAB_RSHIFT          81800
LAB_RTN0            83270
LAB_RTST            81C9E
LAB_RUN             80EF8
LAB_RUNN            80F06
LAB_SADD            81F78
LAB_SAVE            820DC
LAB_SCCA            8163A
LAB_SCER            809D0
LAB_SCGB            81634
LAB_SCL0            82A36
LAB_SCLN            80C8C
LAB_SCZE            82A28
LAB_SET1            823AA
LAB_SGBY            81FA8
LAB_SGN             824B2
LAB_SIN             829E8
LAB_SIZOK           808FE
LAB_SLER            809D4
LAB_SMSG            83D80
LAB_SN              83A39
LAB_SNBS            80FCE
LAB_SNER            80A04
LAB_SQE1            830BA
LAB_SQE2            830C0
LAB_SQNA            830E8
LAB_SQNS            830D2
LAB_SQR             83096
LAB_SSLN            80C84
LAB_ST              83AF4
LAB_STOP            80E7C
LAB_STRS            81C54
LAB_SUBTRACT        8210E
LAB_SVAR            8184E
LAB_SVTB            83068
LAB_SWAP            820A2
LAB_TAN             829AE
LAB_TBSZ            83048
LAB_TM              83AD6
LAB_TMER            809D8
LAB_TWOPI           83122
LAB_U002            82BD8
LAB_U004            82C2E
LAB_U005            82C3E
LAB_U006            82C40
LAB_U008            82C54
LAB_U009            82C76
LAB_U00A            82C7E
LAB_U00B            82C88
LAB_U00C            82C9C
LAB_U00D            82CA0
LAB_U00E            82CB2
LAB_U00F            82CBE
LAB_U010            82CC2
LAB_U014            82CC8
LAB_U018            82CD0
LAB_U01C            82CE6
LAB_U020            82CF2
LAB_U022            82CF8
LAB_U026            82D08
LAB_U02A            82D12
LAB_U02B            82D2A
LAB_U02C            82D30
LAB_U02E            82D42
LAB_U030            82D46
LAB_U034            82D5C
LAB_U036            82D62
LAB_U038            82D6A
LAB_U03C            82D72
LAB_U03E            82D78
LAB_U040            82D90
LAB_U044            82DA0
LAB_U046            82DC8
LAB_U048            82DCA
LAB_U04A            82DD4
LAB_U04C            82E06
LAB_UA              83B4C
LAB_UCASE           81F46
LAB_UDER            809BC
LAB_UF              83B16
LAB_UFAC            82406
LAB_UFER            809C8
LAB_US              83A86
LAB_USER            809EC
LAB_USINGS          82BAE
LAB_USR             820D0
LAB_UV              83B39
LAB_UVER            809C0
LAB_VAL             81FD4
LAB_VALZ            81FFC
LAB_VARCALL         830FA
LAB_VARPTR          830F8
LAB_WAIT            820EA
LAB_WARM            400
LAB_WD              83B60
LAB_WDER            809B8
LAB_WDLP            8307C
LAB_WDTH            83016
LAB_XDIV            823BA
LAB_XERR            80A0A
LAB_XGADW           82030
LC_LOOP             81F2C
LOOPALWAYS          80F9A
LOOPDONE            80FAE
LVARPL              472
L_DDIV              82400
L_DIVRND            823AE
MAINLOOP            82A78
N                   2
NEXTA               82A8A
NEXTB1              82EF6
NEXTB2              82F1C
NEXTH1              82F48
NEXTPRN             8298A
NINC0               82992
NINC1               82998
NOBRK               0
NOLCASE             81F6E
NOSHIFT             817FC
NOSTRING            81F74
NOT2BIG             81814
NOUCASE             81F3E
NOVAR               0
NULLCT              5E4
NUMEXP              5AC
OFCHR               23
OQUOTE              5DD
OUTLOOP             82A98
PRG_STRT            5F0
PRNLWORD            5A0
PRSTK               5D8
RAM_ADDR            2000
RAM_BASE            400
RAM_SIZE            7E000
RAM_STRT            0
RDPTRL              466
RTS_001             8165E
RTS_005             80CEC
RTS_006             80ECE
RTS_007             80FCC
RTS_007A            80FE2
RTS_008             81192
RTS_009             8128E
RTS_011             81B06
RTS_012             81DD6
RTS_013             81E4A
RTS_015             820A0
RTS_016             8217A
RTS_017             82498
RTS_020             8281C
RTS_021             82B5E
RTS_022             82F86
RTS_023             83094
RTS_024             832E0
RTS_025             83342
RXNOTREADY          80844
SARRYL              43E
SFNCL               432
SMEML               42E
SSTORL              446
SSTRL               43A
SUBEXIT             82AA2
SUBLOOP             82A70
SUFNXF              5DF
SUTILL              44E
SVARL               436
TABSIZ              5E2
TAB_ASCA            83BA4
TAB_ASCB            83BB4
TAB_ASCC            83BCD
TAB_ASCD            83BE4
TAB_ASCE            83BFD
TAB_ASCF            83C0C
TAB_ASCG            83C16
TAB_ASCH            83C23
TAB_ASCI            83C29
TAB_ASCL            83C38
TAB_ASCM            83C66
TAB_ASCN            83C74
TAB_ASCO            83C83
TAB_ASCP            83C88
TAB_ASCR            83C9D
TAB_ASCS            83CC7
TAB_ASCT            83CF2
TAB_ASCU            83D06
TAB_ASCV            83D1E
TAB_ASCW            83D2A
TAB_ATNC            835C2
TAB_CHRT            837FA
TAB_EQUL            83B9C
TAB_HTHET           83642
TAB_LESS            83B98
TAB_MNUS            83B94
TAB_MORE            83B9E
TAB_PLUS            83B92
TAB_POWR            83D39
TAB_QEST            83BA2
TAB_SLAS            83B96
TAB_SNCO            83542
TAB_STAR            83B90
TK_ABS              C1
TK_AND              B7
TK_ASC              D3
TK_ATN              CC
TK_BINS             D8
TK_BITCLR           A7
TK_BITSET           A6
TK_BITTST           D9
TK_CALL             9B
TK_CHRS             D6
TK_CLEAR            A1
TK_CONT             9F
TK_COS              C9
TK_DATA             83
TK_DEC              88
TK_DEEK             CE
TK_DEF              97
TK_DIM              85
TK_DIV              B5
TK_DO               9C
TK_DOKE             99
TK_ELSE             A9
TK_END              80
TK_EOR              B8
TK_EQUAL            BD
TK_EXP              C8
TK_FN               AB
TK_FOR              81
TK_FRE              C3
TK_GET              A4
TK_GOSUB            8D
TK_GOTO             89
TK_GT               BC
TK_HEXS             D7
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              C0
TK_LCASES           D5
TK_LEEK             CF
TK_LEFTS            E1
TK_LEN              D0
TK_LET              87
TK_LIST             A0
TK_LOAD             95
TK_LOG              C7
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           BB
TK_LT               BE
TK_MAX              DA
TK_MIDS             E3
TK_MIN              DB
TK_MINUS            B3
TK_MULT             B4
TK_NEW              A2
TK_NEXT             82
TK_NOT              AE
TK_NULL             92
TK_ON               91
TK_OR               B9
TK_PEEK             CD
TK_PI               DD
TK_PLUS             B2
TK_POKE             98
TK_POS              C4
TK_POWER            B6
TK_PRINT            9E
TK_RAM              DC
TK_READ             86
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           E2
TK_RND              C6
TK_RSHIFT           BA
TK_RUN              8A
TK_SADD             E0
TK_SAVE             96
TK_SGN              BF
TK_SIN              CA
TK_SPC              AC
TK_SQR              C5
TK_STEP             AF
TK_STOP             90
TK_STRS             D1
TK_SWAP             A5
TK_TAB              A8
TK_TAN              CB
TK_THEN             AD
TK_TO               AA
TK_TWOPI            DE
TK_UCASES           D4
TK_UNTIL            B0
TK_USINGS           E4
TK_USR              C2
TK_VAL              D2
TK_VPTR             DF
TK_WAIT             94
TK_WHILE            B1
TK_WIDTH            A3
TOOBIG              8181A
TPOS                5E5
TPOWER              5D9
TWIDTH              5E6
TXNOTREADY          8080E
UC_LOOP             81F5C
USDSS               5CC
USRJMP              406
USRJPV              408
UT1_PL              5A4
VARNAME             46A
VEC_CC              82F62
VEC_IN              80822
VEC_LD              8084E
VEC_OUT             80804
VEC_SV              80854
V_CTLC              424
V_CTLCV             426
V_INPT              40C
V_INPTV             40E
V_LOAD              418
V_LOADV             41A
V_OUTP              412
V_OUTPV             414
V_SAVE              41E
V_SAVEV             420
WEXIT               8306C
WRMJPV              402
|                   546B78
