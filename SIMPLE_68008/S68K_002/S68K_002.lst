68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Land Boards, LLC
   4               	|	(c) 2024
   5               	| Use it however you want
   6               	| Borrowed init code from 
   7               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   8               	|
   9               	| Added S-Record load code
  10               	|	Uses SRAM from 0x400-0x407
  11               	
  12               	RAM_START	= 0x00000	| Beginning of the SRAM
  13               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
  14               	RAM_END		= 0x7FFFF	| 512KB SRAM
  15               	ROM_START	= 0x80000	| ROM start
  16               	ROM_CODE	= ROM_START+1024| Skip vector table
  17               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  18               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  19               	
  20               	|||||||||||||||||||||||||||||||||
  21               	| 68681 Duart Register Addresses
  22               	|
  23               	DUART = 0x0F0000	  | Base Addr of DUART
  24               	MRA   = DUART+0		  | Mode Register A           (R/W)
  25               	SRA   = DUART+2       | Status Register A         (r)
  26               	CSRA  = DUART+2       | Clock Select Register A   (w)
  27               	CRA   = DUART+4       | Commands Register A       (w)
  28               	RBA   = DUART+6       | Receiver Buffer A         (r)
  29               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  30               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  31               	ISR   = DUART+10      | Interrupt Status Register (R)
  32               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  33               	MRB   = DUART+16      | Mode Register B           (R/W)
  34               	SRB   = DUART+18      | Status Register B         (R)
  35               	CSRB  = DUART+18      | Clock Select Register B   (W)
  36               	CRB   = DUART+20      | Commands Register B       (W)
  37               	RBB   = DUART+22      | Reciever Buffer B         (R)
  38               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  39               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  40               	OPC   = DUART+26      | Output port config        (W)
  41               	INU   = DUART+26      | Input port (unlatched)    (R)
  42               	OPS   = DUART+28      | Output port Set           (W)
  43               	OPR   = DUART+30      | Output port Clear         (W)
  44               	
  45               	||||||||||||||||||||||||||||||||||
  46               	| ASCII Control Characters
  47               	|
  48               	BEL   = 0x07
  49               	BKSP  = 0x08       | CTRL-H
  50               	TAB   = 0x09
  51               	LF    = 0x0A
  52               	CR    = 0x0D
  53               	ESC   = 0x1B
  54               	EOT	  = 0x00
  55               	
  56               	CTRLC	=	0x03
  57               	CTRLX	=	0x18     | Line Clear
68K GAS  S68K_002.s 			page 2


  58               	
  59 0000 0000 0000 		.ORG    0x000400
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  60 0400 00        	_srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  61 0401 00        	_srecByCt:	ds.b	1		| Byte Count
  62 0402 00        	_srecData:	ds.b	1 		| Data
  63 0403 00        	_srecCSum:	ds.b	1 		| S-Record Checksum
  64 0404 0000 0000 	_srecAddr:	ds.l	1		| S Record current byte address
  65               	
  66               	srecType	=		0x000400	| S1-S9 stored as binary 1-9
  67               	srecByCt	=		0x000401	| Byte Count
  68               	srecData	=		0x000402	| Data
  69               	srecCSum	=		0x000403	| S-Record Checksum
  70               	srecAddr	=		0x000404	| S Record current byte address
  71               	
  72 0408 0000 0000 		.ORG	ROM_START
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  73               	
  74               	| FIRST 8 bytes loaded after reset |
  75 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  76 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  77               	
  78 80008 0000 0000 	        .ORG ROM_CODE
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  79 80400 4E71      		nop
  80 80402 4FF9 0007 		lea		STACK_END, %sp
  80      FFFC 
  81 80408 4DF9 0007 		lea		STACK_END-128, %fp	| Plenty of room for the monitor's stack
  81      FF7C 
  82               									| Need frame pointer for running C code
  83 8040e 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  83      0008 0000 
  84 80416 4E71      		nop
  85               	| LEDs
  86 80418 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  86      000F 001A 
  87 80420 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  87      000F 001E 
  88 80428 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  88      000F 001C 
  89               	|
  90               	| Test the first two SRAM location
  91               	|
  92 80430 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  92      BEEF 
  93 80436 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  94 8043a 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  95 8043c 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
68K GAS  S68K_002.s 			page 3


  96 8043e B042      		cmp			%d2, %d0
  97 80440 6600 00C6 		bne			FERVR2						
  98 80444 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  98      AAAA 
  99 8044a 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
 100 8044e 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
 101 80450 2611      		move.l	(%a1), %d3				| Read back
 102 80452 B243      		cmp			%d3, %d1
 103 80454 6600 00B2 		bne			FERVR2
 104 80458 4E71      		nop
 105               	| Test bits of first location (as bytes)
 106 8045a 7001      		move.l	#1, %d0
 107 8045c 207C 0000 		move.l	#0, %a0
 107      0000 
 108               	loop1stLoc:
 109 80462 1080      		move.b	%d0, (%a0)
 110 80464 1210      		move.b	(%a0), %d1
 111 80466 B200      		cmp.b		%d0, %d1
 112 80468 6600 009E 		bne			failBitTest
 113 8046c E348      		lsl			#1, %d0
 114 8046e 0C80 0000 		cmp.l		#0x00000100, %d0
 114      0100 
 115 80474 6600 FFEC 		bne			loop1stLoc
 116               	|
 117               	| Test all address lines, 512KB SRAM
 118               	| Write incrementing pattern to data bits
 119               	|
 120 80478 7001      		move.l	#1, %d0		| Fill pattern
 121 8047a 7401      		move.l	#1, %d2
 122 8047c 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 122      0001 
 123               	loopAdrFill:
 124 80482 1080      		move.b	%d0,(%a0)	| Do the write
 125 80484 5240      		addq		#1, %d0		| Increment the pattern
 126 80486 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 127 80488 E38A      		lsl.l		#1, %d2		| Shift temp addr
 128 8048a 2042      		move.l	%d2, %a0	| Put back into addr reg
 129 8048c 0C82 0008 		cmp.l		#0x00080000,%d2
 129      0000 
 130 80492 6600 FFEE 		bne			loopAdrFill
 131               	| Check
 132 80496 7001      		move.l	#1, %d0
 133 80498 7401      		move.l	#1, %d2
 134 8049a 207C 0000 		move.l	#1, %a0
 134      0001 
 135               	loopAdrCk:
 136 804a0 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 137 804a2 B200      		cmp.b		%d0, %d1
 138 804a4 6600 0062 		bne			failAdrTest
 139 804a8 5240      		addq		#1, %d0
 140 804aa 2408      		move.l	%a0, %d2 
 141 804ac E38A      		lsl.l		#1, %d2
 142 804ae 2042      		move.l	%d2, %a0
 143 804b0 0C82 0008 		cmp.l		#0x00080000,%d2
 143      0000 
 144 804b6 6600 FFE8 		bne			loopAdrCk
 145               		
68K GAS  S68K_002.s 			page 4


 146               	|
 147               	| Fill SRAM with 0x00 values
 148               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 149               	|
 150               	fillSRAM:
 151 804ba 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 152 804be 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 152      FFFF 
 153 804c4 7000      		move.l	#0x00, %d0			| Fill with zeros
 154               	fillSRAMLoop:
 155 804c6 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 156 804c8 B3C8      		cmpa.l	%a0, %a1
 157 804ca 6E00 FFFA 		bgt		fillSRAMLoop
 158               	
 159               	|
 160               	| Done with address test of SRAM
 161               	|
 162 804ce 4EBA 05BA 		jsr     initDuart       	| Setup the serial port
 163               	monitorStart:					| Warm start
 164 804d2 41FA 06A5 		lea		BANNER_MSG, %a0
 165 804d6 4EBA 005E 		jsr		printString1
 166 804da 41FA 0688 		lea		RAM_PASS_MSG, %a0
 167 804de 4EBA 0056 		jsr		printString1
 168               	|
 169               	| Interpreter Loop
 170               	|
 171               	interpLoop:
 172 804e2 41FA 0743 	    lea     msgPrompt, %a0	| Prompt
 173 804e6 6100 004E 	    bsr.w   printString
 174 804ea 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 174      000F 001E 
 175 804f2 4EBA 0074 		jsr		readLine		| Blocking read of line
 176 804f6 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 176      000F 001C 
 177 804fe 4EBA 00FA 		jsr		lineToUpper
 178 80502 4EBA 0114 		jsr		parseLine
 179 80506 60DA      		bra.s	interpLoop
 180               		
 181               	failBitTest:
 182               	failAdrTest:
 183               	FERVR2:
 184 80508 4E71      		nop
 185 8050a 4EFA FFFC 		jmp	FERVR2
 186               	
 187               	|||||
 188               	| Writes a character to Port A, blocking if not ready (Full buffer)
 189               	|  - Takes a character in D0
 190               	outChar1:
 191               	outChar:
 192 8050e 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 192      000F 0002 
 193 80516 6700 FFF6 	    beq     outChar1     
 194 8051a 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 194      0006 
 195 80520 4E75      	    rts
 196               	
 197               	| Writes a character to Port A, blocking if not ready (Full buffer)
68K GAS  S68K_002.s 			page 5


 198               	|  - Takes a character in D0
 199               	outChar2:
 200 80522 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 200      000F 0012 
 201 8052a 6700 FFF6 	    beq     outChar2     
 202 8052e 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 202      0016 
 203 80534 4E75      	    rts
 204               	
 205               	******
 206               	* Print a null terminated string
 207               	*
 208               	printString1:
 209               	printString:
 210               	PSloop:
 211 80536 1018      	    move.b  (%a0)+, %d0  | Read in character
 212 80538 6704      	    beq.s   PSend         | Check for the null
 213               	    
 214 8053a 61D2      	    bsr.s   outChar      | Otherwise write the character
 215 8053c 60F8      	    bra.s   PSloop        | And continue
 216               	PSend:
 217 8053e 4E75      	    rts
 218               	
 219               	
 220               	|||||
 221               	| Reads in a character from Port A, blocking if none available
 222               	|  - Returns character in D0
 223               	|    
 224               	inChar1:
 225               	inChar:
 226 80540 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 226      000F 0002 
 227 80548 6700 FFF6 	    beq     inChar1
 228 8054c 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 228      0006 
 229 80552 4E75      	    rts
 230               	
 231               	inChar2:
 232 80554 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 232      000F 0012 
 233 8055c 6700 FFF6 	    beq     inChar2
 234 80560 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 234      0016 
 235 80566 4E75      	    rts
 236               	
 237               	| Read in a line into the line buffer
 238               	readLine:
 239 80568 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 240 8056c 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 240      FBAE 
 241 80572 B542      	    eor.w   %d2, %d2           	| Clear the character counter
 242               	 RLloop:
 243 80574 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 244 80578 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 245 8057c 6722      	    beq.s   RLBS
 246 8057e 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 247 80582 673A      	    beq.s   RLlineClr
68K GAS  S68K_002.s 			page 6


 248 80584 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 249 80588 6758      	    beq.s   RLEndLn
 250 8058a 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 251 8058e 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 252               	 .char:                      	| Normal character to be inserted into the buffer
 253 80590 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 254 80594 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 255 80596 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 256 80598 5242      	    addq.w  #1, %d2           	| Increment character count
 257 8059a 6100 FF72 	    bsr.w   outChar          	| Echo the character
 258 8059e 60D4      	    bra.s   RLloop            	| And get the next one
 259               	 RLBS:
 260 805a0 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 261 805a2 67D0      	    beq.s   RLloop            	| Then ignore it
 262 805a4 6100 FF68 	    bsr.w   outChar          	| Backspace
 263 805a8 103C 0020 	    move.b  #' ', %d0
 264 805ac 6100 FF60 	    bsr.w   outChar          	| Space
 265 805b0 103C 0008 	    move.b  #BKSP, %d0
 266 805b4 6100 FF58 	    bsr.w   outChar          	| Backspace
 267 805b8 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 268 805ba 5382      	    subq.l  #1, %d2           	| And current character count
 269 805bc 60B6      	    bra.s   RLloop            	| And goto the next character
 270               	 RLlineClr:
 271 805be 4A42      	    tst     %d2               	| Anything to clear?
 272 805c0 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 273 805c2 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 274               	 RLlineClrloop:
 275 805c4 103C 0008 	    move.b  #BKSP, %d0
 276 805c8 6100 FF44 	    bsr.w   outChar          	| Backspace
 277 805cc 103C 0020 	    move.b  #' ', %d0
 278 805d0 6100 FF3C 	    bsr.w   outChar          	| Space
 279 805d4 103C 0008 	    move.b  #BKSP, %d0
 280 805d8 6100 FF34 	    bsr.w   outChar          	| Backspace
 281 805dc 5342      	    subq.w  #1, %d2          
 282 805de 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 283 805e0 6092      	    bra.s   RLloop   
 284               	 RLEndLn:
 285 805e2 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 286 805e6 103C 000A 	    move.b  #LF, %d0
 287 805ea 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 288 805ee 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 289 805f2 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 290 805f4 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 291 805f8 4E75      	    rts                      	| And return
 292               	
 293               	
 294               	| Convert line buffer to upper case
 295               	lineToUpper:
 296 805fa 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 296      FBAE 
 297               	 LUloop:
 298 80600 1010      	    move.b  (%a0), %d0        | Read in a character
 299 80602 0C00 0061 	    cmp.b   #'a', %d0         
 300 80606 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 301 80608 0C00 007A 	    cmp.b   #'z', %d0
 302 8060c 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 303 8060e 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
68K GAS  S68K_002.s 			page 7


 304               	 LUnext:
 305 80612 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 306 80614 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 307 80616 4E75      	    rts
 308               	
 309               	|
 310               	| Parse Line
 311               	|
 312               	parseLine:
 313 80618 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 314 8061c 41F9 0007 	    lea     varLineBuf, %a0
 314      FBAE 
 315               	 PLfindCommand:
 316 80622 1018      	    move.b  (%a0)+, %d0
 317 80624 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 318 80628 6700 FFF8 	    beq.w   PLfindCommand    
 319 8062c 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 320 80630 6700 0062 	    beq.w   .examine
 321 80634 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 322 80638 6700 0372 	    beq.w   .deposit
 323 8063c 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 324 80640 6700 03CE 	    beq.w   .run
 325 80644 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 326 80648 6700 0026 	    beq.w   .help
 327 8064c 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 328 80650 6700 00DE 	    beq.w   loadSRec
 329 80654 0C00 0042 		cmp.b	#'B', %d0           | BASIC
 330 80658 6700 00C4 		beq		.runBASIC
 331 8065c 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 332 80660 6708      	    beq.s   .exit               
 333               	 .invalid:   
 334 80662 41FA 052E 	    lea     msgInvalidCommand, %a0
 335 80666 6100 FECE 	    bsr.w   printString
 336               	 .exit:
 337 8066a 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 338 8066e 4E75      	    rts
 339               	
 340               	
 341               	|||||||||||||||||||||||||||||||
 342               	|| HELP command
 343               	 .help:
 344 80670 41FA 0535 	    lea     msgHelp, %a0
 345 80674 6100 FEC0 	    bsr.w   printString
 346 80678 6000 FFF0 	    bra.w   .exit
 347               	 .invalidAddr:
 348 8067c 41FA 0587 	    lea     msgInvalidAddress, %a0
 349 80680 6100 FEB4 	    bsr.w   printString
 350 80684 6000 FFE4 	    bra.w   .exit
 351               	 .invalidVal:
 352 80688 41FA 058D 	    lea     msgInvalidValue, %a0
 353 8068c 6100 FEA8 	    bsr.w   printString
 354 80690 6000 FFD8 	    bra.w   .exit
 355               		
 356               	|||||||||||||||||||||||||||||||
 357               	| Examines memory addresses
 358               	| Valid modes:
 359               	|   e ADDR                  Displays a single byte
68K GAS  S68K_002.s 			page 8


 360               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 361               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 362               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 363               	|   e ADDR.                 Quick line, displays one line 
 364               	.examine:
 365 80694 6100 021A 	    bsr.w   parseNumber         | Read in the start address
 366 80698 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 367 8069a 6600 FFE0 	    bne.w   .invalidAddr        
 368 8069e 2640      	    move.l  %d0, %a3            | Save the start address
 369               	 .exloop:
 370 806a0 1018      	    move.b  (%a0)+, %d0
 371 806a2 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 372 806a6 67F8      	    beq.s   .exloop
 373 806a8 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 374 806ac 6716      	    beq.s   .exrange
 375 806ae 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 376 806b2 6722      	    beq.s   .exlength
 377 806b4 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
 378 806b8 672E      	    beq.s   .exinter
 379 806ba 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 380 806be 6712      	    beq.s   .exquick
 381 806c0 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 382 806c2 601C      	    bra.s   .exend              
 383               	 .exrange:
 384 806c4 6100 01EA 	    bsr.w   parseNumber         | Find the end address
 385 806c8 4A01      	    tst.b   %d1                 | Check if we found a valid address
 386 806ca 6600 FFB0 	    bne.w   .invalidAddr
 387 806ce 908B      	    sub.l   %a3, %d0            | Get the length
 388 806d0 600E      	    bra.s   .exend
 389               	 .exquick:                      | Quick mode means show one line of 16 bytes
 390 806d2 7010      	    move.l  #0x10, %d0
 391 806d4 600A      	    bra.s   .exend
 392               	 .exlength:                     | Length mode means a length is specified
 393 806d6 6100 01D8 	    bsr.w   parseNumber         | Find the length
 394 806da 4A01      	    tst.b   %d1
 395 806dc 6600 FF9E 	    bne.w   .invalidAddr
 396               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 397 806e0 204B      	    move.l  %a3, %a0
 398 806e2 6100 022E 	    bsr.w   dumpRAM
 399 806e6 6082      	    bra.s   .exit
 400               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 401 806e8 204B      	    move.l  %a3, %a0            | Current Address
 402 806ea 7010      	    move.l  #0x10, %d0          | 16 bytes
 403 806ec 6100 0224 	    bsr.w   dumpRAM             | Dump this line
 404 806f0 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 404      0010 
 405               	 .exinterend:
 406 806f6 6100 FE48 	    bsr.w   inChar
 407 806fa 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 408 806fe 67E8      	    beq.s   .exinter
 409 80700 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 410 80704 6704      	    beq.s   .exinterpage
 411 80706 6000 FF62 	    bra	   .exit               | Otherwise exit
 412               	 .exinterpage:
 413 8070a 204B      	    move.l  %a3, %a0
 414 8070c 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 414      0100 
68K GAS  S68K_002.s 			page 9


 415 80712 6100 01FE 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 416 80716 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 416      0100 
 417 8071c 60D8      	    bra.s   .exinterend
 418               	
 419               	BasicStart = 0x84800
 420               	.runBASIC:
 421 8071e 41F9 0008 		lea		BasicStart, %a0
 421      4800 
 422 80724 3010      		move.w	(%a0),%d0
 423 80726 0C40 6056 		cmp.w	#0x6056, %d0
 424 8072a 6602      		bne.s	skipBasic			| Not supported
 425 8072c 4E90      		jsr		(%a0)
 426               	skipBasic:
 427 8072e 4E75      		rts
 428               	
 429               	|||||||||||||||||||||||||||||
 430               	|| Load S Record
 431               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 432               	|	srecByCt:	ds.b	1		| Byte Count
 433               	|	srecData:	ds.b	1 		| Data
 434               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 435               	|	srecAddr:	ds.l	1		| S Record current byte address
 436               	|
 437               	| Supports S record types (matches gcc m68k output)
 438               	|	S00F00005336384B5F3030322E746D7074
 439               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 440               	|	S503005BA1
 441               	|
 442               	| Also supports S1 records
 443               	|	S00F00005336384B5F3030332E746D7073
 444               	|	S123100013FC0000000F001A13FC00FC000F001E13FC0004000F001C13FC0004000F001EDE
 445               	|	S1231020203C000186A053806600FFFC13FC0004000F001C203C000186A053806600FFFC00
 446               	|	S10710406000FFD673
 447               	|	S5030003F9
 448               	|
 449               	
 450               	loadSRec:
 451 80730 41FA 04C3 	    lea     ldSRecMsg, %a0					| "Load S-Record"
 452 80734 6100 FE00 	    bsr.w   printString
 453               	loadSRecLoop:
 454 80738 6100 0096 		bsr		setRecType
 455 8073c 6100 00AC 		bsr		setBytCt
 456 80740 11FC 0000 		move.b 	#0, srecCSum
 456      0403 
 457 80746 6100 00EC 		bsr		setAddr
 458               	|	lea		debug_Srec_LDData_Msg, %a0		| "Load Data Loop start"
 459               	|	bsr		printString
 460 8074a 0C38 0001 		cmp.b	#1, srecType			| 16-bit Address
 460      0400 
 461 80750 6700 0010 		beq		loopSData
 462 80754 0C38 0002 		cmp.b	#2, srecType			| 24-bit Address
 462      0400 
 463 8075a 6700 0006 		beq		loopSData
 464 8075e 6000 0014 		bra		sRecDataDone
 465               	loopSData:
 466 80762 0C38 0000 		cmp.b 	#0, srecByCt
68K GAS  S68K_002.s 			page 10


 466      0401 
 467 80768 6700 000A 		beq		sRecDataDone
 468 8076c 6100 003E 		bsr		getSetLdData
 469 80770 6000 FFF0 		bra		loopSData
 470               	sRecDataDone:
 471 80774 6100 0050 		bsr		getChksum
 472 80778 103C 002B 		move.b	#'+', %d0
 473 8077c 6100 FD90 		bsr		outChar
 474 80780 0C38 0000 		cmp.b	#0, srecType
 474      0400 
 475 80786 6700 FFB0 		beq		loadSRecLoop
 476 8078a 0C38 0001 		cmp.b	#1, srecType
 476      0400 
 477 80790 6700 FFA6 		beq		loadSRecLoop
 478 80794 0C38 0002 		cmp.b	#2, srecType
 478      0400 
 479 8079a 6700 FF9C 		beq		loadSRecLoop
 480 8079e 0C38 0003 		cmp.b	#3, srecType
 480      0400 
 481 807a4 6700 FF92 		beq		loadSRecLoop
 482 807a8 6000 FEC0 		bra.w   .exit
 483               	
 484               	|||||||||||||||||||||||||||||
 485               	getSetLdData:
 486 807ac 4EBA 004E 		jsr		getHexPair
 487 807b0 41F8 0404 		lea 	srecAddr, %a0
 488 807b4 2250      		move.l	(%a0), %a1
 489 807b6 12C0      		move.b	%d0, (%a1)+
 490 807b8 21C9 0404 		move.l	%a1, srecAddr
 491 807bc D138 0403 		add.b	%d0, srecCSum
 492 807c0 5338 0401 		sub.b	#1, srecByCt
 493               	skipLdData:
 494 807c4 4E75      		rts
 495               	
 496               	|||||||||||||||||||||||||||||
 497               	getChksum:
 498               	|	lea		debug_Srec_CSum_Msg, %a0	| "S Record Checksum="
 499               	|	bsr.w   printString
 500 807c6 4EBA 0034 		jsr		getHexPair
 501 807ca D138 0403 		add.b	%d0, srecCSum
 502               	|	move.b	srecCSum, %d0
 503               	|	jsr		printHexByte
 504               	|	lea		CRLF_MSG, %a0
 505               	|	bsr.w   printString
 506               	failCSUM:
 507 807ce 4E75      		rts
 508               	
 509               	|||||||||||||||||||||||||||||
 510               	setRecType:
 511 807d0 4EBA FD6E 		jsr		inChar
 512 807d4 0C00 0053 		cmp.b	#'S', %d0
 513 807d8 6600 FFF6 		bne		setRecType					| Toss extra chars
 514 807dc 4EBA FD62 		jsr		inChar
 515 807e0 0200 000F 		andi.b	#0x0f, %d0
 516 807e4 11C0 0400 		move.b	%d0, srecType
 517               	| Debug messages follow
 518               	|	lea		debug_Srec_Typ_Msg, %a0		| "S Record Type="
68K GAS  S68K_002.s 			page 11


 519               	|	bsr.w   printString
 520               	|	move.b	srecType, %d0
 521               	|	add.b	#'0', %d0
 522               	|	jsr		outChar
 523               	|	lea		CRLF_MSG, %a0
 524               	|	bsr.w   printString
 525               	| Debug messages end
 526 807e8 4E75      		rts
 527               		
 528               	|||||||||||||||||||||||||||||
 529               	setBytCt:
 530 807ea 4EBA 0010 		jsr		getHexPair
 531 807ee 11C0 0403 		move.b 	%d0, srecCSum				| Initialize checksum
 532 807f2 11C0 0401 		move.b	%d0, srecByCt				| Byte count
 533               	| Debug messages follow
 534               	|	lea		debug_Srec_BytCt_Msg, %a0	| "S Record Byte Count=0x"
 535               	|	bsr.w   printString
 536               	|	move.b	srecByCt, %d0
 537               	|	jsr		printHexByte
 538               	|	lea		CRLF_MSG, %a0
 539               	|	bsr		printString
 540               	| Debug messages end
 541 807f6 5338 0401 		sub.b	#1, srecByCt
 542 807fa 4E75      		rts
 543               	
 544               	|||||||||||||||||||||||||||||
 545               	getHexPair:
 546 807fc 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 547 80800 4EBA FD3E 		jsr		inChar
 548 80804 4EBA 0016 		jsr		toNibble
 549 80808 E900      		asl.b	#4, %d0
 550 8080a 1400      		move.b	%d0, %d2
 551 8080c 4EBA FD32 		jsr		inChar
 552 80810 4EBA 000A 		jsr		toNibble
 553 80814 8002      		or.b	%d2, %d0
 554 80816 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 555 8081a 4E75      		rts
 556               	
 557               	|||||||||||||||||||||||||||||
 558               	toNibble:
 559 8081c 0C00 0041 		cmp.b	#'A', %d0
 560 80820 6C00 0008 		bge		doHexLetter
 561 80824 0400 0030 		sub.b	#'0', %d0
 562 80828 4E75      		rts
 563               	doHexLetter:
 564 8082a 0400 0041 		sub.b	#'A', %d0
 565 8082e 0600 000A 		add.b	#10, %d0
 566 80832 4E75      		rts
 567               	
 568               	|||||||||||||||||||||||||||||
 569               	setAddr:
 570 80834 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 571 80838 0C38 0002 		cmp.b	#2, srecType
 571      0400 
 572 8083e 6600 0052 		bne		adrLen16
 573 80842 21FC 0000 		move.l	#0, srecAddr
 573      0000 0404 
68K GAS  S68K_002.s 			page 12


 574               	|	lea		debug_S2rec_Addr_Msg, %a0
 575               	|	bsr		printString
 576 8084a 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 577               		| Get the upper 8-bits of 24-bits
 578 8084c 4EBA FFAE 		jsr		getHexPair
 579 80850 0280 0000 		and.l	#0xff, %d0
 579      00FF 
 580 80856 D138 0403 		add.b 	%d0, srecCSum
 581 8085a 8480      		or.l	%d0, %d2
 582 8085c E182      		asl.l	#8, %d2
 583               	|	move.l	%d2, %d0
 584               	|	bsr		printHexLong
 585               	|	lea		CRLF_MSG, %a0
 586               	|   bsr.w   printString
 587               		| Get the middle 8-bits of 24-bits
 588 8085e 4EBA FF9C 		jsr		getHexPair
 589 80862 0280 0000 		and.l	#0xff, %d0
 589      00FF 
 590 80868 D138 0403 		add.b 	%d0, srecCSum
 591 8086c 8480      		or.l	%d0, %d2
 592 8086e E182      		asl.l	#8, %d2
 593               	|	move.l	%d2, %d0
 594               	|	bsr		printHexLong
 595               	|	lea		CRLF_MSG, %a0
 596               	|   bsr.w   printString
 597               		| Get the lower 8-bits of 24-bits
 598 80870 4EBA FF8A 		jsr		getHexPair
 599 80874 0280 0000 		and.l	#0xff, %d0
 599      00FF 
 600 8087a D138 0403 		add.b 	%d0, srecCSum
 601 8087e 8480      		or.l	%d0, %d2
 602 80880 0282 00FF 		andi.l	#0x00ffffff, %d2
 602      FFFF 
 603 80886 21C2 0404 		move.l	%d2, srecAddr		| Save the S record address
 604               	|	move.l	%d2, %d0
 605               	|	bsr		printHexLong
 606               	|	lea		CRLF_MSG, %a0
 607               	|	bsr.w   printString
 608 8088a 5738 0401 		sub.b	#3, srecByCt
 609 8088e 6000 001A 		bra		past16
 610               	adrLen16:
 611               	|	lea		debug_SXrec_Addr_Msg, %a0	| "S (not 2) Record Address=0x"
 612               	|	bsr		printString
 613 80892 7400      		move.l	#0, %d2
 614 80894 4EBA FF66 		jsr		getHexPair
 615               	|	bsr		printHexLong
 616               	|	lea		CRLF_MSG, %a0
 617               	|   bsr.w   printString
 618 80898 8480      		or.l	%d0, %d2
 619 8089a E182      		asl.l	#8, %d2
 620 8089c 4EBA FF5E 		jsr		getHexPair
 621               	|	bsr		printHexLong
 622               	|	lea		CRLF_MSG, %a0
 623               	|	bsr.w   printString
 624 808a0 8480      		or.l	%d0, %d2
 625 808a2 21C2 0404 		move.l	%d2, srecAddr
 626 808a6 5538 0401 		sub.b	#2, srecByCt
68K GAS  S68K_002.s 			page 13


 627               	past16:
 628 808aa 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 629 808ae 4E75      		rts
 630               			
 631               	|||||||||||||||||||||||||||||
 632               	| Find and parse a hex number
 633               	|  Starting address in A0
 634               	|  Number returned in D0
 635               	|  Status in D1   (0 success, 1 fail)
 636               	|  TODO: Try and merge first digit code with remaining digit code
 637               	parseNumber:
 638 808b0 B180      	    eor.l   %d0, %d0		| Zero out d0
 639 808b2 1018      	    move.b  (%a0)+, %d0
 640 808b4 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 641 808b8 67F6      	    beq.s   parseNumber
 642 808ba 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 643 808be 6D14      	    blt.s	PNinvalid
 644 808c0 0C00 0039 	    cmp.b   #'9', %d0
 645 808c4 6F18      	    ble.s   PNfirstdigit1
 646               	
 647 808c6 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 648 808ca 6D00 FD96 	    blt   .invalid    
 649 808ce 0C00 0046 	    cmp.b   #'F', %d0
 650 808d2 6F04      	    ble.s   PNfirstdigit2
 651               	PNinvalid:
 652 808d4 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 653 808d6 4E75      	    rts
 654               	PNfirstdigit2:
 655 808d8 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 656 808dc 6004      	    bra.s   PNloop
 657               	PNfirstdigit1:
 658 808de 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 659               	 PNloop:
 660 808e2 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 661 808e4 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 662 808e8 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 663 808ea 0C01 0039 	    cmp.b   #'9', %d1
 664 808ee 6F18      	    ble.s   PNdigit1
 665 808f0 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 666 808f4 6D06      	    blt.s   PNend
 667 808f6 0C01 0046 	    cmp.b   #'F', %d1
 668 808fa 6F06      	    ble.s   PNdigit2
 669               	
 670               	PNend:                       | We hit a non-hex digit character, we're done parsing
 671 808fc 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 672 808fe 7200      	    move.l  #0, %d1
 673 80900 4E75      	    rts
 674               	PNdigit2:
 675 80902 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 676 80906 6004      	    bra.s   PNdigit3
 677               	PNdigit1:
 678 80908 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 679               	PNdigit3:
 680 8090c E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 681 8090e D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 682 80910 60D0      	    bra.s   PNloop
 683               	    
68K GAS  S68K_002.s 			page 14


 684               	
 685               	|||||||||||||||||||||||||||||
 686               	| Dumps a section of RAM to the screen
 687               	| Displays both hex values and ASCII characters
 688               	| d0 - Number of bytes to dump
 689               	| a0 - Start Address
 690               	dumpRAM:
 691 80912 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 692 80916 2448      	    move.l  %a0, %a2           	| Save the start address
 693 80918 2400      	    move.l  %d0, %d2           	| And the number of bytes
 694               	 .line:
 695 8091a 200A      	    move.l  %a2, %d0          
 696 8091c 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 697 80920 41FA 0308 	    lea     msgColonSpace, %a0
 698 80924 6100 FC10 	    bsr.w   printString
 699 80928 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 700 8092a 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 701               	 .hexbyte:
 702 8092c 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 703 8092e 6718      	    beq.s   .endbytesShort
 704 80930 4A03      	    tst.b   %d3               	| Check if we're done this line
 705 80932 673A      	    beq.s   .endbytes    
 706 80934 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 707 80936 6100 011C 	    bsr.w   printHexByte     	| Display it
 708 8093a 103C 0020 	    move.b  #' ', %d0
 709 8093e 6100 FBCE 	    bsr.w   outChar          	| Space out bytes
 710 80942 5383      	    subq.l  #1, %d3    
 711 80944 5382      	    subq.l  #1, %d2        
 712 80946 60E4      	    bra.s   .hexbyte
 713               	 .endbytesShort:
 714 80948 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 715 8094a 103C 0020 	    move.b  #' ', %d0
 716               	 .endbytesShortLoop:
 717 8094e 4A03      	    tst.b   %d3               	| Check if we ended the line
 718 80950 671C      	    beq.s   .endbytes
 719 80952 103C 0020 	    move.b  #' ', %d0
 720 80956 6100 FBB6 	    bsr.w   outChar          	| Three spaces to pad out
 721 8095a 103C 0020 	    move.b  #' ', %d0
 722 8095e 6100 FBAE 	    bsr.w   outChar
 723 80962 103C 0020 	    move.b  #' ', %d0
 724 80966 6100 FBA6 	    bsr.w   outChar
 725               	    
 726 8096a 5303      	    subq.b  #1, %d3
 727 8096c 60E0      	    bra.s   .endbytesShortLoop
 728               	 .endbytes:
 729 8096e 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 730               	 .endbytesLoop:
 731 80970 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 732 80972 6700 0022 	    beq     .endline    
 733 80976 5304      	    subq.b  #1, %d4
 734 80978 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 735 8097a 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 736 8097e 6D0C      	    blt.s   .unprintable
 737 80980 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 738 80984 6E06      	    bgt.s   .unprintable
 739 80986 6100 FB86 	    bsr.w   outChar
 740 8098a 60E4      	    bra.s   .endbytesLoop
68K GAS  S68K_002.s 			page 15


 741               	 .unprintable:
 742 8098c 103C 002E 	    move.b  #'.', %d0
 743 80990 6100 FB7C 	    bsr.w   outChar
 744 80994 60DA      	    bra.s   .endbytesLoop
 745               	 .endline:
 746 80996 41FA 0295 	    lea     msgNewline, %a0
 747 8099a 6100 FB9A 	    bsr.w   printString
 748 8099e 4A82      	    tst.l   %d2
 749 809a0 6F04      	    ble.s   .end
 750 809a2 6000 FF76 	    bra.w   .line
 751               	 .end:
 752 809a6 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 753 809aa 4E75      	    rts
 754               	
 755               	|||||||||||||||||||||||
 756               	| Deposit values into RAM
 757               	| d ADDR VAL VAL            Deposit value(s) into RAM
 758               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 759               	|  VAL VAL VAL;              - Continuing with further continue
 760               	| d: VAL VAL                Continue depositing values after the last address written to
 761               	|||||||||||||||||||||||
 762               	.deposit:
 763 809ac 1010      	    move.b  (%a0), %d0
 764 809ae 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 765 809b2 6730      	    beq.s   DepCont
 766               	    
 767 809b4 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 768 809b8 4A01      	    tst.b   %d1
 769 809ba 6600 FCC0 	    bne		.invalidAddr
 770 809be 2640      	    move.l  %d0, %a3           	| Save the start address
 771               	 DepLoop:
 772 809c0 1010      	    move.b  (%a0), %d0            
 773 809c2 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 774 809c6 6726      	    beq.s   DepMLine
 775 809c8 4A40      	    tst     %d0              	| Check for the end of line
 776 809ca 6700 003A 	    beq     DepEnd
 777               	    
 778 809ce 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 779 809d2 4A01      	    tst.b   %d1
 780 809d4 6600 FCB2 	    bne		.invalidVal
 781 809d8 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 782 809dc 6E00 FCAA 	    bgt		.invalidVal
 783               	    
 784 809e0 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 785 809e2 60DC      	    bra.s   DepLoop
 786               	    
 787               	 DepCont:
 788 809e4 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 788      FBAA 
 789 809ea 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 790 809ec 60D2      	    bra.s   DepLoop
 791               	    
 792               	 DepMLine:
 793 809ee 41FA 0186 	    lea     msgDepositPrompt, %a0
 794 809f2 6100 FB42 	    bsr.w   printString
 795 809f6 6100 FB70 	    bsr.w   readLine          	| Read in the next line to be parsed
 796 809fa 6100 FBFE 	    bsr.w   lineToUpper         | Convert to uppercase
68K GAS  S68K_002.s 			page 16


 797 809fe 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 797      FBAE 
 798 80a04 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 799               	 DepEnd:
 800 80a06 23CB 0007 	    move.l  %a3, varCurAddr
 800      FBAA 
 801 80a0c 6000 FC5C 	    bra.w   .exit
 802               	
 803               	|||||||||||||||||||||||
 804               	| run code
 805               	 .run:
 806 80a10 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 807 80a14 4A01      	    tst.b   %d1
 808 80a16 6600 FC64 	    bne		.invalidAddr
 809 80a1a 2040      	    move.l  %d0, %a0
 810 80a1c 4E90      	    jsr     (%a0)             	| Jump to the code! 
 811               	                                | Go as subroutine to allow code to return to us
 812 80a1e 4EBA FAB2 	    jsr     monitorStart        | Warm start after returning so everything is in
 813               	                                | a known state.
 814               	
 815               	
 816               	|||||||||||||||||||||||
 817               	|| KEEP All printHex functions together ||
 818               	|||||||||||||||||||||||
 819               	| Print a hex word
 820               	printHexWord:
 821 80a22 2F02      	    move.l  %d2, -(%SP)		| Save D2
 822 80a24 2400      	    move.l  %d0, %d2		| Save the address in d2
 823               	    
 824 80a26 E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 825 80a28 E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 826 80a2a 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 827               	|||||||||||||||||||||||
 828               	| Print a hex 24-bit address
 829               	printHexAddr:
 830 80a2c 2F02      	    move.l %d2, -(%SP)   	| Save D2
 831 80a2e 2400      	    move.l %d0, %d2      	| Save the address in d2
 832               	    
 833 80a30 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 834 80a32 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 835               	|||||||||||||||||||||||
 836               	* Print a hex long
 837               	printHexLong:
 838 80a34 2F02      	    move.l  %d2, -(%SP)     | Save D2
 839 80a36 2400      	    move.l  %d0, %d2        | Save the address in d2
 840               	    
 841 80a38 E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 842 80a3a 2002      	    move.l  %d2, %d0
 843 80a3c 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 844               	printHex_addrentry:     
 845 80a3e E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 846 80a40 2002      	    move.l  %d2, %d0              
 847 80a42 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 848               	printHex_wordentry:    
 849 80a44 E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 850 80a46 2002      	    move.l  %d2, %d0
 851 80a48 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
68K GAS  S68K_002.s 			page 17


 852 80a4a E19A      	    rol.l   #0x8, %d2
 853 80a4c 2002      	    move.l  %d2, %d0
 854 80a4e 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 855               	    
 856 80a50 241F      	    move.l (%SP)+, %d2      | Restore D2
 857 80a52 4E75      	    RTS
 858               	    
 859               	|||||||||||||||||||||||
 860               	| Print a hex byte
 861               	|  - Takes byte in D0
 862               	printHexByte:
 863 80a54 2F02      	    move.l  %D2, -(%SP)
 864 80a56 7400      		move.l	#0, %d2
 865 80a58 1400      	    move.b  %d0, %d2
 866 80a5a E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 867 80a5c 0200 000F 		andi.b	#0xf, %d0
 868 80a60 0600 0030 	    add.b   #'0', %d0
 869 80a64 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 870 80a68 6F02      	    ble.s   PHBsecond
 871 80a6a 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 872               	PHBsecond:
 873 80a6c 6100 FAA0 	    bsr   outChar			| Print the digit
 874 80a70 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 875 80a74 0602 0030 	    add.b   #'0', %d2
 876 80a78 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 877 80a7c 6F02      	    ble.s   PHBend
 878 80a7e 5E02      	    add.b   #0x7, %D2
 879               	PHBend:
 880 80a80 1002      	    move.b  %D2, %D0
 881 80a82 6100 FA8A 	    bsr	   outChar      	| Print the lower digit
 882 80a86 241F      	    move.l  (%SP)+, %D2
 883 80a88 4E75      	    rts
 884               		
 885               	
 886               	|||||
 887               	| Initializes the 68681 DUART port A as 9600 8N1 
 888               	initDuart:
 889 80a8a 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 889      000F 0004 
 890 80a92 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 890      000F 0004 
 891 80a9a 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 891      000F 0004 
 892               	    
 893 80aa2 13FC 0000 	    move.b  #0x00, ACR       | Baud Rate Set #2
 893      000F 0008 
 894               	|    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 895 80aaa 13FC 00CC 	    move.b  #0xCC, CSRA      | Set Tx and Rx rates to 38400
 895      000F 0002 
 896 80ab2 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 896      000F 0000 
 897 80aba 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 897      000F 0000 
 898               	    
 899 80ac2 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 899      000F 0004 
 900               	
68K GAS  S68K_002.s 			page 18


 901 80aca 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 901      000F 0014 
 902 80ad2 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 902      000F 0014 
 903 80ada 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 903      000F 0014 
 904               	    
 905               	|    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 906 80ae2 13FC 00CC 	    move.b  #0xcc, CSRB      | Set Tx and Rx rates to 38400
 906      000F 0012 
 907 80aea 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 907      000F 0010 
 908 80af2 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 908      000F 0010 
 909               	    
 910 80afa 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 910      000F 0014 
 911               		
 912 80b02 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 912      000F 001A 
 913 80b0a 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 913      000F 001E 
 914 80b12 4E75      	    rts    
 915               	
 916               	delay1Sec:
 917 80b14 203C 0003 		move.l	#200000, %d0	| rough count
 917      0D40 
 918               	delay1Loop:
 919 80b1a 5380      		sub.l	#1, %d0			
 920 80b1c 6600 FFFC 		bne		delay1Loop
 921 80b20 4E75      		rts
 922               	
 923               	READINLINE:	  
 924 80b22 5265 6164 		.ascii  "Reading in line"
 924      696E 6720 
 924      696E 206C 
 924      696E 65
 925 80b31 0D0A 00   		dc.b CR,LF,EOT
 926               	L_TO_UPPER_MSG:  
 927 80b34 436F 6E76 		.ascii  "Convert line to upper case"
 927      6572 7420 
 927      6C69 6E65 
 927      2074 6F20 
 927      7570 7065 
 928 80b4e 0D0A 00   		dc.b CR,LF,EOT
 929               	WRITEOUTLINE:	  
 930 80b51 5772 6974 		.ascii  "Writing out line"
 930      696E 6720 
 930      6F75 7420 
 930      6C69 6E65 
 931 80b61 0D0A 00   		dc.b CR,LF,EOT
 932               	RAM_PASS_MSG:  
 933 80b64 5241 4D20 		.ascii  "RAM Test Passed"
 933      5465 7374 
 933      2050 6173 
 933      7365 64
 934 80b73 0D0A 00   		dc.b CR,LF,EOT
68K GAS  S68K_002.s 			page 19


 935               	msgDepositPrompt:
 936 80b76 3A20      	    .ascii	": "
 937 80b78 00        		dc.b 	EOT
 938               	BANNER_MSG:	
 939 80b79 5349 4D50 		.ascii  "SIMPLE-68008 CPU V1.00"
 939      4C45 2D36 
 939      3830 3038 
 939      2043 5055 
 939      2056 312E 
 940 80b8f 0D0A 00   		dc.b CR,LF,EOT
 941               	msgInvalidCommand:
 942 80b92 496E 7661 	    .ascii "Invalid Command"
 942      6C69 6420 
 942      436F 6D6D 
 942      616E 64
 943 80ba1 0D0A 00   		dc.b CR,LF,EOT
 944               	CRLF_MSG:	
 945 80ba4 0D0A 00   		dc.b CR,LF,EOT
 946               	msgHelp:
 947 80ba7 4176 6169 	    .ascii	"Available Commands: "
 947      6C61 626C 
 947      6520 436F 
 947      6D6D 616E 
 947      6473 3A20 
 948 80bbb 0D0A      		dc.b	CR,LF
 949 80bbd 2028 4529 	    .ascii	" (E)xamine  (D)eposit  (R)un  (L)oad  (B)ASIC  (H)elp"
 949      7861 6D69 
 949      6E65 2020 
 949      2844 2965 
 949      706F 7369 
 950 80bf2 0D0A 00   		dc.b	CR,LF,EOT
 951               	ldSRecMsg:
 952 80bf5 4C6F 6164 	    .ascii	"Load S-Record"
 952      2053 2D52 
 952      6563 6F72 
 952      64
 953 80c02 0D0A 00   		dc.b	CR,LF,EOT
 954               	msgInvalidAddress:
 955 80c05 496E 7661 	    .ascii	"Invalid Address"
 955      6C69 6420 
 955      4164 6472 
 955      6573 73
 956 80c14 0D0A 00   		dc.b 	CR,LF,EOT
 957               	msgInvalidValue:
 958 80c17 496E 7661 	    .ascii	"Invalid Value"
 958      6C69 6420 
 958      5661 6C75 
 958      65
 959 80c24 0D0A 00   		dc.b	CR,LF,EOT
 960               	msgPrompt:
 961 80c27 3E20      		.ascii "> "
 962 80c29 00        	    dc.b EOT
 963               	msgColonSpace:
 964 80c2a 3A20      	    .ascii ": "
 965 80c2c 00        	    dc.b EOT
 966               	msgNewline:
 967 80c2d 0D0A 00   	    dc.b CR,LF,EOT
68K GAS  S68K_002.s 			page 20


 968               	debug_Srec_Typ_Msg:
 969 80c30 5320 5265 		.ascii	"S Record Type="
 969      636F 7264 
 969      2054 7970 
 969      653D 
 970 80c3e 00        	    dc.b EOT
 971               	debug_Srec_BytCt_Msg:
 972 80c3f 5320 5265 		.ascii	"S Record Byte Count=0x"
 972      636F 7264 
 972      2042 7974 
 972      6520 436F 
 972      756E 743D 
 973 80c55 00        	    dc.b EOT
 974               	debug_Srec_CSum_Msg:
 975 80c56 5320 5265 		.ascii	"S Record Checksum="
 975      636F 7264 
 975      2043 6865 
 975      636B 7375 
 975      6D3D 
 976 80c68 00        	    dc.b EOT
 977               	debug_S2rec_Addr_Msg:
 978 80c69 5332 2052 		.ascii	"S2 Record Address=0x"
 978      6563 6F72 
 978      6420 4164 
 978      6472 6573 
 978      733D 3078 
 979 80c7d 00        	    dc.b EOT
 980               	debug_SXrec_Addr_Msg:
 981 80c7e 5320 286E 		.ascii	"S (not 2) Record Address=0x"
 981      6F74 2032 
 981      2920 5265 
 981      636F 7264 
 981      2041 6464 
 982 80c99 00        	    dc.b EOT
 983               	debug_Srec_LDData_Msg:
 984 80c9a 4C6F 6164 	    .ascii	"Load Data Loop start"
 984      2044 6174 
 984      6120 4C6F 
 984      6F70 2073 
 984      7461 7274 
 985 80cae 0D0A 00   		dc.b 	CR,LF,EOT
 986               	
 987               	
 988               	MAX_LINE_LENGTH = 80
 989               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 990               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 21


DEFINED SYMBOLS
          S68K_002.s:12     *ABS*:0000000000000000 RAM_START
          S68K_002.s:13     *ABS*:000000000007fffc STACK_END
          S68K_002.s:14     *ABS*:000000000007ffff RAM_END
          S68K_002.s:15     *ABS*:0000000000080000 ROM_START
          S68K_002.s:16     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:18     *ABS*:000000000008ffff ROM_END
          S68K_002.s:23     *ABS*:00000000000f0000 DUART
          S68K_002.s:24     *ABS*:00000000000f0000 MRA
          S68K_002.s:25     *ABS*:00000000000f0002 SRA
          S68K_002.s:26     *ABS*:00000000000f0002 CSRA
          S68K_002.s:27     *ABS*:00000000000f0004 CRA
          S68K_002.s:28     *ABS*:00000000000f0006 RBA
          S68K_002.s:29     *ABS*:00000000000f0006 TBA
          S68K_002.s:30     *ABS*:00000000000f0008 ACR
          S68K_002.s:31     *ABS*:00000000000f000a ISR
          S68K_002.s:32     *ABS*:00000000000f000a IMR
          S68K_002.s:33     *ABS*:00000000000f0010 MRB
          S68K_002.s:34     *ABS*:00000000000f0012 SRB
          S68K_002.s:35     *ABS*:00000000000f0012 CSRB
          S68K_002.s:36     *ABS*:00000000000f0014 CRB
          S68K_002.s:37     *ABS*:00000000000f0016 RBB
          S68K_002.s:38     *ABS*:00000000000f0016 TBB
          S68K_002.s:39     *ABS*:00000000000f0018 IVR
          S68K_002.s:40     *ABS*:00000000000f001a OPC
          S68K_002.s:41     *ABS*:00000000000f001a INU
          S68K_002.s:42     *ABS*:00000000000f001c OPS
          S68K_002.s:43     *ABS*:00000000000f001e OPR
          S68K_002.s:48     *ABS*:0000000000000007 BEL
          S68K_002.s:49     *ABS*:0000000000000008 BKSP
          S68K_002.s:50     *ABS*:0000000000000009 TAB
          S68K_002.s:51     *ABS*:000000000000000a LF
          S68K_002.s:52     *ABS*:000000000000000d CR
          S68K_002.s:53     *ABS*:000000000000001b ESC
          S68K_002.s:54     *ABS*:0000000000000000 EOT
          S68K_002.s:56     *ABS*:0000000000000003 CTRLC
          S68K_002.s:57     *ABS*:0000000000000018 CTRLX
          S68K_002.s:60     .text:0000000000000400 _srecType
          S68K_002.s:61     .text:0000000000000401 _srecByCt
          S68K_002.s:62     .text:0000000000000402 _srecData
          S68K_002.s:63     .text:0000000000000403 _srecCSum
          S68K_002.s:64     .text:0000000000000404 _srecAddr
          S68K_002.s:66     *ABS*:0000000000000400 srecType
          S68K_002.s:67     *ABS*:0000000000000401 srecByCt
          S68K_002.s:68     *ABS*:0000000000000402 srecData
          S68K_002.s:69     *ABS*:0000000000000403 srecCSum
          S68K_002.s:70     *ABS*:0000000000000404 srecAddr
          S68K_002.s:183    .text:0000000000080508 FERVR2
          S68K_002.s:108    .text:0000000000080462 loop1stLoc
          S68K_002.s:181    .text:0000000000080508 failBitTest
          S68K_002.s:123    .text:0000000000080482 loopAdrFill
          S68K_002.s:135    .text:00000000000804a0 loopAdrCk
          S68K_002.s:182    .text:0000000000080508 failAdrTest
          S68K_002.s:150    .text:00000000000804ba fillSRAM
          S68K_002.s:154    .text:00000000000804c6 fillSRAMLoop
          S68K_002.s:888    .text:0000000000080a8a initDuart
          S68K_002.s:163    .text:00000000000804d2 monitorStart
68K GAS  S68K_002.s 			page 22


          S68K_002.s:938    .text:0000000000080b79 BANNER_MSG
          S68K_002.s:208    .text:0000000000080536 printString1
          S68K_002.s:932    .text:0000000000080b64 RAM_PASS_MSG
          S68K_002.s:171    .text:00000000000804e2 interpLoop
          S68K_002.s:960    .text:0000000000080c27 msgPrompt
          S68K_002.s:209    .text:0000000000080536 printString
          S68K_002.s:238    .text:0000000000080568 readLine
          S68K_002.s:295    .text:00000000000805fa lineToUpper
          S68K_002.s:312    .text:0000000000080618 parseLine
          S68K_002.s:190    .text:000000000008050e outChar1
          S68K_002.s:191    .text:000000000008050e outChar
          S68K_002.s:199    .text:0000000000080522 outChar2
          S68K_002.s:210    .text:0000000000080536 PSloop
          S68K_002.s:216    .text:000000000008053e PSend
          S68K_002.s:224    .text:0000000000080540 inChar1
          S68K_002.s:225    .text:0000000000080540 inChar
          S68K_002.s:231    .text:0000000000080554 inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:242    .text:0000000000080574 RLloop
          S68K_002.s:259    .text:00000000000805a0 RLBS
          S68K_002.s:270    .text:00000000000805be RLlineClr
          S68K_002.s:284    .text:00000000000805e2 RLEndLn
          S68K_002.s:252    .text:0000000000080590 .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:274    .text:00000000000805c4 RLlineClrloop
          S68K_002.s:297    .text:0000000000080600 LUloop
          S68K_002.s:304    .text:0000000000080612 LUnext
          S68K_002.s:315    .text:0000000000080622 PLfindCommand
          S68K_002.s:364    .text:0000000000080694 .examine
          S68K_002.s:762    .text:00000000000809ac .deposit
          S68K_002.s:805    .text:0000000000080a10 .run
          S68K_002.s:343    .text:0000000000080670 .help
          S68K_002.s:450    .text:0000000000080730 loadSRec
          S68K_002.s:420    .text:000000000008071e .runBASIC
          S68K_002.s:336    .text:000000000008066a .exit
          S68K_002.s:333    .text:0000000000080662 .invalid
          S68K_002.s:941    .text:0000000000080b92 msgInvalidCommand
          S68K_002.s:946    .text:0000000000080ba7 msgHelp
          S68K_002.s:347    .text:000000000008067c .invalidAddr
          S68K_002.s:954    .text:0000000000080c05 msgInvalidAddress
          S68K_002.s:351    .text:0000000000080688 .invalidVal
          S68K_002.s:957    .text:0000000000080c17 msgInvalidValue
          S68K_002.s:637    .text:00000000000808b0 parseNumber
          S68K_002.s:369    .text:00000000000806a0 .exloop
          S68K_002.s:383    .text:00000000000806c4 .exrange
          S68K_002.s:392    .text:00000000000806d6 .exlength
          S68K_002.s:400    .text:00000000000806e8 .exinter
          S68K_002.s:389    .text:00000000000806d2 .exquick
          S68K_002.s:396    .text:00000000000806e0 .exend
          S68K_002.s:690    .text:0000000000080912 dumpRAM
          S68K_002.s:405    .text:00000000000806f6 .exinterend
          S68K_002.s:412    .text:000000000008070a .exinterpage
          S68K_002.s:419    *ABS*:0000000000084800 BasicStart
          S68K_002.s:426    .text:000000000008072e skipBasic
          S68K_002.s:951    .text:0000000000080bf5 ldSRecMsg
          S68K_002.s:453    .text:0000000000080738 loadSRecLoop
          S68K_002.s:510    .text:00000000000807d0 setRecType
68K GAS  S68K_002.s 			page 23


          S68K_002.s:529    .text:00000000000807ea setBytCt
          S68K_002.s:569    .text:0000000000080834 setAddr
          S68K_002.s:465    .text:0000000000080762 loopSData
          S68K_002.s:470    .text:0000000000080774 sRecDataDone
          S68K_002.s:485    .text:00000000000807ac getSetLdData
          S68K_002.s:497    .text:00000000000807c6 getChksum
          S68K_002.s:545    .text:00000000000807fc getHexPair
          S68K_002.s:493    .text:00000000000807c4 skipLdData
          S68K_002.s:506    .text:00000000000807ce failCSUM
          S68K_002.s:558    .text:000000000008081c toNibble
          S68K_002.s:563    .text:000000000008082a doHexLetter
          S68K_002.s:610    .text:0000000000080892 adrLen16
          S68K_002.s:627    .text:00000000000808aa past16
          S68K_002.s:651    .text:00000000000808d4 PNinvalid
          S68K_002.s:657    .text:00000000000808de PNfirstdigit1
          S68K_002.s:654    .text:00000000000808d8 PNfirstdigit2
          S68K_002.s:659    .text:00000000000808e2 PNloop
          S68K_002.s:670    .text:00000000000808fc PNend
          S68K_002.s:677    .text:0000000000080908 PNdigit1
          S68K_002.s:674    .text:0000000000080902 PNdigit2
          S68K_002.s:679    .text:000000000008090c PNdigit3
          S68K_002.s:694    .text:000000000008091a .line
          S68K_002.s:829    .text:0000000000080a2c printHexAddr
          S68K_002.s:963    .text:0000000000080c2a msgColonSpace
          S68K_002.s:701    .text:000000000008092c .hexbyte
          S68K_002.s:713    .text:0000000000080948 .endbytesShort
          S68K_002.s:728    .text:000000000008096e .endbytes
          S68K_002.s:862    .text:0000000000080a54 printHexByte
          S68K_002.s:716    .text:000000000008094e .endbytesShortLoop
          S68K_002.s:730    .text:0000000000080970 .endbytesLoop
          S68K_002.s:745    .text:0000000000080996 .endline
          S68K_002.s:741    .text:000000000008098c .unprintable
          S68K_002.s:966    .text:0000000000080c2d msgNewline
          S68K_002.s:751    .text:00000000000809a6 .end
          S68K_002.s:787    .text:00000000000809e4 DepCont
          S68K_002.s:771    .text:00000000000809c0 DepLoop
          S68K_002.s:792    .text:00000000000809ee DepMLine
          S68K_002.s:799    .text:0000000000080a06 DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:935    .text:0000000000080b76 msgDepositPrompt
          S68K_002.s:820    .text:0000000000080a22 printHexWord
          S68K_002.s:848    .text:0000000000080a44 printHex_wordentry
          S68K_002.s:844    .text:0000000000080a3e printHex_addrentry
          S68K_002.s:837    .text:0000000000080a34 printHexLong
          S68K_002.s:872    .text:0000000000080a6c PHBsecond
          S68K_002.s:879    .text:0000000000080a80 PHBend
          S68K_002.s:916    .text:0000000000080b14 delay1Sec
          S68K_002.s:918    .text:0000000000080b1a delay1Loop
          S68K_002.s:923    .text:0000000000080b22 READINLINE
          S68K_002.s:926    .text:0000000000080b34 L_TO_UPPER_MSG
          S68K_002.s:929    .text:0000000000080b51 WRITEOUTLINE
          S68K_002.s:944    .text:0000000000080ba4 CRLF_MSG
          S68K_002.s:968    .text:0000000000080c30 debug_Srec_Typ_Msg
          S68K_002.s:971    .text:0000000000080c3f debug_Srec_BytCt_Msg
          S68K_002.s:974    .text:0000000000080c56 debug_Srec_CSum_Msg
          S68K_002.s:977    .text:0000000000080c69 debug_S2rec_Addr_Msg
          S68K_002.s:980    .text:0000000000080c7e debug_SXrec_Addr_Msg
68K GAS  S68K_002.s 			page 24


          S68K_002.s:983    .text:0000000000080c9a debug_Srec_LDData_Msg

NO UNDEFINED SYMBOLS
