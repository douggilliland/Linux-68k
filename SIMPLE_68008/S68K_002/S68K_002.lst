68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Land Boards, LLC
   4               	|	(c) 2024
   5               	| Use it however you want
   6               	| Borrowed init code from 
   7               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   8               	|
   9               	| Added S-Record load code
  10               	|	Uses SRAM from 0x400-0x407
  11               	
  12               	RAM_START	= 0x00000	| Beginning of the SRAM
  13               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
  14               	RAM_END		= 0x7FFFF	| 512KB SRAM
  15               	ROM_START	= 0x80000	| ROM start
  16               	ROM_CODE	= ROM_START+1024| Skip vector table
  17               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  18               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  19               	
  20               	|||||||||||||||||||||||||||||||||
  21               	| 68681 Duart Register Addresses
  22               	|
  23               	DUART = 0x0F0000	  | Base Addr of DUART
  24               	MRA   = DUART+0		  | Mode Register A           (R/W)
  25               	SRA   = DUART+2       | Status Register A         (r)
  26               	CSRA  = DUART+2       | Clock Select Register A   (w)
  27               	CRA   = DUART+4       | Commands Register A       (w)
  28               	RBA   = DUART+6       | Receiver Buffer A         (r)
  29               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  30               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  31               	ISR   = DUART+10      | Interrupt Status Register (R)
  32               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  33               	MRB   = DUART+16      | Mode Register B           (R/W)
  34               	SRB   = DUART+18      | Status Register B         (R)
  35               	CSRB  = DUART+18      | Clock Select Register B   (W)
  36               	CRB   = DUART+20      | Commands Register B       (W)
  37               	RBB   = DUART+22      | Reciever Buffer B         (R)
  38               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  39               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  40               	OPC   = DUART+26      | Output port config        (W)
  41               	INU   = DUART+26      | Input port (unlatched)    (R)
  42               	OPS   = DUART+28      | Output port Set           (W)
  43               	OPR   = DUART+30      | Output port Clear         (W)
  44               	
  45               	||||||||||||||||||||||||||||||||||
  46               	| ASCII Control Characters
  47               	|
  48               	BEL   = 0x07
  49               	BKSP  = 0x08       | CTRL-H
  50               	TAB   = 0x09
  51               	LF    = 0x0A
  52               	CR    = 0x0D
  53               	ESC   = 0x1B
  54               	EOT	  = 0x00
  55               	
  56               	CTRLC	=	0x03
  57               	CTRLX	=	0x18     | Line Clear
68K GAS  S68K_002.s 			page 2


  58               	
  59 0000 0000 0000 		.ORG    0x000400
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  60 0400 00        	_srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  61 0401 00        	_srecByCt:	ds.b	1		| Byte Count
  62 0402 00        	_srecData:	ds.b	1 		| Data
  63 0403 00        	_srecCSum:	ds.b	1 		| S-Record Checksum
  64 0404 0000 0000 	_srecAddr:	ds.l	1		| S Record current byte address
  65               	
  66               	srecType	=		0x000400	| S1-S9 stored as binary 1-9
  67               	srecByCt	=		0x000401	| Byte Count
  68               	srecData	=		0x000402	| Data
  69               	srecCSum	=		0x000403	| S-Record Checksum
  70               	srecAddr	=		0x000404	| S Record current byte address
  71               	
  72 0408 0000 0000 		.ORG	ROM_START
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  73               	
  74               	| FIRST 8 bytes loaded after reset |
  75 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  76 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  77               	
  78 80008 0000 0000 	        .ORG ROM_CODE
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  79 80400 4E71      		nop
  80 80402 4FF9 0007 		lea		STACK_END, %sp
  80      FFFC 
  81 80408 4DF9 0007 		lea		STACK_END-128, %fp	| Plenty of room for the monitor's stack
  81      FF7C 
  82               									| Need frame pointer for running C code
  83 8040e 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  83      0008 0000 
  84 80416 4E71      		nop
  85               	| LEDs
  86 80418 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  86      000F 001A 
  87 80420 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  87      000F 001E 
  88 80428 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  88      000F 001C 
  89               	|
  90               	| Test the first two SRAM location
  91               	|
  92 80430 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  92      BEEF 
  93 80436 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  94 8043a 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  95 8043c 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
68K GAS  S68K_002.s 			page 3


  96 8043e B042      		cmp			%d2, %d0
  97 80440 6600 00C6 		bne			FERVR2						
  98 80444 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  98      AAAA 
  99 8044a 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
 100 8044e 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
 101 80450 2611      		move.l	(%a1), %d3				| Read back
 102 80452 B243      		cmp			%d3, %d1
 103 80454 6600 00B2 		bne			FERVR2
 104 80458 4E71      		nop
 105               	| Test bits of first location (as bytes)
 106 8045a 7001      		move.l	#1, %d0
 107 8045c 207C 0000 		move.l	#0, %a0
 107      0000 
 108               	loop1stLoc:
 109 80462 1080      		move.b	%d0, (%a0)
 110 80464 1210      		move.b	(%a0), %d1
 111 80466 B200      		cmp.b		%d0, %d1
 112 80468 6600 009E 		bne			failBitTest
 113 8046c E348      		lsl			#1, %d0
 114 8046e 0C80 0000 		cmp.l		#0x00000100, %d0
 114      0100 
 115 80474 6600 FFEC 		bne			loop1stLoc
 116               	|
 117               	| Test all address lines, 512KB SRAM
 118               	| Write incrementing pattern to data bits
 119               	|
 120 80478 7001      		move.l	#1, %d0		| Fill pattern
 121 8047a 7401      		move.l	#1, %d2
 122 8047c 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 122      0001 
 123               	loopAdrFill:
 124 80482 1080      		move.b	%d0,(%a0)	| Do the write
 125 80484 5240      		addq		#1, %d0		| Increment the pattern
 126 80486 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 127 80488 E38A      		lsl.l		#1, %d2		| Shift temp addr
 128 8048a 2042      		move.l	%d2, %a0	| Put back into addr reg
 129 8048c 0C82 0008 		cmp.l		#0x00080000,%d2
 129      0000 
 130 80492 6600 FFEE 		bne			loopAdrFill
 131               	| Check
 132 80496 7001      		move.l	#1, %d0
 133 80498 7401      		move.l	#1, %d2
 134 8049a 207C 0000 		move.l	#1, %a0
 134      0001 
 135               	loopAdrCk:
 136 804a0 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 137 804a2 B200      		cmp.b		%d0, %d1
 138 804a4 6600 0062 		bne			failAdrTest
 139 804a8 5240      		addq		#1, %d0
 140 804aa 2408      		move.l	%a0, %d2 
 141 804ac E38A      		lsl.l		#1, %d2
 142 804ae 2042      		move.l	%d2, %a0
 143 804b0 0C82 0008 		cmp.l		#0x00080000,%d2
 143      0000 
 144 804b6 6600 FFE8 		bne			loopAdrCk
 145               		
68K GAS  S68K_002.s 			page 4


 146               	|
 147               	| Fill SRAM with 0x00 values
 148               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 149               	|
 150               	fillSRAM:
 151 804ba 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 152 804be 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 152      FFFF 
 153 804c4 7000      		move.l	#0x00, %d0			| Fill with zeros
 154               	fillSRAMLoop:
 155 804c6 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 156 804c8 B3C8      		cmpa.l	%a0, %a1
 157 804ca 6E00 FFFA 		bgt		fillSRAMLoop
 158               	
 159               	|
 160               	| Done with address test of SRAM
 161               	|
 162 804ce 4EBA 05B2 		jsr     initDuart       	| Setup the serial port
 163               	monitorStart:					| Warm start
 164 804d2 41FA 069D 		lea		BANNER_MSG, %a0
 165 804d6 4EBA 005E 		jsr		printString1
 166 804da 41FA 0680 		lea		RAM_PASS_MSG, %a0
 167 804de 4EBA 0056 		jsr		printString1
 168               	|
 169               	| Interpreter Loop
 170               	|
 171               	interpLoop:
 172 804e2 41FA 073C 	    lea     msgPrompt, %a0	| Prompt
 173 804e6 6100 004E 	    bsr.w   printString
 174 804ea 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 174      000F 001E 
 175 804f2 4EBA 0074 		jsr		readLine		| Blocking read of line
 176 804f6 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 176      000F 001C 
 177 804fe 4EBA 00FA 		jsr		lineToUpper
 178 80502 4EBA 0114 		jsr		parseLine
 179 80506 60DA      		bra.s	interpLoop
 180               		
 181               	failBitTest:
 182               	failAdrTest:
 183               	FERVR2:
 184 80508 4E71      		nop
 185 8050a 4EFA FFFC 		jmp	FERVR2
 186               	
 187               	|||||
 188               	| Writes a character to Port A, blocking if not ready (Full buffer)
 189               	|  - Takes a character in D0
 190               	outChar1:
 191               	outChar:
 192 8050e 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 192      000F 0002 
 193 80516 6700 FFF6 	    beq     outChar1     
 194 8051a 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 194      0006 
 195 80520 4E75      	    rts
 196               	
 197               	| Writes a character to Port A, blocking if not ready (Full buffer)
68K GAS  S68K_002.s 			page 5


 198               	|  - Takes a character in D0
 199               	outChar2:
 200 80522 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 200      000F 0012 
 201 8052a 6700 FFF6 	    beq     outChar2     
 202 8052e 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 202      0016 
 203 80534 4E75      	    rts
 204               	
 205               	******
 206               	* Print a null terminated string
 207               	*
 208               	printString1:
 209               	printString:
 210               	PSloop:
 211 80536 1018      	    move.b  (%a0)+, %d0  | Read in character
 212 80538 6704      	    beq.s   PSend         | Check for the null
 213               	    
 214 8053a 61D2      	    bsr.s   outChar      | Otherwise write the character
 215 8053c 60F8      	    bra.s   PSloop        | And continue
 216               	PSend:
 217 8053e 4E75      	    rts
 218               	
 219               	
 220               	|||||
 221               	| Reads in a character from Port A, blocking if none available
 222               	|  - Returns character in D0
 223               	|    
 224               	inChar1:
 225               	inChar:
 226 80540 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 226      000F 0002 
 227 80548 6700 FFF6 	    beq     inChar1
 228 8054c 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 228      0006 
 229 80552 4E75      	    rts
 230               	
 231               	inChar2:
 232 80554 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 232      000F 0012 
 233 8055c 6700 FFF6 	    beq     inChar2
 234 80560 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 234      0016 
 235 80566 4E75      	    rts
 236               	
 237               	| Read in a line into the line buffer
 238               	readLine:
 239 80568 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 240 8056c 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 240      FBAE 
 241 80572 B542      	    eor.w   %d2, %d2           	| Clear the character counter
 242               	 RLloop:
 243 80574 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 244 80578 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 245 8057c 6722      	    beq.s   RLBS
 246 8057e 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 247 80582 673A      	    beq.s   RLlineClr
68K GAS  S68K_002.s 			page 6


 248 80584 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 249 80588 6758      	    beq.s   RLEndLn
 250 8058a 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 251 8058e 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 252               	 .char:                      	| Normal character to be inserted into the buffer
 253 80590 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 254 80594 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 255 80596 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 256 80598 5242      	    addq.w  #1, %d2           	| Increment character count
 257 8059a 6100 FF72 	    bsr.w   outChar          	| Echo the character
 258 8059e 60D4      	    bra.s   RLloop            	| And get the next one
 259               	 RLBS:
 260 805a0 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 261 805a2 67D0      	    beq.s   RLloop            	| Then ignore it
 262 805a4 6100 FF68 	    bsr.w   outChar          	| Backspace
 263 805a8 103C 0020 	    move.b  #' ', %d0
 264 805ac 6100 FF60 	    bsr.w   outChar          	| Space
 265 805b0 103C 0008 	    move.b  #BKSP, %d0
 266 805b4 6100 FF58 	    bsr.w   outChar          	| Backspace
 267 805b8 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 268 805ba 5382      	    subq.l  #1, %d2           	| And current character count
 269 805bc 60B6      	    bra.s   RLloop            	| And goto the next character
 270               	 RLlineClr:
 271 805be 4A42      	    tst     %d2               	| Anything to clear?
 272 805c0 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 273 805c2 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 274               	 RLlineClrloop:
 275 805c4 103C 0008 	    move.b  #BKSP, %d0
 276 805c8 6100 FF44 	    bsr.w   outChar          	| Backspace
 277 805cc 103C 0020 	    move.b  #' ', %d0
 278 805d0 6100 FF3C 	    bsr.w   outChar          	| Space
 279 805d4 103C 0008 	    move.b  #BKSP, %d0
 280 805d8 6100 FF34 	    bsr.w   outChar          	| Backspace
 281 805dc 5342      	    subq.w  #1, %d2          
 282 805de 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 283 805e0 6092      	    bra.s   RLloop   
 284               	 RLEndLn:
 285 805e2 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 286 805e6 103C 000A 	    move.b  #LF, %d0
 287 805ea 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 288 805ee 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 289 805f2 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 290 805f4 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 291 805f8 4E75      	    rts                      	| And return
 292               	
 293               	
 294               	| Convert line buffer to upper case
 295               	lineToUpper:
 296 805fa 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 296      FBAE 
 297               	 LUloop:
 298 80600 1010      	    move.b  (%a0), %d0        | Read in a character
 299 80602 0C00 0061 	    cmp.b   #'a', %d0         
 300 80606 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 301 80608 0C00 007A 	    cmp.b   #'z', %d0
 302 8060c 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 303 8060e 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
68K GAS  S68K_002.s 			page 7


 304               	 LUnext:
 305 80612 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 306 80614 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 307 80616 4E75      	    rts
 308               	
 309               	|
 310               	| Parse Line
 311               	|
 312               	parseLine:
 313 80618 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 314 8061c 41F9 0007 	    lea     varLineBuf, %a0
 314      FBAE 
 315               	 PLfindCommand:
 316 80622 1018      	    move.b  (%a0)+, %d0
 317 80624 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 318 80628 6700 FFF8 	    beq.w   PLfindCommand    
 319 8062c 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 320 80630 6700 0062 	    beq.w   .examine
 321 80634 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 322 80638 6700 036A 	    beq.w   .deposit
 323 8063c 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 324 80640 6700 03C6 	    beq.w   .run
 325 80644 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 326 80648 6700 0026 	    beq.w   .help
 327 8064c 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 328 80650 6700 00D6 	    beq.w   loadSRec
 329 80654 0C00 0042 		cmp.b	#'B', %d0           | BASIC
 330 80658 6700 00C4 		beq		.runBASIC
 331 8065c 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 332 80660 6708      	    beq.s   .exit               
 333               	 .invalid:   
 334 80662 41FA 0526 	    lea     msgInvalidCommand, %a0
 335 80666 6100 FECE 	    bsr.w   printString
 336               	 .exit:
 337 8066a 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 338 8066e 4E75      	    rts
 339               	
 340               	
 341               	|||||||||||||||||||||||||||||||
 342               	|| HELP command
 343               	 .help:
 344 80670 41FA 052D 	    lea     msgHelp, %a0
 345 80674 6100 FEC0 	    bsr.w   printString
 346 80678 6000 FFF0 	    bra.w   .exit
 347               	 .invalidAddr:
 348 8067c 41FA 0580 	    lea     msgInvalidAddress, %a0
 349 80680 6100 FEB4 	    bsr.w   printString
 350 80684 6000 FFE4 	    bra.w   .exit
 351               	 .invalidVal:
 352 80688 41FA 0586 	    lea     msgInvalidValue, %a0
 353 8068c 6100 FEA8 	    bsr.w   printString
 354 80690 6000 FFD8 	    bra.w   .exit
 355               		
 356               	|||||||||||||||||||||||||||||||
 357               	| Examines memory addresses
 358               	| Valid modes:
 359               	|   e ADDR                  Displays a single byte
68K GAS  S68K_002.s 			page 8


 360               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 361               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 362               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 363               	|   e ADDR.                 Quick line, displays one line 
 364               	.examine:
 365 80694 6100 0212 	    bsr.w   parseNumber         | Read in the start address
 366 80698 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 367 8069a 6600 FFE0 	    bne.w   .invalidAddr        
 368 8069e 2640      	    move.l  %d0, %a3            | Save the start address
 369               	 .exloop:
 370 806a0 1018      	    move.b  (%a0)+, %d0
 371 806a2 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 372 806a6 67F8      	    beq.s   .exloop
 373 806a8 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 374 806ac 6716      	    beq.s   .exrange
 375 806ae 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 376 806b2 6722      	    beq.s   .exlength
 377 806b4 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
 378 806b8 672E      	    beq.s   .exinter
 379 806ba 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 380 806be 6712      	    beq.s   .exquick
 381 806c0 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 382 806c2 601C      	    bra.s   .exend              
 383               	 .exrange:
 384 806c4 6100 01E2 	    bsr.w   parseNumber         | Find the end address
 385 806c8 4A01      	    tst.b   %d1                 | Check if we found a valid address
 386 806ca 6600 FFB0 	    bne.w   .invalidAddr
 387 806ce 908B      	    sub.l   %a3, %d0            | Get the length
 388 806d0 600E      	    bra.s   .exend
 389               	 .exquick:                      | Quick mode means show one line of 16 bytes
 390 806d2 7010      	    move.l  #0x10, %d0
 391 806d4 600A      	    bra.s   .exend
 392               	 .exlength:                     | Length mode means a length is specified
 393 806d6 6100 01D0 	    bsr.w   parseNumber         | Find the length
 394 806da 4A01      	    tst.b   %d1
 395 806dc 6600 FF9E 	    bne.w   .invalidAddr
 396               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 397 806e0 204B      	    move.l  %a3, %a0
 398 806e2 6100 0226 	    bsr.w   dumpRAM
 399 806e6 6082      	    bra.s   .exit
 400               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 401 806e8 204B      	    move.l  %a3, %a0            | Current Address
 402 806ea 7010      	    move.l  #0x10, %d0          | 16 bytes
 403 806ec 6100 021C 	    bsr.w   dumpRAM             | Dump this line
 404 806f0 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 404      0010 
 405               	 .exinterend:
 406 806f6 6100 FE48 	    bsr.w   inChar
 407 806fa 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 408 806fe 67E8      	    beq.s   .exinter
 409 80700 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 410 80704 6704      	    beq.s   .exinterpage
 411 80706 6000 FF62 	    bra	   .exit               | Otherwise exit
 412               	 .exinterpage:
 413 8070a 204B      	    move.l  %a3, %a0
 414 8070c 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 414      0100 
68K GAS  S68K_002.s 			page 9


 415 80712 6100 01F6 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 416 80716 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 416      0100 
 417 8071c 60D8      	    bra.s   .exinterend
 418               	
 419               	.runBASIC:
 420 8071e 41F9 0008 		lea		0x88800, %a0
 420      8800 
 421 80724 4E90      		jsr		(%a0)
 422 80726 4E75      		rts
 423               	
 424               	|||||||||||||||||||||||||||||
 425               	|| Load S Record
 426               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 427               	|	srecByCt:	ds.b	1		| Byte Count
 428               	|	srecData:	ds.b	1 		| Data
 429               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 430               	|	srecAddr:	ds.l	1		| S Record current byte address
 431               	|
 432               	| Supports S record types (matches gcc m68k output)
 433               	|	S00F00005336384B5F3030322E746D7074
 434               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 435               	|	S503005BA1
 436               	|
 437               	| Also supports S1 records
 438               	|	S00F00005336384B5F3030332E746D7073
 439               	|	S123100013FC0000000F001A13FC00FC000F001E13FC0004000F001C13FC0004000F001EDE
 440               	|	S1231020203C000186A053806600FFFC13FC0004000F001C203C000186A053806600FFFC00
 441               	|	S10710406000FFD673
 442               	|	S5030003F9
 443               	|
 444               	
 445               	loadSRec:
 446 80728 41FA 04C4 	    lea     ldSRecMsg, %a0					| "Load S-Record"
 447 8072c 6100 FE08 	    bsr.w   printString
 448               	loadSRecLoop:
 449 80730 6100 0096 		bsr		setRecType
 450 80734 6100 00AC 		bsr		setBytCt
 451 80738 11FC 0000 		move.b 	#0, srecCSum
 451      0403 
 452 8073e 6100 00EC 		bsr		setAddr
 453               	|	lea		debug_Srec_LDData_Msg, %a0		| "Load Data Loop start"
 454               	|	bsr		printString
 455 80742 0C38 0001 		cmp.b	#1, srecType			| 16-bit Address
 455      0400 
 456 80748 6700 0010 		beq		loopSData
 457 8074c 0C38 0002 		cmp.b	#2, srecType			| 24-bit Address
 457      0400 
 458 80752 6700 0006 		beq		loopSData
 459 80756 6000 0014 		bra		sRecDataDone
 460               	loopSData:
 461 8075a 0C38 0000 		cmp.b 	#0, srecByCt
 461      0401 
 462 80760 6700 000A 		beq		sRecDataDone
 463 80764 6100 003E 		bsr		getSetLdData
 464 80768 6000 FFF0 		bra		loopSData
 465               	sRecDataDone:
68K GAS  S68K_002.s 			page 10


 466 8076c 6100 0050 		bsr		getChksum
 467 80770 103C 002B 		move.b	#'+', %d0
 468 80774 6100 FD98 		bsr		outChar
 469 80778 0C38 0000 		cmp.b	#0, srecType
 469      0400 
 470 8077e 6700 FFB0 		beq		loadSRecLoop
 471 80782 0C38 0001 		cmp.b	#1, srecType
 471      0400 
 472 80788 6700 FFA6 		beq		loadSRecLoop
 473 8078c 0C38 0002 		cmp.b	#2, srecType
 473      0400 
 474 80792 6700 FF9C 		beq		loadSRecLoop
 475 80796 0C38 0003 		cmp.b	#3, srecType
 475      0400 
 476 8079c 6700 FF92 		beq		loadSRecLoop
 477 807a0 6000 FEC8 		bra.w   .exit
 478               	
 479               	|||||||||||||||||||||||||||||
 480               	getSetLdData:
 481 807a4 4EBA 004E 		jsr		getHexPair
 482 807a8 41F8 0404 		lea 	srecAddr, %a0
 483 807ac 2250      		move.l	(%a0), %a1
 484 807ae 12C0      		move.b	%d0, (%a1)+
 485 807b0 21C9 0404 		move.l	%a1, srecAddr
 486 807b4 D138 0403 		add.b	%d0, srecCSum
 487 807b8 5338 0401 		sub.b	#1, srecByCt
 488               	skipLdData:
 489 807bc 4E75      		rts
 490               	
 491               	|||||||||||||||||||||||||||||
 492               	getChksum:
 493               	|	lea		debug_Srec_CSum_Msg, %a0	| "S Record Checksum="
 494               	|	bsr.w   printString
 495 807be 4EBA 0034 		jsr		getHexPair
 496 807c2 D138 0403 		add.b	%d0, srecCSum
 497               	|	move.b	srecCSum, %d0
 498               	|	jsr		printHexByte
 499               	|	lea		CRLF_MSG, %a0
 500               	|	bsr.w   printString
 501               	failCSUM:
 502 807c6 4E75      		rts
 503               	
 504               	|||||||||||||||||||||||||||||
 505               	setRecType:
 506 807c8 4EBA FD76 		jsr		inChar
 507 807cc 0C00 0053 		cmp.b	#'S', %d0
 508 807d0 6600 FFF6 		bne		setRecType					| Toss extra chars
 509 807d4 4EBA FD6A 		jsr		inChar
 510 807d8 0200 000F 		andi.b	#0x0f, %d0
 511 807dc 11C0 0400 		move.b	%d0, srecType
 512               	| Debug messages follow
 513               	|	lea		debug_Srec_Typ_Msg, %a0		| "S Record Type="
 514               	|	bsr.w   printString
 515               	|	move.b	srecType, %d0
 516               	|	add.b	#'0', %d0
 517               	|	jsr		outChar
 518               	|	lea		CRLF_MSG, %a0
68K GAS  S68K_002.s 			page 11


 519               	|	bsr.w   printString
 520               	| Debug messages end
 521 807e0 4E75      		rts
 522               		
 523               	|||||||||||||||||||||||||||||
 524               	setBytCt:
 525 807e2 4EBA 0010 		jsr		getHexPair
 526 807e6 11C0 0403 		move.b 	%d0, srecCSum				| Initialize checksum
 527 807ea 11C0 0401 		move.b	%d0, srecByCt				| Byte count
 528               	| Debug messages follow
 529               	|	lea		debug_Srec_BytCt_Msg, %a0	| "S Record Byte Count=0x"
 530               	|	bsr.w   printString
 531               	|	move.b	srecByCt, %d0
 532               	|	jsr		printHexByte
 533               	|	lea		CRLF_MSG, %a0
 534               	|	bsr		printString
 535               	| Debug messages end
 536 807ee 5338 0401 		sub.b	#1, srecByCt
 537 807f2 4E75      		rts
 538               	
 539               	|||||||||||||||||||||||||||||
 540               	getHexPair:
 541 807f4 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 542 807f8 4EBA FD46 		jsr		inChar
 543 807fc 4EBA 0016 		jsr		toNibble
 544 80800 E900      		asl.b	#4, %d0
 545 80802 1400      		move.b	%d0, %d2
 546 80804 4EBA FD3A 		jsr		inChar
 547 80808 4EBA 000A 		jsr		toNibble
 548 8080c 8002      		or.b	%d2, %d0
 549 8080e 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 550 80812 4E75      		rts
 551               	
 552               	|||||||||||||||||||||||||||||
 553               	toNibble:
 554 80814 0C00 0041 		cmp.b	#'A', %d0
 555 80818 6C00 0008 		bge		doHexLetter
 556 8081c 0400 0030 		sub.b	#'0', %d0
 557 80820 4E75      		rts
 558               	doHexLetter:
 559 80822 0400 0041 		sub.b	#'A', %d0
 560 80826 0600 000A 		add.b	#10, %d0
 561 8082a 4E75      		rts
 562               	
 563               	|||||||||||||||||||||||||||||
 564               	setAddr:
 565 8082c 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 566 80830 0C38 0002 		cmp.b	#2, srecType
 566      0400 
 567 80836 6600 0052 		bne		adrLen16
 568 8083a 21FC 0000 		move.l	#0, srecAddr
 568      0000 0404 
 569               	|	lea		debug_S2rec_Addr_Msg, %a0
 570               	|	bsr		printString
 571 80842 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 572               		| Get the upper 8-bits of 24-bits
 573 80844 4EBA FFAE 		jsr		getHexPair
68K GAS  S68K_002.s 			page 12


 574 80848 0280 0000 		and.l	#0xff, %d0
 574      00FF 
 575 8084e D138 0403 		add.b 	%d0, srecCSum
 576 80852 8480      		or.l	%d0, %d2
 577 80854 E182      		asl.l	#8, %d2
 578               	|	move.l	%d2, %d0
 579               	|	bsr		printHexLong
 580               	|	lea		CRLF_MSG, %a0
 581               	|   bsr.w   printString
 582               		| Get the middle 8-bits of 24-bits
 583 80856 4EBA FF9C 		jsr		getHexPair
 584 8085a 0280 0000 		and.l	#0xff, %d0
 584      00FF 
 585 80860 D138 0403 		add.b 	%d0, srecCSum
 586 80864 8480      		or.l	%d0, %d2
 587 80866 E182      		asl.l	#8, %d2
 588               	|	move.l	%d2, %d0
 589               	|	bsr		printHexLong
 590               	|	lea		CRLF_MSG, %a0
 591               	|   bsr.w   printString
 592               		| Get the lower 8-bits of 24-bits
 593 80868 4EBA FF8A 		jsr		getHexPair
 594 8086c 0280 0000 		and.l	#0xff, %d0
 594      00FF 
 595 80872 D138 0403 		add.b 	%d0, srecCSum
 596 80876 8480      		or.l	%d0, %d2
 597 80878 0282 00FF 		andi.l	#0x00ffffff, %d2
 597      FFFF 
 598 8087e 21C2 0404 		move.l	%d2, srecAddr		| Save the S record address
 599               	|	move.l	%d2, %d0
 600               	|	bsr		printHexLong
 601               	|	lea		CRLF_MSG, %a0
 602               	|	bsr.w   printString
 603 80882 5738 0401 		sub.b	#3, srecByCt
 604 80886 6000 001A 		bra		past16
 605               	adrLen16:
 606               	|	lea		debug_SXrec_Addr_Msg, %a0	| "S (not 2) Record Address=0x"
 607               	|	bsr		printString
 608 8088a 7400      		move.l	#0, %d2
 609 8088c 4EBA FF66 		jsr		getHexPair
 610               	|	bsr		printHexLong
 611               	|	lea		CRLF_MSG, %a0
 612               	|   bsr.w   printString
 613 80890 8480      		or.l	%d0, %d2
 614 80892 E182      		asl.l	#8, %d2
 615 80894 4EBA FF5E 		jsr		getHexPair
 616               	|	bsr		printHexLong
 617               	|	lea		CRLF_MSG, %a0
 618               	|	bsr.w   printString
 619 80898 8480      		or.l	%d0, %d2
 620 8089a 21C2 0404 		move.l	%d2, srecAddr
 621 8089e 5538 0401 		sub.b	#2, srecByCt
 622               	past16:
 623 808a2 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 624 808a6 4E75      		rts
 625               			
 626               	|||||||||||||||||||||||||||||
68K GAS  S68K_002.s 			page 13


 627               	| Find and parse a hex number
 628               	|  Starting address in A0
 629               	|  Number returned in D0
 630               	|  Status in D1   (0 success, 1 fail)
 631               	|  TODO: Try and merge first digit code with remaining digit code
 632               	parseNumber:
 633 808a8 B180      	    eor.l   %d0, %d0		| Zero out d0
 634 808aa 1018      	    move.b  (%a0)+, %d0
 635 808ac 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 636 808b0 67F6      	    beq.s   parseNumber
 637 808b2 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 638 808b6 6D14      	    blt.s	PNinvalid
 639 808b8 0C00 0039 	    cmp.b   #'9', %d0
 640 808bc 6F18      	    ble.s   PNfirstdigit1
 641               	
 642 808be 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 643 808c2 6D00 FD9E 	    blt   .invalid    
 644 808c6 0C00 0046 	    cmp.b   #'F', %d0
 645 808ca 6F04      	    ble.s   PNfirstdigit2
 646               	PNinvalid:
 647 808cc 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 648 808ce 4E75      	    rts
 649               	PNfirstdigit2:
 650 808d0 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 651 808d4 6004      	    bra.s   PNloop
 652               	PNfirstdigit1:
 653 808d6 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 654               	 PNloop:
 655 808da 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 656 808dc 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 657 808e0 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 658 808e2 0C01 0039 	    cmp.b   #'9', %d1
 659 808e6 6F18      	    ble.s   PNdigit1
 660 808e8 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 661 808ec 6D06      	    blt.s   PNend
 662 808ee 0C01 0046 	    cmp.b   #'F', %d1
 663 808f2 6F06      	    ble.s   PNdigit2
 664               	
 665               	PNend:                       | We hit a non-hex digit character, we're done parsing
 666 808f4 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 667 808f6 7200      	    move.l  #0, %d1
 668 808f8 4E75      	    rts
 669               	PNdigit2:
 670 808fa 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 671 808fe 6004      	    bra.s   PNdigit3
 672               	PNdigit1:
 673 80900 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 674               	PNdigit3:
 675 80904 E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 676 80906 D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 677 80908 60D0      	    bra.s   PNloop
 678               	    
 679               	
 680               	|||||||||||||||||||||||||||||
 681               	| Dumps a section of RAM to the screen
 682               	| Displays both hex values and ASCII characters
 683               	| d0 - Number of bytes to dump
68K GAS  S68K_002.s 			page 14


 684               	| a0 - Start Address
 685               	dumpRAM:
 686 8090a 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 687 8090e 2448      	    move.l  %a0, %a2           	| Save the start address
 688 80910 2400      	    move.l  %d0, %d2           	| And the number of bytes
 689               	 .line:
 690 80912 200A      	    move.l  %a2, %d0          
 691 80914 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 692 80918 41FA 0309 	    lea     msgColonSpace, %a0
 693 8091c 6100 FC18 	    bsr.w   printString
 694 80920 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 695 80922 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 696               	 .hexbyte:
 697 80924 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 698 80926 6718      	    beq.s   .endbytesShort
 699 80928 4A03      	    tst.b   %d3               	| Check if we're done this line
 700 8092a 673A      	    beq.s   .endbytes    
 701 8092c 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 702 8092e 6100 011C 	    bsr.w   printHexByte     	| Display it
 703 80932 103C 0020 	    move.b  #' ', %d0
 704 80936 6100 FBD6 	    bsr.w   outChar          	| Space out bytes
 705 8093a 5383      	    subq.l  #1, %d3    
 706 8093c 5382      	    subq.l  #1, %d2        
 707 8093e 60E4      	    bra.s   .hexbyte
 708               	 .endbytesShort:
 709 80940 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 710 80942 103C 0020 	    move.b  #' ', %d0
 711               	 .endbytesShortLoop:
 712 80946 4A03      	    tst.b   %d3               	| Check if we ended the line
 713 80948 671C      	    beq.s   .endbytes
 714 8094a 103C 0020 	    move.b  #' ', %d0
 715 8094e 6100 FBBE 	    bsr.w   outChar          	| Three spaces to pad out
 716 80952 103C 0020 	    move.b  #' ', %d0
 717 80956 6100 FBB6 	    bsr.w   outChar
 718 8095a 103C 0020 	    move.b  #' ', %d0
 719 8095e 6100 FBAE 	    bsr.w   outChar
 720               	    
 721 80962 5303      	    subq.b  #1, %d3
 722 80964 60E0      	    bra.s   .endbytesShortLoop
 723               	 .endbytes:
 724 80966 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 725               	 .endbytesLoop:
 726 80968 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 727 8096a 6700 0022 	    beq     .endline    
 728 8096e 5304      	    subq.b  #1, %d4
 729 80970 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 730 80972 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 731 80976 6D0C      	    blt.s   .unprintable
 732 80978 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 733 8097c 6E06      	    bgt.s   .unprintable
 734 8097e 6100 FB8E 	    bsr.w   outChar
 735 80982 60E4      	    bra.s   .endbytesLoop
 736               	 .unprintable:
 737 80984 103C 002E 	    move.b  #'.', %d0
 738 80988 6100 FB84 	    bsr.w   outChar
 739 8098c 60DA      	    bra.s   .endbytesLoop
 740               	 .endline:
68K GAS  S68K_002.s 			page 15


 741 8098e 41FA 0296 	    lea     msgNewline, %a0
 742 80992 6100 FBA2 	    bsr.w   printString
 743 80996 4A82      	    tst.l   %d2
 744 80998 6F04      	    ble.s   .end
 745 8099a 6000 FF76 	    bra.w   .line
 746               	 .end:
 747 8099e 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 748 809a2 4E75      	    rts
 749               	
 750               	|||||||||||||||||||||||
 751               	| Deposit values into RAM
 752               	| d ADDR VAL VAL            Deposit value(s) into RAM
 753               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 754               	|  VAL VAL VAL;              - Continuing with further continue
 755               	| d: VAL VAL                Continue depositing values after the last address written to
 756               	|||||||||||||||||||||||
 757               	.deposit:
 758 809a4 1010      	    move.b  (%a0), %d0
 759 809a6 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 760 809aa 6730      	    beq.s   DepCont
 761               	    
 762 809ac 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 763 809b0 4A01      	    tst.b   %d1
 764 809b2 6600 FCC8 	    bne		.invalidAddr
 765 809b6 2640      	    move.l  %d0, %a3           	| Save the start address
 766               	 DepLoop:
 767 809b8 1010      	    move.b  (%a0), %d0            
 768 809ba 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 769 809be 6726      	    beq.s   DepMLine
 770 809c0 4A40      	    tst     %d0              	| Check for the end of line
 771 809c2 6700 003A 	    beq     DepEnd
 772               	    
 773 809c6 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 774 809ca 4A01      	    tst.b   %d1
 775 809cc 6600 FCBA 	    bne		.invalidVal
 776 809d0 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 777 809d4 6E00 FCB2 	    bgt		.invalidVal
 778               	    
 779 809d8 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 780 809da 60DC      	    bra.s   DepLoop
 781               	    
 782               	 DepCont:
 783 809dc 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 783      FBAA 
 784 809e2 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 785 809e4 60D2      	    bra.s   DepLoop
 786               	    
 787               	 DepMLine:
 788 809e6 41FA 0186 	    lea     msgDepositPrompt, %a0
 789 809ea 6100 FB4A 	    bsr.w   printString
 790 809ee 6100 FB78 	    bsr.w   readLine          	| Read in the next line to be parsed
 791 809f2 6100 FC06 	    bsr.w   lineToUpper         | Convert to uppercase
 792 809f6 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 792      FBAE 
 793 809fc 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 794               	 DepEnd:
 795 809fe 23CB 0007 	    move.l  %a3, varCurAddr
68K GAS  S68K_002.s 			page 16


 795      FBAA 
 796 80a04 6000 FC64 	    bra.w   .exit
 797               	
 798               	|||||||||||||||||||||||
 799               	| run code
 800               	 .run:
 801 80a08 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 802 80a0c 4A01      	    tst.b   %d1
 803 80a0e 6600 FC6C 	    bne		.invalidAddr
 804 80a12 2040      	    move.l  %d0, %a0
 805 80a14 4E90      	    jsr     (%a0)             	| Jump to the code! 
 806               	                                | Go as subroutine to allow code to return to us
 807 80a16 4EBA FABA 	    jsr     monitorStart        | Warm start after returning so everything is in
 808               	                                | a known state.
 809               	
 810               	
 811               	|||||||||||||||||||||||
 812               	|| KEEP All printHex functions together ||
 813               	|||||||||||||||||||||||
 814               	| Print a hex word
 815               	printHexWord:
 816 80a1a 2F02      	    move.l  %d2, -(%SP)		| Save D2
 817 80a1c 2400      	    move.l  %d0, %d2		| Save the address in d2
 818               	    
 819 80a1e E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 820 80a20 E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 821 80a22 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 822               	|||||||||||||||||||||||
 823               	| Print a hex 24-bit address
 824               	printHexAddr:
 825 80a24 2F02      	    move.l %d2, -(%SP)   	| Save D2
 826 80a26 2400      	    move.l %d0, %d2      	| Save the address in d2
 827               	    
 828 80a28 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 829 80a2a 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 830               	|||||||||||||||||||||||
 831               	* Print a hex long
 832               	printHexLong:
 833 80a2c 2F02      	    move.l  %d2, -(%SP)     | Save D2
 834 80a2e 2400      	    move.l  %d0, %d2        | Save the address in d2
 835               	    
 836 80a30 E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 837 80a32 2002      	    move.l  %d2, %d0
 838 80a34 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 839               	printHex_addrentry:     
 840 80a36 E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 841 80a38 2002      	    move.l  %d2, %d0              
 842 80a3a 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 843               	printHex_wordentry:    
 844 80a3c E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 845 80a3e 2002      	    move.l  %d2, %d0
 846 80a40 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 847 80a42 E19A      	    rol.l   #0x8, %d2
 848 80a44 2002      	    move.l  %d2, %d0
 849 80a46 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 850               	    
 851 80a48 241F      	    move.l (%SP)+, %d2      | Restore D2
68K GAS  S68K_002.s 			page 17


 852 80a4a 4E75      	    RTS
 853               	    
 854               	|||||||||||||||||||||||
 855               	| Print a hex byte
 856               	|  - Takes byte in D0
 857               	printHexByte:
 858 80a4c 2F02      	    move.l  %D2, -(%SP)
 859 80a4e 7400      		move.l	#0, %d2
 860 80a50 1400      	    move.b  %d0, %d2
 861 80a52 E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 862 80a54 0200 000F 		andi.b	#0xf, %d0
 863 80a58 0600 0030 	    add.b   #'0', %d0
 864 80a5c 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 865 80a60 6F02      	    ble.s   PHBsecond
 866 80a62 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 867               	PHBsecond:
 868 80a64 6100 FAA8 	    bsr   outChar			| Print the digit
 869 80a68 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 870 80a6c 0602 0030 	    add.b   #'0', %d2
 871 80a70 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 872 80a74 6F02      	    ble.s   PHBend
 873 80a76 5E02      	    add.b   #0x7, %D2
 874               	PHBend:
 875 80a78 1002      	    move.b  %D2, %D0
 876 80a7a 6100 FA92 	    bsr	   outChar      	| Print the lower digit
 877 80a7e 241F      	    move.l  (%SP)+, %D2
 878 80a80 4E75      	    rts
 879               		
 880               	
 881               	|||||
 882               	| Initializes the 68681 DUART port A as 9600 8N1 
 883               	initDuart:
 884 80a82 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 884      000F 0004 
 885 80a8a 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 885      000F 0004 
 886 80a92 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 886      000F 0004 
 887               	    
 888 80a9a 13FC 0000 	    move.b  #0x00, ACR       | Baud Rate Set #2
 888      000F 0008 
 889               	|    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 890 80aa2 13FC 00CC 	    move.b  #0xCC, CSRA      | Set Tx and Rx rates to 38400
 890      000F 0002 
 891 80aaa 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 891      000F 0000 
 892 80ab2 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 892      000F 0000 
 893               	    
 894 80aba 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 894      000F 0004 
 895               	
 896 80ac2 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 896      000F 0014 
 897 80aca 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 897      000F 0014 
 898 80ad2 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
68K GAS  S68K_002.s 			page 18


 898      000F 0014 
 899               	    
 900               	|    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 901 80ada 13FC 00CC 	    move.b  #0xcc, CSRB      | Set Tx and Rx rates to 38400
 901      000F 0012 
 902 80ae2 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 902      000F 0010 
 903 80aea 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 903      000F 0010 
 904               	    
 905 80af2 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 905      000F 0014 
 906               		
 907 80afa 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 907      000F 001A 
 908 80b02 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 908      000F 001E 
 909 80b0a 4E75      	    rts    
 910               	
 911               	delay1Sec:
 912 80b0c 203C 0003 		move.l	#200000, %d0	| rough count
 912      0D40 
 913               	delay1Loop:
 914 80b12 5380      		sub.l	#1, %d0			
 915 80b14 6600 FFFC 		bne		delay1Loop
 916 80b18 4E75      		rts
 917               	
 918               	READINLINE:	  
 919 80b1a 5265 6164 		.ascii  "Reading in line"
 919      696E 6720 
 919      696E 206C 
 919      696E 65
 920 80b29 0D0A 00   		dc.b CR,LF,EOT
 921               	L_TO_UPPER_MSG:  
 922 80b2c 436F 6E76 		.ascii  "Convert line to upper case"
 922      6572 7420 
 922      6C69 6E65 
 922      2074 6F20 
 922      7570 7065 
 923 80b46 0D0A 00   		dc.b CR,LF,EOT
 924               	WRITEOUTLINE:	  
 925 80b49 5772 6974 		.ascii  "Writing out line"
 925      696E 6720 
 925      6F75 7420 
 925      6C69 6E65 
 926 80b59 0D0A 00   		dc.b CR,LF,EOT
 927               	RAM_PASS_MSG:  
 928 80b5c 5241 4D20 		.ascii  "RAM Test Passed"
 928      5465 7374 
 928      2050 6173 
 928      7365 64
 929 80b6b 0D0A 00   		dc.b CR,LF,EOT
 930               	msgDepositPrompt:
 931 80b6e 3A20      	    .ascii	": "
 932 80b70 00        		dc.b 	EOT
 933               	BANNER_MSG:	
 934 80b71 5349 4D50 		.ascii  "SIMPLE-68008 CPU V1.00"
68K GAS  S68K_002.s 			page 19


 934      4C45 2D36 
 934      3830 3038 
 934      2043 5055 
 934      2056 312E 
 935 80b87 0D0A 00   		dc.b CR,LF,EOT
 936               	msgInvalidCommand:
 937 80b8a 496E 7661 	    .ascii "Invalid Command"
 937      6C69 6420 
 937      436F 6D6D 
 937      616E 64
 938 80b99 0D0A 00   		dc.b CR,LF,EOT
 939               	CRLF_MSG:	
 940 80b9c 0D0A 00   		dc.b CR,LF,EOT
 941               	msgHelp:
 942 80b9f 4176 6169 	    .ascii	"Available Commands: "
 942      6C61 626C 
 942      6520 436F 
 942      6D6D 616E 
 942      6473 3A20 
 943 80bb3 0D0A      		dc.b	CR,LF
 944 80bb5 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 944      7861 6D69 
 944      6E65 2020 
 944      2020 2844 
 944      2965 706F 
 945 80beb 0D0A 00   		dc.b	CR,LF,EOT
 946               	ldSRecMsg:
 947 80bee 4C6F 6164 	    .ascii	"Load S-Record"
 947      2053 2D52 
 947      6563 6F72 
 947      64
 948 80bfb 0D0A 00   		dc.b	CR,LF,EOT
 949               	msgInvalidAddress:
 950 80bfe 496E 7661 	    .ascii	"Invalid Address"
 950      6C69 6420 
 950      4164 6472 
 950      6573 73
 951 80c0d 0D0A 00   		dc.b 	CR,LF,EOT
 952               	msgInvalidValue:
 953 80c10 496E 7661 	    .ascii	"Invalid Value"
 953      6C69 6420 
 953      5661 6C75 
 953      65
 954 80c1d 0D0A 00   		dc.b	CR,LF,EOT
 955               	msgPrompt:
 956 80c20 3E20      		.ascii "> "
 957 80c22 00        	    dc.b EOT
 958               	msgColonSpace:
 959 80c23 3A20      	    .ascii ": "
 960 80c25 00        	    dc.b EOT
 961               	msgNewline:
 962 80c26 0D0A 00   	    dc.b CR,LF,EOT
 963               	debug_Srec_Typ_Msg:
 964 80c29 5320 5265 		.ascii	"S Record Type="
 964      636F 7264 
 964      2054 7970 
 964      653D 
68K GAS  S68K_002.s 			page 20


 965 80c37 00        	    dc.b EOT
 966               	debug_Srec_BytCt_Msg:
 967 80c38 5320 5265 		.ascii	"S Record Byte Count=0x"
 967      636F 7264 
 967      2042 7974 
 967      6520 436F 
 967      756E 743D 
 968 80c4e 00        	    dc.b EOT
 969               	debug_Srec_CSum_Msg:
 970 80c4f 5320 5265 		.ascii	"S Record Checksum="
 970      636F 7264 
 970      2043 6865 
 970      636B 7375 
 970      6D3D 
 971 80c61 00        	    dc.b EOT
 972               	debug_S2rec_Addr_Msg:
 973 80c62 5332 2052 		.ascii	"S2 Record Address=0x"
 973      6563 6F72 
 973      6420 4164 
 973      6472 6573 
 973      733D 3078 
 974 80c76 00        	    dc.b EOT
 975               	debug_SXrec_Addr_Msg:
 976 80c77 5320 286E 		.ascii	"S (not 2) Record Address=0x"
 976      6F74 2032 
 976      2920 5265 
 976      636F 7264 
 976      2041 6464 
 977 80c92 00        	    dc.b EOT
 978               	debug_Srec_LDData_Msg:
 979 80c93 4C6F 6164 	    .ascii	"Load Data Loop start"
 979      2044 6174 
 979      6120 4C6F 
 979      6F70 2073 
 979      7461 7274 
 980 80ca7 0D0A 00   		dc.b 	CR,LF,EOT
 981               	
 982               	
 983               	MAX_LINE_LENGTH = 80
 984               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 985               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 21


DEFINED SYMBOLS
          S68K_002.s:12     *ABS*:0000000000000000 RAM_START
          S68K_002.s:13     *ABS*:000000000007fffc STACK_END
          S68K_002.s:14     *ABS*:000000000007ffff RAM_END
          S68K_002.s:15     *ABS*:0000000000080000 ROM_START
          S68K_002.s:16     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:18     *ABS*:000000000008ffff ROM_END
          S68K_002.s:23     *ABS*:00000000000f0000 DUART
          S68K_002.s:24     *ABS*:00000000000f0000 MRA
          S68K_002.s:25     *ABS*:00000000000f0002 SRA
          S68K_002.s:26     *ABS*:00000000000f0002 CSRA
          S68K_002.s:27     *ABS*:00000000000f0004 CRA
          S68K_002.s:28     *ABS*:00000000000f0006 RBA
          S68K_002.s:29     *ABS*:00000000000f0006 TBA
          S68K_002.s:30     *ABS*:00000000000f0008 ACR
          S68K_002.s:31     *ABS*:00000000000f000a ISR
          S68K_002.s:32     *ABS*:00000000000f000a IMR
          S68K_002.s:33     *ABS*:00000000000f0010 MRB
          S68K_002.s:34     *ABS*:00000000000f0012 SRB
          S68K_002.s:35     *ABS*:00000000000f0012 CSRB
          S68K_002.s:36     *ABS*:00000000000f0014 CRB
          S68K_002.s:37     *ABS*:00000000000f0016 RBB
          S68K_002.s:38     *ABS*:00000000000f0016 TBB
          S68K_002.s:39     *ABS*:00000000000f0018 IVR
          S68K_002.s:40     *ABS*:00000000000f001a OPC
          S68K_002.s:41     *ABS*:00000000000f001a INU
          S68K_002.s:42     *ABS*:00000000000f001c OPS
          S68K_002.s:43     *ABS*:00000000000f001e OPR
          S68K_002.s:48     *ABS*:0000000000000007 BEL
          S68K_002.s:49     *ABS*:0000000000000008 BKSP
          S68K_002.s:50     *ABS*:0000000000000009 TAB
          S68K_002.s:51     *ABS*:000000000000000a LF
          S68K_002.s:52     *ABS*:000000000000000d CR
          S68K_002.s:53     *ABS*:000000000000001b ESC
          S68K_002.s:54     *ABS*:0000000000000000 EOT
          S68K_002.s:56     *ABS*:0000000000000003 CTRLC
          S68K_002.s:57     *ABS*:0000000000000018 CTRLX
          S68K_002.s:60     .text:0000000000000400 _srecType
          S68K_002.s:61     .text:0000000000000401 _srecByCt
          S68K_002.s:62     .text:0000000000000402 _srecData
          S68K_002.s:63     .text:0000000000000403 _srecCSum
          S68K_002.s:64     .text:0000000000000404 _srecAddr
          S68K_002.s:66     *ABS*:0000000000000400 srecType
          S68K_002.s:67     *ABS*:0000000000000401 srecByCt
          S68K_002.s:68     *ABS*:0000000000000402 srecData
          S68K_002.s:69     *ABS*:0000000000000403 srecCSum
          S68K_002.s:70     *ABS*:0000000000000404 srecAddr
          S68K_002.s:183    .text:0000000000080508 FERVR2
          S68K_002.s:108    .text:0000000000080462 loop1stLoc
          S68K_002.s:181    .text:0000000000080508 failBitTest
          S68K_002.s:123    .text:0000000000080482 loopAdrFill
          S68K_002.s:135    .text:00000000000804a0 loopAdrCk
          S68K_002.s:182    .text:0000000000080508 failAdrTest
          S68K_002.s:150    .text:00000000000804ba fillSRAM
          S68K_002.s:154    .text:00000000000804c6 fillSRAMLoop
          S68K_002.s:883    .text:0000000000080a82 initDuart
          S68K_002.s:163    .text:00000000000804d2 monitorStart
68K GAS  S68K_002.s 			page 22


          S68K_002.s:933    .text:0000000000080b71 BANNER_MSG
          S68K_002.s:208    .text:0000000000080536 printString1
          S68K_002.s:927    .text:0000000000080b5c RAM_PASS_MSG
          S68K_002.s:171    .text:00000000000804e2 interpLoop
          S68K_002.s:955    .text:0000000000080c20 msgPrompt
          S68K_002.s:209    .text:0000000000080536 printString
          S68K_002.s:238    .text:0000000000080568 readLine
          S68K_002.s:295    .text:00000000000805fa lineToUpper
          S68K_002.s:312    .text:0000000000080618 parseLine
          S68K_002.s:190    .text:000000000008050e outChar1
          S68K_002.s:191    .text:000000000008050e outChar
          S68K_002.s:199    .text:0000000000080522 outChar2
          S68K_002.s:210    .text:0000000000080536 PSloop
          S68K_002.s:216    .text:000000000008053e PSend
          S68K_002.s:224    .text:0000000000080540 inChar1
          S68K_002.s:225    .text:0000000000080540 inChar
          S68K_002.s:231    .text:0000000000080554 inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:242    .text:0000000000080574 RLloop
          S68K_002.s:259    .text:00000000000805a0 RLBS
          S68K_002.s:270    .text:00000000000805be RLlineClr
          S68K_002.s:284    .text:00000000000805e2 RLEndLn
          S68K_002.s:252    .text:0000000000080590 .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:274    .text:00000000000805c4 RLlineClrloop
          S68K_002.s:297    .text:0000000000080600 LUloop
          S68K_002.s:304    .text:0000000000080612 LUnext
          S68K_002.s:315    .text:0000000000080622 PLfindCommand
          S68K_002.s:364    .text:0000000000080694 .examine
          S68K_002.s:757    .text:00000000000809a4 .deposit
          S68K_002.s:800    .text:0000000000080a08 .run
          S68K_002.s:343    .text:0000000000080670 .help
          S68K_002.s:445    .text:0000000000080728 loadSRec
          S68K_002.s:419    .text:000000000008071e .runBASIC
          S68K_002.s:336    .text:000000000008066a .exit
          S68K_002.s:333    .text:0000000000080662 .invalid
          S68K_002.s:936    .text:0000000000080b8a msgInvalidCommand
          S68K_002.s:941    .text:0000000000080b9f msgHelp
          S68K_002.s:347    .text:000000000008067c .invalidAddr
          S68K_002.s:949    .text:0000000000080bfe msgInvalidAddress
          S68K_002.s:351    .text:0000000000080688 .invalidVal
          S68K_002.s:952    .text:0000000000080c10 msgInvalidValue
          S68K_002.s:632    .text:00000000000808a8 parseNumber
          S68K_002.s:369    .text:00000000000806a0 .exloop
          S68K_002.s:383    .text:00000000000806c4 .exrange
          S68K_002.s:392    .text:00000000000806d6 .exlength
          S68K_002.s:400    .text:00000000000806e8 .exinter
          S68K_002.s:389    .text:00000000000806d2 .exquick
          S68K_002.s:396    .text:00000000000806e0 .exend
          S68K_002.s:685    .text:000000000008090a dumpRAM
          S68K_002.s:405    .text:00000000000806f6 .exinterend
          S68K_002.s:412    .text:000000000008070a .exinterpage
          S68K_002.s:946    .text:0000000000080bee ldSRecMsg
          S68K_002.s:448    .text:0000000000080730 loadSRecLoop
          S68K_002.s:505    .text:00000000000807c8 setRecType
          S68K_002.s:524    .text:00000000000807e2 setBytCt
          S68K_002.s:564    .text:000000000008082c setAddr
68K GAS  S68K_002.s 			page 23


          S68K_002.s:460    .text:000000000008075a loopSData
          S68K_002.s:465    .text:000000000008076c sRecDataDone
          S68K_002.s:480    .text:00000000000807a4 getSetLdData
          S68K_002.s:492    .text:00000000000807be getChksum
          S68K_002.s:540    .text:00000000000807f4 getHexPair
          S68K_002.s:488    .text:00000000000807bc skipLdData
          S68K_002.s:501    .text:00000000000807c6 failCSUM
          S68K_002.s:553    .text:0000000000080814 toNibble
          S68K_002.s:558    .text:0000000000080822 doHexLetter
          S68K_002.s:605    .text:000000000008088a adrLen16
          S68K_002.s:622    .text:00000000000808a2 past16
          S68K_002.s:646    .text:00000000000808cc PNinvalid
          S68K_002.s:652    .text:00000000000808d6 PNfirstdigit1
          S68K_002.s:649    .text:00000000000808d0 PNfirstdigit2
          S68K_002.s:654    .text:00000000000808da PNloop
          S68K_002.s:665    .text:00000000000808f4 PNend
          S68K_002.s:672    .text:0000000000080900 PNdigit1
          S68K_002.s:669    .text:00000000000808fa PNdigit2
          S68K_002.s:674    .text:0000000000080904 PNdigit3
          S68K_002.s:689    .text:0000000000080912 .line
          S68K_002.s:824    .text:0000000000080a24 printHexAddr
          S68K_002.s:958    .text:0000000000080c23 msgColonSpace
          S68K_002.s:696    .text:0000000000080924 .hexbyte
          S68K_002.s:708    .text:0000000000080940 .endbytesShort
          S68K_002.s:723    .text:0000000000080966 .endbytes
          S68K_002.s:857    .text:0000000000080a4c printHexByte
          S68K_002.s:711    .text:0000000000080946 .endbytesShortLoop
          S68K_002.s:725    .text:0000000000080968 .endbytesLoop
          S68K_002.s:740    .text:000000000008098e .endline
          S68K_002.s:736    .text:0000000000080984 .unprintable
          S68K_002.s:961    .text:0000000000080c26 msgNewline
          S68K_002.s:746    .text:000000000008099e .end
          S68K_002.s:782    .text:00000000000809dc DepCont
          S68K_002.s:766    .text:00000000000809b8 DepLoop
          S68K_002.s:787    .text:00000000000809e6 DepMLine
          S68K_002.s:794    .text:00000000000809fe DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:930    .text:0000000000080b6e msgDepositPrompt
          S68K_002.s:815    .text:0000000000080a1a printHexWord
          S68K_002.s:843    .text:0000000000080a3c printHex_wordentry
          S68K_002.s:839    .text:0000000000080a36 printHex_addrentry
          S68K_002.s:832    .text:0000000000080a2c printHexLong
          S68K_002.s:867    .text:0000000000080a64 PHBsecond
          S68K_002.s:874    .text:0000000000080a78 PHBend
          S68K_002.s:911    .text:0000000000080b0c delay1Sec
          S68K_002.s:913    .text:0000000000080b12 delay1Loop
          S68K_002.s:918    .text:0000000000080b1a READINLINE
          S68K_002.s:921    .text:0000000000080b2c L_TO_UPPER_MSG
          S68K_002.s:924    .text:0000000000080b49 WRITEOUTLINE
          S68K_002.s:939    .text:0000000000080b9c CRLF_MSG
          S68K_002.s:963    .text:0000000000080c29 debug_Srec_Typ_Msg
          S68K_002.s:966    .text:0000000000080c38 debug_Srec_BytCt_Msg
          S68K_002.s:969    .text:0000000000080c4f debug_Srec_CSum_Msg
          S68K_002.s:972    .text:0000000000080c62 debug_S2rec_Addr_Msg
          S68K_002.s:975    .text:0000000000080c77 debug_SXrec_Addr_Msg
          S68K_002.s:978    .text:0000000000080c93 debug_Srec_LDData_Msg

68K GAS  S68K_002.s 			page 24


NO UNDEFINED SYMBOLS
