68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Land Boards, LLC
   4               	|	(c) 2024
   5               	| Use it however you want
   6               	| Borrowed init code from 
   7               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   8               	|
   9               	| Added S-Record load code
  10               	|	Uses SRAM from 0x400-0x407
  11               	
  12               	RAM_START	= 0x00000	| Beginning of the SRAM
  13               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
  14               	RAM_END		= 0x7FFFF	| 512KB SRAM
  15               	ROM_START	= 0x80000	| ROM start
  16               	ROM_CODE	= ROM_START+1024| Skip vector table
  17               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  18               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  19               	
  20               	|||||||||||||||||||||||||||||||||
  21               	| 68681 Duart Register Addresses
  22               	|
  23               	DUART = 0x0F0000	  | Base Addr of DUART
  24               	MRA   = DUART+0		  | Mode Register A           (R/W)
  25               	SRA   = DUART+2       | Status Register A         (r)
  26               	CSRA  = DUART+2       | Clock Select Register A   (w)
  27               	CRA   = DUART+4       | Commands Register A       (w)
  28               	RBA   = DUART+6       | Receiver Buffer A         (r)
  29               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  30               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  31               	ISR   = DUART+10      | Interrupt Status Register (R)
  32               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  33               	MRB   = DUART+16      | Mode Register B           (R/W)
  34               	SRB   = DUART+18      | Status Register B         (R)
  35               	CSRB  = DUART+18      | Clock Select Register B   (W)
  36               	CRB   = DUART+20      | Commands Register B       (W)
  37               	RBB   = DUART+22      | Reciever Buffer B         (R)
  38               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  39               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  40               	OPC   = DUART+26      | Output port config        (W)
  41               	INU   = DUART+26      | Input port (unlatched)    (R)
  42               	OPS   = DUART+28      | Output port Set           (W)
  43               	OPR   = DUART+30      | Output port Clear         (W)
  44               	
  45               	||||||||||||||||||||||||||||||||||
  46               	| ASCII Control Characters
  47               	|
  48               	BEL   = 0x07
  49               	BKSP  = 0x08       | CTRL-H
  50               	TAB   = 0x09
  51               	LF    = 0x0A
  52               	CR    = 0x0D
  53               	ESC   = 0x1B
  54               	EOT	  = 0x00
  55               	
  56               	CTRLC	=	0x03
  57               	CTRLX	=	0x18     | Line Clear
68K GAS  S68K_002.s 			page 2


  58               	
  59 0000 0000 0000 		.ORG    0x000400
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  60 0400 00        	_srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  61 0401 00        	_srecByCt:	ds.b	1		| Byte Count
  62 0402 00        	_srecData:	ds.b	1 		| Data
  63 0403 00        	_srecCSum:	ds.b	1 		| S-Record Checksum
  64 0404 0000 0000 	_srecAddr:	ds.l	1		| S Record current byte address
  65               	
  66               	srecType	=		0x000400	| S1-S9 stored as binary 1-9
  67               	srecByCt	=		0x000401	| Byte Count
  68               	srecData	=		0x000402	| Data
  69               	srecCSum	=		0x000403	| S-Record Checksum
  70               	srecAddr	=		0x000404	| S Record current byte address
  71               	
  72 0408 0000 0000 		.ORG	ROM_START
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  73               	
  74               	| FIRST 8 bytes loaded after reset |
  75 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  76 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  77               	
  78 80008 0000 0000 	        .ORG ROM_CODE
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  79 80400 4E71      		nop
  80 80402 4FF9 0007 		lea		STACK_END, %sp
  80      FFFC 
  81 80408 4DF9 0007 		lea		STACK_END-128, %fp	| Plenty of room for the monitor's stack
  81      FF7C 
  82               									| Need frame pointer for running C code
  83 8040e 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  83      0008 0000 
  84 80416 4E71      		nop
  85               	| LEDs
  86 80418 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  86      000F 001A 
  87 80420 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  87      000F 001E 
  88 80428 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  88      000F 001C 
  89               	|
  90               	| Test the first two SRAM location
  91               	|
  92 80430 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  92      BEEF 
  93 80436 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  94 8043a 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  95 8043c 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
68K GAS  S68K_002.s 			page 3


  96 8043e B042      		cmp			%d2, %d0
  97 80440 6600 00C6 		bne			FERVR2						
  98 80444 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  98      AAAA 
  99 8044a 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
 100 8044e 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
 101 80450 2611      		move.l	(%a1), %d3				| Read back
 102 80452 B243      		cmp			%d3, %d1
 103 80454 6600 00B2 		bne			FERVR2
 104 80458 4E71      		nop
 105               	| Test bits of first location (as bytes)
 106 8045a 7001      		move.l	#1, %d0
 107 8045c 207C 0000 		move.l	#0, %a0
 107      0000 
 108               	loop1stLoc:
 109 80462 1080      		move.b	%d0, (%a0)
 110 80464 1210      		move.b	(%a0), %d1
 111 80466 B200      		cmp.b		%d0, %d1
 112 80468 6600 009E 		bne			failBitTest
 113 8046c E348      		lsl			#1, %d0
 114 8046e 0C80 0000 		cmp.l		#0x00000100, %d0
 114      0100 
 115 80474 6600 FFEC 		bne			loop1stLoc
 116               	|
 117               	| Test all address lines, 512KB SRAM
 118               	| Write incrementing pattern to data bits
 119               	|
 120 80478 7001      		move.l	#1, %d0		| Fill pattern
 121 8047a 7401      		move.l	#1, %d2
 122 8047c 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 122      0001 
 123               	loopAdrFill:
 124 80482 1080      		move.b	%d0,(%a0)	| Do the write
 125 80484 5240      		addq		#1, %d0		| Increment the pattern
 126 80486 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 127 80488 E38A      		lsl.l		#1, %d2		| Shift temp addr
 128 8048a 2042      		move.l	%d2, %a0	| Put back into addr reg
 129 8048c 0C82 0008 		cmp.l		#0x00080000,%d2
 129      0000 
 130 80492 6600 FFEE 		bne			loopAdrFill
 131               	| Check
 132 80496 7001      		move.l	#1, %d0
 133 80498 7401      		move.l	#1, %d2
 134 8049a 207C 0000 		move.l	#1, %a0
 134      0001 
 135               	loopAdrCk:
 136 804a0 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 137 804a2 B200      		cmp.b		%d0, %d1
 138 804a4 6600 0062 		bne			failAdrTest
 139 804a8 5240      		addq		#1, %d0
 140 804aa 2408      		move.l	%a0, %d2 
 141 804ac E38A      		lsl.l		#1, %d2
 142 804ae 2042      		move.l	%d2, %a0
 143 804b0 0C82 0008 		cmp.l		#0x00080000,%d2
 143      0000 
 144 804b6 6600 FFE8 		bne			loopAdrCk
 145               		
68K GAS  S68K_002.s 			page 4


 146               	|
 147               	| Fill SRAM with 0x00 values
 148               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 149               	|
 150               	fillSRAM:
 151 804ba 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 152 804be 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 152      FFFF 
 153 804c4 7000      		move.l	#0x00, %d0			| Fill with zeros
 154               	fillSRAMLoop:
 155 804c6 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 156 804c8 B3C8      		cmpa.l	%a0, %a1
 157 804ca 6E00 FFFA 		bgt		fillSRAMLoop
 158               	
 159               	|
 160               	| Done with address test of SRAM
 161               	|
 162 804ce 4EBA 05A0 		jsr     initDuart       	| Setup the serial port
 163               	monitorStart:					| Warm start
 164 804d2 41FA 068B 		lea		BANNER_MSG, %a0
 165 804d6 4EBA 005E 		jsr		printString1
 166 804da 41FA 066E 		lea		RAM_PASS_MSG, %a0
 167 804de 4EBA 0056 		jsr		printString1
 168               	|
 169               	| Interpreter Loop
 170               	|
 171               	interpLoop:
 172 804e2 41FA 072A 	    lea     msgPrompt, %a0	| Prompt
 173 804e6 6100 004E 	    bsr.w   printString
 174 804ea 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 174      000F 001E 
 175 804f2 4EBA 0074 		jsr		readLine		| Blocking read of line
 176 804f6 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 176      000F 001C 
 177 804fe 4EBA 00FA 		jsr		lineToUpper
 178 80502 4EBA 0114 		jsr		parseLine
 179 80506 60DA      		bra.s	interpLoop
 180               		
 181               	failBitTest:
 182               	failAdrTest:
 183               	FERVR2:
 184 80508 4E71      		nop
 185 8050a 4EFA FFFC 		jmp	FERVR2
 186               	
 187               	|||||
 188               	| Writes a character to Port A, blocking if not ready (Full buffer)
 189               	|  - Takes a character in D0
 190               	outChar1:
 191               	outChar:
 192 8050e 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 192      000F 0002 
 193 80516 6700 FFF6 	    beq     outChar1     
 194 8051a 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 194      0006 
 195 80520 4E75      	    rts
 196               	
 197               	| Writes a character to Port A, blocking if not ready (Full buffer)
68K GAS  S68K_002.s 			page 5


 198               	|  - Takes a character in D0
 199               	outChar2:
 200 80522 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 200      000F 0012 
 201 8052a 6700 FFF6 	    beq     outChar2     
 202 8052e 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 202      0016 
 203 80534 4E75      	    rts
 204               	
 205               	******
 206               	* Print a null terminated string
 207               	*
 208               	printString1:
 209               	printString:
 210               	PSloop:
 211 80536 1018      	    move.b  (%a0)+, %d0  | Read in character
 212 80538 6704      	    beq.s   PSend         | Check for the null
 213               	    
 214 8053a 61D2      	    bsr.s   outChar      | Otherwise write the character
 215 8053c 60F8      	    bra.s   PSloop        | And continue
 216               	PSend:
 217 8053e 4E75      	    rts
 218               	
 219               	
 220               	|||||
 221               	| Reads in a character from Port A, blocking if none available
 222               	|  - Returns character in D0
 223               	|    
 224               	inChar1:
 225               	inChar:
 226 80540 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 226      000F 0002 
 227 80548 6700 FFF6 	    beq     inChar1
 228 8054c 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 228      0006 
 229 80552 4E75      	    rts
 230               	
 231               	inChar2:
 232 80554 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 232      000F 0012 
 233 8055c 6700 FFF6 	    beq     inChar2
 234 80560 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 234      0016 
 235 80566 4E75      	    rts
 236               	
 237               	| Read in a line into the line buffer
 238               	readLine:
 239 80568 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 240 8056c 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 240      FBAE 
 241 80572 B542      	    eor.w   %d2, %d2           	| Clear the character counter
 242               	 RLloop:
 243 80574 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 244 80578 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 245 8057c 6722      	    beq.s   RLBS
 246 8057e 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 247 80582 673A      	    beq.s   RLlineClr
68K GAS  S68K_002.s 			page 6


 248 80584 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 249 80588 6758      	    beq.s   RLEndLn
 250 8058a 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 251 8058e 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 252               	 .char:                      	| Normal character to be inserted into the buffer
 253 80590 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 254 80594 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 255 80596 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 256 80598 5242      	    addq.w  #1, %d2           	| Increment character count
 257 8059a 6100 FF72 	    bsr.w   outChar          	| Echo the character
 258 8059e 60D4      	    bra.s   RLloop            	| And get the next one
 259               	 RLBS:
 260 805a0 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 261 805a2 67D0      	    beq.s   RLloop            	| Then ignore it
 262 805a4 6100 FF68 	    bsr.w   outChar          	| Backspace
 263 805a8 103C 0020 	    move.b  #' ', %d0
 264 805ac 6100 FF60 	    bsr.w   outChar          	| Space
 265 805b0 103C 0008 	    move.b  #BKSP, %d0
 266 805b4 6100 FF58 	    bsr.w   outChar          	| Backspace
 267 805b8 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 268 805ba 5382      	    subq.l  #1, %d2           	| And current character count
 269 805bc 60B6      	    bra.s   RLloop            	| And goto the next character
 270               	 RLlineClr:
 271 805be 4A42      	    tst     %d2               	| Anything to clear?
 272 805c0 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 273 805c2 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 274               	 RLlineClrloop:
 275 805c4 103C 0008 	    move.b  #BKSP, %d0
 276 805c8 6100 FF44 	    bsr.w   outChar          	| Backspace
 277 805cc 103C 0020 	    move.b  #' ', %d0
 278 805d0 6100 FF3C 	    bsr.w   outChar          	| Space
 279 805d4 103C 0008 	    move.b  #BKSP, %d0
 280 805d8 6100 FF34 	    bsr.w   outChar          	| Backspace
 281 805dc 5342      	    subq.w  #1, %d2          
 282 805de 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 283 805e0 6092      	    bra.s   RLloop   
 284               	 RLEndLn:
 285 805e2 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 286 805e6 103C 000A 	    move.b  #LF, %d0
 287 805ea 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 288 805ee 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 289 805f2 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 290 805f4 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 291 805f8 4E75      	    rts                      	| And return
 292               	
 293               	
 294               	| Convert line buffer to upper case
 295               	lineToUpper:
 296 805fa 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 296      FBAE 
 297               	 LUloop:
 298 80600 1010      	    move.b  (%a0), %d0        | Read in a character
 299 80602 0C00 0061 	    cmp.b   #'a', %d0         
 300 80606 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 301 80608 0C00 007A 	    cmp.b   #'z', %d0
 302 8060c 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 303 8060e 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
68K GAS  S68K_002.s 			page 7


 304               	 LUnext:
 305 80612 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 306 80614 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 307 80616 4E75      	    rts
 308               	
 309               	|
 310               	| Parse Line
 311               	|
 312               	parseLine:
 313 80618 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 314 8061c 41F9 0007 	    lea     varLineBuf, %a0
 314      FBAE 
 315               	 PLfindCommand:
 316 80622 1018      	    move.b  (%a0)+, %d0
 317 80624 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 318 80628 6700 FFF8 	    beq.w   PLfindCommand    
 319 8062c 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 320 80630 6700 005A 	    beq.w   .examine
 321 80634 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 322 80638 6700 0358 	    beq.w   .deposit
 323 8063c 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 324 80640 6700 03B4 	    beq.w   .run
 325 80644 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 326 80648 6700 001E 	    beq.w   .help
 327 8064c 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 328 80650 6700 00C4 	    beq.w   loadSRec
 329 80654 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 330 80658 6708      	    beq.s   .exit               
 331               	 .invalid:   
 332 8065a 41FA 051C 	    lea     msgInvalidCommand, %a0
 333 8065e 6100 FED6 	    bsr.w   printString
 334               	 .exit:
 335 80662 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 336 80666 4E75      	    rts
 337               	
 338               	|||||||||||||||||||||||||||||||
 339               	|| HELP command
 340               	 .help:
 341 80668 41FA 0523 	    lea     msgHelp, %a0
 342 8066c 6100 FEC8 	    bsr.w   printString
 343 80670 6000 FFF0 	    bra.w   .exit
 344               	 .invalidAddr:
 345 80674 41FA 0576 	    lea     msgInvalidAddress, %a0
 346 80678 6100 FEBC 	    bsr.w   printString
 347 8067c 6000 FFE4 	    bra.w   .exit
 348               	 .invalidVal:
 349 80680 41FA 057C 	    lea     msgInvalidValue, %a0
 350 80684 6100 FEB0 	    bsr.w   printString
 351 80688 6000 FFD8 	    bra.w   .exit
 352               		
 353               	|||||||||||||||||||||||||||||||
 354               	| Examines memory addresses
 355               	| Valid modes:
 356               	|   e ADDR                  Displays a single byte
 357               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 358               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 359               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
68K GAS  S68K_002.s 			page 8


 360               	|   e ADDR.                 Quick line, displays one line 
 361               	.examine:
 362 8068c 6100 0208 	    bsr.w   parseNumber         | Read in the start address
 363 80690 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 364 80692 6600 FFE0 	    bne.w   .invalidAddr        
 365 80696 2640      	    move.l  %d0, %a3            | Save the start address
 366               	 .exloop:
 367 80698 1018      	    move.b  (%a0)+, %d0
 368 8069a 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 369 8069e 67F8      	    beq.s   .exloop
 370 806a0 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 371 806a4 6716      	    beq.s   .exrange
 372 806a6 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 373 806aa 6722      	    beq.s   .exlength
 374 806ac 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
 375 806b0 672E      	    beq.s   .exinter
 376 806b2 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 377 806b6 6712      	    beq.s   .exquick
 378 806b8 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 379 806ba 601C      	    bra.s   .exend              
 380               	 .exrange:
 381 806bc 6100 01D8 	    bsr.w   parseNumber         | Find the end address
 382 806c0 4A01      	    tst.b   %d1                 | Check if we found a valid address
 383 806c2 6600 FFB0 	    bne.w   .invalidAddr
 384 806c6 908B      	    sub.l   %a3, %d0            | Get the length
 385 806c8 600E      	    bra.s   .exend
 386               	 .exquick:                      | Quick mode means show one line of 16 bytes
 387 806ca 7010      	    move.l  #0x10, %d0
 388 806cc 600A      	    bra.s   .exend
 389               	 .exlength:                     | Length mode means a length is specified
 390 806ce 6100 01C6 	    bsr.w   parseNumber         | Find the length
 391 806d2 4A01      	    tst.b   %d1
 392 806d4 6600 FF9E 	    bne.w   .invalidAddr
 393               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 394 806d8 204B      	    move.l  %a3, %a0
 395 806da 6100 021C 	    bsr.w   dumpRAM
 396 806de 6082      	    bra.s   .exit
 397               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 398 806e0 204B      	    move.l  %a3, %a0            | Current Address
 399 806e2 7010      	    move.l  #0x10, %d0          | 16 bytes
 400 806e4 6100 0212 	    bsr.w   dumpRAM             | Dump this line
 401 806e8 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 401      0010 
 402               	 .exinterend:
 403 806ee 6100 FE50 	    bsr.w   inChar
 404 806f2 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 405 806f6 67E8      	    beq.s   .exinter
 406 806f8 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 407 806fc 6704      	    beq.s   .exinterpage
 408 806fe 6000 FF62 	    bra	   .exit               | Otherwise exit
 409               	 .exinterpage:
 410 80702 204B      	    move.l  %a3, %a0
 411 80704 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 411      0100 
 412 8070a 6100 01EC 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 413 8070e D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 413      0100 
68K GAS  S68K_002.s 			page 9


 414 80714 60D8      	    bra.s   .exinterend
 415               	
 416               	|||||||||||||||||||||||||||||
 417               	|| Load S Record
 418               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 419               	|	srecByCt:	ds.b	1		| Byte Count
 420               	|	srecData:	ds.b	1 		| Data
 421               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 422               	|	srecAddr:	ds.l	1		| S Record current byte address
 423               	|
 424               	| Supports S record types (matches gcc m68k output)
 425               	|	S00F00005336384B5F3030322E746D7074
 426               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 427               	|	S503005BA1
 428               	|
 429               	| Also supports S1 records
 430               	|	S00F00005336384B5F3030332E746D7073
 431               	|	S123100013FC0000000F001A13FC00FC000F001E13FC0004000F001C13FC0004000F001EDE
 432               	|	S1231020203C000186A053806600FFFC13FC0004000F001C203C000186A053806600FFFC00
 433               	|	S10710406000FFD673
 434               	|	S5030003F9
 435               	|
 436               	
 437               	loadSRec:
 438 80716 41FA 04C4 	    lea     ldSRecMsg, %a0					| "Load S-Record"
 439 8071a 6100 FE1A 	    bsr.w   printString
 440               	loadSRecLoop:
 441 8071e 6100 0096 		bsr		setRecType
 442 80722 6100 00AC 		bsr		setBytCt
 443 80726 11FC 0000 		move.b 	#0, srecCSum
 443      0403 
 444 8072c 6100 00EC 		bsr		setAddr
 445               	|	lea		debug_Srec_LDData_Msg, %a0		| "Load Data Loop start"
 446               	|	bsr		printString
 447 80730 0C38 0001 		cmp.b	#1, srecType			| 16-bit Address
 447      0400 
 448 80736 6700 0010 		beq		loopSData
 449 8073a 0C38 0002 		cmp.b	#2, srecType			| 24-bit Address
 449      0400 
 450 80740 6700 0006 		beq		loopSData
 451 80744 6000 0014 		bra		sRecDataDone
 452               	loopSData:
 453 80748 0C38 0000 		cmp.b 	#0, srecByCt
 453      0401 
 454 8074e 6700 000A 		beq		sRecDataDone
 455 80752 6100 003E 		bsr		getSetLdData
 456 80756 6000 FFF0 		bra		loopSData
 457               	sRecDataDone:
 458 8075a 6100 0050 		bsr		getChksum
 459 8075e 103C 002B 		move.b	#'+', %d0
 460 80762 6100 FDAA 		bsr		outChar
 461 80766 0C38 0000 		cmp.b	#0, srecType
 461      0400 
 462 8076c 6700 FFB0 		beq		loadSRecLoop
 463 80770 0C38 0001 		cmp.b	#1, srecType
 463      0400 
 464 80776 6700 FFA6 		beq		loadSRecLoop
68K GAS  S68K_002.s 			page 10


 465 8077a 0C38 0002 		cmp.b	#2, srecType
 465      0400 
 466 80780 6700 FF9C 		beq		loadSRecLoop
 467 80784 0C38 0003 		cmp.b	#3, srecType
 467      0400 
 468 8078a 6700 FF92 		beq		loadSRecLoop
 469 8078e 6000 FED2 		bra.w   .exit
 470               	
 471               	|||||||||||||||||||||||||||||
 472               	getSetLdData:
 473 80792 4EBA 004E 		jsr		getHexPair
 474 80796 41F8 0404 		lea 	srecAddr, %a0
 475 8079a 2250      		move.l	(%a0), %a1
 476 8079c 12C0      		move.b	%d0, (%a1)+
 477 8079e 21C9 0404 		move.l	%a1, srecAddr
 478 807a2 D138 0403 		add.b	%d0, srecCSum
 479 807a6 5338 0401 		sub.b	#1, srecByCt
 480               	skipLdData:
 481 807aa 4E75      		rts
 482               	
 483               	|||||||||||||||||||||||||||||
 484               	getChksum:
 485               	|	lea		debug_Srec_CSum_Msg, %a0	| "S Record Checksum="
 486               	|	bsr.w   printString
 487 807ac 4EBA 0034 		jsr		getHexPair
 488 807b0 D138 0403 		add.b	%d0, srecCSum
 489               	|	move.b	srecCSum, %d0
 490               	|	jsr		printHexByte
 491               	|	lea		CRLF_MSG, %a0
 492               	|	bsr.w   printString
 493               	failCSUM:
 494 807b4 4E75      		rts
 495               	
 496               	|||||||||||||||||||||||||||||
 497               	setRecType:
 498 807b6 4EBA FD88 		jsr		inChar
 499 807ba 0C00 0053 		cmp.b	#'S', %d0
 500 807be 6600 FFF6 		bne		setRecType					| Toss extra chars
 501 807c2 4EBA FD7C 		jsr		inChar
 502 807c6 0200 000F 		andi.b	#0x0f, %d0
 503 807ca 11C0 0400 		move.b	%d0, srecType
 504               	| Debug messages follow
 505               	|	lea		debug_Srec_Typ_Msg, %a0		| "S Record Type="
 506               	|	bsr.w   printString
 507               	|	move.b	srecType, %d0
 508               	|	add.b	#'0', %d0
 509               	|	jsr		outChar
 510               	|	lea		CRLF_MSG, %a0
 511               	|	bsr.w   printString
 512               	| Debug messages end
 513 807ce 4E75      		rts
 514               		
 515               	|||||||||||||||||||||||||||||
 516               	setBytCt:
 517 807d0 4EBA 0010 		jsr		getHexPair
 518 807d4 11C0 0403 		move.b 	%d0, srecCSum				| Initialize checksum
 519 807d8 11C0 0401 		move.b	%d0, srecByCt				| Byte count
68K GAS  S68K_002.s 			page 11


 520               	| Debug messages follow
 521               	|	lea		debug_Srec_BytCt_Msg, %a0	| "S Record Byte Count=0x"
 522               	|	bsr.w   printString
 523               	|	move.b	srecByCt, %d0
 524               	|	jsr		printHexByte
 525               	|	lea		CRLF_MSG, %a0
 526               	|	bsr		printString
 527               	| Debug messages end
 528 807dc 5338 0401 		sub.b	#1, srecByCt
 529 807e0 4E75      		rts
 530               	
 531               	|||||||||||||||||||||||||||||
 532               	getHexPair:
 533 807e2 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 534 807e6 4EBA FD58 		jsr		inChar
 535 807ea 4EBA 0016 		jsr		toNibble
 536 807ee E900      		asl.b	#4, %d0
 537 807f0 1400      		move.b	%d0, %d2
 538 807f2 4EBA FD4C 		jsr		inChar
 539 807f6 4EBA 000A 		jsr		toNibble
 540 807fa 8002      		or.b	%d2, %d0
 541 807fc 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 542 80800 4E75      		rts
 543               	
 544               	|||||||||||||||||||||||||||||
 545               	toNibble:
 546 80802 0C00 0041 		cmp.b	#'A', %d0
 547 80806 6C00 0008 		bge		doHexLetter
 548 8080a 0400 0030 		sub.b	#'0', %d0
 549 8080e 4E75      		rts
 550               	doHexLetter:
 551 80810 0400 0041 		sub.b	#'A', %d0
 552 80814 0600 000A 		add.b	#10, %d0
 553 80818 4E75      		rts
 554               	
 555               	|||||||||||||||||||||||||||||
 556               	setAddr:
 557 8081a 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 558 8081e 0C38 0002 		cmp.b	#2, srecType
 558      0400 
 559 80824 6600 0052 		bne		adrLen16
 560 80828 21FC 0000 		move.l	#0, srecAddr
 560      0000 0404 
 561               	|	lea		debug_S2rec_Addr_Msg, %a0
 562               	|	bsr		printString
 563 80830 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 564               		| Get the upper 8-bits of 24-bits
 565 80832 4EBA FFAE 		jsr		getHexPair
 566 80836 0280 0000 		and.l	#0xff, %d0
 566      00FF 
 567 8083c D138 0403 		add.b 	%d0, srecCSum
 568 80840 8480      		or.l	%d0, %d2
 569 80842 E182      		asl.l	#8, %d2
 570               	|	move.l	%d2, %d0
 571               	|	bsr		printHexLong
 572               	|	lea		CRLF_MSG, %a0
 573               	|   bsr.w   printString
68K GAS  S68K_002.s 			page 12


 574               		| Get the middle 8-bits of 24-bits
 575 80844 4EBA FF9C 		jsr		getHexPair
 576 80848 0280 0000 		and.l	#0xff, %d0
 576      00FF 
 577 8084e D138 0403 		add.b 	%d0, srecCSum
 578 80852 8480      		or.l	%d0, %d2
 579 80854 E182      		asl.l	#8, %d2
 580               	|	move.l	%d2, %d0
 581               	|	bsr		printHexLong
 582               	|	lea		CRLF_MSG, %a0
 583               	|   bsr.w   printString
 584               		| Get the lower 8-bits of 24-bits
 585 80856 4EBA FF8A 		jsr		getHexPair
 586 8085a 0280 0000 		and.l	#0xff, %d0
 586      00FF 
 587 80860 D138 0403 		add.b 	%d0, srecCSum
 588 80864 8480      		or.l	%d0, %d2
 589 80866 0282 00FF 		andi.l	#0x00ffffff, %d2
 589      FFFF 
 590 8086c 21C2 0404 		move.l	%d2, srecAddr		| Save the S record address
 591               	|	move.l	%d2, %d0
 592               	|	bsr		printHexLong
 593               	|	lea		CRLF_MSG, %a0
 594               	|	bsr.w   printString
 595 80870 5738 0401 		sub.b	#3, srecByCt
 596 80874 6000 001A 		bra		past16
 597               	adrLen16:
 598               	|	lea		debug_SXrec_Addr_Msg, %a0	| "S (not 2) Record Address=0x"
 599               	|	bsr		printString
 600 80878 7400      		move.l	#0, %d2
 601 8087a 4EBA FF66 		jsr		getHexPair
 602               	|	bsr		printHexLong
 603               	|	lea		CRLF_MSG, %a0
 604               	|   bsr.w   printString
 605 8087e 8480      		or.l	%d0, %d2
 606 80880 E182      		asl.l	#8, %d2
 607 80882 4EBA FF5E 		jsr		getHexPair
 608               	|	bsr		printHexLong
 609               	|	lea		CRLF_MSG, %a0
 610               	|	bsr.w   printString
 611 80886 8480      		or.l	%d0, %d2
 612 80888 21C2 0404 		move.l	%d2, srecAddr
 613 8088c 5538 0401 		sub.b	#2, srecByCt
 614               	past16:
 615 80890 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 616 80894 4E75      		rts
 617               			
 618               	|||||||||||||||||||||||||||||
 619               	| Find and parse a hex number
 620               	|  Starting address in A0
 621               	|  Number returned in D0
 622               	|  Status in D1   (0 success, 1 fail)
 623               	|  TODO: Try and merge first digit code with remaining digit code
 624               	parseNumber:
 625 80896 B180      	    eor.l   %d0, %d0		| Zero out d0
 626 80898 1018      	    move.b  (%a0)+, %d0
 627 8089a 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
68K GAS  S68K_002.s 			page 13


 628 8089e 67F6      	    beq.s   parseNumber
 629 808a0 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 630 808a4 6D14      	    blt.s	PNinvalid
 631 808a6 0C00 0039 	    cmp.b   #'9', %d0
 632 808aa 6F18      	    ble.s   PNfirstdigit1
 633               	
 634 808ac 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 635 808b0 6D00 FDA8 	    blt   .invalid    
 636 808b4 0C00 0046 	    cmp.b   #'F', %d0
 637 808b8 6F04      	    ble.s   PNfirstdigit2
 638               	PNinvalid:
 639 808ba 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 640 808bc 4E75      	    rts
 641               	PNfirstdigit2:
 642 808be 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 643 808c2 6004      	    bra.s   PNloop
 644               	PNfirstdigit1:
 645 808c4 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 646               	 PNloop:
 647 808c8 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 648 808ca 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 649 808ce 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 650 808d0 0C01 0039 	    cmp.b   #'9', %d1
 651 808d4 6F18      	    ble.s   PNdigit1
 652 808d6 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 653 808da 6D06      	    blt.s   PNend
 654 808dc 0C01 0046 	    cmp.b   #'F', %d1
 655 808e0 6F06      	    ble.s   PNdigit2
 656               	
 657               	PNend:                       | We hit a non-hex digit character, we're done parsing
 658 808e2 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 659 808e4 7200      	    move.l  #0, %d1
 660 808e6 4E75      	    rts
 661               	PNdigit2:
 662 808e8 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 663 808ec 6004      	    bra.s   PNdigit3
 664               	PNdigit1:
 665 808ee 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 666               	PNdigit3:
 667 808f2 E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 668 808f4 D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 669 808f6 60D0      	    bra.s   PNloop
 670               	    
 671               	
 672               	|||||||||||||||||||||||||||||
 673               	| Dumps a section of RAM to the screen
 674               	| Displays both hex values and ASCII characters
 675               	| d0 - Number of bytes to dump
 676               	| a0 - Start Address
 677               	dumpRAM:
 678 808f8 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 679 808fc 2448      	    move.l  %a0, %a2           	| Save the start address
 680 808fe 2400      	    move.l  %d0, %d2           	| And the number of bytes
 681               	 .line:
 682 80900 200A      	    move.l  %a2, %d0          
 683 80902 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 684 80906 41FA 0309 	    lea     msgColonSpace, %a0
68K GAS  S68K_002.s 			page 14


 685 8090a 6100 FC2A 	    bsr.w   printString
 686 8090e 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 687 80910 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 688               	 .hexbyte:
 689 80912 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 690 80914 6718      	    beq.s   .endbytesShort
 691 80916 4A03      	    tst.b   %d3               	| Check if we're done this line
 692 80918 673A      	    beq.s   .endbytes    
 693 8091a 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 694 8091c 6100 011C 	    bsr.w   printHexByte     	| Display it
 695 80920 103C 0020 	    move.b  #' ', %d0
 696 80924 6100 FBE8 	    bsr.w   outChar          	| Space out bytes
 697 80928 5383      	    subq.l  #1, %d3    
 698 8092a 5382      	    subq.l  #1, %d2        
 699 8092c 60E4      	    bra.s   .hexbyte
 700               	 .endbytesShort:
 701 8092e 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 702 80930 103C 0020 	    move.b  #' ', %d0
 703               	 .endbytesShortLoop:
 704 80934 4A03      	    tst.b   %d3               	| Check if we ended the line
 705 80936 671C      	    beq.s   .endbytes
 706 80938 103C 0020 	    move.b  #' ', %d0
 707 8093c 6100 FBD0 	    bsr.w   outChar          	| Three spaces to pad out
 708 80940 103C 0020 	    move.b  #' ', %d0
 709 80944 6100 FBC8 	    bsr.w   outChar
 710 80948 103C 0020 	    move.b  #' ', %d0
 711 8094c 6100 FBC0 	    bsr.w   outChar
 712               	    
 713 80950 5303      	    subq.b  #1, %d3
 714 80952 60E0      	    bra.s   .endbytesShortLoop
 715               	 .endbytes:
 716 80954 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 717               	 .endbytesLoop:
 718 80956 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 719 80958 6700 0022 	    beq     .endline    
 720 8095c 5304      	    subq.b  #1, %d4
 721 8095e 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 722 80960 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 723 80964 6D0C      	    blt.s   .unprintable
 724 80966 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 725 8096a 6E06      	    bgt.s   .unprintable
 726 8096c 6100 FBA0 	    bsr.w   outChar
 727 80970 60E4      	    bra.s   .endbytesLoop
 728               	 .unprintable:
 729 80972 103C 002E 	    move.b  #'.', %d0
 730 80976 6100 FB96 	    bsr.w   outChar
 731 8097a 60DA      	    bra.s   .endbytesLoop
 732               	 .endline:
 733 8097c 41FA 0296 	    lea     msgNewline, %a0
 734 80980 6100 FBB4 	    bsr.w   printString
 735 80984 4A82      	    tst.l   %d2
 736 80986 6F04      	    ble.s   .end
 737 80988 6000 FF76 	    bra.w   .line
 738               	 .end:
 739 8098c 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 740 80990 4E75      	    rts
 741               	
68K GAS  S68K_002.s 			page 15


 742               	|||||||||||||||||||||||
 743               	| Deposit values into RAM
 744               	| d ADDR VAL VAL            Deposit value(s) into RAM
 745               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 746               	|  VAL VAL VAL;              - Continuing with further continue
 747               	| d: VAL VAL                Continue depositing values after the last address written to
 748               	|||||||||||||||||||||||
 749               	.deposit:
 750 80992 1010      	    move.b  (%a0), %d0
 751 80994 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 752 80998 6730      	    beq.s   DepCont
 753               	    
 754 8099a 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 755 8099e 4A01      	    tst.b   %d1
 756 809a0 6600 FCD2 	    bne		.invalidAddr
 757 809a4 2640      	    move.l  %d0, %a3           	| Save the start address
 758               	 DepLoop:
 759 809a6 1010      	    move.b  (%a0), %d0            
 760 809a8 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 761 809ac 6726      	    beq.s   DepMLine
 762 809ae 4A40      	    tst     %d0              	| Check for the end of line
 763 809b0 6700 003A 	    beq     DepEnd
 764               	    
 765 809b4 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 766 809b8 4A01      	    tst.b   %d1
 767 809ba 6600 FCC4 	    bne		.invalidVal
 768 809be 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 769 809c2 6E00 FCBC 	    bgt		.invalidVal
 770               	    
 771 809c6 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 772 809c8 60DC      	    bra.s   DepLoop
 773               	    
 774               	 DepCont:
 775 809ca 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 775      FBAA 
 776 809d0 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 777 809d2 60D2      	    bra.s   DepLoop
 778               	    
 779               	 DepMLine:
 780 809d4 41FA 0186 	    lea     msgDepositPrompt, %a0
 781 809d8 6100 FB5C 	    bsr.w   printString
 782 809dc 6100 FB8A 	    bsr.w   readLine          	| Read in the next line to be parsed
 783 809e0 6100 FC18 	    bsr.w   lineToUpper         | Convert to uppercase
 784 809e4 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 784      FBAE 
 785 809ea 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 786               	 DepEnd:
 787 809ec 23CB 0007 	    move.l  %a3, varCurAddr
 787      FBAA 
 788 809f2 6000 FC6E 	    bra.w   .exit
 789               	
 790               	|||||||||||||||||||||||
 791               	| run code
 792               	 .run:
 793 809f6 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 794 809fa 4A01      	    tst.b   %d1
 795 809fc 6600 FC76 	    bne		.invalidAddr
68K GAS  S68K_002.s 			page 16


 796 80a00 2040      	    move.l  %d0, %a0
 797 80a02 4E90      	    jsr     (%a0)             	| Jump to the code! 
 798               	                                | Go as subroutine to allow code to return to us
 799 80a04 4EBA FACC 	    jsr     monitorStart        | Warm start after returning so everything is in
 800               	                                | a known state.
 801               	
 802               	
 803               	|||||||||||||||||||||||
 804               	|| KEEP All printHex functions together ||
 805               	|||||||||||||||||||||||
 806               	| Print a hex word
 807               	printHexWord:
 808 80a08 2F02      	    move.l  %d2, -(%SP)		| Save D2
 809 80a0a 2400      	    move.l  %d0, %d2		| Save the address in d2
 810               	    
 811 80a0c E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 812 80a0e E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 813 80a10 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 814               	|||||||||||||||||||||||
 815               	| Print a hex 24-bit address
 816               	printHexAddr:
 817 80a12 2F02      	    move.l %d2, -(%SP)   	| Save D2
 818 80a14 2400      	    move.l %d0, %d2      	| Save the address in d2
 819               	    
 820 80a16 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 821 80a18 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 822               	|||||||||||||||||||||||
 823               	* Print a hex long
 824               	printHexLong:
 825 80a1a 2F02      	    move.l  %d2, -(%SP)     | Save D2
 826 80a1c 2400      	    move.l  %d0, %d2        | Save the address in d2
 827               	    
 828 80a1e E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 829 80a20 2002      	    move.l  %d2, %d0
 830 80a22 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 831               	printHex_addrentry:     
 832 80a24 E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 833 80a26 2002      	    move.l  %d2, %d0              
 834 80a28 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 835               	printHex_wordentry:    
 836 80a2a E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 837 80a2c 2002      	    move.l  %d2, %d0
 838 80a2e 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 839 80a30 E19A      	    rol.l   #0x8, %d2
 840 80a32 2002      	    move.l  %d2, %d0
 841 80a34 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 842               	    
 843 80a36 241F      	    move.l (%SP)+, %d2      | Restore D2
 844 80a38 4E75      	    RTS
 845               	    
 846               	|||||||||||||||||||||||
 847               	| Print a hex byte
 848               	|  - Takes byte in D0
 849               	printHexByte:
 850 80a3a 2F02      	    move.l  %D2, -(%SP)
 851 80a3c 7400      		move.l	#0, %d2
 852 80a3e 1400      	    move.b  %d0, %d2
68K GAS  S68K_002.s 			page 17


 853 80a40 E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 854 80a42 0200 000F 		andi.b	#0xf, %d0
 855 80a46 0600 0030 	    add.b   #'0', %d0
 856 80a4a 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 857 80a4e 6F02      	    ble.s   PHBsecond
 858 80a50 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 859               	PHBsecond:
 860 80a52 6100 FABA 	    bsr   outChar			| Print the digit
 861 80a56 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 862 80a5a 0602 0030 	    add.b   #'0', %d2
 863 80a5e 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 864 80a62 6F02      	    ble.s   PHBend
 865 80a64 5E02      	    add.b   #0x7, %D2
 866               	PHBend:
 867 80a66 1002      	    move.b  %D2, %D0
 868 80a68 6100 FAA4 	    bsr	   outChar      	| Print the lower digit
 869 80a6c 241F      	    move.l  (%SP)+, %D2
 870 80a6e 4E75      	    rts
 871               		
 872               	
 873               	|||||
 874               	| Initializes the 68681 DUART port A as 9600 8N1 
 875               	initDuart:
 876 80a70 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 876      000F 0004 
 877 80a78 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 877      000F 0004 
 878 80a80 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 878      000F 0004 
 879               	    
 880 80a88 13FC 0000 	    move.b  #0x00, ACR       | Baud Rate Set #2
 880      000F 0008 
 881               	|    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 882 80a90 13FC 00CC 	    move.b  #0xCC, CSRA      | Set Tx and Rx rates to 38400
 882      000F 0002 
 883 80a98 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 883      000F 0000 
 884 80aa0 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 884      000F 0000 
 885               	    
 886 80aa8 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 886      000F 0004 
 887               	
 888 80ab0 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 888      000F 0014 
 889 80ab8 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 889      000F 0014 
 890 80ac0 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 890      000F 0014 
 891               	    
 892               	|    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 893 80ac8 13FC 00CC 	    move.b  #0xcc, CSRB      | Set Tx and Rx rates to 38400
 893      000F 0012 
 894 80ad0 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 894      000F 0010 
 895 80ad8 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 895      000F 0010 
68K GAS  S68K_002.s 			page 18


 896               	    
 897 80ae0 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 897      000F 0014 
 898               		
 899 80ae8 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 899      000F 001A 
 900 80af0 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 900      000F 001E 
 901 80af8 4E75      	    rts    
 902               	
 903               	delay1Sec:
 904 80afa 203C 0003 		move.l	#200000, %d0	| rough count
 904      0D40 
 905               	delay1Loop:
 906 80b00 5380      		sub.l	#1, %d0			
 907 80b02 6600 FFFC 		bne		delay1Loop
 908 80b06 4E75      		rts
 909               	
 910               	READINLINE:	  
 911 80b08 5265 6164 		.ascii  "Reading in line"
 911      696E 6720 
 911      696E 206C 
 911      696E 65
 912 80b17 0D0A 00   		dc.b CR,LF,EOT
 913               	L_TO_UPPER_MSG:  
 914 80b1a 436F 6E76 		.ascii  "Convert line to upper case"
 914      6572 7420 
 914      6C69 6E65 
 914      2074 6F20 
 914      7570 7065 
 915 80b34 0D0A 00   		dc.b CR,LF,EOT
 916               	WRITEOUTLINE:	  
 917 80b37 5772 6974 		.ascii  "Writing out line"
 917      696E 6720 
 917      6F75 7420 
 917      6C69 6E65 
 918 80b47 0D0A 00   		dc.b CR,LF,EOT
 919               	RAM_PASS_MSG:  
 920 80b4a 5241 4D20 		.ascii  "RAM Test Passed"
 920      5465 7374 
 920      2050 6173 
 920      7365 64
 921 80b59 0D0A 00   		dc.b CR,LF,EOT
 922               	msgDepositPrompt:
 923 80b5c 3A20      	    .ascii	": "
 924 80b5e 00        		dc.b 	EOT
 925               	BANNER_MSG:	
 926 80b5f 5349 4D50 		.ascii  "SIMPLE-68008 CPU V1.00"
 926      4C45 2D36 
 926      3830 3038 
 926      2043 5055 
 926      2056 312E 
 927 80b75 0D0A 00   		dc.b CR,LF,EOT
 928               	msgInvalidCommand:
 929 80b78 496E 7661 	    .ascii "Invalid Command"
 929      6C69 6420 
 929      436F 6D6D 
68K GAS  S68K_002.s 			page 19


 929      616E 64
 930 80b87 0D0A 00   		dc.b CR,LF,EOT
 931               	CRLF_MSG:	
 932 80b8a 0D0A 00   		dc.b CR,LF,EOT
 933               	msgHelp:
 934 80b8d 4176 6169 	    .ascii	"Available Commands: "
 934      6C61 626C 
 934      6520 436F 
 934      6D6D 616E 
 934      6473 3A20 
 935 80ba1 0D0A      		dc.b	CR,LF
 936 80ba3 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 936      7861 6D69 
 936      6E65 2020 
 936      2020 2844 
 936      2965 706F 
 937 80bd9 0D0A 00   		dc.b	CR,LF,EOT
 938               	ldSRecMsg:
 939 80bdc 4C6F 6164 	    .ascii	"Load S-Record"
 939      2053 2D52 
 939      6563 6F72 
 939      64
 940 80be9 0D0A 00   		dc.b	CR,LF,EOT
 941               	msgInvalidAddress:
 942 80bec 496E 7661 	    .ascii	"Invalid Address"
 942      6C69 6420 
 942      4164 6472 
 942      6573 73
 943 80bfb 0D0A 00   		dc.b 	CR,LF,EOT
 944               	msgInvalidValue:
 945 80bfe 496E 7661 	    .ascii	"Invalid Value"
 945      6C69 6420 
 945      5661 6C75 
 945      65
 946 80c0b 0D0A 00   		dc.b	CR,LF,EOT
 947               	msgPrompt:
 948 80c0e 3E20      		.ascii "> "
 949 80c10 00        	    dc.b EOT
 950               	msgColonSpace:
 951 80c11 3A20      	    .ascii ": "
 952 80c13 00        	    dc.b EOT
 953               	msgNewline:
 954 80c14 0D0A 00   	    dc.b CR,LF,EOT
 955               	debug_Srec_Typ_Msg:
 956 80c17 5320 5265 		.ascii	"S Record Type="
 956      636F 7264 
 956      2054 7970 
 956      653D 
 957 80c25 00        	    dc.b EOT
 958               	debug_Srec_BytCt_Msg:
 959 80c26 5320 5265 		.ascii	"S Record Byte Count=0x"
 959      636F 7264 
 959      2042 7974 
 959      6520 436F 
 959      756E 743D 
 960 80c3c 00        	    dc.b EOT
 961               	debug_Srec_CSum_Msg:
68K GAS  S68K_002.s 			page 20


 962 80c3d 5320 5265 		.ascii	"S Record Checksum="
 962      636F 7264 
 962      2043 6865 
 962      636B 7375 
 962      6D3D 
 963 80c4f 00        	    dc.b EOT
 964               	debug_S2rec_Addr_Msg:
 965 80c50 5332 2052 		.ascii	"S2 Record Address=0x"
 965      6563 6F72 
 965      6420 4164 
 965      6472 6573 
 965      733D 3078 
 966 80c64 00        	    dc.b EOT
 967               	debug_SXrec_Addr_Msg:
 968 80c65 5320 286E 		.ascii	"S (not 2) Record Address=0x"
 968      6F74 2032 
 968      2920 5265 
 968      636F 7264 
 968      2041 6464 
 969 80c80 00        	    dc.b EOT
 970               	debug_Srec_LDData_Msg:
 971 80c81 4C6F 6164 	    .ascii	"Load Data Loop start"
 971      2044 6174 
 971      6120 4C6F 
 971      6F70 2073 
 971      7461 7274 
 972 80c95 0D0A 00   		dc.b 	CR,LF,EOT
 973               	
 974               	
 975               	MAX_LINE_LENGTH = 80
 976               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 977               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 21


DEFINED SYMBOLS
          S68K_002.s:12     *ABS*:0000000000000000 RAM_START
          S68K_002.s:13     *ABS*:000000000007fffc STACK_END
          S68K_002.s:14     *ABS*:000000000007ffff RAM_END
          S68K_002.s:15     *ABS*:0000000000080000 ROM_START
          S68K_002.s:16     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:18     *ABS*:000000000008ffff ROM_END
          S68K_002.s:23     *ABS*:00000000000f0000 DUART
          S68K_002.s:24     *ABS*:00000000000f0000 MRA
          S68K_002.s:25     *ABS*:00000000000f0002 SRA
          S68K_002.s:26     *ABS*:00000000000f0002 CSRA
          S68K_002.s:27     *ABS*:00000000000f0004 CRA
          S68K_002.s:28     *ABS*:00000000000f0006 RBA
          S68K_002.s:29     *ABS*:00000000000f0006 TBA
          S68K_002.s:30     *ABS*:00000000000f0008 ACR
          S68K_002.s:31     *ABS*:00000000000f000a ISR
          S68K_002.s:32     *ABS*:00000000000f000a IMR
          S68K_002.s:33     *ABS*:00000000000f0010 MRB
          S68K_002.s:34     *ABS*:00000000000f0012 SRB
          S68K_002.s:35     *ABS*:00000000000f0012 CSRB
          S68K_002.s:36     *ABS*:00000000000f0014 CRB
          S68K_002.s:37     *ABS*:00000000000f0016 RBB
          S68K_002.s:38     *ABS*:00000000000f0016 TBB
          S68K_002.s:39     *ABS*:00000000000f0018 IVR
          S68K_002.s:40     *ABS*:00000000000f001a OPC
          S68K_002.s:41     *ABS*:00000000000f001a INU
          S68K_002.s:42     *ABS*:00000000000f001c OPS
          S68K_002.s:43     *ABS*:00000000000f001e OPR
          S68K_002.s:48     *ABS*:0000000000000007 BEL
          S68K_002.s:49     *ABS*:0000000000000008 BKSP
          S68K_002.s:50     *ABS*:0000000000000009 TAB
          S68K_002.s:51     *ABS*:000000000000000a LF
          S68K_002.s:52     *ABS*:000000000000000d CR
          S68K_002.s:53     *ABS*:000000000000001b ESC
          S68K_002.s:54     *ABS*:0000000000000000 EOT
          S68K_002.s:56     *ABS*:0000000000000003 CTRLC
          S68K_002.s:57     *ABS*:0000000000000018 CTRLX
          S68K_002.s:60     .text:0000000000000400 _srecType
          S68K_002.s:61     .text:0000000000000401 _srecByCt
          S68K_002.s:62     .text:0000000000000402 _srecData
          S68K_002.s:63     .text:0000000000000403 _srecCSum
          S68K_002.s:64     .text:0000000000000404 _srecAddr
          S68K_002.s:66     *ABS*:0000000000000400 srecType
          S68K_002.s:67     *ABS*:0000000000000401 srecByCt
          S68K_002.s:68     *ABS*:0000000000000402 srecData
          S68K_002.s:69     *ABS*:0000000000000403 srecCSum
          S68K_002.s:70     *ABS*:0000000000000404 srecAddr
          S68K_002.s:183    .text:0000000000080508 FERVR2
          S68K_002.s:108    .text:0000000000080462 loop1stLoc
          S68K_002.s:181    .text:0000000000080508 failBitTest
          S68K_002.s:123    .text:0000000000080482 loopAdrFill
          S68K_002.s:135    .text:00000000000804a0 loopAdrCk
          S68K_002.s:182    .text:0000000000080508 failAdrTest
          S68K_002.s:150    .text:00000000000804ba fillSRAM
          S68K_002.s:154    .text:00000000000804c6 fillSRAMLoop
          S68K_002.s:875    .text:0000000000080a70 initDuart
          S68K_002.s:163    .text:00000000000804d2 monitorStart
68K GAS  S68K_002.s 			page 22


          S68K_002.s:925    .text:0000000000080b5f BANNER_MSG
          S68K_002.s:208    .text:0000000000080536 printString1
          S68K_002.s:919    .text:0000000000080b4a RAM_PASS_MSG
          S68K_002.s:171    .text:00000000000804e2 interpLoop
          S68K_002.s:947    .text:0000000000080c0e msgPrompt
          S68K_002.s:209    .text:0000000000080536 printString
          S68K_002.s:238    .text:0000000000080568 readLine
          S68K_002.s:295    .text:00000000000805fa lineToUpper
          S68K_002.s:312    .text:0000000000080618 parseLine
          S68K_002.s:190    .text:000000000008050e outChar1
          S68K_002.s:191    .text:000000000008050e outChar
          S68K_002.s:199    .text:0000000000080522 outChar2
          S68K_002.s:210    .text:0000000000080536 PSloop
          S68K_002.s:216    .text:000000000008053e PSend
          S68K_002.s:224    .text:0000000000080540 inChar1
          S68K_002.s:225    .text:0000000000080540 inChar
          S68K_002.s:231    .text:0000000000080554 inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:242    .text:0000000000080574 RLloop
          S68K_002.s:259    .text:00000000000805a0 RLBS
          S68K_002.s:270    .text:00000000000805be RLlineClr
          S68K_002.s:284    .text:00000000000805e2 RLEndLn
          S68K_002.s:252    .text:0000000000080590 .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:274    .text:00000000000805c4 RLlineClrloop
          S68K_002.s:297    .text:0000000000080600 LUloop
          S68K_002.s:304    .text:0000000000080612 LUnext
          S68K_002.s:315    .text:0000000000080622 PLfindCommand
          S68K_002.s:361    .text:000000000008068c .examine
          S68K_002.s:749    .text:0000000000080992 .deposit
          S68K_002.s:792    .text:00000000000809f6 .run
          S68K_002.s:340    .text:0000000000080668 .help
          S68K_002.s:437    .text:0000000000080716 loadSRec
          S68K_002.s:334    .text:0000000000080662 .exit
          S68K_002.s:331    .text:000000000008065a .invalid
          S68K_002.s:928    .text:0000000000080b78 msgInvalidCommand
          S68K_002.s:933    .text:0000000000080b8d msgHelp
          S68K_002.s:344    .text:0000000000080674 .invalidAddr
          S68K_002.s:941    .text:0000000000080bec msgInvalidAddress
          S68K_002.s:348    .text:0000000000080680 .invalidVal
          S68K_002.s:944    .text:0000000000080bfe msgInvalidValue
          S68K_002.s:624    .text:0000000000080896 parseNumber
          S68K_002.s:366    .text:0000000000080698 .exloop
          S68K_002.s:380    .text:00000000000806bc .exrange
          S68K_002.s:389    .text:00000000000806ce .exlength
          S68K_002.s:397    .text:00000000000806e0 .exinter
          S68K_002.s:386    .text:00000000000806ca .exquick
          S68K_002.s:393    .text:00000000000806d8 .exend
          S68K_002.s:677    .text:00000000000808f8 dumpRAM
          S68K_002.s:402    .text:00000000000806ee .exinterend
          S68K_002.s:409    .text:0000000000080702 .exinterpage
          S68K_002.s:938    .text:0000000000080bdc ldSRecMsg
          S68K_002.s:440    .text:000000000008071e loadSRecLoop
          S68K_002.s:497    .text:00000000000807b6 setRecType
          S68K_002.s:516    .text:00000000000807d0 setBytCt
          S68K_002.s:556    .text:000000000008081a setAddr
          S68K_002.s:452    .text:0000000000080748 loopSData
68K GAS  S68K_002.s 			page 23


          S68K_002.s:457    .text:000000000008075a sRecDataDone
          S68K_002.s:472    .text:0000000000080792 getSetLdData
          S68K_002.s:484    .text:00000000000807ac getChksum
          S68K_002.s:532    .text:00000000000807e2 getHexPair
          S68K_002.s:480    .text:00000000000807aa skipLdData
          S68K_002.s:493    .text:00000000000807b4 failCSUM
          S68K_002.s:545    .text:0000000000080802 toNibble
          S68K_002.s:550    .text:0000000000080810 doHexLetter
          S68K_002.s:597    .text:0000000000080878 adrLen16
          S68K_002.s:614    .text:0000000000080890 past16
          S68K_002.s:638    .text:00000000000808ba PNinvalid
          S68K_002.s:644    .text:00000000000808c4 PNfirstdigit1
          S68K_002.s:641    .text:00000000000808be PNfirstdigit2
          S68K_002.s:646    .text:00000000000808c8 PNloop
          S68K_002.s:657    .text:00000000000808e2 PNend
          S68K_002.s:664    .text:00000000000808ee PNdigit1
          S68K_002.s:661    .text:00000000000808e8 PNdigit2
          S68K_002.s:666    .text:00000000000808f2 PNdigit3
          S68K_002.s:681    .text:0000000000080900 .line
          S68K_002.s:816    .text:0000000000080a12 printHexAddr
          S68K_002.s:950    .text:0000000000080c11 msgColonSpace
          S68K_002.s:688    .text:0000000000080912 .hexbyte
          S68K_002.s:700    .text:000000000008092e .endbytesShort
          S68K_002.s:715    .text:0000000000080954 .endbytes
          S68K_002.s:849    .text:0000000000080a3a printHexByte
          S68K_002.s:703    .text:0000000000080934 .endbytesShortLoop
          S68K_002.s:717    .text:0000000000080956 .endbytesLoop
          S68K_002.s:732    .text:000000000008097c .endline
          S68K_002.s:728    .text:0000000000080972 .unprintable
          S68K_002.s:953    .text:0000000000080c14 msgNewline
          S68K_002.s:738    .text:000000000008098c .end
          S68K_002.s:774    .text:00000000000809ca DepCont
          S68K_002.s:758    .text:00000000000809a6 DepLoop
          S68K_002.s:779    .text:00000000000809d4 DepMLine
          S68K_002.s:786    .text:00000000000809ec DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:922    .text:0000000000080b5c msgDepositPrompt
          S68K_002.s:807    .text:0000000000080a08 printHexWord
          S68K_002.s:835    .text:0000000000080a2a printHex_wordentry
          S68K_002.s:831    .text:0000000000080a24 printHex_addrentry
          S68K_002.s:824    .text:0000000000080a1a printHexLong
          S68K_002.s:859    .text:0000000000080a52 PHBsecond
          S68K_002.s:866    .text:0000000000080a66 PHBend
          S68K_002.s:903    .text:0000000000080afa delay1Sec
          S68K_002.s:905    .text:0000000000080b00 delay1Loop
          S68K_002.s:910    .text:0000000000080b08 READINLINE
          S68K_002.s:913    .text:0000000000080b1a L_TO_UPPER_MSG
          S68K_002.s:916    .text:0000000000080b37 WRITEOUTLINE
          S68K_002.s:931    .text:0000000000080b8a CRLF_MSG
          S68K_002.s:955    .text:0000000000080c17 debug_Srec_Typ_Msg
          S68K_002.s:958    .text:0000000000080c26 debug_Srec_BytCt_Msg
          S68K_002.s:961    .text:0000000000080c3d debug_Srec_CSum_Msg
          S68K_002.s:964    .text:0000000000080c50 debug_S2rec_Addr_Msg
          S68K_002.s:967    .text:0000000000080c65 debug_SXrec_Addr_Msg
          S68K_002.s:970    .text:0000000000080c81 debug_Srec_LDData_Msg

NO UNDEFINED SYMBOLS
68K GAS  S68K_002.s 			page 24


