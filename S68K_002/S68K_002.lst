68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Borrowed init code from 
   4               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   5               	
   6               	RAM_START	= 0x00000	| Beginning of the SRAM
   7               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
   8               	RAM_END		= 0x7FFFF	| 512KB SRAM
   9               	ROM_START	= 0x80000	| ROM start
  10               	ROM_CODE	= ROM_START+1024| Skip vector table
  11               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  12               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  13               	
  14               	|||||||||||||||||||||||||||||||||
  15               	| 68681 Duart Register Addresses
  16               	|
  17               	DUART = 0x0F0000	  | Base Addr of DUART
  18               	MRA   = DUART+0		  | Mode Register A           (R/W)
  19               	SRA   = DUART+2       | Status Register A         (r)
  20               	CSRA  = DUART+2       | Clock Select Register A   (w)
  21               	CRA   = DUART+4       | Commands Register A       (w)
  22               	RBA   = DUART+6       | Receiver Buffer A         (r)
  23               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  24               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  25               	ISR   = DUART+10      | Interrupt Status Register (R)
  26               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  27               	MRB   = DUART+16      | Mode Register B           (R/W)
  28               	SRB   = DUART+18      | Status Register B         (R)
  29               	CSRB  = DUART+18      | Clock Select Register B   (W)
  30               	CRB   = DUART+20      | Commands Register B       (W)
  31               	RBB   = DUART+22      | Reciever Buffer B         (R)
  32               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  33               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  34               	OPC   = DUART+26      | Output port config        (W)
  35               	INU   = DUART+26      | Input port (unlatched)    (R)
  36               	OPS   = DUART+28      | Output port Set           (W)
  37               	OPR   = DUART+30      | Output port Clear         (W)
  38               	
  39               	||||||||||||||||||||||||||||||||||
  40               	| ASCII Control Characters
  41               	|
  42               	BEL   = 0x07
  43               	BKSP  = 0x08       | CTRL-H
  44               	TAB   = 0x09
  45               	LF    = 0x0A
  46               	CR    = 0x0D
  47               	ESC   = 0x1B
  48               	EOT	  = 0x00
  49               	
  50               	CTRLC	=	0x03
  51               	CTRLX	=	0x18     | Line Clear
  52               	
  53 0000 0000 0000 		.ORG    0x000400
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
68K GAS  S68K_002.s 			page 2


  54 0400 00        	_srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  55 0401 00        	_srecByCt:	ds.b	1		| Byte Count
  56 0402 00        	_srecData:	ds.b	1 		| Data
  57 0403 00        	_srecCSum:	ds.b	1 		| S-Record Checksum
  58 0404 0000 0000 	_srecAddr:	ds.l	1		| S Record current byte address
  59               	
  60               	srecType	=		0x000400	| S1-S9 stored as binary 1-9
  61               	srecByCt	=		0x000401	| Byte Count
  62               	srecData	=		0x000402	| Data
  63               	srecCSum	=		0x000403	| S-Record Checksum
  64               	srecAddr	=		0x000404	| S Record current byte address
  65               	
  66 0408 0000 0000 		.ORG	ROM_START
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  67               	
  68               	| FIRST 8 bytes loaded after reset |
  69 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  70 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  71               	
  72 80008 0000 0000 	        .ORG ROM_CODE
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  73 80400 4E71      		nop
  74 80402 4FF9 0007 		lea			STACK_END,%sp
  74      FFFC 
  75 80408 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  75      0008 0000 
  76 80410 4E71      		nop
  77               	| LEDs
  78 80412 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  78      000F 001A 
  79 8041a 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  79      000F 001E 
  80 80422 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  80      000F 001C 
  81               	|
  82               	| Test the first two SRAM location
  83               	|
  84 8042a 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  84      BEEF 
  85 80430 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  86 80434 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  87 80436 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
  88 80438 B042      		cmp			%d2, %d0
  89 8043a 6600 00C6 		bne			FERVR2						
  90 8043e 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  90      AAAA 
  91 80444 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
  92 80448 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
  93 8044a 2611      		move.l	(%a1), %d3				| Read back
  94 8044c B243      		cmp			%d3, %d1
  95 8044e 6600 00B2 		bne			FERVR2
68K GAS  S68K_002.s 			page 3


  96 80452 4E71      		nop
  97               	| Test bits of first location (as bytes)
  98 80454 7001      		move.l	#1, %d0
  99 80456 207C 0000 		move.l	#0, %a0
  99      0000 
 100               	loop1stLoc:
 101 8045c 1080      		move.b	%d0, (%a0)
 102 8045e 1210      		move.b	(%a0), %d1
 103 80460 B200      		cmp.b		%d0, %d1
 104 80462 6600 009E 		bne			failBitTest
 105 80466 E348      		lsl			#1, %d0
 106 80468 0C80 0000 		cmp.l		#0x00000100, %d0
 106      0100 
 107 8046e 6600 FFEC 		bne			loop1stLoc
 108               	|
 109               	| Test all address lines, 512KB SRAM
 110               	| Write incrementing pattern to data bits
 111               	|
 112 80472 7001      		move.l	#1, %d0		| Fill pattern
 113 80474 7401      		move.l	#1, %d2
 114 80476 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 114      0001 
 115               	loopAdrFill:
 116 8047c 1080      		move.b	%d0,(%a0)	| Do the write
 117 8047e 5240      		addq		#1, %d0		| Increment the pattern
 118 80480 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 119 80482 E38A      		lsl.l		#1, %d2		| Shift temp addr
 120 80484 2042      		move.l	%d2, %a0	| Put back into addr reg
 121 80486 0C82 0008 		cmp.l		#0x00080000,%d2
 121      0000 
 122 8048c 6600 FFEE 		bne			loopAdrFill
 123               	| Check
 124 80490 7001      		move.l	#1, %d0
 125 80492 7401      		move.l	#1, %d2
 126 80494 207C 0000 		move.l	#1, %a0
 126      0001 
 127               	loopAdrCk:
 128 8049a 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 129 8049c B200      		cmp.b		%d0, %d1
 130 8049e 6600 0062 		bne			failAdrTest
 131 804a2 5240      		addq		#1, %d0
 132 804a4 2408      		move.l	%a0, %d2 
 133 804a6 E38A      		lsl.l		#1, %d2
 134 804a8 2042      		move.l	%d2, %a0
 135 804aa 0C82 0008 		cmp.l		#0x00080000,%d2
 135      0000 
 136 804b0 6600 FFE8 		bne			loopAdrCk
 137               		
 138               	|
 139               	| Fill SRAM with 0x00 values
 140               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 141               	|
 142               	fillSRAM:
 143 804b4 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 144 804b8 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 144      FFFF 
 145 804be 7000      		move.l	#0x00, %d0			| Fill with zeros
68K GAS  S68K_002.s 			page 4


 146               	fillSRAMLoop:
 147 804c0 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 148 804c2 B3C8      		cmpa.l	%a0, %a1
 149 804c4 6E00 FFFA 		bgt		fillSRAMLoop
 150               	
 151               	|
 152               	| Done with address test of SRAM
 153               	|
 154 804c8 4EBA 05E8 		jsr     initDuart       	| Setup the serial port
 155               	monitorStart:					| Warm start
 156 804cc 41FA 06D3 		lea		BANNER_MSG, %a0
 157 804d0 4EBA 005E 		jsr		printString1
 158 804d4 41FA 06B6 		lea		RAM_PASS_MSG, %a0
 159 804d8 4EBA 0056 		jsr		printString1
 160               	|
 161               	| Interpreter Loop
 162               	|
 163               	interpLoop:
 164 804dc 41FA 076C 	    lea     msgPrompt, %a0	| Prompt
 165 804e0 6100 004E 	    bsr.w   printString
 166 804e4 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 166      000F 001E 
 167 804ec 4EBA 0074 		jsr		readLine		| Blocking read of line
 168 804f0 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 168      000F 001C 
 169 804f8 4EBA 00FA 		jsr		lineToUpper
 170 804fc 4EBA 0114 		jsr		parseLine
 171 80500 60DA      		bra.s	interpLoop
 172               		
 173               	failBitTest:
 174               	failAdrTest:
 175               	FERVR2:
 176 80502 4E71      		nop
 177 80504 4EFA FFFC 		jmp	FERVR2
 178               	
 179               	|||||
 180               	| Writes a character to Port A, blocking if not ready (Full buffer)
 181               	|  - Takes a character in D0
 182               	outChar1:
 183               	outChar:
 184 80508 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 184      000F 0002 
 185 80510 6700 FFF6 	    beq     outChar1     
 186 80514 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 186      0006 
 187 8051a 4E75      	    rts
 188               	
 189               	| Writes a character to Port A, blocking if not ready (Full buffer)
 190               	|  - Takes a character in D0
 191               	outChar2:
 192 8051c 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 192      000F 0012 
 193 80524 6700 FFF6 	    beq     outChar2     
 194 80528 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 194      0016 
 195 8052e 4E75      	    rts
 196               	
68K GAS  S68K_002.s 			page 5


 197               	******
 198               	* Print a null terminated string
 199               	*
 200               	printString1:
 201               	printString:
 202               	PSloop:
 203 80530 1018      	    move.b  (%a0)+, %d0  | Read in character
 204 80532 6704      	    beq.s   PSend         | Check for the null
 205               	    
 206 80534 61D2      	    bsr.s   outChar      | Otherwise write the character
 207 80536 60F8      	    bra.s   PSloop        | And continue
 208               	PSend:
 209 80538 4E75      	    rts
 210               	
 211               	
 212               	|||||
 213               	| Reads in a character from Port A, blocking if none available
 214               	|  - Returns character in D0
 215               	|    
 216               	inChar1:
 217               	inChar:
 218 8053a 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 218      000F 0002 
 219 80542 6700 FFF6 	    beq     inChar1
 220 80546 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 220      0006 
 221 8054c 4E75      	    rts
 222               	
 223               	inChar2:
 224 8054e 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 224      000F 0012 
 225 80556 6700 FFF6 	    beq     inChar2
 226 8055a 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 226      0016 
 227 80560 4E75      	    rts
 228               	
 229               	| Read in a line into the line buffer
 230               	readLine:
 231 80562 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 232 80566 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 232      FBAE 
 233 8056c B542      	    eor.w   %d2, %d2           	| Clear the character counter
 234               	 RLloop:
 235 8056e 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 236 80572 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 237 80576 6722      	    beq.s   RLBS
 238 80578 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 239 8057c 673A      	    beq.s   RLlineClr
 240 8057e 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 241 80582 6758      	    beq.s   RLEndLn
 242 80584 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 243 80588 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 244               	 .char:                      	| Normal character to be inserted into the buffer
 245 8058a 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 246 8058e 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 247 80590 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 248 80592 5242      	    addq.w  #1, %d2           	| Increment character count
68K GAS  S68K_002.s 			page 6


 249 80594 6100 FF72 	    bsr.w   outChar          	| Echo the character
 250 80598 60D4      	    bra.s   RLloop            	| And get the next one
 251               	 RLBS:
 252 8059a 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 253 8059c 67D0      	    beq.s   RLloop            	| Then ignore it
 254 8059e 6100 FF68 	    bsr.w   outChar          	| Backspace
 255 805a2 103C 0020 	    move.b  #' ', %d0
 256 805a6 6100 FF60 	    bsr.w   outChar          	| Space
 257 805aa 103C 0008 	    move.b  #BKSP, %d0
 258 805ae 6100 FF58 	    bsr.w   outChar          	| Backspace
 259 805b2 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 260 805b4 5382      	    subq.l  #1, %d2           	| And current character count
 261 805b6 60B6      	    bra.s   RLloop            	| And goto the next character
 262               	 RLlineClr:
 263 805b8 4A42      	    tst     %d2               	| Anything to clear?
 264 805ba 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 265 805bc 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 266               	 RLlineClrloop:
 267 805be 103C 0008 	    move.b  #BKSP, %d0
 268 805c2 6100 FF44 	    bsr.w   outChar          	| Backspace
 269 805c6 103C 0020 	    move.b  #' ', %d0
 270 805ca 6100 FF3C 	    bsr.w   outChar          	| Space
 271 805ce 103C 0008 	    move.b  #BKSP, %d0
 272 805d2 6100 FF34 	    bsr.w   outChar          	| Backspace
 273 805d6 5342      	    subq.w  #1, %d2          
 274 805d8 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 275 805da 6092      	    bra.s   RLloop   
 276               	 RLEndLn:
 277 805dc 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 278 805e0 103C 000A 	    move.b  #LF, %d0
 279 805e4 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 280 805e8 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 281 805ec 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 282 805ee 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 283 805f2 4E75      	    rts                      	| And return
 284               	
 285               	
 286               	| Convert line buffer to upper case
 287               	lineToUpper:
 288 805f4 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 288      FBAE 
 289               	 LUloop:
 290 805fa 1010      	    move.b  (%a0), %d0        | Read in a character
 291 805fc 0C00 0061 	    cmp.b   #'a', %d0         
 292 80600 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 293 80602 0C00 007A 	    cmp.b   #'z', %d0
 294 80606 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 295 80608 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
 296               	 LUnext:
 297 8060c 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 298 8060e 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 299 80610 4E75      	    rts
 300               	
 301               	|
 302               	| Parse Line
 303               	|
 304               	parseLine:
68K GAS  S68K_002.s 			page 7


 305 80612 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 306 80616 41F9 0007 	    lea     varLineBuf, %a0
 306      FBAE 
 307               	 PLfindCommand:
 308 8061c 1018      	    move.b  (%a0)+, %d0
 309 8061e 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 310 80622 6700 FFF8 	    beq.w   PLfindCommand    
 311 80626 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 312 8062a 6700 005A 	    beq.w   .examine
 313 8062e 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 314 80632 6700 03A0 	    beq.w   .deposit
 315 80636 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 316 8063a 6700 03FC 	    beq.w   .run
 317 8063e 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 318 80642 6700 001E 	    beq.w   .help
 319 80646 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 320 8064a 6700 00C4 	    beq.w   loadSRec
 321 8064e 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 322 80652 6708      	    beq.s   .exit               
 323               	 .invalid:   
 324 80654 41FA 055E 	    lea     msgInvalidCommand, %a0
 325 80658 6100 FED6 	    bsr.w   printString
 326               	 .exit:
 327 8065c 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 328 80660 4E75      	    rts
 329               	
 330               	|||||||||||||||||||||||||||||||
 331               	|| HELP command
 332               	 .help:
 333 80662 41FA 0565 	    lea     msgHelp, %a0
 334 80666 6100 FEC8 	    bsr.w   printString
 335 8066a 6000 FFF0 	    bra.w   .exit
 336               	 .invalidAddr:
 337 8066e 41FA 05B8 	    lea     msgInvalidAddress, %a0
 338 80672 6100 FEBC 	    bsr.w   printString
 339 80676 6000 FFE4 	    bra.w   .exit
 340               	 .invalidVal:
 341 8067a 41FA 05BE 	    lea     msgInvalidValue, %a0
 342 8067e 6100 FEB0 	    bsr.w   printString
 343 80682 6000 FFD8 	    bra.w   .exit
 344               		
 345               	|||||||||||||||||||||||||||||||
 346               	| Examines memory addresses
 347               	| Valid modes:
 348               	|   e ADDR                  Displays a single byte
 349               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 350               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 351               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 352               	|   e ADDR.                 Quick line, displays one line 
 353               	.examine:
 354 80686 6100 0250 	    bsr.w   parseNumber         | Read in the start address
 355 8068a 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 356 8068c 6600 FFE0 	    bne.w   .invalidAddr        
 357 80690 2640      	    move.l  %d0, %a3            | Save the start address
 358               	 .exloop:
 359 80692 1018      	    move.b  (%a0)+, %d0
 360 80694 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
68K GAS  S68K_002.s 			page 8


 361 80698 67F8      	    beq.s   .exloop
 362 8069a 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 363 8069e 6716      	    beq.s   .exrange
 364 806a0 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 365 806a4 6722      	    beq.s   .exlength
 366 806a6 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
 367 806aa 672E      	    beq.s   .exinter
 368 806ac 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 369 806b0 6712      	    beq.s   .exquick
 370 806b2 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 371 806b4 601C      	    bra.s   .exend              
 372               	 .exrange:
 373 806b6 6100 0220 	    bsr.w   parseNumber         | Find the end address
 374 806ba 4A01      	    tst.b   %d1                 | Check if we found a valid address
 375 806bc 6600 FFB0 	    bne.w   .invalidAddr
 376 806c0 908B      	    sub.l   %a3, %d0            | Get the length
 377 806c2 600E      	    bra.s   .exend
 378               	 .exquick:                      | Quick mode means show one line of 16 bytes
 379 806c4 7010      	    move.l  #0x10, %d0
 380 806c6 600A      	    bra.s   .exend
 381               	 .exlength:                     | Length mode means a length is specified
 382 806c8 6100 020E 	    bsr.w   parseNumber         | Find the length
 383 806cc 4A01      	    tst.b   %d1
 384 806ce 6600 FF9E 	    bne.w   .invalidAddr
 385               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 386 806d2 204B      	    move.l  %a3, %a0
 387 806d4 6100 0264 	    bsr.w   dumpRAM
 388 806d8 6082      	    bra.s   .exit
 389               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 390 806da 204B      	    move.l  %a3, %a0            | Current Address
 391 806dc 7010      	    move.l  #0x10, %d0          | 16 bytes
 392 806de 6100 025A 	    bsr.w   dumpRAM             | Dump this line
 393 806e2 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 393      0010 
 394               	 .exinterend:
 395 806e8 6100 FE50 	    bsr.w   inChar
 396 806ec 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 397 806f0 67E8      	    beq.s   .exinter
 398 806f2 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 399 806f6 6704      	    beq.s   .exinterpage
 400 806f8 6000 FF62 	    bra	   .exit               | Otherwise exit
 401               	 .exinterpage:
 402 806fc 204B      	    move.l  %a3, %a0
 403 806fe 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 403      0100 
 404 80704 6100 0234 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 405 80708 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 405      0100 
 406 8070e 60D8      	    bra.s   .exinterend
 407               	
 408               	|||||||||||||||||||||||||||||
 409               	|| Load S Record
 410               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 411               	|	srecByCt:	ds.b	1		| Byte Count
 412               	|	srecData:	ds.b	1 		| Data
 413               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 414               	|	srecAddr:	ds.l	1		| S Record current byte address
68K GAS  S68K_002.s 			page 9


 415               	|
 416               	| Supports 3 S record types (matches gcc m68k output)
 417               	|	S00F00005336384B5F3030322E746D7074
 418               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 419               	|	S503005BA1
 420               	
 421               	loadSRec:
 422 80710 41FA 0506 	    lea     ldSRecMsg, %a0
 423 80714 6100 FE1A 	    bsr.w   printString
 424 80718 6100 0078 		bsr		setRecType
 425 8071c 6100 00AA 		bsr		setBytCt
 426 80720 11FC 0000 		move.b 	#0, srecCSum
 426      0403 
 427 80726 6100 0102 		bsr		setAddr
 428 8072a 41FA 0591 		lea		debug_Srec_LDData_Msg, %a0
 429 8072e 6100 FE00 		bsr		printString
 430 80732 0C38 0002 		cmp.b	#2, srecType
 430      0400 
 431 80738 6600 0014 		bne		sRecDataDone
 432               	loopSData:
 433 8073c 0C38 0000 		cmp.b 	#0, srecByCt
 433      0401 
 434 80742 6700 000A 		beq		sRecDataDone
 435 80746 6100 000E 		bsr		getSetLdData
 436 8074a 6000 FFF0 		bra		loopSData
 437               	sRecDataDone:
 438 8074e 6100 0020 		bsr		getChksum
 439 80752 6000 FF08 		bra.w   .exit
 440               	
 441               	|||||||||||||||||||||||||||||
 442               	getSetLdData:
 443 80756 4EBA 009A 		jsr		getHexPair
 444 8075a 41F8 0404 		lea 	srecAddr, %a0
 445 8075e 2250      		move.l	(%a0), %a1
 446 80760 12C0      		move.b	%d0, (%a1)+
 447 80762 21C9 0404 		move.l	%a1, srecAddr
 448 80766 D138 0403 		add.b	%d0, srecCSum
 449 8076a 5338 0401 		sub.b	#1, srecByCt
 450               	skipLdData:
 451 8076e 4E75      		rts
 452               	
 453               	|||||||||||||||||||||||||||||
 454               	getChksum:
 455 80770 41FA 0507 		lea		debug_Srec_CSum_Msg, %a0
 456 80774 6100 FDBA 	    bsr.w   printString
 457 80778 4EBA 0078 		jsr		getHexPair
 458 8077c D138 0403 		add.b	%d0, srecCSum
 459 80780 1038 0403 		move.b	srecCSum, %d0
 460 80784 4EBA 02F6 		jsr		printHexByte
 461 80788 41FA 043C 		lea		CRLF_MSG, %a0
 462 8078c 6100 FDA2 	    bsr.w   printString
 463               	failCSUM:
 464 80790 4E75      		rts
 465               	
 466               	|||||||||||||||||||||||||||||
 467               	setRecType:
 468 80792 4EBA FDA6 		jsr		inChar
68K GAS  S68K_002.s 			page 10


 469 80796 0C00 0053 		cmp.b	#'S', %d0
 470 8079a 6600 FFF6 		bne		setRecType					| Toss extra chars
 471 8079e 4EBA FD9A 		jsr		inChar
 472 807a2 0200 000F 		andi.b	#0x0f, %d0
 473 807a6 11C0 0400 		move.b	%d0, srecType
 474               	| Debug messages follow
 475 807aa 41FA 04A7 		lea		debug_Srec_Typ_Msg, %a0		| Debug message
 476 807ae 6100 FD80 	    bsr.w   printString
 477 807b2 1038 0400 		move.b	srecType, %d0
 478 807b6 0600 0030 		add.b	#'0', %d0
 479 807ba 4EBA FD4C 		jsr		outChar
 480 807be 41FA 0406 		lea		CRLF_MSG, %a0
 481 807c2 6100 FD6C 	    bsr.w   printString
 482               	| Debug messages end
 483 807c6 4E75      		rts
 484               		
 485               	|||||||||||||||||||||||||||||
 486               	setBytCt:
 487 807c8 4EBA 0028 		jsr		getHexPair
 488 807cc 11C0 0403 		move.b 	%d0, srecCSum	| Initialize checksum
 489 807d0 11C0 0401 		move.b	%d0, srecByCt	| Byte count
 490               	| Debug messages follow
 491 807d4 41FA 048C 		lea		debug_Srec_BytCt_Msg, %a0
 492 807d8 6100 FD56 	    bsr.w   printString
 493 807dc 1038 0401 		move.b	srecByCt, %d0
 494 807e0 4EBA 029A 		jsr		printHexByte
 495 807e4 41FA 03E0 		lea		CRLF_MSG, %a0
 496 807e8 6100 FD46 	    bsr.w   printString
 497               	| Debug messages end
 498 807ec 5338 0401 		sub.b	#1, srecByCt
 499 807f0 4E75      		rts
 500               	
 501               	|||||||||||||||||||||||||||||
 502               	getHexPair:
 503 807f2 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 504 807f6 4EBA FD42 		jsr		inChar
 505 807fa 4EBA 0016 		jsr		toNibble
 506 807fe E900      		asl.b	#4, %d0
 507 80800 1400      		move.b	%d0, %d2
 508 80802 4EBA FD36 		jsr		inChar
 509 80806 4EBA 000A 		jsr		toNibble
 510 8080a 8002      		or.b	%d2, %d0
 511 8080c 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 512 80810 4E75      		rts
 513               	
 514               	|||||||||||||||||||||||||||||
 515               	toNibble:
 516 80812 0C00 0041 		cmp.b	#'A', %d0
 517 80816 6C00 0008 		bge		doHexLetter
 518 8081a 0400 0030 		sub.b	#'0', %d0
 519 8081e 4E75      		rts
 520               	doHexLetter:
 521 80820 0400 0041 		sub.b	#'A', %d0
 522 80824 0600 000A 		add.b	#10, %d0
 523 80828 4E75      		rts
 524               	
 525               	|||||||||||||||||||||||||||||
68K GAS  S68K_002.s 			page 11


 526               	setAddr:
 527 8082a 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 528 8082e 0C38 0002 		cmp.b	#2, srecType
 528      0400 
 529 80834 6600 0068 		bne		adrLen16
 530 80838 21FC 0000 		move.l	#0, srecAddr
 530      0000 0404 
 531 80840 41FA 044A 		lea		debug_S2rec_Addr_Msg, %a0
 532 80844 6100 FCEA 		bsr		printString
 533 80848 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 534               		| Get the upper 8-bits of 24-bits
 535 8084a 4EBA FFA6 		jsr		getHexPair
 536 8084e 0280 0000 		and.l	#0xff, %d0
 536      00FF 
 537 80854 D138 0403 		add.b 	%d0, srecCSum
 538 80858 8480      		or.l	%d0, %d2
 539 8085a E182      		asl.l	#8, %d2
 540               	|	move.l	%d2, %d0
 541               	|	bsr		printHexLong
 542               	|	lea		CRLF_MSG, %a0
 543               	|   bsr.w   printString
 544               		| Get the middle 8-bits of 24-bits
 545 8085c 4EBA FF94 		jsr		getHexPair
 546 80860 0280 0000 		and.l	#0xff, %d0
 546      00FF 
 547 80866 D138 0403 		add.b 	%d0, srecCSum
 548 8086a 8480      		or.l	%d0, %d2
 549 8086c E182      		asl.l	#8, %d2
 550               	|	move.l	%d2, %d0
 551               	|	bsr		printHexLong
 552               	|	lea		CRLF_MSG, %a0
 553               	|   bsr.w   printString
 554               		| Get the lower 8-bits of 24-bits
 555 8086e 4EBA FF82 		jsr		getHexPair
 556 80872 0280 0000 		and.l	#0xff, %d0
 556      00FF 
 557 80878 D138 0403 		add.b 	%d0, srecCSum
 558 8087c 8480      		or.l	%d0, %d2
 559 8087e 0282 00FF 		andi.l	#0x00ffffff, %d2
 559      FFFF 
 560 80884 21C2 0404 		move.l	%d2, srecAddr		| Save the S record address
 561 80888 2002      		move.l	%d2, %d0
 562 8088a 6100 01D0 		bsr		printHexLong
 563 8088e 41FA 0336 		lea		CRLF_MSG, %a0
 564 80892 6100 FC9C 	    bsr.w   printString
 565 80896 5738 0401 		sub.b	#3, srecByCt
 566 8089a 6000 0036 		bra		past16
 567               	adrLen16:
 568 8089e 41FA 0401 		lea		debug_SXrec_Addr_Msg, %a0
 569 808a2 6100 FC8C 		bsr		printString
 570               	|	move.l	#0, %d2
 571 808a6 4EBA FF4A 		jsr		getHexPair
 572 808aa 5738 0401 		sub.b	#3, srecByCt
 573 808ae 6100 01AC 		bsr		printHexLong
 574 808b2 41FA 0312 		lea		CRLF_MSG, %a0
 575 808b6 6100 FC78 	    bsr.w   printString
 576               	|	or.l	%d0, %d2
68K GAS  S68K_002.s 			page 12


 577               	|	asl.l	#8, %d2
 578 808ba 4EBA FF36 		jsr		getHexPair
 579 808be 5738 0401 		sub.b	#3, srecByCt
 580 808c2 6100 0198 		bsr		printHexLong
 581 808c6 41FA 02FE 		lea		CRLF_MSG, %a0
 582 808ca 6100 FC64 	    bsr.w   printString
 583               	|	or.l	%d0, %d2
 584               	|	move.l	%d2, srecAddr
 585 808ce 5538 0401 		sub.b	#2, srecByCt
 586               	past16:
 587 808d2 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 588 808d6 4E75      		rts
 589               			
 590               	|||||||||||||||||||||||||||||
 591               	| Find and parse a hex number
 592               	|  Starting address in A0
 593               	|  Number returned in D0
 594               	|  Status in D1   (0 success, 1 fail)
 595               	|  TODO: Try and merge first digit code with remaining digit code
 596               	parseNumber:
 597 808d8 B180      	    eor.l   %d0, %d0		| Zero out d0
 598 808da 1018      	    move.b  (%a0)+, %d0
 599 808dc 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 600 808e0 67F6      	    beq.s   parseNumber
 601 808e2 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 602 808e6 6D14      	    blt.s	PNinvalid
 603 808e8 0C00 0039 	    cmp.b   #'9', %d0
 604 808ec 6F18      	    ble.s   PNfirstdigit1
 605               	
 606 808ee 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 607 808f2 6D00 FD60 	    blt   .invalid    
 608 808f6 0C00 0046 	    cmp.b   #'F', %d0
 609 808fa 6F04      	    ble.s   PNfirstdigit2
 610               	PNinvalid:
 611 808fc 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 612 808fe 4E75      	    rts
 613               	PNfirstdigit2:
 614 80900 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 615 80904 6004      	    bra.s   PNloop
 616               	PNfirstdigit1:
 617 80906 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 618               	 PNloop:
 619 8090a 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 620 8090c 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 621 80910 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 622 80912 0C01 0039 	    cmp.b   #'9', %d1
 623 80916 6F18      	    ble.s   PNdigit1
 624 80918 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 625 8091c 6D06      	    blt.s   PNend
 626 8091e 0C01 0046 	    cmp.b   #'F', %d1
 627 80922 6F06      	    ble.s   PNdigit2
 628               	
 629               	PNend:                       | We hit a non-hex digit character, we're done parsing
 630 80924 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 631 80926 7200      	    move.l  #0, %d1
 632 80928 4E75      	    rts
 633               	PNdigit2:
68K GAS  S68K_002.s 			page 13


 634 8092a 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 635 8092e 6004      	    bra.s   PNdigit3
 636               	PNdigit1:
 637 80930 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 638               	PNdigit3:
 639 80934 E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 640 80936 D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 641 80938 60D0      	    bra.s   PNloop
 642               	    
 643               	
 644               	|||||||||||||||||||||||||||||
 645               	| Dumps a section of RAM to the screen
 646               	| Displays both hex values and ASCII characters
 647               	| d0 - Number of bytes to dump
 648               	| a0 - Start Address
 649               	dumpRAM:
 650 8093a 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 651 8093e 2448      	    move.l  %a0, %a2           	| Save the start address
 652 80940 2400      	    move.l  %d0, %d2           	| And the number of bytes
 653               	 .line:
 654 80942 200A      	    move.l  %a2, %d0          
 655 80944 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 656 80948 41FA 0303 	    lea     msgColonSpace, %a0
 657 8094c 6100 FBE2 	    bsr.w   printString
 658 80950 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 659 80952 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 660               	 .hexbyte:
 661 80954 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 662 80956 6718      	    beq.s   .endbytesShort
 663 80958 4A03      	    tst.b   %d3               	| Check if we're done this line
 664 8095a 673A      	    beq.s   .endbytes    
 665 8095c 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 666 8095e 6100 011C 	    bsr.w   printHexByte     	| Display it
 667 80962 103C 0020 	    move.b  #' ', %d0
 668 80966 6100 FBA0 	    bsr.w   outChar          	| Space out bytes
 669 8096a 5383      	    subq.l  #1, %d3    
 670 8096c 5382      	    subq.l  #1, %d2        
 671 8096e 60E4      	    bra.s   .hexbyte
 672               	 .endbytesShort:
 673 80970 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 674 80972 103C 0020 	    move.b  #' ', %d0
 675               	 .endbytesShortLoop:
 676 80976 4A03      	    tst.b   %d3               	| Check if we ended the line
 677 80978 671C      	    beq.s   .endbytes
 678 8097a 103C 0020 	    move.b  #' ', %d0
 679 8097e 6100 FB88 	    bsr.w   outChar          	| Three spaces to pad out
 680 80982 103C 0020 	    move.b  #' ', %d0
 681 80986 6100 FB80 	    bsr.w   outChar
 682 8098a 103C 0020 	    move.b  #' ', %d0
 683 8098e 6100 FB78 	    bsr.w   outChar
 684               	    
 685 80992 5303      	    subq.b  #1, %d3
 686 80994 60E0      	    bra.s   .endbytesShortLoop
 687               	 .endbytes:
 688 80996 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 689               	 .endbytesLoop:
 690 80998 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
68K GAS  S68K_002.s 			page 14


 691 8099a 6700 0022 	    beq     .endline    
 692 8099e 5304      	    subq.b  #1, %d4
 693 809a0 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 694 809a2 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 695 809a6 6D0C      	    blt.s   .unprintable
 696 809a8 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 697 809ac 6E06      	    bgt.s   .unprintable
 698 809ae 6100 FB58 	    bsr.w   outChar
 699 809b2 60E4      	    bra.s   .endbytesLoop
 700               	 .unprintable:
 701 809b4 103C 002E 	    move.b  #'.', %d0
 702 809b8 6100 FB4E 	    bsr.w   outChar
 703 809bc 60DA      	    bra.s   .endbytesLoop
 704               	 .endline:
 705 809be 41FA 0290 	    lea     msgNewline, %a0
 706 809c2 6100 FB6C 	    bsr.w   printString
 707 809c6 4A82      	    tst.l   %d2
 708 809c8 6F04      	    ble.s   .end
 709 809ca 6000 FF76 	    bra.w   .line
 710               	 .end:
 711 809ce 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 712 809d2 4E75      	    rts
 713               	
 714               	|||||||||||||||||||||||
 715               	| Deposit values into RAM
 716               	| d ADDR VAL VAL            Deposit value(s) into RAM
 717               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 718               	|  VAL VAL VAL;              - Continuing with further continue
 719               	| d: VAL VAL                Continue depositing values after the last address written to
 720               	|||||||||||||||||||||||
 721               	.deposit:
 722 809d4 1010      	    move.b  (%a0), %d0
 723 809d6 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 724 809da 6730      	    beq.s   DepCont
 725               	    
 726 809dc 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 727 809e0 4A01      	    tst.b   %d1
 728 809e2 6600 FC8A 	    bne		.invalidAddr
 729 809e6 2640      	    move.l  %d0, %a3           	| Save the start address
 730               	 DepLoop:
 731 809e8 1010      	    move.b  (%a0), %d0            
 732 809ea 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 733 809ee 6726      	    beq.s   DepMLine
 734 809f0 4A40      	    tst     %d0              	| Check for the end of line
 735 809f2 6700 003A 	    beq     DepEnd
 736               	    
 737 809f6 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 738 809fa 4A01      	    tst.b   %d1
 739 809fc 6600 FC7C 	    bne		.invalidVal
 740 80a00 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 741 80a04 6E00 FC74 	    bgt		.invalidVal
 742               	    
 743 80a08 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 744 80a0a 60DC      	    bra.s   DepLoop
 745               	    
 746               	 DepCont:
 747 80a0c 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
68K GAS  S68K_002.s 			page 15


 747      FBAA 
 748 80a12 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 749 80a14 60D2      	    bra.s   DepLoop
 750               	    
 751               	 DepMLine:
 752 80a16 41FA 0186 	    lea     msgDepositPrompt, %a0
 753 80a1a 6100 FB14 	    bsr.w   printString
 754 80a1e 6100 FB42 	    bsr.w   readLine          	| Read in the next line to be parsed
 755 80a22 6100 FBD0 	    bsr.w   lineToUpper         | Convert to uppercase
 756 80a26 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 756      FBAE 
 757 80a2c 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 758               	 DepEnd:
 759 80a2e 23CB 0007 	    move.l  %a3, varCurAddr
 759      FBAA 
 760 80a34 6000 FC26 	    bra.w   .exit
 761               	
 762               	|||||||||||||||||||||||
 763               	| run code
 764               	 .run:
 765 80a38 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 766 80a3c 4A01      	    tst.b   %d1
 767 80a3e 6600 FC2E 	    bne		.invalidAddr
 768 80a42 2040      	    move.l  %d0, %a0
 769 80a44 4E90      	    jsr     (%a0)             	| Jump to the code! 
 770               	                                | Go as subroutine to allow code to return to us
 771 80a46 4EBA FA84 	    jsr     monitorStart        | Warm start after returning so everything is in
 772               	                                | a known state.
 773               	
 774               	
 775               	|||||||||||||||||||||||
 776               	|| KEEP All printHex functions together ||
 777               	|||||||||||||||||||||||
 778               	| Print a hex word
 779               	printHexWord:
 780 80a4a 2F02      	    move.l  %d2, -(%SP)		| Save D2
 781 80a4c 2400      	    move.l  %d0, %d2		| Save the address in d2
 782               	    
 783 80a4e E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 784 80a50 E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 785 80a52 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 786               	|||||||||||||||||||||||
 787               	| Print a hex 24-bit address
 788               	printHexAddr:
 789 80a54 2F02      	    move.l %d2, -(%SP)   	| Save D2
 790 80a56 2400      	    move.l %d0, %d2      	| Save the address in d2
 791               	    
 792 80a58 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 793 80a5a 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 794               	|||||||||||||||||||||||
 795               	* Print a hex long
 796               	printHexLong:
 797 80a5c 2F02      	    move.l  %d2, -(%SP)     | Save D2
 798 80a5e 2400      	    move.l  %d0, %d2        | Save the address in d2
 799               	    
 800 80a60 E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 801 80a62 2002      	    move.l  %d2, %d0
68K GAS  S68K_002.s 			page 16


 802 80a64 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 803               	printHex_addrentry:     
 804 80a66 E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 805 80a68 2002      	    move.l  %d2, %d0              
 806 80a6a 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 807               	printHex_wordentry:    
 808 80a6c E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 809 80a6e 2002      	    move.l  %d2, %d0
 810 80a70 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 811 80a72 E19A      	    rol.l   #0x8, %d2
 812 80a74 2002      	    move.l  %d2, %d0
 813 80a76 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 814               	    
 815 80a78 241F      	    move.l (%SP)+, %d2      | Restore D2
 816 80a7a 4E75      	    RTS
 817               	    
 818               	|||||||||||||||||||||||
 819               	| Print a hex byte
 820               	|  - Takes byte in D0
 821               	printHexByte:
 822 80a7c 2F02      	    move.l  %D2, -(%SP)
 823 80a7e 7400      		move.l	#0, %d2
 824 80a80 1400      	    move.b  %d0, %d2
 825 80a82 E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 826 80a84 0200 000F 		andi.b	#0xf, %d0
 827 80a88 0600 0030 	    add.b   #'0', %d0
 828 80a8c 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 829 80a90 6F02      	    ble.s   PHBsecond
 830 80a92 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 831               	PHBsecond:
 832 80a94 6100 FA72 	    bsr   outChar			| Print the digit
 833 80a98 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 834 80a9c 0602 0030 	    add.b   #'0', %d2
 835 80aa0 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 836 80aa4 6F02      	    ble.s   PHBend
 837 80aa6 5E02      	    add.b   #0x7, %D2
 838               	PHBend:
 839 80aa8 1002      	    move.b  %D2, %D0
 840 80aaa 6100 FA5C 	    bsr	   outChar      	| Print the lower digit
 841 80aae 241F      	    move.l  (%SP)+, %D2
 842 80ab0 4E75      	    rts
 843               		
 844               	
 845               	|||||
 846               	| Initializes the 68681 DUART port A as 9600 8N1 
 847               	initDuart:
 848 80ab2 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 848      000F 0004 
 849 80aba 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 849      000F 0004 
 850 80ac2 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 850      000F 0004 
 851               	    
 852 80aca 13FC 0080 	    move.b  #0x80, ACR       | Baud Rate Set #2
 852      000F 0008 
 853 80ad2 13FC 00BB 	    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 853      000F 0002 
68K GAS  S68K_002.s 			page 17


 854 80ada 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 854      000F 0000 
 855 80ae2 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 855      000F 0000 
 856               	    
 857 80aea 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 857      000F 0004 
 858               	
 859 80af2 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 859      000F 0014 
 860 80afa 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 860      000F 0014 
 861 80b02 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 861      000F 0014 
 862               	    
 863 80b0a 13FC 00BB 	    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 863      000F 0012 
 864 80b12 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 864      000F 0010 
 865 80b1a 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 865      000F 0010 
 866               	    
 867 80b22 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 867      000F 0014 
 868               		
 869 80b2a 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 869      000F 001A 
 870 80b32 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 870      000F 001E 
 871 80b3a 4E75      	    rts    
 872               	
 873               	delay1Sec:
 874 80b3c 203C 0003 		move.l	#200000, %d0	| rough count
 874      0D40 
 875               	delay1Loop:
 876 80b42 5380      		sub.l	#1, %d0			
 877 80b44 6600 FFFC 		bne		delay1Loop
 878 80b48 4E75      		rts
 879               	
 880               	READINLINE:	  
 881 80b4a 5265 6164 		.ascii  "Reading in line"
 881      696E 6720 
 881      696E 206C 
 881      696E 65
 882 80b59 0D0A 00   		dc.b CR,LF,EOT
 883               	L_TO_UPPER_MSG:  
 884 80b5c 436F 6E76 		.ascii  "Convert line to upper case"
 884      6572 7420 
 884      6C69 6E65 
 884      2074 6F20 
 884      7570 7065 
 885 80b76 0D0A 00   		dc.b CR,LF,EOT
 886               	WRITEOUTLINE:	  
 887 80b79 5772 6974 		.ascii  "Writing out line"
 887      696E 6720 
 887      6F75 7420 
 887      6C69 6E65 
68K GAS  S68K_002.s 			page 18


 888 80b89 0D0A 00   		dc.b CR,LF,EOT
 889               	RAM_PASS_MSG:  
 890 80b8c 5241 4D20 		.ascii  "RAM Test Passed"
 890      5465 7374 
 890      2050 6173 
 890      7365 64
 891 80b9b 0D0A 00   		dc.b CR,LF,EOT
 892               	msgDepositPrompt:
 893 80b9e 3A20      	    .ascii	": "
 894 80ba0 00        		dc.b 	EOT
 895               	BANNER_MSG:	
 896 80ba1 5349 4D50 		.ascii  "SIMPLE-68008 CPU"
 896      4C45 2D36 
 896      3830 3038 
 896      2043 5055 
 897 80bb1 0D0A 00   		dc.b CR,LF,EOT
 898               	msgInvalidCommand:
 899 80bb4 496E 7661 	    .ascii "Invalid Command"
 899      6C69 6420 
 899      436F 6D6D 
 899      616E 64
 900 80bc3 0D0A 00   		dc.b CR,LF,EOT
 901               	CRLF_MSG:	
 902 80bc6 0D0A 00   		dc.b CR,LF,EOT
 903               	msgHelp:
 904 80bc9 4176 6169 	    .ascii	"Available Commands: "
 904      6C61 626C 
 904      6520 436F 
 904      6D6D 616E 
 904      6473 3A20 
 905 80bdd 0D0A      		dc.b	CR,LF
 906 80bdf 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 906      7861 6D69 
 906      6E65 2020 
 906      2020 2844 
 906      2965 706F 
 907 80c15 0D0A 00   		dc.b	CR,LF,EOT
 908               	ldSRecMsg:
 909 80c18 4C6F 6164 	    .ascii	"Load S-Record"
 909      2053 2D52 
 909      6563 6F72 
 909      64
 910 80c25 0D0A 00   		dc.b	CR,LF,EOT
 911               	msgInvalidAddress:
 912 80c28 496E 7661 	    .ascii	"Invalid Address"
 912      6C69 6420 
 912      4164 6472 
 912      6573 73
 913 80c37 0D0A 00   		dc.b 	CR,LF,EOT
 914               	msgInvalidValue:
 915 80c3a 496E 7661 	    .ascii	"Invalid Value"
 915      6C69 6420 
 915      5661 6C75 
 915      65
 916 80c47 0D0A 00   		dc.b	CR,LF,EOT
 917               	msgPrompt:
 918 80c4a 3E20      		.ascii "> "
68K GAS  S68K_002.s 			page 19


 919 80c4c 00        	    dc.b EOT
 920               	msgColonSpace:
 921 80c4d 3A20      	    .ascii ": "
 922 80c4f 00        	    dc.b EOT
 923               	msgNewline:
 924 80c50 0D0A 00   	    dc.b CR,LF,EOT
 925               	debug_Srec_Typ_Msg:
 926 80c53 5320 5265 		.ascii	"S Record Type="
 926      636F 7264 
 926      2054 7970 
 926      653D 
 927 80c61 00        	    dc.b EOT
 928               	debug_Srec_BytCt_Msg:
 929 80c62 5320 5265 		.ascii	"S Record Byte Count=0x"
 929      636F 7264 
 929      2042 7974 
 929      6520 436F 
 929      756E 743D 
 930 80c78 00        	    dc.b EOT
 931               	debug_Srec_CSum_Msg:
 932 80c79 5320 5265 		.ascii	"S Record Checksum="
 932      636F 7264 
 932      2043 6865 
 932      636B 7375 
 932      6D3D 
 933 80c8b 00        	    dc.b EOT
 934               	debug_S2rec_Addr_Msg:
 935 80c8c 5332 2052 		.ascii	"S2 Record Address=0x"
 935      6563 6F72 
 935      6420 4164 
 935      6472 6573 
 935      733D 3078 
 936 80ca0 00        	    dc.b EOT
 937               	debug_SXrec_Addr_Msg:
 938 80ca1 5320 286E 		.ascii	"S (not 2) Record Address=0x"
 938      6F74 2032 
 938      2920 5265 
 938      636F 7264 
 938      2041 6464 
 939 80cbc 00        	    dc.b EOT
 940               	debug_Srec_LDData_Msg:
 941 80cbd 4C6F 6164 	    .ascii	"Load Data Loop start"
 941      2044 6174 
 941      6120 4C6F 
 941      6F70 2073 
 941      7461 7274 
 942 80cd1 0D0A 00   		dc.b 	CR,LF,EOT
 943               	
 944               	
 945               	MAX_LINE_LENGTH = 80
 946               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 947               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 20


DEFINED SYMBOLS
          S68K_002.s:6      *ABS*:0000000000000000 RAM_START
          S68K_002.s:7      *ABS*:000000000007fffc STACK_END
          S68K_002.s:8      *ABS*:000000000007ffff RAM_END
          S68K_002.s:9      *ABS*:0000000000080000 ROM_START
          S68K_002.s:10     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:12     *ABS*:000000000008ffff ROM_END
          S68K_002.s:17     *ABS*:00000000000f0000 DUART
          S68K_002.s:18     *ABS*:00000000000f0000 MRA
          S68K_002.s:19     *ABS*:00000000000f0002 SRA
          S68K_002.s:20     *ABS*:00000000000f0002 CSRA
          S68K_002.s:21     *ABS*:00000000000f0004 CRA
          S68K_002.s:22     *ABS*:00000000000f0006 RBA
          S68K_002.s:23     *ABS*:00000000000f0006 TBA
          S68K_002.s:24     *ABS*:00000000000f0008 ACR
          S68K_002.s:25     *ABS*:00000000000f000a ISR
          S68K_002.s:26     *ABS*:00000000000f000a IMR
          S68K_002.s:27     *ABS*:00000000000f0010 MRB
          S68K_002.s:28     *ABS*:00000000000f0012 SRB
          S68K_002.s:29     *ABS*:00000000000f0012 CSRB
          S68K_002.s:30     *ABS*:00000000000f0014 CRB
          S68K_002.s:31     *ABS*:00000000000f0016 RBB
          S68K_002.s:32     *ABS*:00000000000f0016 TBB
          S68K_002.s:33     *ABS*:00000000000f0018 IVR
          S68K_002.s:34     *ABS*:00000000000f001a OPC
          S68K_002.s:35     *ABS*:00000000000f001a INU
          S68K_002.s:36     *ABS*:00000000000f001c OPS
          S68K_002.s:37     *ABS*:00000000000f001e OPR
          S68K_002.s:42     *ABS*:0000000000000007 BEL
          S68K_002.s:43     *ABS*:0000000000000008 BKSP
          S68K_002.s:44     *ABS*:0000000000000009 TAB
          S68K_002.s:45     *ABS*:000000000000000a LF
          S68K_002.s:46     *ABS*:000000000000000d CR
          S68K_002.s:47     *ABS*:000000000000001b ESC
          S68K_002.s:48     *ABS*:0000000000000000 EOT
          S68K_002.s:50     *ABS*:0000000000000003 CTRLC
          S68K_002.s:51     *ABS*:0000000000000018 CTRLX
          S68K_002.s:54     .text:0000000000000400 _srecType
          S68K_002.s:55     .text:0000000000000401 _srecByCt
          S68K_002.s:56     .text:0000000000000402 _srecData
          S68K_002.s:57     .text:0000000000000403 _srecCSum
          S68K_002.s:58     .text:0000000000000404 _srecAddr
          S68K_002.s:60     *ABS*:0000000000000400 srecType
          S68K_002.s:61     *ABS*:0000000000000401 srecByCt
          S68K_002.s:62     *ABS*:0000000000000402 srecData
          S68K_002.s:63     *ABS*:0000000000000403 srecCSum
          S68K_002.s:64     *ABS*:0000000000000404 srecAddr
          S68K_002.s:175    .text:0000000000080502 FERVR2
          S68K_002.s:100    .text:000000000008045c loop1stLoc
          S68K_002.s:173    .text:0000000000080502 failBitTest
          S68K_002.s:115    .text:000000000008047c loopAdrFill
          S68K_002.s:127    .text:000000000008049a loopAdrCk
          S68K_002.s:174    .text:0000000000080502 failAdrTest
          S68K_002.s:142    .text:00000000000804b4 fillSRAM
          S68K_002.s:146    .text:00000000000804c0 fillSRAMLoop
          S68K_002.s:847    .text:0000000000080ab2 initDuart
          S68K_002.s:155    .text:00000000000804cc monitorStart
68K GAS  S68K_002.s 			page 21


          S68K_002.s:895    .text:0000000000080ba1 BANNER_MSG
          S68K_002.s:200    .text:0000000000080530 printString1
          S68K_002.s:889    .text:0000000000080b8c RAM_PASS_MSG
          S68K_002.s:163    .text:00000000000804dc interpLoop
          S68K_002.s:917    .text:0000000000080c4a msgPrompt
          S68K_002.s:201    .text:0000000000080530 printString
          S68K_002.s:230    .text:0000000000080562 readLine
          S68K_002.s:287    .text:00000000000805f4 lineToUpper
          S68K_002.s:304    .text:0000000000080612 parseLine
          S68K_002.s:182    .text:0000000000080508 outChar1
          S68K_002.s:183    .text:0000000000080508 outChar
          S68K_002.s:191    .text:000000000008051c outChar2
          S68K_002.s:202    .text:0000000000080530 PSloop
          S68K_002.s:208    .text:0000000000080538 PSend
          S68K_002.s:216    .text:000000000008053a inChar1
          S68K_002.s:217    .text:000000000008053a inChar
          S68K_002.s:223    .text:000000000008054e inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:234    .text:000000000008056e RLloop
          S68K_002.s:251    .text:000000000008059a RLBS
          S68K_002.s:262    .text:00000000000805b8 RLlineClr
          S68K_002.s:276    .text:00000000000805dc RLEndLn
          S68K_002.s:244    .text:000000000008058a .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:266    .text:00000000000805be RLlineClrloop
          S68K_002.s:289    .text:00000000000805fa LUloop
          S68K_002.s:296    .text:000000000008060c LUnext
          S68K_002.s:307    .text:000000000008061c PLfindCommand
          S68K_002.s:353    .text:0000000000080686 .examine
          S68K_002.s:721    .text:00000000000809d4 .deposit
          S68K_002.s:764    .text:0000000000080a38 .run
          S68K_002.s:332    .text:0000000000080662 .help
          S68K_002.s:421    .text:0000000000080710 loadSRec
          S68K_002.s:326    .text:000000000008065c .exit
          S68K_002.s:323    .text:0000000000080654 .invalid
          S68K_002.s:898    .text:0000000000080bb4 msgInvalidCommand
          S68K_002.s:903    .text:0000000000080bc9 msgHelp
          S68K_002.s:336    .text:000000000008066e .invalidAddr
          S68K_002.s:911    .text:0000000000080c28 msgInvalidAddress
          S68K_002.s:340    .text:000000000008067a .invalidVal
          S68K_002.s:914    .text:0000000000080c3a msgInvalidValue
          S68K_002.s:596    .text:00000000000808d8 parseNumber
          S68K_002.s:358    .text:0000000000080692 .exloop
          S68K_002.s:372    .text:00000000000806b6 .exrange
          S68K_002.s:381    .text:00000000000806c8 .exlength
          S68K_002.s:389    .text:00000000000806da .exinter
          S68K_002.s:378    .text:00000000000806c4 .exquick
          S68K_002.s:385    .text:00000000000806d2 .exend
          S68K_002.s:649    .text:000000000008093a dumpRAM
          S68K_002.s:394    .text:00000000000806e8 .exinterend
          S68K_002.s:401    .text:00000000000806fc .exinterpage
          S68K_002.s:908    .text:0000000000080c18 ldSRecMsg
          S68K_002.s:467    .text:0000000000080792 setRecType
          S68K_002.s:486    .text:00000000000807c8 setBytCt
          S68K_002.s:526    .text:000000000008082a setAddr
          S68K_002.s:940    .text:0000000000080cbd debug_Srec_LDData_Msg
          S68K_002.s:437    .text:000000000008074e sRecDataDone
68K GAS  S68K_002.s 			page 22


          S68K_002.s:432    .text:000000000008073c loopSData
          S68K_002.s:442    .text:0000000000080756 getSetLdData
          S68K_002.s:454    .text:0000000000080770 getChksum
          S68K_002.s:502    .text:00000000000807f2 getHexPair
          S68K_002.s:450    .text:000000000008076e skipLdData
          S68K_002.s:931    .text:0000000000080c79 debug_Srec_CSum_Msg
          S68K_002.s:821    .text:0000000000080a7c printHexByte
          S68K_002.s:901    .text:0000000000080bc6 CRLF_MSG
          S68K_002.s:463    .text:0000000000080790 failCSUM
          S68K_002.s:925    .text:0000000000080c53 debug_Srec_Typ_Msg
          S68K_002.s:928    .text:0000000000080c62 debug_Srec_BytCt_Msg
          S68K_002.s:515    .text:0000000000080812 toNibble
          S68K_002.s:520    .text:0000000000080820 doHexLetter
          S68K_002.s:567    .text:000000000008089e adrLen16
          S68K_002.s:934    .text:0000000000080c8c debug_S2rec_Addr_Msg
          S68K_002.s:796    .text:0000000000080a5c printHexLong
          S68K_002.s:586    .text:00000000000808d2 past16
          S68K_002.s:937    .text:0000000000080ca1 debug_SXrec_Addr_Msg
          S68K_002.s:610    .text:00000000000808fc PNinvalid
          S68K_002.s:616    .text:0000000000080906 PNfirstdigit1
          S68K_002.s:613    .text:0000000000080900 PNfirstdigit2
          S68K_002.s:618    .text:000000000008090a PNloop
          S68K_002.s:629    .text:0000000000080924 PNend
          S68K_002.s:636    .text:0000000000080930 PNdigit1
          S68K_002.s:633    .text:000000000008092a PNdigit2
          S68K_002.s:638    .text:0000000000080934 PNdigit3
          S68K_002.s:653    .text:0000000000080942 .line
          S68K_002.s:788    .text:0000000000080a54 printHexAddr
          S68K_002.s:920    .text:0000000000080c4d msgColonSpace
          S68K_002.s:660    .text:0000000000080954 .hexbyte
          S68K_002.s:672    .text:0000000000080970 .endbytesShort
          S68K_002.s:687    .text:0000000000080996 .endbytes
          S68K_002.s:675    .text:0000000000080976 .endbytesShortLoop
          S68K_002.s:689    .text:0000000000080998 .endbytesLoop
          S68K_002.s:704    .text:00000000000809be .endline
          S68K_002.s:700    .text:00000000000809b4 .unprintable
          S68K_002.s:923    .text:0000000000080c50 msgNewline
          S68K_002.s:710    .text:00000000000809ce .end
          S68K_002.s:746    .text:0000000000080a0c DepCont
          S68K_002.s:730    .text:00000000000809e8 DepLoop
          S68K_002.s:751    .text:0000000000080a16 DepMLine
          S68K_002.s:758    .text:0000000000080a2e DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:892    .text:0000000000080b9e msgDepositPrompt
          S68K_002.s:779    .text:0000000000080a4a printHexWord
          S68K_002.s:807    .text:0000000000080a6c printHex_wordentry
          S68K_002.s:803    .text:0000000000080a66 printHex_addrentry
          S68K_002.s:831    .text:0000000000080a94 PHBsecond
          S68K_002.s:838    .text:0000000000080aa8 PHBend
          S68K_002.s:873    .text:0000000000080b3c delay1Sec
          S68K_002.s:875    .text:0000000000080b42 delay1Loop
          S68K_002.s:880    .text:0000000000080b4a READINLINE
          S68K_002.s:883    .text:0000000000080b5c L_TO_UPPER_MSG
          S68K_002.s:886    .text:0000000000080b79 WRITEOUTLINE

NO UNDEFINED SYMBOLS
