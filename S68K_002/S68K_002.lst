68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Borrowed init code from 
   4               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   5               	
   6               	RAM_START	= 0x00000	| Beginning of the SRAM
   7               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
   8               	RAM_END		= 0x7FFFF	| 512KB SRAM
   9               	ROM_START	= 0x80000	| ROM start
  10               	ROM_CODE	= ROM_START+1024| Skip vector table
  11               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  12               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  13               	
  14               	|||||||||||||||||||||||||||||||||
  15               	| 68681 Duart Register Addresses
  16               	|
  17               	DUART = 0x0F0000	  | Base Addr of DUART
  18               	MRA   = DUART+0		  | Mode Register A           (R/W)
  19               	SRA   = DUART+2       | Status Register A         (r)
  20               	CSRA  = DUART+2       | Clock Select Register A   (w)
  21               	CRA   = DUART+4       | Commands Register A       (w)
  22               	RBA   = DUART+6       | Receiver Buffer A         (r)
  23               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  24               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  25               	ISR   = DUART+10      | Interrupt Status Register (R)
  26               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  27               	MRB   = DUART+16      | Mode Register B           (R/W)
  28               	SRB   = DUART+18      | Status Register B         (R)
  29               	CSRB  = DUART+18      | Clock Select Register B   (W)
  30               	CRB   = DUART+20      | Commands Register B       (W)
  31               	RBB   = DUART+22      | Reciever Buffer B         (R)
  32               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  33               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  34               	OPC   = DUART+26      | Output port config        (W)
  35               	INU   = DUART+26      | Input port (unlatched)    (R)
  36               	OPS   = DUART+28      | Output port Set           (W)
  37               	OPR   = DUART+30      | Output port Clear         (W)
  38               	
  39               	||||||||||||||||||||||||||||||||||
  40               	| ASCII Control Characters
  41               	|
  42               	BEL   = 0x07
  43               	BKSP  = 0x08       | CTRL-H
  44               	TAB   = 0x09
  45               	LF    = 0x0A
  46               	CR    = 0x0D
  47               	ESC   = 0x1B
  48               	EOT	  = 0x00
  49               	
  50               	CTRLC	=	0x03
  51               	CTRLX	=	0x18     | Line Clear
  52               	
  53 0000 0000 0000 		.ORG    0x000400
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
68K GAS  S68K_002.s 			page 2


  54 0400 00        	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  55 0401 00        	srecByCt:	ds.b	1		| Byte Count
  56 0402 00        	srecData:	ds.b	1 		| Data
  57 0403 00        	srecCSum:	ds.b	1 		| S-Record Checksum
  58 0404 0000 0000 	srecAddr:	ds.l	1		| S Record current byte address
  59               	
  60 0408 0000 0000 		.ORG	ROM_START
  60      0000 0000 
  60      0000 0000 
  60      0000 0000 
  60      0000 0000 
  61               	
  62               	| FIRST 8 bytes loaded after reset |
  63 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  64 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  65               	
  66 80008 0000 0000 	        .ORG ROM_CODE
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  67 80400 4E71      		nop
  68 80402 4FF9 0007 		lea			STACK_END,%sp
  68      FFFC 
  69 80408 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  69      0008 0000 
  70 80410 4E71      		nop
  71               	|
  72               	| Test the first two SRAM location
  73               	|
  74 80412 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  74      BEEF 
  75 80418 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  76 8041c 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  77 8041e 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
  78 80420 B042      		cmp			%d2, %d0
  79 80422 6600 00C6 		bne			FERVR2						
  80 80426 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  80      AAAA 
  81 8042c 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
  82 80430 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
  83 80432 2611      		move.l	(%a1), %d3				| Read back
  84 80434 B243      		cmp			%d3, %d1
  85 80436 6600 00B2 		bne			FERVR2
  86 8043a 4E71      		nop
  87               	| Test bits of first location (as bytes)
  88 8043c 7001      		move.l	#1, %d0
  89 8043e 207C 0000 		move.l	#0, %a0
  89      0000 
  90               	loop1stLoc:
  91 80444 1080      		move.b	%d0, (%a0)
  92 80446 1210      		move.b	(%a0), %d1
  93 80448 B200      		cmp.b		%d0, %d1
  94 8044a 6600 009E 		bne			failBitTest
  95 8044e E348      		lsl			#1, %d0
  96 80450 0C80 0000 		cmp.l		#0x00000100, %d0
  96      0100 
68K GAS  S68K_002.s 			page 3


  97 80456 6600 FFEC 		bne			loop1stLoc
  98               	|
  99               	| Test all address lines, 512KB SRAM
 100               	| Write incrementing pattern to data bits
 101               	|
 102 8045a 7001      		move.l	#1, %d0		| Fill pattern
 103 8045c 7401      		move.l	#1, %d2
 104 8045e 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 104      0001 
 105               	loopAdrFill:
 106 80464 1080      		move.b	%d0,(%a0)	| Do the write
 107 80466 5240      		addq		#1, %d0		| Increment the pattern
 108 80468 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 109 8046a E38A      		lsl.l		#1, %d2		| Shift temp addr
 110 8046c 2042      		move.l	%d2, %a0	| Put back into addr reg
 111 8046e 0C82 0008 		cmp.l		#0x00080000,%d2
 111      0000 
 112 80474 6600 FFEE 		bne			loopAdrFill
 113               	| Check
 114 80478 7001      		move.l	#1, %d0
 115 8047a 7401      		move.l	#1, %d2
 116 8047c 207C 0000 		move.l	#1, %a0
 116      0001 
 117               	loopAdrCk:
 118 80482 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 119 80484 B200      		cmp.b		%d0, %d1
 120 80486 6600 0062 		bne			failAdrTest
 121 8048a 5240      		addq		#1, %d0
 122 8048c 2408      		move.l	%a0, %d2 
 123 8048e E38A      		lsl.l		#1, %d2
 124 80490 2042      		move.l	%d2, %a0
 125 80492 0C82 0008 		cmp.l		#0x00080000,%d2
 125      0000 
 126 80498 6600 FFE8 		bne			loopAdrCk
 127               		
 128               	|
 129               	| Fill SRAM with 0x00 values
 130               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 131               	|
 132               	fillSRAM:
 133 8049c 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 134 804a0 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 134      FFFF 
 135 804a6 7000      		move.l	#0x00, %d0			| Fill with zeros
 136               	fillSRAMLoop:
 137 804a8 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 138 804aa B3C8      		cmpa.l	%a0, %a1
 139 804ac 6E00 FFFA 		bgt		fillSRAMLoop
 140               	
 141               	|
 142               	| Done with address test of SRAM
 143               	|
 144 804b0 4EBA 058A 		jsr     initDuart       	| Setup the serial port
 145               	monitorStart:					| Warm start
 146 804b4 41FA 0675 		lea		BANNER_MSG, %a0
 147 804b8 4EBA 005E 		jsr		printString1
 148 804bc 41FA 0658 		lea		RAM_PASS_MSG, %a0
68K GAS  S68K_002.s 			page 4


 149 804c0 4EBA 0056 		jsr		printString1
 150               	|
 151               	| Interpreter Loop
 152               	|
 153               	interpLoop:
 154 804c4 41FA 070E 	    lea     msgPrompt, %a0	| Prompt
 155 804c8 6100 004E 	    bsr.w   printString
 156 804cc 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 156      000F 001E 
 157 804d4 4EBA 0074 		jsr		readLine		| Blocking read of line
 158 804d8 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 158      000F 001C 
 159 804e0 4EBA 00FA 		jsr		lineToUpper
 160 804e4 4EBA 0114 		jsr		parseLine
 161 804e8 60DA      		bra.s	interpLoop
 162               		
 163               	failBitTest:
 164               	failAdrTest:
 165               	FERVR2:
 166 804ea 4E71      		nop
 167 804ec 4EFA FFFC 		jmp	FERVR2
 168               	
 169               	|||||
 170               	| Writes a character to Port A, blocking if not ready (Full buffer)
 171               	|  - Takes a character in D0
 172               	outChar1:
 173               	outChar:
 174 804f0 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 174      000F 0002 
 175 804f8 6700 FFF6 	    beq     outChar1     
 176 804fc 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 176      0006 
 177 80502 4E75      	    rts
 178               	
 179               	| Writes a character to Port A, blocking if not ready (Full buffer)
 180               	|  - Takes a character in D0
 181               	outChar2:
 182 80504 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 182      000F 0012 
 183 8050c 6700 FFF6 	    beq     outChar2     
 184 80510 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 184      0016 
 185 80516 4E75      	    rts
 186               	
 187               	******
 188               	* Print a null terminated string
 189               	*
 190               	printString1:
 191               	printString:
 192               	 PSloop:
 193 80518 1018      	    move.b  (%a0)+, %d0  | Read in character
 194 8051a 6704      	    beq.s   PSend         | Check for the null
 195               	    
 196 8051c 61D2      	    bsr.s   outChar      | Otherwise write the character
 197 8051e 60F8      	    bra.s   PSloop        | And continue
 198               	PSend:
 199 80520 4E75      	    rts
68K GAS  S68K_002.s 			page 5


 200               	
 201               	
 202               	|||||
 203               	| Reads in a character from Port A, blocking if none available
 204               	|  - Returns character in D0
 205               	|    
 206               	inChar1:
 207               	inChar:
 208 80522 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 208      000F 0002 
 209 8052a 6700 FFF6 	    beq     inChar1
 210 8052e 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 210      0006 
 211 80534 4E75      	    rts
 212               	
 213               	inChar2:
 214 80536 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 214      000F 0012 
 215 8053e 6700 FFF6 	    beq     inChar2
 216 80542 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 216      0016 
 217 80548 4E75      	    rts
 218               	
 219               	| Read in a line into the line buffer
 220               	readLine:
 221 8054a 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 222 8054e 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 222      FBAE 
 223 80554 B542      	    eor.w   %d2, %d2           	| Clear the character counter
 224               	 RLloop:
 225 80556 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 226 8055a 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 227 8055e 6722      	    beq.s   RLBS
 228 80560 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 229 80564 673A      	    beq.s   RLlineClr
 230 80566 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 231 8056a 6758      	    beq.s   RLEndLn
 232 8056c 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 233 80570 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 234               	 .char:                      	| Normal character to be inserted into the buffer
 235 80572 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 236 80576 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 237 80578 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 238 8057a 5242      	    addq.w  #1, %d2           	| Increment character count
 239 8057c 6100 FF72 	    bsr.w   outChar          	| Echo the character
 240 80580 60D4      	    bra.s   RLloop            	| And get the next one
 241               	 RLBS:
 242 80582 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 243 80584 67D0      	    beq.s   RLloop            	| Then ignore it
 244 80586 6100 FF68 	    bsr.w   outChar          	| Backspace
 245 8058a 103C 0020 	    move.b  #' ', %d0
 246 8058e 6100 FF60 	    bsr.w   outChar          	| Space
 247 80592 103C 0008 	    move.b  #BKSP, %d0
 248 80596 6100 FF58 	    bsr.w   outChar          	| Backspace
 249 8059a 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 250 8059c 5382      	    subq.l  #1, %d2           	| And current character count
 251 8059e 60B6      	    bra.s   RLloop            	| And goto the next character
68K GAS  S68K_002.s 			page 6


 252               	 RLlineClr:
 253 805a0 4A42      	    tst     %d2               	| Anything to clear?
 254 805a2 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 255 805a4 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 256               	 RLlineClrloop:
 257 805a6 103C 0008 	    move.b  #BKSP, %d0
 258 805aa 6100 FF44 	    bsr.w   outChar          	| Backspace
 259 805ae 103C 0020 	    move.b  #' ', %d0
 260 805b2 6100 FF3C 	    bsr.w   outChar          	| Space
 261 805b6 103C 0008 	    move.b  #BKSP, %d0
 262 805ba 6100 FF34 	    bsr.w   outChar          	| Backspace
 263 805be 5342      	    subq.w  #1, %d2          
 264 805c0 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 265 805c2 6092      	    bra.s   RLloop   
 266               	 RLEndLn:
 267 805c4 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 268 805c8 103C 000A 	    move.b  #LF, %d0
 269 805cc 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 270 805d0 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 271 805d4 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 272 805d6 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 273 805da 4E75      	    rts                      	| And return
 274               	
 275               	
 276               	| Convert line buffer to upper case
 277               	lineToUpper:
 278 805dc 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 278      FBAE 
 279               	 LUloop:
 280 805e2 1010      	    move.b  (%a0), %d0        | Read in a character
 281 805e4 0C00 0061 	    cmp.b   #'a', %d0         
 282 805e8 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 283 805ea 0C00 007A 	    cmp.b   #'z', %d0
 284 805ee 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 285 805f0 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
 286               	 LUnext:
 287 805f4 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 288 805f6 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 289 805f8 4E75      	    rts
 290               	
 291               	|
 292               	| Parse Line
 293               	|
 294               	parseLine:
 295 805fa 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 296 805fe 41F9 0007 	    lea     varLineBuf, %a0
 296      FBAE 
 297               	 PLfindCommand:
 298 80604 1018      	    move.b  (%a0)+, %d0
 299 80606 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 300 8060a 6700 FFF8 	    beq.w   PLfindCommand    
 301 8060e 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 302 80612 6700 005A 	    beq.w   .examine
 303 80616 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 304 8061a 6700 0342 	    beq.w   .deposit
 305 8061e 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 306 80622 6700 039E 	    beq.w   .run
68K GAS  S68K_002.s 			page 7


 307 80626 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 308 8062a 6700 001E 	    beq.w   .help
 309 8062e 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 310 80632 6700 00C4 	    beq.w   loadSRec
 311 80636 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 312 8063a 6708      	    beq.s   .exit               
 313               	 .invalid:   
 314 8063c 41FA 0500 	    lea     msgInvalidCommand, %a0
 315 80640 6100 FED6 	    bsr.w   printString
 316               	 .exit:
 317 80644 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 318 80648 4E75      	    rts
 319               	
 320               	|||||||||||||||||||||||||||||||
 321               	|| HELP command
 322               	 .help:
 323 8064a 41FA 0507 	    lea     msgHelp, %a0
 324 8064e 6100 FEC8 	    bsr.w   printString
 325 80652 6000 FFF0 	    bra.w   .exit
 326               	 .invalidAddr:
 327 80656 41FA 055A 	    lea     msgInvalidAddress, %a0
 328 8065a 6100 FEBC 	    bsr.w   printString
 329 8065e 6000 FFE4 	    bra.w   .exit
 330               	 .invalidVal:
 331 80662 41FA 0560 	    lea     msgInvalidValue, %a0
 332 80666 6100 FEB0 	    bsr.w   printString
 333 8066a 6000 FFD8 	    bra.w   .exit
 334               		
 335               	|||||||||||||||||||||||||||||||
 336               	| Examines memory addresses
 337               	| Valid modes:
 338               	|   e ADDR                  Displays a single byte
 339               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 340               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 341               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 342               	|   e ADDR.                 Quick line, displays one line 
 343               	.examine:
 344 8066e 6100 01F2 	    bsr.w   parseNumber         | Read in the start address
 345 80672 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 346 80674 6600 FFE0 	    bne.w   .invalidAddr        
 347 80678 2640      	    move.l  %d0, %a3            | Save the start address
 348               	 .exloop:
 349 8067a 1018      	    move.b  (%a0)+, %d0
 350 8067c 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 351 80680 67F8      	    beq.s   .exloop
 352 80682 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 353 80686 6716      	    beq.s   .exrange
 354 80688 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 355 8068c 6722      	    beq.s   .exlength
 356 8068e 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
 357 80692 672E      	    beq.s   .exinter
 358 80694 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 359 80698 6712      	    beq.s   .exquick
 360 8069a 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 361 8069c 601C      	    bra.s   .exend              
 362               	 .exrange:
 363 8069e 6100 01C2 	    bsr.w   parseNumber         | Find the end address
68K GAS  S68K_002.s 			page 8


 364 806a2 4A01      	    tst.b   %d1                 | Check if we found a valid address
 365 806a4 6600 FFB0 	    bne.w   .invalidAddr
 366 806a8 908B      	    sub.l   %a3, %d0            | Get the length
 367 806aa 600E      	    bra.s   .exend
 368               	 .exquick:                      | Quick mode means show one line of 16 bytes
 369 806ac 7010      	    move.l  #0x10, %d0
 370 806ae 600A      	    bra.s   .exend
 371               	 .exlength:                     | Length mode means a length is specified
 372 806b0 6100 01B0 	    bsr.w   parseNumber         | Find the length
 373 806b4 4A01      	    tst.b   %d1
 374 806b6 6600 FF9E 	    bne.w   .invalidAddr
 375               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 376 806ba 204B      	    move.l  %a3, %a0
 377 806bc 6100 0206 	    bsr.w   dumpRAM
 378 806c0 6082      	    bra.s   .exit
 379               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 380 806c2 204B      	    move.l  %a3, %a0            | Current Address
 381 806c4 7010      	    move.l  #0x10, %d0          | 16 bytes
 382 806c6 6100 01FC 	    bsr.w   dumpRAM             | Dump this line
 383 806ca D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 383      0010 
 384               	 .exinterend:
 385 806d0 6100 FE50 	    bsr.w   inChar
 386 806d4 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 387 806d8 67E8      	    beq.s   .exinter
 388 806da 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 389 806de 6704      	    beq.s   .exinterpage
 390 806e0 6000 FF62 	    bra	   .exit               | Otherwise exit
 391               	 .exinterpage:
 392 806e4 204B      	    move.l  %a3, %a0
 393 806e6 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 393      0100 
 394 806ec 6100 01D6 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 395 806f0 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 395      0100 
 396 806f6 60D8      	    bra.s   .exinterend
 397               	
 398               	|||||||||||||||||||||||||||||
 399               	|| Load S Record
 400               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 401               	|	srecByCt:	ds.b	1		| Byte Count
 402               	|	srecData:	ds.b	1 		| Data
 403               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 404               	|	srecAddr:	ds.l	1		| S Record current byte address
 405               	|
 406               	| Supports 3 S record types (matches gcc m68k output)
 407               	|	S00F00005336384B5F3030322E746D7074
 408               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 409               	|	S503005BA1
 410               	
 411               	loadSRec:
 412 806f8 41FA 04A8 	    lea     ldSRecMsg, %a0
 413 806fc 6100 FE1A 	    bsr.w   printString
 414 80700 4EBA 0060 		jsr		getRecType
 415 80704 4EBA 0096 		jsr		getBytCt
 416 80708 13FC 0000 		move.b 	#0, srecCSum
 416      0000 0000 
68K GAS  S68K_002.s 			page 9


 417 80710 4EBA 00F0 		jsr		getAddr
 418               	loopSData:
 419 80714 0C39 0001 		cmp.b 	#1, srecByCt
 419      0000 0000 
 420 8071c 6700 000A 		beq		sRecDataDone
 421 80720 4EBA 000E 		jsr		getLdData
 422 80724 6000 FFEE 		bra		loopSData
 423               	sRecDataDone:
 424 80728 4EBA 0032 		jsr		getChksum
 425 8072c 6000 FF16 		bra.w   .exit
 426               	
 427               	getLdData:
 428 80730 4EBA 009C 		jsr		getHexPair
 429 80734 0C39 0002 		cmp.b	#2, srecType
 429      0000 0000 
 430 8073c 6600 000A 		bne		skipLdData
 431 80740 41F9 0000 		lea 	srecAddr, %a0
 431      0000 
 432 80746 1080      		move.b	%d0, (%a0)
 433               	skipLdData:
 434 80748 D139 0000 		add.b	%d0, srecCSum
 434      0000 
 435 8074e 5339 0000 		sub.b	#1, srecByCt
 435      0000 
 436 80754 52B9 0000 		add.l	#1, srecAddr
 436      0000 
 437 8075a 4E75      		rts
 438               	
 439               	getChksum:
 440 8075c 4EBA 0070 		jsr		getHexPair
 441 80760 4E75      		rts
 442               	
 443               	getRecType:
 444 80762 4EBA FDBE 		jsr		inChar
 445 80766 0C00 0053 		cmp.b	#'S', %d0
 446 8076a 6600 FFF6 		bne		getRecType
 447 8076e 4EBA FDB2 		jsr		inChar
 448 80772 0200 000F 		andi.b	#0x0f, %d0
 449 80776 13C0 0000 		move.b	%d0, srecType
 449      0000 
 450               	| Debug messages follow
 451 8077c 41FA 045F 		lea		debug_Srec_Typ_Msg, %a0		| Debug message
 452 80780 6100 FD96 	    bsr.w   printString
 453 80784 1039 0000 		move.b	srecType, %d0
 453      0000 
 454 8078a 0600 0030 		add.b	#'0', %d0
 455 8078e 4EBA FD60 		jsr		outChar
 456 80792 41FA 03BC 		lea		CRLF_MSG, %a0
 457 80796 6100 FD80 	    bsr.w   printString
 458               	| Debug messages end
 459 8079a 4E75      		rts
 460               		
 461               	getBytCt:
 462 8079c 4EBA 0030 		jsr		getHexPair
 463 807a0 13C0 0000 		move.b 	%d0, srecCSum
 463      0000 
 464 807a6 13C0 0000 		move.b	%d0, srecByCt
68K GAS  S68K_002.s 			page 10


 464      0000 
 465 807ac 5339 0000 		sub.b	#1, srecByCt
 465      0000 
 466               	| Debug messages follow
 467 807b2 41FA 0438 		lea		debug_Srec_BytCt_Msg, %a0
 468 807b6 6100 FD60 	    bsr.w   printString
 469 807ba 1039 0000 		move.b	srecByCt, %d0
 469      0000 
 470 807c0 4EBA 0244 		jsr		printHexByte
 471 807c4 41FA 038A 		lea		CRLF_MSG, %a0
 472 807c8 6100 FD4E 	    bsr.w   printString
 473               	| Debug messages end
 474 807cc 4E75      		rts
 475               	
 476               	getHexPair:
 477 807ce 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 478 807d2 4EBA FD4E 		jsr		inChar
 479 807d6 4EBA 0016 		jsr		toNibble
 480 807da E900      		asl.b	#4, %d0
 481 807dc 1400      		move.b	%d0, %d2
 482 807de 4EBA FD42 		jsr		inChar
 483 807e2 4EBA 000A 		jsr		toNibble
 484 807e6 8002      		or.b	%d2, %d0
 485 807e8 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 486 807ec 4E75      		rts
 487               	
 488               	toNibble:
 489 807ee 0C00 0041 		cmp.b	#'A', %d0
 490 807f2 6C00 0008 		bge		doHexLetter
 491 807f6 0400 0030 		sub.b	#'0', %d0
 492 807fa 4E75      		rts
 493               	doHexLetter:
 494 807fc 0400 004B 		sub.b	#'A'+10, %d0
 495 80800 4E75      		rts
 496               	
 497               	getAddr:
 498 80802 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 499 80806 1039 0000 		move.b	srecType, %d0
 499      0000 
 500 8080c 0C00 0032 		cmp.b	#'2', %d0
 501 80810 6600 003C 		bne		adrLen16
 502 80814 7400      		move.l	#0, %d2
 503 80816 4EBA FFB6 		jsr		getHexPair
 504 8081a D139 0000 		add.b 	%d0, srecCSum
 504      0000 
 505 80820 8480      		or.l	%d0, %d2
 506 80822 E182      		asl.l	#8, %d2
 507 80824 4EBA FFA8 		jsr		getHexPair
 508 80828 D139 0000 		add.b 	%d0, srecCSum
 508      0000 
 509 8082e 8480      		or.l	%d0, %d2
 510 80830 E182      		asl.l	#8, %d2
 511 80832 4EBA FF9A 		jsr		getHexPair
 512 80836 D139 0000 		add.b 	%d0, srecCSum
 512      0000 
 513 8083c 8480      		or.l	%d0, %d2
 514 8083e 23C2 0000 		move.l	%d2, srecAddr
68K GAS  S68K_002.s 			page 11


 514      0000 
 515 80844 5739 0000 		sub.b	#3, srecByCt
 515      0000 
 516 8084a 6000 0010 		bra		past16
 517               	adrLen16:
 518               	|	move.l	#0, %d2
 519 8084e 4EBA FF7E 		jsr		getHexPair
 520               	|	or.l	%d0, %d2
 521               	|	asl.l	#8, %d2
 522 80852 4EBA FF7A 		jsr		getHexPair
 523               	|	or.l	%d0, %d2
 524               	|	move.l	%d2, srecAddr
 525 80856 5539 0000 		sub.b	#2, srecByCt
 525      0000 
 526               	past16:
 527 8085c 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 528 80860 4E75      		rts
 529               			
 530               	|||||||||||||||||||||||||||||
 531               	| Find and parse a hex number
 532               	|  Starting address in A0
 533               	|  Number returned in D0
 534               	|  Status in D1   (0 success, 1 fail)
 535               	|  TODO: Try and merge first digit code with remaining digit code
 536               	parseNumber:
 537 80862 B180      	    eor.l   %d0, %d0		| Zero out d0
 538 80864 1018      	    move.b  (%a0)+, %d0
 539 80866 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 540 8086a 67F6      	    beq.s   parseNumber
 541 8086c 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 542 80870 6D14      	    blt.s	PNinvalid
 543 80872 0C00 0039 	    cmp.b   #'9', %d0
 544 80876 6F18      	    ble.s   PNfirstdigit1
 545               	
 546 80878 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 547 8087c 6D00 FDBE 	    blt   .invalid    
 548 80880 0C00 0046 	    cmp.b   #'F', %d0
 549 80884 6F04      	    ble.s   PNfirstdigit2
 550               	PNinvalid:
 551 80886 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 552 80888 4E75      	    rts
 553               	PNfirstdigit2:
 554 8088a 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 555 8088e 6004      	    bra.s   PNloop
 556               	PNfirstdigit1:
 557 80890 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 558               	 PNloop:
 559 80894 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 560 80896 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 561 8089a 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 562 8089c 0C01 0039 	    cmp.b   #'9', %d1
 563 808a0 6F18      	    ble.s   PNdigit1
 564 808a2 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 565 808a6 6D06      	    blt.s   PNend
 566 808a8 0C01 0046 	    cmp.b   #'F', %d1
 567 808ac 6F06      	    ble.s   PNdigit2
 568               	
68K GAS  S68K_002.s 			page 12


 569               	PNend:                       | We hit a non-hex digit character, we're done parsing
 570 808ae 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 571 808b0 7200      	    move.l  #0, %d1
 572 808b2 4E75      	    rts
 573               	PNdigit2:
 574 808b4 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 575 808b8 6004      	    bra.s   PNdigit3
 576               	PNdigit1:
 577 808ba 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 578               	PNdigit3:
 579 808be E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 580 808c0 D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 581 808c2 60D0      	    bra.s   PNloop
 582               	    
 583               	
 584               	|||||||||||||||||||||||||||||
 585               	| Dumps a section of RAM to the screen
 586               	| Displays both hex values and ASCII characters
 587               	| d0 - Number of bytes to dump
 588               	| a0 - Start Address
 589               	dumpRAM:
 590 808c4 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 591 808c8 2448      	    move.l  %a0, %a2           	| Save the start address
 592 808ca 2400      	    move.l  %d0, %d2           	| And the number of bytes
 593               	 .line:
 594 808cc 200A      	    move.l  %a2, %d0          
 595 808ce 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 596 808d2 41FA 0303 	    lea     msgColonSpace, %a0
 597 808d6 6100 FC40 	    bsr.w   printString
 598 808da 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 599 808dc 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 600               	 .hexbyte:
 601 808de 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 602 808e0 6718      	    beq.s   .endbytesShort
 603 808e2 4A03      	    tst.b   %d3               	| Check if we're done this line
 604 808e4 673A      	    beq.s   .endbytes    
 605 808e6 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 606 808e8 6100 011C 	    bsr.w   printHexByte     	| Display it
 607 808ec 103C 0020 	    move.b  #' ', %d0
 608 808f0 6100 FBFE 	    bsr.w   outChar          	| Space out bytes
 609 808f4 5383      	    subq.l  #1, %d3    
 610 808f6 5382      	    subq.l  #1, %d2        
 611 808f8 60E4      	    bra.s   .hexbyte
 612               	 .endbytesShort:
 613 808fa 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 614 808fc 103C 0020 	    move.b  #' ', %d0
 615               	 .endbytesShortLoop:
 616 80900 4A03      	    tst.b   %d3               	| Check if we ended the line
 617 80902 671C      	    beq.s   .endbytes
 618 80904 103C 0020 	    move.b  #' ', %d0
 619 80908 6100 FBE6 	    bsr.w   outChar          	| Three spaces to pad out
 620 8090c 103C 0020 	    move.b  #' ', %d0
 621 80910 6100 FBDE 	    bsr.w   outChar
 622 80914 103C 0020 	    move.b  #' ', %d0
 623 80918 6100 FBD6 	    bsr.w   outChar
 624               	    
 625 8091c 5303      	    subq.b  #1, %d3
68K GAS  S68K_002.s 			page 13


 626 8091e 60E0      	    bra.s   .endbytesShortLoop
 627               	 .endbytes:
 628 80920 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 629               	 .endbytesLoop:
 630 80922 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 631 80924 6700 0022 	    beq     .endline    
 632 80928 5304      	    subq.b  #1, %d4
 633 8092a 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 634 8092c 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 635 80930 6D0C      	    blt.s   .unprintable
 636 80932 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 637 80936 6E06      	    bgt.s   .unprintable
 638 80938 6100 FBB6 	    bsr.w   outChar
 639 8093c 60E4      	    bra.s   .endbytesLoop
 640               	 .unprintable:
 641 8093e 103C 002E 	    move.b  #'.', %d0
 642 80942 6100 FBAC 	    bsr.w   outChar
 643 80946 60DA      	    bra.s   .endbytesLoop
 644               	 .endline:
 645 80948 41FA 0290 	    lea     msgNewline, %a0
 646 8094c 6100 FBCA 	    bsr.w   printString
 647 80950 4A82      	    tst.l   %d2
 648 80952 6F04      	    ble.s   .end
 649 80954 6000 FF76 	    bra.w   .line
 650               	 .end:
 651 80958 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 652 8095c 4E75      	    rts
 653               	
 654               	|||||||||||||||||||||||
 655               	| Deposit values into RAM
 656               	| d ADDR VAL VAL            Deposit value(s) into RAM
 657               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 658               	|  VAL VAL VAL;              - Continuing with further continue
 659               	| d: VAL VAL                Continue depositing values after the last address written to
 660               	|||||||||||||||||||||||
 661               	.deposit:
 662 8095e 1010      	    move.b  (%a0), %d0
 663 80960 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 664 80964 6730      	    beq.s   DepCont
 665               	    
 666 80966 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 667 8096a 4A01      	    tst.b   %d1
 668 8096c 6600 FCE8 	    bne		.invalidAddr
 669 80970 2640      	    move.l  %d0, %a3           	| Save the start address
 670               	 DepLoop:
 671 80972 1010      	    move.b  (%a0), %d0            
 672 80974 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 673 80978 6726      	    beq.s   DepMLine
 674 8097a 4A40      	    tst     %d0              	| Check for the end of line
 675 8097c 6700 003A 	    beq     DepEnd
 676               	    
 677 80980 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 678 80984 4A01      	    tst.b   %d1
 679 80986 6600 FCDA 	    bne		.invalidVal
 680 8098a 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 681 8098e 6E00 FCD2 	    bgt		.invalidVal
 682               	    
68K GAS  S68K_002.s 			page 14


 683 80992 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 684 80994 60DC      	    bra.s   DepLoop
 685               	    
 686               	 DepCont:
 687 80996 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 687      FBAA 
 688 8099c 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 689 8099e 60D2      	    bra.s   DepLoop
 690               	    
 691               	 DepMLine:
 692 809a0 41FA 0186 	    lea     msgDepositPrompt, %a0
 693 809a4 6100 FB72 	    bsr.w   printString
 694 809a8 6100 FBA0 	    bsr.w   readLine          	| Read in the next line to be parsed
 695 809ac 6100 FC2E 	    bsr.w   lineToUpper         | Convert to uppercase
 696 809b0 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 696      FBAE 
 697 809b6 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 698               	 DepEnd:
 699 809b8 23CB 0007 	    move.l  %a3, varCurAddr
 699      FBAA 
 700 809be 6000 FC84 	    bra.w   .exit
 701               	
 702               	|||||||||||||||||||||||
 703               	| run code
 704               	 .run:
 705 809c2 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 706 809c6 4A01      	    tst.b   %d1
 707 809c8 6600 FC8C 	    bne		.invalidAddr
 708 809cc 2040      	    move.l  %d0, %a0
 709 809ce 4E90      	    jsr     (%a0)             	| Jump to the code! 
 710               	                                | Go as subroutine to allow code to return to us
 711 809d0 4EBA FAE2 	    jsr     monitorStart        | Warm start after returning so everything is in
 712               	                                | a known state.
 713               	
 714               	
 715               	|||||||||||||||||||||||
 716               	|| KEEP All printHex functions together ||
 717               	|||||||||||||||||||||||
 718               	| Print a hex word
 719               	printHexWord:
 720 809d4 2F02      	    move.l  %d2, -(%SP)		| Save D2
 721 809d6 2400      	    move.l  %d0, %d2		| Save the address in d2
 722               	    
 723 809d8 E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 724 809da E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 725 809dc 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 726               	|||||||||||||||||||||||
 727               	| Print a hex 24-bit address
 728               	printHexAddr:
 729 809de 2F02      	    move.l %d2, -(%SP)   	| Save D2
 730 809e0 2400      	    move.l %d0, %d2      	| Save the address in d2
 731               	    
 732 809e2 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 733 809e4 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 734               	|||||||||||||||||||||||
 735               	* Print a hex long
 736               	printHexLong:
68K GAS  S68K_002.s 			page 15


 737 809e6 2F02      	    move.l  %d2, -(%SP)     | Save D2
 738 809e8 2400      	    move.l  %d0, %d2        | Save the address in d2
 739               	    
 740 809ea E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 741 809ec 2002      	    move.l  %d2, %d0
 742 809ee 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 743               	printHex_addrentry:     
 744 809f0 E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 745 809f2 2002      	    move.l  %d2, %d0              
 746 809f4 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 747               	printHex_wordentry:    
 748 809f6 E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 749 809f8 2002      	    move.l  %d2, %d0
 750 809fa 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 751 809fc E19A      	    rol.l   #0x8, %d2
 752 809fe 2002      	    move.l  %d2, %d0
 753 80a00 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 754               	    
 755 80a02 241F      	    move.l (%SP)+, %d2      | Restore D2
 756 80a04 4E75      	    RTS
 757               	    
 758               	|||||||||||||||||||||||
 759               	| Print a hex byte
 760               	|  - Takes byte in D0
 761               	printHexByte:
 762 80a06 2F02      	    move.l  %D2, -(%SP)
 763 80a08 7400      		move.l	#0, %d2
 764 80a0a 1400      	    move.b  %d0, %d2
 765 80a0c E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 766 80a0e 0200 000F 		andi.b	#0xf, %d0
 767 80a12 0600 0030 	    add.b   #'0', %d0
 768 80a16 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 769 80a1a 6F02      	    ble.s   PHBsecond
 770 80a1c 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 771               	PHBsecond:
 772 80a1e 6100 FAD0 	    bsr   outChar			| Print the digit
 773 80a22 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 774 80a26 0602 0030 	    add.b   #'0', %d2
 775 80a2a 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 776 80a2e 6F02      	    ble.s   PHBend
 777 80a30 5E02      	    add.b   #0x7, %D2
 778               	PHBend:
 779 80a32 1002      	    move.b  %D2, %D0
 780 80a34 6100 FABA 	    bsr	   outChar      	| Print the lower digit
 781 80a38 241F      	    move.l  (%SP)+, %D2
 782 80a3a 4E75      	    rts
 783               		
 784               	
 785               	|||||
 786               	| Initializes the 68681 DUART port A as 9600 8N1 
 787               	initDuart:
 788 80a3c 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 788      000F 0004 
 789 80a44 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 789      000F 0004 
 790 80a4c 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 790      000F 0004 
68K GAS  S68K_002.s 			page 16


 791               	    
 792 80a54 13FC 0080 	    move.b  #0x80, ACR       | Baud Rate Set #2
 792      000F 0008 
 793 80a5c 13FC 00BB 	    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 793      000F 0002 
 794 80a64 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 794      000F 0000 
 795 80a6c 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 795      000F 0000 
 796               	    
 797 80a74 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 797      000F 0004 
 798               	
 799 80a7c 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 799      000F 0014 
 800 80a84 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 800      000F 0014 
 801 80a8c 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 801      000F 0014 
 802               	    
 803 80a94 13FC 00BB 	    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 803      000F 0012 
 804 80a9c 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 804      000F 0010 
 805 80aa4 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 805      000F 0010 
 806               	    
 807 80aac 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 807      000F 0014 
 808               		
 809 80ab4 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 809      000F 001A 
 810 80abc 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 810      000F 001E 
 811 80ac4 4E75      	    rts    
 812               	
 813               	delay1Sec:
 814 80ac6 203C 0003 		move.l	#200000, %d0	| rough count
 814      0D40 
 815               	delay1Loop:
 816 80acc 5380      		sub.l	#1, %d0			
 817 80ace 6600 FFFC 		bne		delay1Loop
 818 80ad2 4E75      		rts
 819               	
 820               	READINLINE:	  
 821 80ad4 5265 6164 		.ascii  "Reading in line"
 821      696E 6720 
 821      696E 206C 
 821      696E 65
 822 80ae3 0D0A 00   		dc.b CR,LF,EOT
 823               	L_TO_UPPER_MSG:  
 824 80ae6 436F 6E76 		.ascii  "Convert line to upper case"
 824      6572 7420 
 824      6C69 6E65 
 824      2074 6F20 
 824      7570 7065 
 825 80b00 0D0A 00   		dc.b CR,LF,EOT
68K GAS  S68K_002.s 			page 17


 826               	WRITEOUTLINE:	  
 827 80b03 5772 6974 		.ascii  "Writing out line"
 827      696E 6720 
 827      6F75 7420 
 827      6C69 6E65 
 828 80b13 0D0A 00   		dc.b CR,LF,EOT
 829               	RAM_PASS_MSG:  
 830 80b16 5241 4D20 		.ascii  "RAM Test Passed"
 830      5465 7374 
 830      2050 6173 
 830      7365 64
 831 80b25 0D0A 00   		dc.b CR,LF,EOT
 832               	msgDepositPrompt:
 833 80b28 3A20      	    .ascii	": "
 834 80b2a 00        		dc.b 	EOT
 835               	BANNER_MSG:	
 836 80b2b 5349 4D50 		.ascii  "SIMPLE-68008 CPU"
 836      4C45 2D36 
 836      3830 3038 
 836      2043 5055 
 837 80b3b 0D0A 00   		dc.b CR,LF,EOT
 838               	msgInvalidCommand:
 839 80b3e 496E 7661 	    .ascii "Invalid Command"
 839      6C69 6420 
 839      436F 6D6D 
 839      616E 64
 840 80b4d 0D0A 00   		dc.b CR,LF,EOT
 841               	CRLF_MSG:	
 842 80b50 0D0A 00   		dc.b CR,LF,EOT
 843               	msgHelp:
 844 80b53 4176 6169 	    .ascii	"Available Commands: "
 844      6C61 626C 
 844      6520 436F 
 844      6D6D 616E 
 844      6473 3A20 
 845 80b67 0D0A      		dc.b	CR,LF
 846 80b69 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 846      7861 6D69 
 846      6E65 2020 
 846      2020 2844 
 846      2965 706F 
 847 80b9f 0D0A 00   		dc.b	CR,LF,EOT
 848               	ldSRecMsg:
 849 80ba2 4C6F 6164 	    .ascii	"Load S-Record"
 849      2053 2D52 
 849      6563 6F72 
 849      64
 850 80baf 0D0A 00   		dc.b	CR,LF,EOT
 851               	msgInvalidAddress:
 852 80bb2 496E 7661 	    .ascii	"Invalid Address"
 852      6C69 6420 
 852      4164 6472 
 852      6573 73
 853 80bc1 0D0A 00   		dc.b 	CR,LF,EOT
 854               	msgInvalidValue:
 855 80bc4 496E 7661 	    .ascii	"Invalid Value"
 855      6C69 6420 
68K GAS  S68K_002.s 			page 18


 855      5661 6C75 
 855      65
 856 80bd1 0D0A 00   		dc.b	CR,LF,EOT
 857               	msgPrompt:
 858 80bd4 3E20      		.ascii "> "
 859 80bd6 00        	    dc.b EOT
 860               	msgColonSpace:
 861 80bd7 3A20      	    .ascii ": "
 862 80bd9 00        	    dc.b EOT
 863               	msgNewline:
 864 80bda 0D0A 00   	    dc.b CR,LF,EOT
 865               	debug_Srec_Typ_Msg:
 866 80bdd 5320 5265 		.ascii	"S Record Type="
 866      636F 7264 
 866      2054 7970 
 866      653D 
 867 80beb 00        	    dc.b EOT
 868               	debug_Srec_BytCt_Msg:
 869 80bec 5320 5265 		.ascii	"S Record Byte Count="
 869      636F 7264 
 869      2042 7974 
 869      6520 436F 
 869      756E 743D 
 870 80c00 00        	    dc.b EOT
 871               	
 872               	
 873               	MAX_LINE_LENGTH = 80
 874               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 875               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 19


DEFINED SYMBOLS
          S68K_002.s:6      *ABS*:0000000000000000 RAM_START
          S68K_002.s:7      *ABS*:000000000007fffc STACK_END
          S68K_002.s:8      *ABS*:000000000007ffff RAM_END
          S68K_002.s:9      *ABS*:0000000000080000 ROM_START
          S68K_002.s:10     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:12     *ABS*:000000000008ffff ROM_END
          S68K_002.s:17     *ABS*:00000000000f0000 DUART
          S68K_002.s:18     *ABS*:00000000000f0000 MRA
          S68K_002.s:19     *ABS*:00000000000f0002 SRA
          S68K_002.s:20     *ABS*:00000000000f0002 CSRA
          S68K_002.s:21     *ABS*:00000000000f0004 CRA
          S68K_002.s:22     *ABS*:00000000000f0006 RBA
          S68K_002.s:23     *ABS*:00000000000f0006 TBA
          S68K_002.s:24     *ABS*:00000000000f0008 ACR
          S68K_002.s:25     *ABS*:00000000000f000a ISR
          S68K_002.s:26     *ABS*:00000000000f000a IMR
          S68K_002.s:27     *ABS*:00000000000f0010 MRB
          S68K_002.s:28     *ABS*:00000000000f0012 SRB
          S68K_002.s:29     *ABS*:00000000000f0012 CSRB
          S68K_002.s:30     *ABS*:00000000000f0014 CRB
          S68K_002.s:31     *ABS*:00000000000f0016 RBB
          S68K_002.s:32     *ABS*:00000000000f0016 TBB
          S68K_002.s:33     *ABS*:00000000000f0018 IVR
          S68K_002.s:34     *ABS*:00000000000f001a OPC
          S68K_002.s:35     *ABS*:00000000000f001a INU
          S68K_002.s:36     *ABS*:00000000000f001c OPS
          S68K_002.s:37     *ABS*:00000000000f001e OPR
          S68K_002.s:42     *ABS*:0000000000000007 BEL
          S68K_002.s:43     *ABS*:0000000000000008 BKSP
          S68K_002.s:44     *ABS*:0000000000000009 TAB
          S68K_002.s:45     *ABS*:000000000000000a LF
          S68K_002.s:46     *ABS*:000000000000000d CR
          S68K_002.s:47     *ABS*:000000000000001b ESC
          S68K_002.s:48     *ABS*:0000000000000000 EOT
          S68K_002.s:50     *ABS*:0000000000000003 CTRLC
          S68K_002.s:51     *ABS*:0000000000000018 CTRLX
          S68K_002.s:54     .text:0000000000000400 srecType
          S68K_002.s:55     .text:0000000000000401 srecByCt
          S68K_002.s:56     .text:0000000000000402 srecData
          S68K_002.s:57     .text:0000000000000403 srecCSum
          S68K_002.s:58     .text:0000000000000404 srecAddr
          S68K_002.s:165    .text:00000000000804ea FERVR2
          S68K_002.s:90     .text:0000000000080444 loop1stLoc
          S68K_002.s:163    .text:00000000000804ea failBitTest
          S68K_002.s:105    .text:0000000000080464 loopAdrFill
          S68K_002.s:117    .text:0000000000080482 loopAdrCk
          S68K_002.s:164    .text:00000000000804ea failAdrTest
          S68K_002.s:132    .text:000000000008049c fillSRAM
          S68K_002.s:136    .text:00000000000804a8 fillSRAMLoop
          S68K_002.s:787    .text:0000000000080a3c initDuart
          S68K_002.s:145    .text:00000000000804b4 monitorStart
          S68K_002.s:835    .text:0000000000080b2b BANNER_MSG
          S68K_002.s:190    .text:0000000000080518 printString1
          S68K_002.s:829    .text:0000000000080b16 RAM_PASS_MSG
          S68K_002.s:153    .text:00000000000804c4 interpLoop
          S68K_002.s:857    .text:0000000000080bd4 msgPrompt
68K GAS  S68K_002.s 			page 20


          S68K_002.s:191    .text:0000000000080518 printString
          S68K_002.s:220    .text:000000000008054a readLine
          S68K_002.s:277    .text:00000000000805dc lineToUpper
          S68K_002.s:294    .text:00000000000805fa parseLine
          S68K_002.s:172    .text:00000000000804f0 outChar1
          S68K_002.s:173    .text:00000000000804f0 outChar
          S68K_002.s:181    .text:0000000000080504 outChar2
          S68K_002.s:192    .text:0000000000080518 PSloop
          S68K_002.s:198    .text:0000000000080520 PSend
          S68K_002.s:206    .text:0000000000080522 inChar1
          S68K_002.s:207    .text:0000000000080522 inChar
          S68K_002.s:213    .text:0000000000080536 inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:224    .text:0000000000080556 RLloop
          S68K_002.s:241    .text:0000000000080582 RLBS
          S68K_002.s:252    .text:00000000000805a0 RLlineClr
          S68K_002.s:266    .text:00000000000805c4 RLEndLn
          S68K_002.s:234    .text:0000000000080572 .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:256    .text:00000000000805a6 RLlineClrloop
          S68K_002.s:279    .text:00000000000805e2 LUloop
          S68K_002.s:286    .text:00000000000805f4 LUnext
          S68K_002.s:297    .text:0000000000080604 PLfindCommand
          S68K_002.s:343    .text:000000000008066e .examine
          S68K_002.s:661    .text:000000000008095e .deposit
          S68K_002.s:704    .text:00000000000809c2 .run
          S68K_002.s:322    .text:000000000008064a .help
          S68K_002.s:411    .text:00000000000806f8 loadSRec
          S68K_002.s:316    .text:0000000000080644 .exit
          S68K_002.s:313    .text:000000000008063c .invalid
          S68K_002.s:838    .text:0000000000080b3e msgInvalidCommand
          S68K_002.s:843    .text:0000000000080b53 msgHelp
          S68K_002.s:326    .text:0000000000080656 .invalidAddr
          S68K_002.s:851    .text:0000000000080bb2 msgInvalidAddress
          S68K_002.s:330    .text:0000000000080662 .invalidVal
          S68K_002.s:854    .text:0000000000080bc4 msgInvalidValue
          S68K_002.s:536    .text:0000000000080862 parseNumber
          S68K_002.s:348    .text:000000000008067a .exloop
          S68K_002.s:362    .text:000000000008069e .exrange
          S68K_002.s:371    .text:00000000000806b0 .exlength
          S68K_002.s:379    .text:00000000000806c2 .exinter
          S68K_002.s:368    .text:00000000000806ac .exquick
          S68K_002.s:375    .text:00000000000806ba .exend
          S68K_002.s:589    .text:00000000000808c4 dumpRAM
          S68K_002.s:384    .text:00000000000806d0 .exinterend
          S68K_002.s:391    .text:00000000000806e4 .exinterpage
          S68K_002.s:848    .text:0000000000080ba2 ldSRecMsg
          S68K_002.s:443    .text:0000000000080762 getRecType
          S68K_002.s:461    .text:000000000008079c getBytCt
          S68K_002.s:497    .text:0000000000080802 getAddr
          S68K_002.s:418    .text:0000000000080714 loopSData
          S68K_002.s:423    .text:0000000000080728 sRecDataDone
          S68K_002.s:427    .text:0000000000080730 getLdData
          S68K_002.s:439    .text:000000000008075c getChksum
          S68K_002.s:476    .text:00000000000807ce getHexPair
          S68K_002.s:433    .text:0000000000080748 skipLdData
          S68K_002.s:865    .text:0000000000080bdd debug_Srec_Typ_Msg
68K GAS  S68K_002.s 			page 21


          S68K_002.s:841    .text:0000000000080b50 CRLF_MSG
          S68K_002.s:868    .text:0000000000080bec debug_Srec_BytCt_Msg
          S68K_002.s:761    .text:0000000000080a06 printHexByte
          S68K_002.s:488    .text:00000000000807ee toNibble
          S68K_002.s:493    .text:00000000000807fc doHexLetter
          S68K_002.s:517    .text:000000000008084e adrLen16
          S68K_002.s:526    .text:000000000008085c past16
          S68K_002.s:550    .text:0000000000080886 PNinvalid
          S68K_002.s:556    .text:0000000000080890 PNfirstdigit1
          S68K_002.s:553    .text:000000000008088a PNfirstdigit2
          S68K_002.s:558    .text:0000000000080894 PNloop
          S68K_002.s:569    .text:00000000000808ae PNend
          S68K_002.s:576    .text:00000000000808ba PNdigit1
          S68K_002.s:573    .text:00000000000808b4 PNdigit2
          S68K_002.s:578    .text:00000000000808be PNdigit3
          S68K_002.s:593    .text:00000000000808cc .line
          S68K_002.s:728    .text:00000000000809de printHexAddr
          S68K_002.s:860    .text:0000000000080bd7 msgColonSpace
          S68K_002.s:600    .text:00000000000808de .hexbyte
          S68K_002.s:612    .text:00000000000808fa .endbytesShort
          S68K_002.s:627    .text:0000000000080920 .endbytes
          S68K_002.s:615    .text:0000000000080900 .endbytesShortLoop
          S68K_002.s:629    .text:0000000000080922 .endbytesLoop
          S68K_002.s:644    .text:0000000000080948 .endline
          S68K_002.s:640    .text:000000000008093e .unprintable
          S68K_002.s:863    .text:0000000000080bda msgNewline
          S68K_002.s:650    .text:0000000000080958 .end
          S68K_002.s:686    .text:0000000000080996 DepCont
          S68K_002.s:670    .text:0000000000080972 DepLoop
          S68K_002.s:691    .text:00000000000809a0 DepMLine
          S68K_002.s:698    .text:00000000000809b8 DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:832    .text:0000000000080b28 msgDepositPrompt
          S68K_002.s:719    .text:00000000000809d4 printHexWord
          S68K_002.s:747    .text:00000000000809f6 printHex_wordentry
          S68K_002.s:743    .text:00000000000809f0 printHex_addrentry
          S68K_002.s:736    .text:00000000000809e6 printHexLong
          S68K_002.s:771    .text:0000000000080a1e PHBsecond
          S68K_002.s:778    .text:0000000000080a32 PHBend
          S68K_002.s:813    .text:0000000000080ac6 delay1Sec
          S68K_002.s:815    .text:0000000000080acc delay1Loop
          S68K_002.s:820    .text:0000000000080ad4 READINLINE
          S68K_002.s:823    .text:0000000000080ae6 L_TO_UPPER_MSG
          S68K_002.s:826    .text:0000000000080b03 WRITEOUTLINE

NO UNDEFINED SYMBOLS
