68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Borrowed init code from 
   4               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   5               	
   6               	RAM_START	= 0x00000	| Beginning of the SRAM
   7               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
   8               	RAM_END		= 0x7FFFF	| 512KB SRAM
   9               	ROM_START	= 0x80000	| ROM start
  10               	ROM_CODE	= ROM_START+1024| Skip vector table
  11               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  12               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  13               	
  14               	|||||||||||||||||||||||||||||||||
  15               	| 68681 Duart Register Addresses
  16               	|
  17               	DUART = 0x0F0000	  | Base Addr of DUART
  18               	MRA   = DUART+0		  | Mode Register A           (R/W)
  19               	SRA   = DUART+2       | Status Register A         (r)
  20               	CSRA  = DUART+2       | Clock Select Register A   (w)
  21               	CRA   = DUART+4       | Commands Register A       (w)
  22               	RBA   = DUART+6       | Receiver Buffer A         (r)
  23               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  24               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  25               	ISR   = DUART+10      | Interrupt Status Register (R)
  26               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  27               	MRB   = DUART+16      | Mode Register B           (R/W)
  28               	SRB   = DUART+18      | Status Register B         (R)
  29               	CSRB  = DUART+18      | Clock Select Register B   (W)
  30               	CRB   = DUART+20      | Commands Register B       (W)
  31               	RBB   = DUART+22      | Reciever Buffer B         (R)
  32               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  33               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  34               	OPC   = DUART+26      | Output port config        (W)
  35               	INU   = DUART+26      | Input port (unlatched)    (R)
  36               	OPS   = DUART+28      | Output port Set           (W)
  37               	OPR   = DUART+30      | Output port Clear         (W)
  38               	
  39               	||||||||||||||||||||||||||||||||||
  40               	| ASCII Control Characters
  41               	|
  42               	BEL   = 0x07
  43               	BKSP  = 0x08       | CTRL-H
  44               	TAB   = 0x09
  45               	LF    = 0x0A
  46               	CR    = 0x0D
  47               	ESC   = 0x1B
  48               	EOT	  = 0x00
  49               	
  50               	CTRLC	=	0x03
  51               	CTRLX	=	0x18     | Line Clear
  52               	
  53 0000 0000 0000 		.ORG    0x000400
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
68K GAS  S68K_002.s 			page 2


  54 0400 00        	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  55 0401 00        	srecByCt:	ds.b	1		| Byte Count
  56 0402 00        	srecData:	ds.b	1 		| Data
  57 0403 00        	srecCSum:	ds.b	1 		| S-Record Checksum
  58 0404 0000 0000 	srecAddr:	ds.l	1		| S Record current byte address
  59               	
  60 0408 0000 0000 		.ORG	ROM_START
  60      0000 0000 
  60      0000 0000 
  60      0000 0000 
  60      0000 0000 
  61               	
  62               	| FIRST 8 bytes loaded after reset |
  63 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  64 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  65               	
  66 80008 0000 0000 	        .ORG ROM_CODE
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  67 80400 4E71      		nop
  68 80402 4FF9 0007 		lea			STACK_END,%sp
  68      FFFC 
  69 80408 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  69      0008 0000 
  70 80410 4E71      		nop
  71               	| LEDs
  72 80412 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  72      000F 001A 
  73 8041a 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  73      000F 001E 
  74 80422 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  74      000F 001C 
  75               	|
  76               	| Test the first two SRAM location
  77               	|
  78 8042a 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  78      BEEF 
  79 80430 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  80 80434 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  81 80436 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
  82 80438 B042      		cmp			%d2, %d0
  83 8043a 6600 00C6 		bne			FERVR2						
  84 8043e 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  84      AAAA 
  85 80444 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
  86 80448 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
  87 8044a 2611      		move.l	(%a1), %d3				| Read back
  88 8044c B243      		cmp			%d3, %d1
  89 8044e 6600 00B2 		bne			FERVR2
  90 80452 4E71      		nop
  91               	| Test bits of first location (as bytes)
  92 80454 7001      		move.l	#1, %d0
  93 80456 207C 0000 		move.l	#0, %a0
  93      0000 
  94               	loop1stLoc:
68K GAS  S68K_002.s 			page 3


  95 8045c 1080      		move.b	%d0, (%a0)
  96 8045e 1210      		move.b	(%a0), %d1
  97 80460 B200      		cmp.b		%d0, %d1
  98 80462 6600 009E 		bne			failBitTest
  99 80466 E348      		lsl			#1, %d0
 100 80468 0C80 0000 		cmp.l		#0x00000100, %d0
 100      0100 
 101 8046e 6600 FFEC 		bne			loop1stLoc
 102               	|
 103               	| Test all address lines, 512KB SRAM
 104               	| Write incrementing pattern to data bits
 105               	|
 106 80472 7001      		move.l	#1, %d0		| Fill pattern
 107 80474 7401      		move.l	#1, %d2
 108 80476 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 108      0001 
 109               	loopAdrFill:
 110 8047c 1080      		move.b	%d0,(%a0)	| Do the write
 111 8047e 5240      		addq		#1, %d0		| Increment the pattern
 112 80480 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 113 80482 E38A      		lsl.l		#1, %d2		| Shift temp addr
 114 80484 2042      		move.l	%d2, %a0	| Put back into addr reg
 115 80486 0C82 0008 		cmp.l		#0x00080000,%d2
 115      0000 
 116 8048c 6600 FFEE 		bne			loopAdrFill
 117               	| Check
 118 80490 7001      		move.l	#1, %d0
 119 80492 7401      		move.l	#1, %d2
 120 80494 207C 0000 		move.l	#1, %a0
 120      0001 
 121               	loopAdrCk:
 122 8049a 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 123 8049c B200      		cmp.b		%d0, %d1
 124 8049e 6600 0062 		bne			failAdrTest
 125 804a2 5240      		addq		#1, %d0
 126 804a4 2408      		move.l	%a0, %d2 
 127 804a6 E38A      		lsl.l		#1, %d2
 128 804a8 2042      		move.l	%d2, %a0
 129 804aa 0C82 0008 		cmp.l		#0x00080000,%d2
 129      0000 
 130 804b0 6600 FFE8 		bne			loopAdrCk
 131               		
 132               	|
 133               	| Fill SRAM with 0x00 values
 134               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 135               	|
 136               	fillSRAM:
 137 804b4 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 138 804b8 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 138      FFFF 
 139 804be 7000      		move.l	#0x00, %d0			| Fill with zeros
 140               	fillSRAMLoop:
 141 804c0 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 142 804c2 B3C8      		cmpa.l	%a0, %a1
 143 804c4 6E00 FFFA 		bgt		fillSRAMLoop
 144               	
 145               	|
68K GAS  S68K_002.s 			page 4


 146               	| Done with address test of SRAM
 147               	|
 148 804c8 4EBA 0608 		jsr     initDuart       	| Setup the serial port
 149               	monitorStart:					| Warm start
 150 804cc 41FA 06F3 		lea		BANNER_MSG, %a0
 151 804d0 4EBA 005E 		jsr		printString1
 152 804d4 41FA 06D6 		lea		RAM_PASS_MSG, %a0
 153 804d8 4EBA 0056 		jsr		printString1
 154               	|
 155               	| Interpreter Loop
 156               	|
 157               	interpLoop:
 158 804dc 41FA 078C 	    lea     msgPrompt, %a0	| Prompt
 159 804e0 6100 004E 	    bsr.w   printString
 160 804e4 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 160      000F 001E 
 161 804ec 4EBA 0074 		jsr		readLine		| Blocking read of line
 162 804f0 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 162      000F 001C 
 163 804f8 4EBA 00FA 		jsr		lineToUpper
 164 804fc 4EBA 0114 		jsr		parseLine
 165 80500 60DA      		bra.s	interpLoop
 166               		
 167               	failBitTest:
 168               	failAdrTest:
 169               	FERVR2:
 170 80502 4E71      		nop
 171 80504 4EFA FFFC 		jmp	FERVR2
 172               	
 173               	|||||
 174               	| Writes a character to Port A, blocking if not ready (Full buffer)
 175               	|  - Takes a character in D0
 176               	outChar1:
 177               	outChar:
 178 80508 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 178      000F 0002 
 179 80510 6700 FFF6 	    beq     outChar1     
 180 80514 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 180      0006 
 181 8051a 4E75      	    rts
 182               	
 183               	| Writes a character to Port A, blocking if not ready (Full buffer)
 184               	|  - Takes a character in D0
 185               	outChar2:
 186 8051c 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 186      000F 0012 
 187 80524 6700 FFF6 	    beq     outChar2     
 188 80528 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 188      0016 
 189 8052e 4E75      	    rts
 190               	
 191               	******
 192               	* Print a null terminated string
 193               	*
 194               	printString1:
 195               	printString:
 196               	PSloop:
68K GAS  S68K_002.s 			page 5


 197 80530 1018      	    move.b  (%a0)+, %d0  | Read in character
 198 80532 6704      	    beq.s   PSend         | Check for the null
 199               	    
 200 80534 61D2      	    bsr.s   outChar      | Otherwise write the character
 201 80536 60F8      	    bra.s   PSloop        | And continue
 202               	PSend:
 203 80538 4E75      	    rts
 204               	
 205               	
 206               	|||||
 207               	| Reads in a character from Port A, blocking if none available
 208               	|  - Returns character in D0
 209               	|    
 210               	inChar1:
 211               	inChar:
 212 8053a 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 212      000F 0002 
 213 80542 6700 FFF6 	    beq     inChar1
 214 80546 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 214      0006 
 215 8054c 4E75      	    rts
 216               	
 217               	inChar2:
 218 8054e 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 218      000F 0012 
 219 80556 6700 FFF6 	    beq     inChar2
 220 8055a 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 220      0016 
 221 80560 4E75      	    rts
 222               	
 223               	| Read in a line into the line buffer
 224               	readLine:
 225 80562 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 226 80566 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 226      FBAE 
 227 8056c B542      	    eor.w   %d2, %d2           	| Clear the character counter
 228               	 RLloop:
 229 8056e 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 230 80572 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 231 80576 6722      	    beq.s   RLBS
 232 80578 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 233 8057c 673A      	    beq.s   RLlineClr
 234 8057e 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 235 80582 6758      	    beq.s   RLEndLn
 236 80584 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 237 80588 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 238               	 .char:                      	| Normal character to be inserted into the buffer
 239 8058a 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 240 8058e 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 241 80590 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 242 80592 5242      	    addq.w  #1, %d2           	| Increment character count
 243 80594 6100 FF72 	    bsr.w   outChar          	| Echo the character
 244 80598 60D4      	    bra.s   RLloop            	| And get the next one
 245               	 RLBS:
 246 8059a 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 247 8059c 67D0      	    beq.s   RLloop            	| Then ignore it
 248 8059e 6100 FF68 	    bsr.w   outChar          	| Backspace
68K GAS  S68K_002.s 			page 6


 249 805a2 103C 0020 	    move.b  #' ', %d0
 250 805a6 6100 FF60 	    bsr.w   outChar          	| Space
 251 805aa 103C 0008 	    move.b  #BKSP, %d0
 252 805ae 6100 FF58 	    bsr.w   outChar          	| Backspace
 253 805b2 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 254 805b4 5382      	    subq.l  #1, %d2           	| And current character count
 255 805b6 60B6      	    bra.s   RLloop            	| And goto the next character
 256               	 RLlineClr:
 257 805b8 4A42      	    tst     %d2               	| Anything to clear?
 258 805ba 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 259 805bc 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 260               	 RLlineClrloop:
 261 805be 103C 0008 	    move.b  #BKSP, %d0
 262 805c2 6100 FF44 	    bsr.w   outChar          	| Backspace
 263 805c6 103C 0020 	    move.b  #' ', %d0
 264 805ca 6100 FF3C 	    bsr.w   outChar          	| Space
 265 805ce 103C 0008 	    move.b  #BKSP, %d0
 266 805d2 6100 FF34 	    bsr.w   outChar          	| Backspace
 267 805d6 5342      	    subq.w  #1, %d2          
 268 805d8 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 269 805da 6092      	    bra.s   RLloop   
 270               	 RLEndLn:
 271 805dc 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 272 805e0 103C 000A 	    move.b  #LF, %d0
 273 805e4 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 274 805e8 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 275 805ec 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 276 805ee 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 277 805f2 4E75      	    rts                      	| And return
 278               	
 279               	
 280               	| Convert line buffer to upper case
 281               	lineToUpper:
 282 805f4 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 282      FBAE 
 283               	 LUloop:
 284 805fa 1010      	    move.b  (%a0), %d0        | Read in a character
 285 805fc 0C00 0061 	    cmp.b   #'a', %d0         
 286 80600 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 287 80602 0C00 007A 	    cmp.b   #'z', %d0
 288 80606 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 289 80608 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
 290               	 LUnext:
 291 8060c 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 292 8060e 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 293 80610 4E75      	    rts
 294               	
 295               	|
 296               	| Parse Line
 297               	|
 298               	parseLine:
 299 80612 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 300 80616 41F9 0007 	    lea     varLineBuf, %a0
 300      FBAE 
 301               	 PLfindCommand:
 302 8061c 1018      	    move.b  (%a0)+, %d0
 303 8061e 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
68K GAS  S68K_002.s 			page 7


 304 80622 6700 FFF8 	    beq.w   PLfindCommand    
 305 80626 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 306 8062a 6700 005A 	    beq.w   .examine
 307 8062e 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 308 80632 6700 03C0 	    beq.w   .deposit
 309 80636 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 310 8063a 6700 041C 	    beq.w   .run
 311 8063e 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 312 80642 6700 001E 	    beq.w   .help
 313 80646 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 314 8064a 6700 00C4 	    beq.w   loadSRec
 315 8064e 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 316 80652 6708      	    beq.s   .exit               
 317               	 .invalid:   
 318 80654 41FA 057E 	    lea     msgInvalidCommand, %a0
 319 80658 6100 FED6 	    bsr.w   printString
 320               	 .exit:
 321 8065c 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 322 80660 4E75      	    rts
 323               	
 324               	|||||||||||||||||||||||||||||||
 325               	|| HELP command
 326               	 .help:
 327 80662 41FA 0585 	    lea     msgHelp, %a0
 328 80666 6100 FEC8 	    bsr.w   printString
 329 8066a 6000 FFF0 	    bra.w   .exit
 330               	 .invalidAddr:
 331 8066e 41FA 05D8 	    lea     msgInvalidAddress, %a0
 332 80672 6100 FEBC 	    bsr.w   printString
 333 80676 6000 FFE4 	    bra.w   .exit
 334               	 .invalidVal:
 335 8067a 41FA 05DE 	    lea     msgInvalidValue, %a0
 336 8067e 6100 FEB0 	    bsr.w   printString
 337 80682 6000 FFD8 	    bra.w   .exit
 338               		
 339               	|||||||||||||||||||||||||||||||
 340               	| Examines memory addresses
 341               	| Valid modes:
 342               	|   e ADDR                  Displays a single byte
 343               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 344               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 345               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 346               	|   e ADDR.                 Quick line, displays one line 
 347               	.examine:
 348 80686 6100 0270 	    bsr.w   parseNumber         | Read in the start address
 349 8068a 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 350 8068c 6600 FFE0 	    bne.w   .invalidAddr        
 351 80690 2640      	    move.l  %d0, %a3            | Save the start address
 352               	 .exloop:
 353 80692 1018      	    move.b  (%a0)+, %d0
 354 80694 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 355 80698 67F8      	    beq.s   .exloop
 356 8069a 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 357 8069e 6716      	    beq.s   .exrange
 358 806a0 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 359 806a4 6722      	    beq.s   .exlength
 360 806a6 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
68K GAS  S68K_002.s 			page 8


 361 806aa 672E      	    beq.s   .exinter
 362 806ac 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 363 806b0 6712      	    beq.s   .exquick
 364 806b2 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 365 806b4 601C      	    bra.s   .exend              
 366               	 .exrange:
 367 806b6 6100 0240 	    bsr.w   parseNumber         | Find the end address
 368 806ba 4A01      	    tst.b   %d1                 | Check if we found a valid address
 369 806bc 6600 FFB0 	    bne.w   .invalidAddr
 370 806c0 908B      	    sub.l   %a3, %d0            | Get the length
 371 806c2 600E      	    bra.s   .exend
 372               	 .exquick:                      | Quick mode means show one line of 16 bytes
 373 806c4 7010      	    move.l  #0x10, %d0
 374 806c6 600A      	    bra.s   .exend
 375               	 .exlength:                     | Length mode means a length is specified
 376 806c8 6100 022E 	    bsr.w   parseNumber         | Find the length
 377 806cc 4A01      	    tst.b   %d1
 378 806ce 6600 FF9E 	    bne.w   .invalidAddr
 379               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 380 806d2 204B      	    move.l  %a3, %a0
 381 806d4 6100 0284 	    bsr.w   dumpRAM
 382 806d8 6082      	    bra.s   .exit
 383               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 384 806da 204B      	    move.l  %a3, %a0            | Current Address
 385 806dc 7010      	    move.l  #0x10, %d0          | 16 bytes
 386 806de 6100 027A 	    bsr.w   dumpRAM             | Dump this line
 387 806e2 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 387      0010 
 388               	 .exinterend:
 389 806e8 6100 FE50 	    bsr.w   inChar
 390 806ec 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 391 806f0 67E8      	    beq.s   .exinter
 392 806f2 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 393 806f6 6704      	    beq.s   .exinterpage
 394 806f8 6000 FF62 	    bra	   .exit               | Otherwise exit
 395               	 .exinterpage:
 396 806fc 204B      	    move.l  %a3, %a0
 397 806fe 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 397      0100 
 398 80704 6100 0254 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 399 80708 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 399      0100 
 400 8070e 60D8      	    bra.s   .exinterend
 401               	
 402               	|||||||||||||||||||||||||||||
 403               	|| Load S Record
 404               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 405               	|	srecByCt:	ds.b	1		| Byte Count
 406               	|	srecData:	ds.b	1 		| Data
 407               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 408               	|	srecAddr:	ds.l	1		| S Record current byte address
 409               	|
 410               	| Supports 3 S record types (matches gcc m68k output)
 411               	|	S00F00005336384B5F3030322E746D7074
 412               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 413               	|	S503005BA1
 414               	
68K GAS  S68K_002.s 			page 9


 415               	loadSRec:
 416 80710 41FA 0526 	    lea     ldSRecMsg, %a0
 417 80714 6100 FE1A 	    bsr.w   printString
 418 80718 6100 0080 		bsr		getRecType
 419 8071c 6100 00B6 		bsr		getBytCt
 420 80720 13FC 0000 		move.b 	#0, srecCSum
 420      0000 0000 
 421 80728 6100 0110 		bsr		getAddr
 422               	loopSData:
 423 8072c 0C39 0001 		cmp.b 	#1, srecByCt
 423      0000 0000 
 424 80734 6700 000A 		beq		sRecDataDone
 425 80738 4EBA 000E 		jsr		getLdData
 426 8073c 6000 FFEE 		bra		loopSData
 427               	sRecDataDone:
 428 80740 4EBA 0032 		jsr		getChksum
 429 80744 6000 FF16 		bra.w   .exit
 430               	
 431               	getLdData:
 432 80748 4EBA 00BC 		jsr		getHexPair
 433 8074c 0C39 0002 		cmp.b	#2, srecType
 433      0000 0000 
 434 80754 6600 0010 		bne		skipLdData
 435 80758 41F9 0000 		lea 	srecAddr, %a0
 435      0000 
 436 8075e 1080      		move.b	%d0, (%a0)
 437 80760 52B9 0000 		add.l	#1, srecAddr
 437      0000 
 438               	skipLdData:
 439 80766 D139 0000 		add.b	%d0, srecCSum
 439      0000 
 440 8076c 5339 0000 		sub.b	#1, srecByCt
 440      0000 
 441 80772 4E75      		rts
 442               	
 443               	getChksum:
 444 80774 41FA 0521 		lea		debug_Srec_CSum_Msg, %a0
 445 80778 6100 FDB6 	    bsr.w   printString
 446 8077c 4EBA 0088 		jsr		getHexPair
 447 80780 D139 0000 		add.b	%d0, srecCSum
 447      0000 
 448 80786 1039 0000 		move.b	srecCSum, %d0
 448      0000 
 449 8078c 4EBA 030E 		jsr		printHexByte
 450 80790 41FA 0454 		lea		CRLF_MSG, %a0
 451 80794 6100 FD9A 	    bsr.w   printString
 452               	failCSUM:
 453 80798 4E75      		rts
 454               	
 455               	getRecType:
 456 8079a 4EBA FD9E 		jsr		inChar
 457 8079e 0C00 0053 		cmp.b	#'S', %d0
 458 807a2 6600 FFF6 		bne		getRecType
 459 807a6 4EBA FD92 		jsr		inChar
 460 807aa 0200 000F 		andi.b	#0x0f, %d0
 461 807ae 13C0 0000 		move.b	%d0, srecType
 461      0000 
68K GAS  S68K_002.s 			page 10


 462               	| Debug messages follow
 463 807b4 41FA 04BD 		lea		debug_Srec_Typ_Msg, %a0		| Debug message
 464 807b8 6100 FD76 	    bsr.w   printString
 465 807bc 1039 0000 		move.b	srecType, %d0
 465      0000 
 466 807c2 0600 0030 		add.b	#'0', %d0
 467 807c6 4EBA FD40 		jsr		outChar
 468 807ca 41FA 041A 		lea		CRLF_MSG, %a0
 469 807ce 6100 FD60 	    bsr.w   printString
 470               	| Debug messages end
 471 807d2 4E75      		rts
 472               		
 473               	getBytCt:
 474 807d4 4EBA 0030 		jsr		getHexPair
 475 807d8 13C0 0000 		move.b 	%d0, srecCSum
 475      0000 
 476 807de 13C0 0000 		move.b	%d0, srecByCt
 476      0000 
 477               	| Debug messages follow
 478 807e4 41FA 049C 		lea		debug_Srec_BytCt_Msg, %a0
 479 807e8 6100 FD46 	    bsr.w   printString
 480 807ec 1039 0000 		move.b	srecByCt, %d0
 480      0000 
 481 807f2 4EBA 02A8 		jsr		printHexByte
 482 807f6 41FA 03EE 		lea		CRLF_MSG, %a0
 483 807fa 6100 FD34 	    bsr.w   printString
 484               	| Debug messages end
 485 807fe 5339 0000 		sub.b	#1, srecByCt
 485      0000 
 486 80804 4E75      		rts
 487               	
 488               	getHexPair:
 489 80806 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 490 8080a 4EBA FD2E 		jsr		inChar
 491 8080e 4EBA 0016 		jsr		toNibble
 492 80812 E900      		asl.b	#4, %d0
 493 80814 1400      		move.b	%d0, %d2
 494 80816 4EBA FD22 		jsr		inChar
 495 8081a 4EBA 000A 		jsr		toNibble
 496 8081e 8002      		or.b	%d2, %d0
 497 80820 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 498 80824 4E75      		rts
 499               	
 500               	toNibble:
 501 80826 0C00 0041 		cmp.b	#'A', %d0
 502 8082a 6C00 0008 		bge		doHexLetter
 503 8082e 0400 0030 		sub.b	#'0', %d0
 504 80832 4E75      		rts
 505               	doHexLetter:
 506 80834 0400 004B 		sub.b	#'A'+10, %d0
 507 80838 4E75      		rts
 508               	
 509               	getAddr:
 510 8083a 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 511 8083e 1039 0000 		move.b	srecType, %d0
 511      0000 
 512 80844 0C00 0032 		cmp.b	#'2', %d0
68K GAS  S68K_002.s 			page 11


 513 80848 6600 006E 		bne		adrLen16
 514 8084c 41FA 045C 		lea		debug_S2rec_Addr_Msg, %a0
 515 80850 6100 FCDE 		bsr		printString
 516 80854 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 517               		| Get the upper 8-bits of 24-bits
 518 80856 4EBA FFAE 		jsr		getHexPair
 519 8085a D139 0000 		add.b 	%d0, srecCSum
 519      0000 
 520 80860 8480      		or.l	%d0, %d2
 521 80862 E182      		asl.l	#8, %d2
 522 80864 2002      		move.l	%d2, %d0
 523 80866 6100 0214 		bsr		printHexLong
 524 8086a 41FA 037A 		lea		CRLF_MSG, %a0
 525 8086e 6100 FCC0 	    bsr.w   printString
 526               		| Get the middle 8-bits of 24-bits
 527 80872 4EBA FF92 		jsr		getHexPair
 528 80876 D139 0000 		add.b 	%d0, srecCSum
 528      0000 
 529 8087c 8480      		or.l	%d0, %d2
 530 8087e E182      		asl.l	#8, %d2
 531 80880 2002      		move.l	%d2, %d0
 532 80882 6100 01F8 		bsr		printHexLong
 533 80886 41FA 035E 		lea		CRLF_MSG, %a0
 534 8088a 6100 FCA4 	    bsr.w   printString
 535               		| Get the lower 8-bits of 24-bits
 536 8088e 4EBA FF76 		jsr		getHexPair
 537 80892 D139 0000 		add.b 	%d0, srecCSum
 537      0000 
 538 80898 8480      		or.l	%d0, %d2
 539 8089a 23C2 0000 		move.l	%d2, srecAddr		| Save the S record address
 539      0000 
 540 808a0 5739 0000 		sub.b	#3, srecByCt
 540      0000 
 541 808a6 2002      		move.l	%d2, %d0
 542 808a8 6100 01D2 		bsr		printHexLong
 543 808ac 41FA 0338 		lea		CRLF_MSG, %a0
 544 808b0 6100 FC7E 	    bsr.w   printString
 545 808b4 6000 003C 		bra		past16
 546               	adrLen16:
 547 808b8 41FA 0403 		lea		debug_SXrec_Addr_Msg, %a0
 548 808bc 6100 FC72 		bsr		printString
 549               	|	move.l	#0, %d2
 550 808c0 4EBA FF44 		jsr		getHexPair
 551 808c4 5739 0000 		sub.b	#3, srecByCt
 551      0000 
 552 808ca 6100 01B0 		bsr		printHexLong
 553 808ce 41FA 0316 		lea		CRLF_MSG, %a0
 554 808d2 6100 FC5C 	    bsr.w   printString
 555               	|	or.l	%d0, %d2
 556               	|	asl.l	#8, %d2
 557 808d6 4EBA FF2E 		jsr		getHexPair
 558 808da 5739 0000 		sub.b	#3, srecByCt
 558      0000 
 559 808e0 6100 019A 		bsr		printHexLong
 560 808e4 41FA 0300 		lea		CRLF_MSG, %a0
 561 808e8 6100 FC46 	    bsr.w   printString
 562               	|	or.l	%d0, %d2
68K GAS  S68K_002.s 			page 12


 563               	|	move.l	%d2, srecAddr
 564 808ec 5539 0000 		sub.b	#2, srecByCt
 564      0000 
 565               	past16:
 566 808f2 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 567 808f6 4E75      		rts
 568               			
 569               	|||||||||||||||||||||||||||||
 570               	| Find and parse a hex number
 571               	|  Starting address in A0
 572               	|  Number returned in D0
 573               	|  Status in D1   (0 success, 1 fail)
 574               	|  TODO: Try and merge first digit code with remaining digit code
 575               	parseNumber:
 576 808f8 B180      	    eor.l   %d0, %d0		| Zero out d0
 577 808fa 1018      	    move.b  (%a0)+, %d0
 578 808fc 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 579 80900 67F6      	    beq.s   parseNumber
 580 80902 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 581 80906 6D14      	    blt.s	PNinvalid
 582 80908 0C00 0039 	    cmp.b   #'9', %d0
 583 8090c 6F18      	    ble.s   PNfirstdigit1
 584               	
 585 8090e 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 586 80912 6D00 FD40 	    blt   .invalid    
 587 80916 0C00 0046 	    cmp.b   #'F', %d0
 588 8091a 6F04      	    ble.s   PNfirstdigit2
 589               	PNinvalid:
 590 8091c 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 591 8091e 4E75      	    rts
 592               	PNfirstdigit2:
 593 80920 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 594 80924 6004      	    bra.s   PNloop
 595               	PNfirstdigit1:
 596 80926 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 597               	 PNloop:
 598 8092a 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 599 8092c 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 600 80930 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 601 80932 0C01 0039 	    cmp.b   #'9', %d1
 602 80936 6F18      	    ble.s   PNdigit1
 603 80938 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 604 8093c 6D06      	    blt.s   PNend
 605 8093e 0C01 0046 	    cmp.b   #'F', %d1
 606 80942 6F06      	    ble.s   PNdigit2
 607               	
 608               	PNend:                       | We hit a non-hex digit character, we're done parsing
 609 80944 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 610 80946 7200      	    move.l  #0, %d1
 611 80948 4E75      	    rts
 612               	PNdigit2:
 613 8094a 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 614 8094e 6004      	    bra.s   PNdigit3
 615               	PNdigit1:
 616 80950 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 617               	PNdigit3:
 618 80954 E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
68K GAS  S68K_002.s 			page 13


 619 80956 D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 620 80958 60D0      	    bra.s   PNloop
 621               	    
 622               	
 623               	|||||||||||||||||||||||||||||
 624               	| Dumps a section of RAM to the screen
 625               	| Displays both hex values and ASCII characters
 626               	| d0 - Number of bytes to dump
 627               	| a0 - Start Address
 628               	dumpRAM:
 629 8095a 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 630 8095e 2448      	    move.l  %a0, %a2           	| Save the start address
 631 80960 2400      	    move.l  %d0, %d2           	| And the number of bytes
 632               	 .line:
 633 80962 200A      	    move.l  %a2, %d0          
 634 80964 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 635 80968 41FA 0303 	    lea     msgColonSpace, %a0
 636 8096c 6100 FBC2 	    bsr.w   printString
 637 80970 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 638 80972 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 639               	 .hexbyte:
 640 80974 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 641 80976 6718      	    beq.s   .endbytesShort
 642 80978 4A03      	    tst.b   %d3               	| Check if we're done this line
 643 8097a 673A      	    beq.s   .endbytes    
 644 8097c 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 645 8097e 6100 011C 	    bsr.w   printHexByte     	| Display it
 646 80982 103C 0020 	    move.b  #' ', %d0
 647 80986 6100 FB80 	    bsr.w   outChar          	| Space out bytes
 648 8098a 5383      	    subq.l  #1, %d3    
 649 8098c 5382      	    subq.l  #1, %d2        
 650 8098e 60E4      	    bra.s   .hexbyte
 651               	 .endbytesShort:
 652 80990 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 653 80992 103C 0020 	    move.b  #' ', %d0
 654               	 .endbytesShortLoop:
 655 80996 4A03      	    tst.b   %d3               	| Check if we ended the line
 656 80998 671C      	    beq.s   .endbytes
 657 8099a 103C 0020 	    move.b  #' ', %d0
 658 8099e 6100 FB68 	    bsr.w   outChar          	| Three spaces to pad out
 659 809a2 103C 0020 	    move.b  #' ', %d0
 660 809a6 6100 FB60 	    bsr.w   outChar
 661 809aa 103C 0020 	    move.b  #' ', %d0
 662 809ae 6100 FB58 	    bsr.w   outChar
 663               	    
 664 809b2 5303      	    subq.b  #1, %d3
 665 809b4 60E0      	    bra.s   .endbytesShortLoop
 666               	 .endbytes:
 667 809b6 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 668               	 .endbytesLoop:
 669 809b8 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 670 809ba 6700 0022 	    beq     .endline    
 671 809be 5304      	    subq.b  #1, %d4
 672 809c0 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 673 809c2 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 674 809c6 6D0C      	    blt.s   .unprintable
 675 809c8 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
68K GAS  S68K_002.s 			page 14


 676 809cc 6E06      	    bgt.s   .unprintable
 677 809ce 6100 FB38 	    bsr.w   outChar
 678 809d2 60E4      	    bra.s   .endbytesLoop
 679               	 .unprintable:
 680 809d4 103C 002E 	    move.b  #'.', %d0
 681 809d8 6100 FB2E 	    bsr.w   outChar
 682 809dc 60DA      	    bra.s   .endbytesLoop
 683               	 .endline:
 684 809de 41FA 0290 	    lea     msgNewline, %a0
 685 809e2 6100 FB4C 	    bsr.w   printString
 686 809e6 4A82      	    tst.l   %d2
 687 809e8 6F04      	    ble.s   .end
 688 809ea 6000 FF76 	    bra.w   .line
 689               	 .end:
 690 809ee 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 691 809f2 4E75      	    rts
 692               	
 693               	|||||||||||||||||||||||
 694               	| Deposit values into RAM
 695               	| d ADDR VAL VAL            Deposit value(s) into RAM
 696               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 697               	|  VAL VAL VAL;              - Continuing with further continue
 698               	| d: VAL VAL                Continue depositing values after the last address written to
 699               	|||||||||||||||||||||||
 700               	.deposit:
 701 809f4 1010      	    move.b  (%a0), %d0
 702 809f6 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 703 809fa 6730      	    beq.s   DepCont
 704               	    
 705 809fc 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 706 80a00 4A01      	    tst.b   %d1
 707 80a02 6600 FC6A 	    bne		.invalidAddr
 708 80a06 2640      	    move.l  %d0, %a3           	| Save the start address
 709               	 DepLoop:
 710 80a08 1010      	    move.b  (%a0), %d0            
 711 80a0a 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 712 80a0e 6726      	    beq.s   DepMLine
 713 80a10 4A40      	    tst     %d0              	| Check for the end of line
 714 80a12 6700 003A 	    beq     DepEnd
 715               	    
 716 80a16 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 717 80a1a 4A01      	    tst.b   %d1
 718 80a1c 6600 FC5C 	    bne		.invalidVal
 719 80a20 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 720 80a24 6E00 FC54 	    bgt		.invalidVal
 721               	    
 722 80a28 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 723 80a2a 60DC      	    bra.s   DepLoop
 724               	    
 725               	 DepCont:
 726 80a2c 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 726      FBAA 
 727 80a32 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 728 80a34 60D2      	    bra.s   DepLoop
 729               	    
 730               	 DepMLine:
 731 80a36 41FA 0186 	    lea     msgDepositPrompt, %a0
68K GAS  S68K_002.s 			page 15


 732 80a3a 6100 FAF4 	    bsr.w   printString
 733 80a3e 6100 FB22 	    bsr.w   readLine          	| Read in the next line to be parsed
 734 80a42 6100 FBB0 	    bsr.w   lineToUpper         | Convert to uppercase
 735 80a46 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 735      FBAE 
 736 80a4c 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 737               	 DepEnd:
 738 80a4e 23CB 0007 	    move.l  %a3, varCurAddr
 738      FBAA 
 739 80a54 6000 FC06 	    bra.w   .exit
 740               	
 741               	|||||||||||||||||||||||
 742               	| run code
 743               	 .run:
 744 80a58 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 745 80a5c 4A01      	    tst.b   %d1
 746 80a5e 6600 FC0E 	    bne		.invalidAddr
 747 80a62 2040      	    move.l  %d0, %a0
 748 80a64 4E90      	    jsr     (%a0)             	| Jump to the code! 
 749               	                                | Go as subroutine to allow code to return to us
 750 80a66 4EBA FA64 	    jsr     monitorStart        | Warm start after returning so everything is in
 751               	                                | a known state.
 752               	
 753               	
 754               	|||||||||||||||||||||||
 755               	|| KEEP All printHex functions together ||
 756               	|||||||||||||||||||||||
 757               	| Print a hex word
 758               	printHexWord:
 759 80a6a 2F02      	    move.l  %d2, -(%SP)		| Save D2
 760 80a6c 2400      	    move.l  %d0, %d2		| Save the address in d2
 761               	    
 762 80a6e E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 763 80a70 E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 764 80a72 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 765               	|||||||||||||||||||||||
 766               	| Print a hex 24-bit address
 767               	printHexAddr:
 768 80a74 2F02      	    move.l %d2, -(%SP)   	| Save D2
 769 80a76 2400      	    move.l %d0, %d2      	| Save the address in d2
 770               	    
 771 80a78 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 772 80a7a 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 773               	|||||||||||||||||||||||
 774               	* Print a hex long
 775               	printHexLong:
 776 80a7c 2F02      	    move.l  %d2, -(%SP)     | Save D2
 777 80a7e 2400      	    move.l  %d0, %d2        | Save the address in d2
 778               	    
 779 80a80 E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 780 80a82 2002      	    move.l  %d2, %d0
 781 80a84 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 782               	printHex_addrentry:     
 783 80a86 E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 784 80a88 2002      	    move.l  %d2, %d0              
 785 80a8a 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 786               	printHex_wordentry:    
68K GAS  S68K_002.s 			page 16


 787 80a8c E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 788 80a8e 2002      	    move.l  %d2, %d0
 789 80a90 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 790 80a92 E19A      	    rol.l   #0x8, %d2
 791 80a94 2002      	    move.l  %d2, %d0
 792 80a96 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 793               	    
 794 80a98 241F      	    move.l (%SP)+, %d2      | Restore D2
 795 80a9a 4E75      	    RTS
 796               	    
 797               	|||||||||||||||||||||||
 798               	| Print a hex byte
 799               	|  - Takes byte in D0
 800               	printHexByte:
 801 80a9c 2F02      	    move.l  %D2, -(%SP)
 802 80a9e 7400      		move.l	#0, %d2
 803 80aa0 1400      	    move.b  %d0, %d2
 804 80aa2 E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 805 80aa4 0200 000F 		andi.b	#0xf, %d0
 806 80aa8 0600 0030 	    add.b   #'0', %d0
 807 80aac 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 808 80ab0 6F02      	    ble.s   PHBsecond
 809 80ab2 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 810               	PHBsecond:
 811 80ab4 6100 FA52 	    bsr   outChar			| Print the digit
 812 80ab8 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 813 80abc 0602 0030 	    add.b   #'0', %d2
 814 80ac0 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 815 80ac4 6F02      	    ble.s   PHBend
 816 80ac6 5E02      	    add.b   #0x7, %D2
 817               	PHBend:
 818 80ac8 1002      	    move.b  %D2, %D0
 819 80aca 6100 FA3C 	    bsr	   outChar      	| Print the lower digit
 820 80ace 241F      	    move.l  (%SP)+, %D2
 821 80ad0 4E75      	    rts
 822               		
 823               	
 824               	|||||
 825               	| Initializes the 68681 DUART port A as 9600 8N1 
 826               	initDuart:
 827 80ad2 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 827      000F 0004 
 828 80ada 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 828      000F 0004 
 829 80ae2 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 829      000F 0004 
 830               	    
 831 80aea 13FC 0080 	    move.b  #0x80, ACR       | Baud Rate Set #2
 831      000F 0008 
 832 80af2 13FC 00BB 	    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 832      000F 0002 
 833 80afa 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 833      000F 0000 
 834 80b02 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 834      000F 0000 
 835               	    
 836 80b0a 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
68K GAS  S68K_002.s 			page 17


 836      000F 0004 
 837               	
 838 80b12 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 838      000F 0014 
 839 80b1a 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 839      000F 0014 
 840 80b22 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 840      000F 0014 
 841               	    
 842 80b2a 13FC 00BB 	    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 842      000F 0012 
 843 80b32 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 843      000F 0010 
 844 80b3a 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 844      000F 0010 
 845               	    
 846 80b42 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 846      000F 0014 
 847               		
 848 80b4a 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 848      000F 001A 
 849 80b52 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 849      000F 001E 
 850 80b5a 4E75      	    rts    
 851               	
 852               	delay1Sec:
 853 80b5c 203C 0003 		move.l	#200000, %d0	| rough count
 853      0D40 
 854               	delay1Loop:
 855 80b62 5380      		sub.l	#1, %d0			
 856 80b64 6600 FFFC 		bne		delay1Loop
 857 80b68 4E75      		rts
 858               	
 859               	READINLINE:	  
 860 80b6a 5265 6164 		.ascii  "Reading in line"
 860      696E 6720 
 860      696E 206C 
 860      696E 65
 861 80b79 0D0A 00   		dc.b CR,LF,EOT
 862               	L_TO_UPPER_MSG:  
 863 80b7c 436F 6E76 		.ascii  "Convert line to upper case"
 863      6572 7420 
 863      6C69 6E65 
 863      2074 6F20 
 863      7570 7065 
 864 80b96 0D0A 00   		dc.b CR,LF,EOT
 865               	WRITEOUTLINE:	  
 866 80b99 5772 6974 		.ascii  "Writing out line"
 866      696E 6720 
 866      6F75 7420 
 866      6C69 6E65 
 867 80ba9 0D0A 00   		dc.b CR,LF,EOT
 868               	RAM_PASS_MSG:  
 869 80bac 5241 4D20 		.ascii  "RAM Test Passed"
 869      5465 7374 
 869      2050 6173 
 869      7365 64
68K GAS  S68K_002.s 			page 18


 870 80bbb 0D0A 00   		dc.b CR,LF,EOT
 871               	msgDepositPrompt:
 872 80bbe 3A20      	    .ascii	": "
 873 80bc0 00        		dc.b 	EOT
 874               	BANNER_MSG:	
 875 80bc1 5349 4D50 		.ascii  "SIMPLE-68008 CPU"
 875      4C45 2D36 
 875      3830 3038 
 875      2043 5055 
 876 80bd1 0D0A 00   		dc.b CR,LF,EOT
 877               	msgInvalidCommand:
 878 80bd4 496E 7661 	    .ascii "Invalid Command"
 878      6C69 6420 
 878      436F 6D6D 
 878      616E 64
 879 80be3 0D0A 00   		dc.b CR,LF,EOT
 880               	CRLF_MSG:	
 881 80be6 0D0A 00   		dc.b CR,LF,EOT
 882               	msgHelp:
 883 80be9 4176 6169 	    .ascii	"Available Commands: "
 883      6C61 626C 
 883      6520 436F 
 883      6D6D 616E 
 883      6473 3A20 
 884 80bfd 0D0A      		dc.b	CR,LF
 885 80bff 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 885      7861 6D69 
 885      6E65 2020 
 885      2020 2844 
 885      2965 706F 
 886 80c35 0D0A 00   		dc.b	CR,LF,EOT
 887               	ldSRecMsg:
 888 80c38 4C6F 6164 	    .ascii	"Load S-Record"
 888      2053 2D52 
 888      6563 6F72 
 888      64
 889 80c45 0D0A 00   		dc.b	CR,LF,EOT
 890               	msgInvalidAddress:
 891 80c48 496E 7661 	    .ascii	"Invalid Address"
 891      6C69 6420 
 891      4164 6472 
 891      6573 73
 892 80c57 0D0A 00   		dc.b 	CR,LF,EOT
 893               	msgInvalidValue:
 894 80c5a 496E 7661 	    .ascii	"Invalid Value"
 894      6C69 6420 
 894      5661 6C75 
 894      65
 895 80c67 0D0A 00   		dc.b	CR,LF,EOT
 896               	msgPrompt:
 897 80c6a 3E20      		.ascii "> "
 898 80c6c 00        	    dc.b EOT
 899               	msgColonSpace:
 900 80c6d 3A20      	    .ascii ": "
 901 80c6f 00        	    dc.b EOT
 902               	msgNewline:
 903 80c70 0D0A 00   	    dc.b CR,LF,EOT
68K GAS  S68K_002.s 			page 19


 904               	debug_Srec_Typ_Msg:
 905 80c73 5320 5265 		.ascii	"S Record Type="
 905      636F 7264 
 905      2054 7970 
 905      653D 
 906 80c81 00        	    dc.b EOT
 907               	debug_Srec_BytCt_Msg:
 908 80c82 5320 5265 		.ascii	"S Record Byte Count="
 908      636F 7264 
 908      2042 7974 
 908      6520 436F 
 908      756E 743D 
 909 80c96 00        	    dc.b EOT
 910               	debug_Srec_CSum_Msg:
 911 80c97 5320 5265 		.ascii	"S Record Checksum="
 911      636F 7264 
 911      2043 6865 
 911      636B 7375 
 911      6D3D 
 912 80ca9 00        	    dc.b EOT
 913               	debug_S2rec_Addr_Msg:
 914 80caa 5332 2052 		.ascii	"S2 Record Address="
 914      6563 6F72 
 914      6420 4164 
 914      6472 6573 
 914      733D 
 915 80cbc 00        	    dc.b EOT
 916               	debug_SXrec_Addr_Msg:
 917 80cbd 5332 2052 		.ascii	"S2 Record Address="
 917      6563 6F72 
 917      6420 4164 
 917      6472 6573 
 917      733D 
 918 80ccf 00        	    dc.b EOT
 919               	
 920               	MAX_LINE_LENGTH = 80
 921               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 922               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 20


DEFINED SYMBOLS
          S68K_002.s:6      *ABS*:0000000000000000 RAM_START
          S68K_002.s:7      *ABS*:000000000007fffc STACK_END
          S68K_002.s:8      *ABS*:000000000007ffff RAM_END
          S68K_002.s:9      *ABS*:0000000000080000 ROM_START
          S68K_002.s:10     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:12     *ABS*:000000000008ffff ROM_END
          S68K_002.s:17     *ABS*:00000000000f0000 DUART
          S68K_002.s:18     *ABS*:00000000000f0000 MRA
          S68K_002.s:19     *ABS*:00000000000f0002 SRA
          S68K_002.s:20     *ABS*:00000000000f0002 CSRA
          S68K_002.s:21     *ABS*:00000000000f0004 CRA
          S68K_002.s:22     *ABS*:00000000000f0006 RBA
          S68K_002.s:23     *ABS*:00000000000f0006 TBA
          S68K_002.s:24     *ABS*:00000000000f0008 ACR
          S68K_002.s:25     *ABS*:00000000000f000a ISR
          S68K_002.s:26     *ABS*:00000000000f000a IMR
          S68K_002.s:27     *ABS*:00000000000f0010 MRB
          S68K_002.s:28     *ABS*:00000000000f0012 SRB
          S68K_002.s:29     *ABS*:00000000000f0012 CSRB
          S68K_002.s:30     *ABS*:00000000000f0014 CRB
          S68K_002.s:31     *ABS*:00000000000f0016 RBB
          S68K_002.s:32     *ABS*:00000000000f0016 TBB
          S68K_002.s:33     *ABS*:00000000000f0018 IVR
          S68K_002.s:34     *ABS*:00000000000f001a OPC
          S68K_002.s:35     *ABS*:00000000000f001a INU
          S68K_002.s:36     *ABS*:00000000000f001c OPS
          S68K_002.s:37     *ABS*:00000000000f001e OPR
          S68K_002.s:42     *ABS*:0000000000000007 BEL
          S68K_002.s:43     *ABS*:0000000000000008 BKSP
          S68K_002.s:44     *ABS*:0000000000000009 TAB
          S68K_002.s:45     *ABS*:000000000000000a LF
          S68K_002.s:46     *ABS*:000000000000000d CR
          S68K_002.s:47     *ABS*:000000000000001b ESC
          S68K_002.s:48     *ABS*:0000000000000000 EOT
          S68K_002.s:50     *ABS*:0000000000000003 CTRLC
          S68K_002.s:51     *ABS*:0000000000000018 CTRLX
          S68K_002.s:54     .text:0000000000000400 srecType
          S68K_002.s:55     .text:0000000000000401 srecByCt
          S68K_002.s:56     .text:0000000000000402 srecData
          S68K_002.s:57     .text:0000000000000403 srecCSum
          S68K_002.s:58     .text:0000000000000404 srecAddr
          S68K_002.s:169    .text:0000000000080502 FERVR2
          S68K_002.s:94     .text:000000000008045c loop1stLoc
          S68K_002.s:167    .text:0000000000080502 failBitTest
          S68K_002.s:109    .text:000000000008047c loopAdrFill
          S68K_002.s:121    .text:000000000008049a loopAdrCk
          S68K_002.s:168    .text:0000000000080502 failAdrTest
          S68K_002.s:136    .text:00000000000804b4 fillSRAM
          S68K_002.s:140    .text:00000000000804c0 fillSRAMLoop
          S68K_002.s:826    .text:0000000000080ad2 initDuart
          S68K_002.s:149    .text:00000000000804cc monitorStart
          S68K_002.s:874    .text:0000000000080bc1 BANNER_MSG
          S68K_002.s:194    .text:0000000000080530 printString1
          S68K_002.s:868    .text:0000000000080bac RAM_PASS_MSG
          S68K_002.s:157    .text:00000000000804dc interpLoop
          S68K_002.s:896    .text:0000000000080c6a msgPrompt
68K GAS  S68K_002.s 			page 21


          S68K_002.s:195    .text:0000000000080530 printString
          S68K_002.s:224    .text:0000000000080562 readLine
          S68K_002.s:281    .text:00000000000805f4 lineToUpper
          S68K_002.s:298    .text:0000000000080612 parseLine
          S68K_002.s:176    .text:0000000000080508 outChar1
          S68K_002.s:177    .text:0000000000080508 outChar
          S68K_002.s:185    .text:000000000008051c outChar2
          S68K_002.s:196    .text:0000000000080530 PSloop
          S68K_002.s:202    .text:0000000000080538 PSend
          S68K_002.s:210    .text:000000000008053a inChar1
          S68K_002.s:211    .text:000000000008053a inChar
          S68K_002.s:217    .text:000000000008054e inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:228    .text:000000000008056e RLloop
          S68K_002.s:245    .text:000000000008059a RLBS
          S68K_002.s:256    .text:00000000000805b8 RLlineClr
          S68K_002.s:270    .text:00000000000805dc RLEndLn
          S68K_002.s:238    .text:000000000008058a .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:260    .text:00000000000805be RLlineClrloop
          S68K_002.s:283    .text:00000000000805fa LUloop
          S68K_002.s:290    .text:000000000008060c LUnext
          S68K_002.s:301    .text:000000000008061c PLfindCommand
          S68K_002.s:347    .text:0000000000080686 .examine
          S68K_002.s:700    .text:00000000000809f4 .deposit
          S68K_002.s:743    .text:0000000000080a58 .run
          S68K_002.s:326    .text:0000000000080662 .help
          S68K_002.s:415    .text:0000000000080710 loadSRec
          S68K_002.s:320    .text:000000000008065c .exit
          S68K_002.s:317    .text:0000000000080654 .invalid
          S68K_002.s:877    .text:0000000000080bd4 msgInvalidCommand
          S68K_002.s:882    .text:0000000000080be9 msgHelp
          S68K_002.s:330    .text:000000000008066e .invalidAddr
          S68K_002.s:890    .text:0000000000080c48 msgInvalidAddress
          S68K_002.s:334    .text:000000000008067a .invalidVal
          S68K_002.s:893    .text:0000000000080c5a msgInvalidValue
          S68K_002.s:575    .text:00000000000808f8 parseNumber
          S68K_002.s:352    .text:0000000000080692 .exloop
          S68K_002.s:366    .text:00000000000806b6 .exrange
          S68K_002.s:375    .text:00000000000806c8 .exlength
          S68K_002.s:383    .text:00000000000806da .exinter
          S68K_002.s:372    .text:00000000000806c4 .exquick
          S68K_002.s:379    .text:00000000000806d2 .exend
          S68K_002.s:628    .text:000000000008095a dumpRAM
          S68K_002.s:388    .text:00000000000806e8 .exinterend
          S68K_002.s:395    .text:00000000000806fc .exinterpage
          S68K_002.s:887    .text:0000000000080c38 ldSRecMsg
          S68K_002.s:455    .text:000000000008079a getRecType
          S68K_002.s:473    .text:00000000000807d4 getBytCt
          S68K_002.s:509    .text:000000000008083a getAddr
          S68K_002.s:422    .text:000000000008072c loopSData
          S68K_002.s:427    .text:0000000000080740 sRecDataDone
          S68K_002.s:431    .text:0000000000080748 getLdData
          S68K_002.s:443    .text:0000000000080774 getChksum
          S68K_002.s:488    .text:0000000000080806 getHexPair
          S68K_002.s:438    .text:0000000000080766 skipLdData
          S68K_002.s:910    .text:0000000000080c97 debug_Srec_CSum_Msg
68K GAS  S68K_002.s 			page 22


          S68K_002.s:800    .text:0000000000080a9c printHexByte
          S68K_002.s:880    .text:0000000000080be6 CRLF_MSG
          S68K_002.s:452    .text:0000000000080798 failCSUM
          S68K_002.s:904    .text:0000000000080c73 debug_Srec_Typ_Msg
          S68K_002.s:907    .text:0000000000080c82 debug_Srec_BytCt_Msg
          S68K_002.s:500    .text:0000000000080826 toNibble
          S68K_002.s:505    .text:0000000000080834 doHexLetter
          S68K_002.s:546    .text:00000000000808b8 adrLen16
          S68K_002.s:913    .text:0000000000080caa debug_S2rec_Addr_Msg
          S68K_002.s:775    .text:0000000000080a7c printHexLong
          S68K_002.s:565    .text:00000000000808f2 past16
          S68K_002.s:916    .text:0000000000080cbd debug_SXrec_Addr_Msg
          S68K_002.s:589    .text:000000000008091c PNinvalid
          S68K_002.s:595    .text:0000000000080926 PNfirstdigit1
          S68K_002.s:592    .text:0000000000080920 PNfirstdigit2
          S68K_002.s:597    .text:000000000008092a PNloop
          S68K_002.s:608    .text:0000000000080944 PNend
          S68K_002.s:615    .text:0000000000080950 PNdigit1
          S68K_002.s:612    .text:000000000008094a PNdigit2
          S68K_002.s:617    .text:0000000000080954 PNdigit3
          S68K_002.s:632    .text:0000000000080962 .line
          S68K_002.s:767    .text:0000000000080a74 printHexAddr
          S68K_002.s:899    .text:0000000000080c6d msgColonSpace
          S68K_002.s:639    .text:0000000000080974 .hexbyte
          S68K_002.s:651    .text:0000000000080990 .endbytesShort
          S68K_002.s:666    .text:00000000000809b6 .endbytes
          S68K_002.s:654    .text:0000000000080996 .endbytesShortLoop
          S68K_002.s:668    .text:00000000000809b8 .endbytesLoop
          S68K_002.s:683    .text:00000000000809de .endline
          S68K_002.s:679    .text:00000000000809d4 .unprintable
          S68K_002.s:902    .text:0000000000080c70 msgNewline
          S68K_002.s:689    .text:00000000000809ee .end
          S68K_002.s:725    .text:0000000000080a2c DepCont
          S68K_002.s:709    .text:0000000000080a08 DepLoop
          S68K_002.s:730    .text:0000000000080a36 DepMLine
          S68K_002.s:737    .text:0000000000080a4e DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:871    .text:0000000000080bbe msgDepositPrompt
          S68K_002.s:758    .text:0000000000080a6a printHexWord
          S68K_002.s:786    .text:0000000000080a8c printHex_wordentry
          S68K_002.s:782    .text:0000000000080a86 printHex_addrentry
          S68K_002.s:810    .text:0000000000080ab4 PHBsecond
          S68K_002.s:817    .text:0000000000080ac8 PHBend
          S68K_002.s:852    .text:0000000000080b5c delay1Sec
          S68K_002.s:854    .text:0000000000080b62 delay1Loop
          S68K_002.s:859    .text:0000000000080b6a READINLINE
          S68K_002.s:862    .text:0000000000080b7c L_TO_UPPER_MSG
          S68K_002.s:865    .text:0000000000080b99 WRITEOUTLINE

NO UNDEFINED SYMBOLS
