68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Borrowed init code from 
   4               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   5               	
   6               	RAM_START	= 0x00000	| Beginning of the SRAM
   7               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
   8               	RAM_END		= 0x7FFFF	| 512KB SRAM
   9               	ROM_START	= 0x80000	| ROM start
  10               	ROM_CODE	= ROM_START+1024| Skip vector table
  11               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  12               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  13               	
  14               	|||||||||||||||||||||||||||||||||
  15               	| 68681 Duart Register Addresses
  16               	|
  17               	DUART = 0x0F0000	  | Base Addr of DUART
  18               	MRA   = DUART+0		  | Mode Register A           (R/W)
  19               	SRA   = DUART+2       | Status Register A         (r)
  20               	CSRA  = DUART+2       | Clock Select Register A   (w)
  21               	CRA   = DUART+4       | Commands Register A       (w)
  22               	RBA   = DUART+6       | Receiver Buffer A         (r)
  23               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  24               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  25               	ISR   = DUART+10      | Interrupt Status Register (R)
  26               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  27               	MRB   = DUART+16      | Mode Register B           (R/W)
  28               	SRB   = DUART+18      | Status Register B         (R)
  29               	CSRB  = DUART+18      | Clock Select Register B   (W)
  30               	CRB   = DUART+20      | Commands Register B       (W)
  31               	RBB   = DUART+22      | Reciever Buffer B         (R)
  32               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  33               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  34               	OPC   = DUART+26      | Output port config        (W)
  35               	INU   = DUART+26      | Input port (unlatched)    (R)
  36               	OPS   = DUART+28      | Output port Set           (W)
  37               	OPR   = DUART+30      | Output port Clear         (W)
  38               	
  39               	||||||||||||||||||||||||||||||||||
  40               	| ASCII Control Characters
  41               	|
  42               	BEL   = 0x07
  43               	BKSP  = 0x08       | CTRL-H
  44               	TAB   = 0x09
  45               	LF    = 0x0A
  46               	CR    = 0x0D
  47               	ESC   = 0x1B
  48               	EOT	  = 0x00
  49               	
  50               	CTRLC	=	0x03
  51               	CTRLX	=	0x18     | Line Clear
  52               	
  53 0000 0000 0000 		.ORG    0x000400
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
  53      0000 0000 
68K GAS  S68K_002.s 			page 2


  54 0400 00        	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  55 0401 00        	srecByCt:	ds.b	1		| Byte Count
  56 0402 00        	srecData:	ds.b	1 		| Data
  57 0403 00        	srecCSum:	ds.b	1 		| S-Record Checksum
  58 0404 0000 0000 	srecAddr:	ds.l	1		| S Record current byte address
  59               	
  60 0408 0000 0000 		.ORG	ROM_START
  60      0000 0000 
  60      0000 0000 
  60      0000 0000 
  60      0000 0000 
  61               	
  62               	| FIRST 8 bytes loaded after reset |
  63 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  64 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  65               	
  66 80008 0000 0000 	        .ORG ROM_CODE
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  66      0000 0000 
  67 80400 4E71      		nop
  68 80402 4FF9 0007 		lea			STACK_END,%sp
  68      FFFC 
  69 80408 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  69      0008 0000 
  70 80410 4E71      		nop
  71               	| LEDs
  72 80412 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  72      000F 001A 
  73 8041a 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  73      000F 001E 
  74 80422 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  74      000F 001C 
  75               	|
  76               	| Test the first two SRAM location
  77               	|
  78 8042a 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  78      BEEF 
  79 80430 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  80 80434 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  81 80436 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
  82 80438 B042      		cmp			%d2, %d0
  83 8043a 6600 00C6 		bne			FERVR2						
  84 8043e 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
  84      AAAA 
  85 80444 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
  86 80448 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
  87 8044a 2611      		move.l	(%a1), %d3				| Read back
  88 8044c B243      		cmp			%d3, %d1
  89 8044e 6600 00B2 		bne			FERVR2
  90 80452 4E71      		nop
  91               	| Test bits of first location (as bytes)
  92 80454 7001      		move.l	#1, %d0
  93 80456 207C 0000 		move.l	#0, %a0
  93      0000 
  94               	loop1stLoc:
68K GAS  S68K_002.s 			page 3


  95 8045c 1080      		move.b	%d0, (%a0)
  96 8045e 1210      		move.b	(%a0), %d1
  97 80460 B200      		cmp.b		%d0, %d1
  98 80462 6600 009E 		bne			failBitTest
  99 80466 E348      		lsl			#1, %d0
 100 80468 0C80 0000 		cmp.l		#0x00000100, %d0
 100      0100 
 101 8046e 6600 FFEC 		bne			loop1stLoc
 102               	|
 103               	| Test all address lines, 512KB SRAM
 104               	| Write incrementing pattern to data bits
 105               	|
 106 80472 7001      		move.l	#1, %d0		| Fill pattern
 107 80474 7401      		move.l	#1, %d2
 108 80476 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 108      0001 
 109               	loopAdrFill:
 110 8047c 1080      		move.b	%d0,(%a0)	| Do the write
 111 8047e 5240      		addq		#1, %d0		| Increment the pattern
 112 80480 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 113 80482 E38A      		lsl.l		#1, %d2		| Shift temp addr
 114 80484 2042      		move.l	%d2, %a0	| Put back into addr reg
 115 80486 0C82 0008 		cmp.l		#0x00080000,%d2
 115      0000 
 116 8048c 6600 FFEE 		bne			loopAdrFill
 117               	| Check
 118 80490 7001      		move.l	#1, %d0
 119 80492 7401      		move.l	#1, %d2
 120 80494 207C 0000 		move.l	#1, %a0
 120      0001 
 121               	loopAdrCk:
 122 8049a 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 123 8049c B200      		cmp.b		%d0, %d1
 124 8049e 6600 0062 		bne			failAdrTest
 125 804a2 5240      		addq		#1, %d0
 126 804a4 2408      		move.l	%a0, %d2 
 127 804a6 E38A      		lsl.l		#1, %d2
 128 804a8 2042      		move.l	%d2, %a0
 129 804aa 0C82 0008 		cmp.l		#0x00080000,%d2
 129      0000 
 130 804b0 6600 FFE8 		bne			loopAdrCk
 131               		
 132               	|
 133               	| Fill SRAM with 0x00 values
 134               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
 135               	|
 136               	fillSRAM:
 137 804b4 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 138 804b8 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 138      FFFF 
 139 804be 7000      		move.l	#0x00, %d0			| Fill with zeros
 140               	fillSRAMLoop:
 141 804c0 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 142 804c2 B3C8      		cmpa.l	%a0, %a1
 143 804c4 6E00 FFFA 		bgt		fillSRAMLoop
 144               	
 145               	|
68K GAS  S68K_002.s 			page 4


 146               	| Done with address test of SRAM
 147               	|
 148 804c8 4EBA 0610 		jsr     initDuart       	| Setup the serial port
 149               	monitorStart:					| Warm start
 150 804cc 41FA 06FB 		lea		BANNER_MSG, %a0
 151 804d0 4EBA 005E 		jsr		printString1
 152 804d4 41FA 06DE 		lea		RAM_PASS_MSG, %a0
 153 804d8 4EBA 0056 		jsr		printString1
 154               	|
 155               	| Interpreter Loop
 156               	|
 157               	interpLoop:
 158 804dc 41FA 0794 	    lea     msgPrompt, %a0	| Prompt
 159 804e0 6100 004E 	    bsr.w   printString
 160 804e4 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 160      000F 001E 
 161 804ec 4EBA 0074 		jsr		readLine		| Blocking read of line
 162 804f0 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 162      000F 001C 
 163 804f8 4EBA 00FA 		jsr		lineToUpper
 164 804fc 4EBA 0114 		jsr		parseLine
 165 80500 60DA      		bra.s	interpLoop
 166               		
 167               	failBitTest:
 168               	failAdrTest:
 169               	FERVR2:
 170 80502 4E71      		nop
 171 80504 4EFA FFFC 		jmp	FERVR2
 172               	
 173               	|||||
 174               	| Writes a character to Port A, blocking if not ready (Full buffer)
 175               	|  - Takes a character in D0
 176               	outChar1:
 177               	outChar:
 178 80508 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 178      000F 0002 
 179 80510 6700 FFF6 	    beq     outChar1     
 180 80514 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 180      0006 
 181 8051a 4E75      	    rts
 182               	
 183               	| Writes a character to Port A, blocking if not ready (Full buffer)
 184               	|  - Takes a character in D0
 185               	outChar2:
 186 8051c 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
 186      000F 0012 
 187 80524 6700 FFF6 	    beq     outChar2     
 188 80528 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 188      0016 
 189 8052e 4E75      	    rts
 190               	
 191               	******
 192               	* Print a null terminated string
 193               	*
 194               	printString1:
 195               	printString:
 196               	PSloop:
68K GAS  S68K_002.s 			page 5


 197 80530 1018      	    move.b  (%a0)+, %d0  | Read in character
 198 80532 6704      	    beq.s   PSend         | Check for the null
 199               	    
 200 80534 61D2      	    bsr.s   outChar      | Otherwise write the character
 201 80536 60F8      	    bra.s   PSloop        | And continue
 202               	PSend:
 203 80538 4E75      	    rts
 204               	
 205               	
 206               	|||||
 207               	| Reads in a character from Port A, blocking if none available
 208               	|  - Returns character in D0
 209               	|    
 210               	inChar1:
 211               	inChar:
 212 8053a 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 212      000F 0002 
 213 80542 6700 FFF6 	    beq     inChar1
 214 80546 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 214      0006 
 215 8054c 4E75      	    rts
 216               	
 217               	inChar2:
 218 8054e 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 218      000F 0012 
 219 80556 6700 FFF6 	    beq     inChar2
 220 8055a 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 220      0016 
 221 80560 4E75      	    rts
 222               	
 223               	| Read in a line into the line buffer
 224               	readLine:
 225 80562 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 226 80566 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 226      FBAE 
 227 8056c B542      	    eor.w   %d2, %d2           	| Clear the character counter
 228               	 RLloop:
 229 8056e 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 230 80572 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 231 80576 6722      	    beq.s   RLBS
 232 80578 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 233 8057c 673A      	    beq.s   RLlineClr
 234 8057e 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 235 80582 6758      	    beq.s   RLEndLn
 236 80584 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
 237 80588 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 238               	 .char:                      	| Normal character to be inserted into the buffer
 239 8058a 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 240 8058e 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 241 80590 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 242 80592 5242      	    addq.w  #1, %d2           	| Increment character count
 243 80594 6100 FF72 	    bsr.w   outChar          	| Echo the character
 244 80598 60D4      	    bra.s   RLloop            	| And get the next one
 245               	 RLBS:
 246 8059a 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 247 8059c 67D0      	    beq.s   RLloop            	| Then ignore it
 248 8059e 6100 FF68 	    bsr.w   outChar          	| Backspace
68K GAS  S68K_002.s 			page 6


 249 805a2 103C 0020 	    move.b  #' ', %d0
 250 805a6 6100 FF60 	    bsr.w   outChar          	| Space
 251 805aa 103C 0008 	    move.b  #BKSP, %d0
 252 805ae 6100 FF58 	    bsr.w   outChar          	| Backspace
 253 805b2 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 254 805b4 5382      	    subq.l  #1, %d2           	| And current character count
 255 805b6 60B6      	    bra.s   RLloop            	| And goto the next character
 256               	 RLlineClr:
 257 805b8 4A42      	    tst     %d2               	| Anything to clear?
 258 805ba 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 259 805bc 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 260               	 RLlineClrloop:
 261 805be 103C 0008 	    move.b  #BKSP, %d0
 262 805c2 6100 FF44 	    bsr.w   outChar          	| Backspace
 263 805c6 103C 0020 	    move.b  #' ', %d0
 264 805ca 6100 FF3C 	    bsr.w   outChar          	| Space
 265 805ce 103C 0008 	    move.b  #BKSP, %d0
 266 805d2 6100 FF34 	    bsr.w   outChar          	| Backspace
 267 805d6 5342      	    subq.w  #1, %d2          
 268 805d8 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 269 805da 6092      	    bra.s   RLloop   
 270               	 RLEndLn:
 271 805dc 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 272 805e0 103C 000A 	    move.b  #LF, %d0
 273 805e4 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 274 805e8 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 275 805ec 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 276 805ee 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 277 805f2 4E75      	    rts                      	| And return
 278               	
 279               	
 280               	| Convert line buffer to upper case
 281               	lineToUpper:
 282 805f4 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 282      FBAE 
 283               	 LUloop:
 284 805fa 1010      	    move.b  (%a0), %d0        | Read in a character
 285 805fc 0C00 0061 	    cmp.b   #'a', %d0         
 286 80600 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 287 80602 0C00 007A 	    cmp.b   #'z', %d0
 288 80606 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 289 80608 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
 290               	 LUnext:
 291 8060c 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 292 8060e 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
 293 80610 4E75      	    rts
 294               	
 295               	|
 296               	| Parse Line
 297               	|
 298               	parseLine:
 299 80612 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 300 80616 41F9 0007 	    lea     varLineBuf, %a0
 300      FBAE 
 301               	 PLfindCommand:
 302 8061c 1018      	    move.b  (%a0)+, %d0
 303 8061e 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
68K GAS  S68K_002.s 			page 7


 304 80622 6700 FFF8 	    beq.w   PLfindCommand    
 305 80626 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 306 8062a 6700 005A 	    beq.w   .examine
 307 8062e 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 308 80632 6700 03C8 	    beq.w   .deposit
 309 80636 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 310 8063a 6700 0424 	    beq.w   .run
 311 8063e 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 312 80642 6700 001E 	    beq.w   .help
 313 80646 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 314 8064a 6700 00C4 	    beq.w   loadSRec
 315 8064e 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 316 80652 6708      	    beq.s   .exit               
 317               	 .invalid:   
 318 80654 41FA 0586 	    lea     msgInvalidCommand, %a0
 319 80658 6100 FED6 	    bsr.w   printString
 320               	 .exit:
 321 8065c 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 322 80660 4E75      	    rts
 323               	
 324               	|||||||||||||||||||||||||||||||
 325               	|| HELP command
 326               	 .help:
 327 80662 41FA 058D 	    lea     msgHelp, %a0
 328 80666 6100 FEC8 	    bsr.w   printString
 329 8066a 6000 FFF0 	    bra.w   .exit
 330               	 .invalidAddr:
 331 8066e 41FA 05E0 	    lea     msgInvalidAddress, %a0
 332 80672 6100 FEBC 	    bsr.w   printString
 333 80676 6000 FFE4 	    bra.w   .exit
 334               	 .invalidVal:
 335 8067a 41FA 05E6 	    lea     msgInvalidValue, %a0
 336 8067e 6100 FEB0 	    bsr.w   printString
 337 80682 6000 FFD8 	    bra.w   .exit
 338               		
 339               	|||||||||||||||||||||||||||||||
 340               	| Examines memory addresses
 341               	| Valid modes:
 342               	|   e ADDR                  Displays a single byte
 343               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 344               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 345               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 346               	|   e ADDR.                 Quick line, displays one line 
 347               	.examine:
 348 80686 6100 0278 	    bsr.w   parseNumber         | Read in the start address
 349 8068a 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 350 8068c 6600 FFE0 	    bne.w   .invalidAddr        
 351 80690 2640      	    move.l  %d0, %a3            | Save the start address
 352               	 .exloop:
 353 80692 1018      	    move.b  (%a0)+, %d0
 354 80694 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 355 80698 67F8      	    beq.s   .exloop
 356 8069a 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 357 8069e 6716      	    beq.s   .exrange
 358 806a0 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 359 806a4 6722      	    beq.s   .exlength
 360 806a6 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
68K GAS  S68K_002.s 			page 8


 361 806aa 672E      	    beq.s   .exinter
 362 806ac 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 363 806b0 6712      	    beq.s   .exquick
 364 806b2 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 365 806b4 601C      	    bra.s   .exend              
 366               	 .exrange:
 367 806b6 6100 0248 	    bsr.w   parseNumber         | Find the end address
 368 806ba 4A01      	    tst.b   %d1                 | Check if we found a valid address
 369 806bc 6600 FFB0 	    bne.w   .invalidAddr
 370 806c0 908B      	    sub.l   %a3, %d0            | Get the length
 371 806c2 600E      	    bra.s   .exend
 372               	 .exquick:                      | Quick mode means show one line of 16 bytes
 373 806c4 7010      	    move.l  #0x10, %d0
 374 806c6 600A      	    bra.s   .exend
 375               	 .exlength:                     | Length mode means a length is specified
 376 806c8 6100 0236 	    bsr.w   parseNumber         | Find the length
 377 806cc 4A01      	    tst.b   %d1
 378 806ce 6600 FF9E 	    bne.w   .invalidAddr
 379               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 380 806d2 204B      	    move.l  %a3, %a0
 381 806d4 6100 028C 	    bsr.w   dumpRAM
 382 806d8 6082      	    bra.s   .exit
 383               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 384 806da 204B      	    move.l  %a3, %a0            | Current Address
 385 806dc 7010      	    move.l  #0x10, %d0          | 16 bytes
 386 806de 6100 0282 	    bsr.w   dumpRAM             | Dump this line
 387 806e2 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 387      0010 
 388               	 .exinterend:
 389 806e8 6100 FE50 	    bsr.w   inChar
 390 806ec 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 391 806f0 67E8      	    beq.s   .exinter
 392 806f2 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 393 806f6 6704      	    beq.s   .exinterpage
 394 806f8 6000 FF62 	    bra	   .exit               | Otherwise exit
 395               	 .exinterpage:
 396 806fc 204B      	    move.l  %a3, %a0
 397 806fe 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 397      0100 
 398 80704 6100 025C 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 399 80708 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 399      0100 
 400 8070e 60D8      	    bra.s   .exinterend
 401               	
 402               	|||||||||||||||||||||||||||||
 403               	|| Load S Record
 404               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 405               	|	srecByCt:	ds.b	1		| Byte Count
 406               	|	srecData:	ds.b	1 		| Data
 407               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 408               	|	srecAddr:	ds.l	1		| S Record current byte address
 409               	|
 410               	| Supports 3 S record types (matches gcc m68k output)
 411               	|	S00F00005336384B5F3030322E746D7074
 412               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 413               	|	S503005BA1
 414               	
68K GAS  S68K_002.s 			page 9


 415               	loadSRec:
 416 80710 41FA 052E 	    lea     ldSRecMsg, %a0
 417 80714 6100 FE1A 	    bsr.w   printString
 418 80718 6100 0088 		bsr		getRecType
 419 8071c 6100 00BE 		bsr		getBytCt
 420 80720 13FC 0000 		move.b 	#0, srecCSum
 420      0000 0000 
 421 80728 6100 0118 		bsr		getAddr
 422 8072c 41FA 05B1 		lea		debug_Srec_LDData_Msg, %a0
 423 80730 6100 FDFE 		bsr		printString
 424               	loopSData:
 425 80734 0C39 0001 		cmp.b 	#1, srecByCt
 425      0000 0000 
 426 8073c 6700 000A 		beq		sRecDataDone
 427 80740 4EBA 000E 		jsr		getLdData
 428 80744 6000 FFEE 		bra		loopSData
 429               	sRecDataDone:
 430 80748 4EBA 0032 		jsr		getChksum
 431 8074c 6000 FF0E 		bra.w   .exit
 432               	
 433               	getLdData:
 434 80750 4EBA 00BC 		jsr		getHexPair
 435 80754 0C39 0002 		cmp.b	#2, srecType
 435      0000 0000 
 436 8075c 6600 0010 		bne		skipLdData
 437 80760 41F9 0000 		lea 	srecAddr, %a0
 437      0000 
 438 80766 1080      		move.b	%d0, (%a0)
 439 80768 52B9 0000 		add.l	#1, srecAddr
 439      0000 
 440               	skipLdData:
 441 8076e D139 0000 		add.b	%d0, srecCSum
 441      0000 
 442 80774 5339 0000 		sub.b	#1, srecByCt
 442      0000 
 443 8077a 4E75      		rts
 444               	
 445               	getChksum:
 446 8077c 41FA 0521 		lea		debug_Srec_CSum_Msg, %a0
 447 80780 6100 FDAE 	    bsr.w   printString
 448 80784 4EBA 0088 		jsr		getHexPair
 449 80788 D139 0000 		add.b	%d0, srecCSum
 449      0000 
 450 8078e 1039 0000 		move.b	srecCSum, %d0
 450      0000 
 451 80794 4EBA 030E 		jsr		printHexByte
 452 80798 41FA 0454 		lea		CRLF_MSG, %a0
 453 8079c 6100 FD92 	    bsr.w   printString
 454               	failCSUM:
 455 807a0 4E75      		rts
 456               	
 457               	getRecType:
 458 807a2 4EBA FD96 		jsr		inChar
 459 807a6 0C00 0053 		cmp.b	#'S', %d0
 460 807aa 6600 FFF6 		bne		getRecType
 461 807ae 4EBA FD8A 		jsr		inChar
 462 807b2 0200 000F 		andi.b	#0x0f, %d0
68K GAS  S68K_002.s 			page 10


 463 807b6 13C0 0000 		move.b	%d0, srecType
 463      0000 
 464               	| Debug messages follow
 465 807bc 41FA 04BD 		lea		debug_Srec_Typ_Msg, %a0		| Debug message
 466 807c0 6100 FD6E 	    bsr.w   printString
 467 807c4 1039 0000 		move.b	srecType, %d0
 467      0000 
 468 807ca 0600 0030 		add.b	#'0', %d0
 469 807ce 4EBA FD38 		jsr		outChar
 470 807d2 41FA 041A 		lea		CRLF_MSG, %a0
 471 807d6 6100 FD58 	    bsr.w   printString
 472               	| Debug messages end
 473 807da 4E75      		rts
 474               		
 475               	getBytCt:
 476 807dc 4EBA 0030 		jsr		getHexPair
 477 807e0 13C0 0000 		move.b 	%d0, srecCSum
 477      0000 
 478 807e6 13C0 0000 		move.b	%d0, srecByCt
 478      0000 
 479               	| Debug messages follow
 480 807ec 41FA 049C 		lea		debug_Srec_BytCt_Msg, %a0
 481 807f0 6100 FD3E 	    bsr.w   printString
 482 807f4 1039 0000 		move.b	srecByCt, %d0
 482      0000 
 483 807fa 4EBA 02A8 		jsr		printHexByte
 484 807fe 41FA 03EE 		lea		CRLF_MSG, %a0
 485 80802 6100 FD2C 	    bsr.w   printString
 486               	| Debug messages end
 487 80806 5339 0000 		sub.b	#1, srecByCt
 487      0000 
 488 8080c 4E75      		rts
 489               	
 490               	getHexPair:
 491 8080e 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 492 80812 4EBA FD26 		jsr		inChar
 493 80816 4EBA 0016 		jsr		toNibble
 494 8081a E900      		asl.b	#4, %d0
 495 8081c 1400      		move.b	%d0, %d2
 496 8081e 4EBA FD1A 		jsr		inChar
 497 80822 4EBA 000A 		jsr		toNibble
 498 80826 8002      		or.b	%d2, %d0
 499 80828 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 500 8082c 4E75      		rts
 501               	
 502               	toNibble:
 503 8082e 0C00 0041 		cmp.b	#'A', %d0
 504 80832 6C00 0008 		bge		doHexLetter
 505 80836 0400 0030 		sub.b	#'0', %d0
 506 8083a 4E75      		rts
 507               	doHexLetter:
 508 8083c 0400 004B 		sub.b	#'A'+10, %d0
 509 80840 4E75      		rts
 510               	
 511               	getAddr:
 512 80842 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 513 80846 1039 0000 		move.b	srecType, %d0
68K GAS  S68K_002.s 			page 11


 513      0000 
 514 8084c 0C00 0032 		cmp.b	#'2', %d0
 515 80850 6600 006E 		bne		adrLen16
 516 80854 41FA 045C 		lea		debug_S2rec_Addr_Msg, %a0
 517 80858 6100 FCD6 		bsr		printString
 518 8085c 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 519               		| Get the upper 8-bits of 24-bits
 520 8085e 4EBA FFAE 		jsr		getHexPair
 521 80862 D139 0000 		add.b 	%d0, srecCSum
 521      0000 
 522 80868 8480      		or.l	%d0, %d2
 523 8086a E182      		asl.l	#8, %d2
 524 8086c 2002      		move.l	%d2, %d0
 525 8086e 6100 0214 		bsr		printHexLong
 526 80872 41FA 037A 		lea		CRLF_MSG, %a0
 527 80876 6100 FCB8 	    bsr.w   printString
 528               		| Get the middle 8-bits of 24-bits
 529 8087a 4EBA FF92 		jsr		getHexPair
 530 8087e D139 0000 		add.b 	%d0, srecCSum
 530      0000 
 531 80884 8480      		or.l	%d0, %d2
 532 80886 E182      		asl.l	#8, %d2
 533 80888 2002      		move.l	%d2, %d0
 534 8088a 6100 01F8 		bsr		printHexLong
 535 8088e 41FA 035E 		lea		CRLF_MSG, %a0
 536 80892 6100 FC9C 	    bsr.w   printString
 537               		| Get the lower 8-bits of 24-bits
 538 80896 4EBA FF76 		jsr		getHexPair
 539 8089a D139 0000 		add.b 	%d0, srecCSum
 539      0000 
 540 808a0 8480      		or.l	%d0, %d2
 541 808a2 23C2 0000 		move.l	%d2, srecAddr		| Save the S record address
 541      0000 
 542 808a8 5739 0000 		sub.b	#3, srecByCt
 542      0000 
 543 808ae 2002      		move.l	%d2, %d0
 544 808b0 6100 01D2 		bsr		printHexLong
 545 808b4 41FA 0338 		lea		CRLF_MSG, %a0
 546 808b8 6100 FC76 	    bsr.w   printString
 547 808bc 6000 003C 		bra		past16
 548               	adrLen16:
 549 808c0 41FA 0403 		lea		debug_SXrec_Addr_Msg, %a0
 550 808c4 6100 FC6A 		bsr		printString
 551               	|	move.l	#0, %d2
 552 808c8 4EBA FF44 		jsr		getHexPair
 553 808cc 5739 0000 		sub.b	#3, srecByCt
 553      0000 
 554 808d2 6100 01B0 		bsr		printHexLong
 555 808d6 41FA 0316 		lea		CRLF_MSG, %a0
 556 808da 6100 FC54 	    bsr.w   printString
 557               	|	or.l	%d0, %d2
 558               	|	asl.l	#8, %d2
 559 808de 4EBA FF2E 		jsr		getHexPair
 560 808e2 5739 0000 		sub.b	#3, srecByCt
 560      0000 
 561 808e8 6100 019A 		bsr		printHexLong
 562 808ec 41FA 0300 		lea		CRLF_MSG, %a0
68K GAS  S68K_002.s 			page 12


 563 808f0 6100 FC3E 	    bsr.w   printString
 564               	|	or.l	%d0, %d2
 565               	|	move.l	%d2, srecAddr
 566 808f4 5539 0000 		sub.b	#2, srecByCt
 566      0000 
 567               	past16:
 568 808fa 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 569 808fe 4E75      		rts
 570               			
 571               	|||||||||||||||||||||||||||||
 572               	| Find and parse a hex number
 573               	|  Starting address in A0
 574               	|  Number returned in D0
 575               	|  Status in D1   (0 success, 1 fail)
 576               	|  TODO: Try and merge first digit code with remaining digit code
 577               	parseNumber:
 578 80900 B180      	    eor.l   %d0, %d0		| Zero out d0
 579 80902 1018      	    move.b  (%a0)+, %d0
 580 80904 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 581 80908 67F6      	    beq.s   parseNumber
 582 8090a 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 583 8090e 6D14      	    blt.s	PNinvalid
 584 80910 0C00 0039 	    cmp.b   #'9', %d0
 585 80914 6F18      	    ble.s   PNfirstdigit1
 586               	
 587 80916 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 588 8091a 6D00 FD38 	    blt   .invalid    
 589 8091e 0C00 0046 	    cmp.b   #'F', %d0
 590 80922 6F04      	    ble.s   PNfirstdigit2
 591               	PNinvalid:
 592 80924 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 593 80926 4E75      	    rts
 594               	PNfirstdigit2:
 595 80928 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 596 8092c 6004      	    bra.s   PNloop
 597               	PNfirstdigit1:
 598 8092e 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 599               	 PNloop:
 600 80932 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 601 80934 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 602 80938 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 603 8093a 0C01 0039 	    cmp.b   #'9', %d1
 604 8093e 6F18      	    ble.s   PNdigit1
 605 80940 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 606 80944 6D06      	    blt.s   PNend
 607 80946 0C01 0046 	    cmp.b   #'F', %d1
 608 8094a 6F06      	    ble.s   PNdigit2
 609               	
 610               	PNend:                       | We hit a non-hex digit character, we're done parsing
 611 8094c 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 612 8094e 7200      	    move.l  #0, %d1
 613 80950 4E75      	    rts
 614               	PNdigit2:
 615 80952 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 616 80956 6004      	    bra.s   PNdigit3
 617               	PNdigit1:
 618 80958 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
68K GAS  S68K_002.s 			page 13


 619               	PNdigit3:
 620 8095c E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 621 8095e D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 622 80960 60D0      	    bra.s   PNloop
 623               	    
 624               	
 625               	|||||||||||||||||||||||||||||
 626               	| Dumps a section of RAM to the screen
 627               	| Displays both hex values and ASCII characters
 628               	| d0 - Number of bytes to dump
 629               	| a0 - Start Address
 630               	dumpRAM:
 631 80962 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 632 80966 2448      	    move.l  %a0, %a2           	| Save the start address
 633 80968 2400      	    move.l  %d0, %d2           	| And the number of bytes
 634               	 .line:
 635 8096a 200A      	    move.l  %a2, %d0          
 636 8096c 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 637 80970 41FA 0303 	    lea     msgColonSpace, %a0
 638 80974 6100 FBBA 	    bsr.w   printString
 639 80978 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 640 8097a 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
 641               	 .hexbyte:
 642 8097c 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 643 8097e 6718      	    beq.s   .endbytesShort
 644 80980 4A03      	    tst.b   %d3               	| Check if we're done this line
 645 80982 673A      	    beq.s   .endbytes    
 646 80984 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 647 80986 6100 011C 	    bsr.w   printHexByte     	| Display it
 648 8098a 103C 0020 	    move.b  #' ', %d0
 649 8098e 6100 FB78 	    bsr.w   outChar          	| Space out bytes
 650 80992 5383      	    subq.l  #1, %d3    
 651 80994 5382      	    subq.l  #1, %d2        
 652 80996 60E4      	    bra.s   .hexbyte
 653               	 .endbytesShort:
 654 80998 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 655 8099a 103C 0020 	    move.b  #' ', %d0
 656               	 .endbytesShortLoop:
 657 8099e 4A03      	    tst.b   %d3               	| Check if we ended the line
 658 809a0 671C      	    beq.s   .endbytes
 659 809a2 103C 0020 	    move.b  #' ', %d0
 660 809a6 6100 FB60 	    bsr.w   outChar          	| Three spaces to pad out
 661 809aa 103C 0020 	    move.b  #' ', %d0
 662 809ae 6100 FB58 	    bsr.w   outChar
 663 809b2 103C 0020 	    move.b  #' ', %d0
 664 809b6 6100 FB50 	    bsr.w   outChar
 665               	    
 666 809ba 5303      	    subq.b  #1, %d3
 667 809bc 60E0      	    bra.s   .endbytesShortLoop
 668               	 .endbytes:
 669 809be 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 670               	 .endbytesLoop:
 671 809c0 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 672 809c2 6700 0022 	    beq     .endline    
 673 809c6 5304      	    subq.b  #1, %d4
 674 809c8 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 675 809ca 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
68K GAS  S68K_002.s 			page 14


 676 809ce 6D0C      	    blt.s   .unprintable
 677 809d0 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 678 809d4 6E06      	    bgt.s   .unprintable
 679 809d6 6100 FB30 	    bsr.w   outChar
 680 809da 60E4      	    bra.s   .endbytesLoop
 681               	 .unprintable:
 682 809dc 103C 002E 	    move.b  #'.', %d0
 683 809e0 6100 FB26 	    bsr.w   outChar
 684 809e4 60DA      	    bra.s   .endbytesLoop
 685               	 .endline:
 686 809e6 41FA 0290 	    lea     msgNewline, %a0
 687 809ea 6100 FB44 	    bsr.w   printString
 688 809ee 4A82      	    tst.l   %d2
 689 809f0 6F04      	    ble.s   .end
 690 809f2 6000 FF76 	    bra.w   .line
 691               	 .end:
 692 809f6 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 693 809fa 4E75      	    rts
 694               	
 695               	|||||||||||||||||||||||
 696               	| Deposit values into RAM
 697               	| d ADDR VAL VAL            Deposit value(s) into RAM
 698               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 699               	|  VAL VAL VAL;              - Continuing with further continue
 700               	| d: VAL VAL                Continue depositing values after the last address written to
 701               	|||||||||||||||||||||||
 702               	.deposit:
 703 809fc 1010      	    move.b  (%a0), %d0
 704 809fe 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 705 80a02 6730      	    beq.s   DepCont
 706               	    
 707 80a04 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 708 80a08 4A01      	    tst.b   %d1
 709 80a0a 6600 FC62 	    bne		.invalidAddr
 710 80a0e 2640      	    move.l  %d0, %a3           	| Save the start address
 711               	 DepLoop:
 712 80a10 1010      	    move.b  (%a0), %d0            
 713 80a12 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 714 80a16 6726      	    beq.s   DepMLine
 715 80a18 4A40      	    tst     %d0              	| Check for the end of line
 716 80a1a 6700 003A 	    beq     DepEnd
 717               	    
 718 80a1e 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 719 80a22 4A01      	    tst.b   %d1
 720 80a24 6600 FC54 	    bne		.invalidVal
 721 80a28 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 722 80a2c 6E00 FC4C 	    bgt		.invalidVal
 723               	    
 724 80a30 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 725 80a32 60DC      	    bra.s   DepLoop
 726               	    
 727               	 DepCont:
 728 80a34 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 728      FBAA 
 729 80a3a 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 730 80a3c 60D2      	    bra.s   DepLoop
 731               	    
68K GAS  S68K_002.s 			page 15


 732               	 DepMLine:
 733 80a3e 41FA 0186 	    lea     msgDepositPrompt, %a0
 734 80a42 6100 FAEC 	    bsr.w   printString
 735 80a46 6100 FB1A 	    bsr.w   readLine          	| Read in the next line to be parsed
 736 80a4a 6100 FBA8 	    bsr.w   lineToUpper         | Convert to uppercase
 737 80a4e 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 737      FBAE 
 738 80a54 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 739               	 DepEnd:
 740 80a56 23CB 0007 	    move.l  %a3, varCurAddr
 740      FBAA 
 741 80a5c 6000 FBFE 	    bra.w   .exit
 742               	
 743               	|||||||||||||||||||||||
 744               	| run code
 745               	 .run:
 746 80a60 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 747 80a64 4A01      	    tst.b   %d1
 748 80a66 6600 FC06 	    bne		.invalidAddr
 749 80a6a 2040      	    move.l  %d0, %a0
 750 80a6c 4E90      	    jsr     (%a0)             	| Jump to the code! 
 751               	                                | Go as subroutine to allow code to return to us
 752 80a6e 4EBA FA5C 	    jsr     monitorStart        | Warm start after returning so everything is in
 753               	                                | a known state.
 754               	
 755               	
 756               	|||||||||||||||||||||||
 757               	|| KEEP All printHex functions together ||
 758               	|||||||||||||||||||||||
 759               	| Print a hex word
 760               	printHexWord:
 761 80a72 2F02      	    move.l  %d2, -(%SP)		| Save D2
 762 80a74 2400      	    move.l  %d0, %d2		| Save the address in d2
 763               	    
 764 80a76 E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 765 80a78 E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 766 80a7a 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 767               	|||||||||||||||||||||||
 768               	| Print a hex 24-bit address
 769               	printHexAddr:
 770 80a7c 2F02      	    move.l %d2, -(%SP)   	| Save D2
 771 80a7e 2400      	    move.l %d0, %d2      	| Save the address in d2
 772               	    
 773 80a80 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 774 80a82 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 775               	|||||||||||||||||||||||
 776               	* Print a hex long
 777               	printHexLong:
 778 80a84 2F02      	    move.l  %d2, -(%SP)     | Save D2
 779 80a86 2400      	    move.l  %d0, %d2        | Save the address in d2
 780               	    
 781 80a88 E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 782 80a8a 2002      	    move.l  %d2, %d0
 783 80a8c 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 784               	printHex_addrentry:     
 785 80a8e E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 786 80a90 2002      	    move.l  %d2, %d0              
68K GAS  S68K_002.s 			page 16


 787 80a92 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 788               	printHex_wordentry:    
 789 80a94 E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 790 80a96 2002      	    move.l  %d2, %d0
 791 80a98 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 792 80a9a E19A      	    rol.l   #0x8, %d2
 793 80a9c 2002      	    move.l  %d2, %d0
 794 80a9e 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 795               	    
 796 80aa0 241F      	    move.l (%SP)+, %d2      | Restore D2
 797 80aa2 4E75      	    RTS
 798               	    
 799               	|||||||||||||||||||||||
 800               	| Print a hex byte
 801               	|  - Takes byte in D0
 802               	printHexByte:
 803 80aa4 2F02      	    move.l  %D2, -(%SP)
 804 80aa6 7400      		move.l	#0, %d2
 805 80aa8 1400      	    move.b  %d0, %d2
 806 80aaa E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 807 80aac 0200 000F 		andi.b	#0xf, %d0
 808 80ab0 0600 0030 	    add.b   #'0', %d0
 809 80ab4 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 810 80ab8 6F02      	    ble.s   PHBsecond
 811 80aba 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 812               	PHBsecond:
 813 80abc 6100 FA4A 	    bsr   outChar			| Print the digit
 814 80ac0 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 815 80ac4 0602 0030 	    add.b   #'0', %d2
 816 80ac8 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 817 80acc 6F02      	    ble.s   PHBend
 818 80ace 5E02      	    add.b   #0x7, %D2
 819               	PHBend:
 820 80ad0 1002      	    move.b  %D2, %D0
 821 80ad2 6100 FA34 	    bsr	   outChar      	| Print the lower digit
 822 80ad6 241F      	    move.l  (%SP)+, %D2
 823 80ad8 4E75      	    rts
 824               		
 825               	
 826               	|||||
 827               	| Initializes the 68681 DUART port A as 9600 8N1 
 828               	initDuart:
 829 80ada 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 829      000F 0004 
 830 80ae2 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 830      000F 0004 
 831 80aea 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 831      000F 0004 
 832               	    
 833 80af2 13FC 0080 	    move.b  #0x80, ACR       | Baud Rate Set #2
 833      000F 0008 
 834 80afa 13FC 00BB 	    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 834      000F 0002 
 835 80b02 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 835      000F 0000 
 836 80b0a 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 836      000F 0000 
68K GAS  S68K_002.s 			page 17


 837               	    
 838 80b12 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 838      000F 0004 
 839               	
 840 80b1a 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 840      000F 0014 
 841 80b22 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 841      000F 0014 
 842 80b2a 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 842      000F 0014 
 843               	    
 844 80b32 13FC 00BB 	    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 844      000F 0012 
 845 80b3a 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 845      000F 0010 
 846 80b42 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 846      000F 0010 
 847               	    
 848 80b4a 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 848      000F 0014 
 849               		
 850 80b52 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
 850      000F 001A 
 851 80b5a 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 851      000F 001E 
 852 80b62 4E75      	    rts    
 853               	
 854               	delay1Sec:
 855 80b64 203C 0003 		move.l	#200000, %d0	| rough count
 855      0D40 
 856               	delay1Loop:
 857 80b6a 5380      		sub.l	#1, %d0			
 858 80b6c 6600 FFFC 		bne		delay1Loop
 859 80b70 4E75      		rts
 860               	
 861               	READINLINE:	  
 862 80b72 5265 6164 		.ascii  "Reading in line"
 862      696E 6720 
 862      696E 206C 
 862      696E 65
 863 80b81 0D0A 00   		dc.b CR,LF,EOT
 864               	L_TO_UPPER_MSG:  
 865 80b84 436F 6E76 		.ascii  "Convert line to upper case"
 865      6572 7420 
 865      6C69 6E65 
 865      2074 6F20 
 865      7570 7065 
 866 80b9e 0D0A 00   		dc.b CR,LF,EOT
 867               	WRITEOUTLINE:	  
 868 80ba1 5772 6974 		.ascii  "Writing out line"
 868      696E 6720 
 868      6F75 7420 
 868      6C69 6E65 
 869 80bb1 0D0A 00   		dc.b CR,LF,EOT
 870               	RAM_PASS_MSG:  
 871 80bb4 5241 4D20 		.ascii  "RAM Test Passed"
 871      5465 7374 
68K GAS  S68K_002.s 			page 18


 871      2050 6173 
 871      7365 64
 872 80bc3 0D0A 00   		dc.b CR,LF,EOT
 873               	msgDepositPrompt:
 874 80bc6 3A20      	    .ascii	": "
 875 80bc8 00        		dc.b 	EOT
 876               	BANNER_MSG:	
 877 80bc9 5349 4D50 		.ascii  "SIMPLE-68008 CPU"
 877      4C45 2D36 
 877      3830 3038 
 877      2043 5055 
 878 80bd9 0D0A 00   		dc.b CR,LF,EOT
 879               	msgInvalidCommand:
 880 80bdc 496E 7661 	    .ascii "Invalid Command"
 880      6C69 6420 
 880      436F 6D6D 
 880      616E 64
 881 80beb 0D0A 00   		dc.b CR,LF,EOT
 882               	CRLF_MSG:	
 883 80bee 0D0A 00   		dc.b CR,LF,EOT
 884               	msgHelp:
 885 80bf1 4176 6169 	    .ascii	"Available Commands: "
 885      6C61 626C 
 885      6520 436F 
 885      6D6D 616E 
 885      6473 3A20 
 886 80c05 0D0A      		dc.b	CR,LF
 887 80c07 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 887      7861 6D69 
 887      6E65 2020 
 887      2020 2844 
 887      2965 706F 
 888 80c3d 0D0A 00   		dc.b	CR,LF,EOT
 889               	ldSRecMsg:
 890 80c40 4C6F 6164 	    .ascii	"Load S-Record"
 890      2053 2D52 
 890      6563 6F72 
 890      64
 891 80c4d 0D0A 00   		dc.b	CR,LF,EOT
 892               	msgInvalidAddress:
 893 80c50 496E 7661 	    .ascii	"Invalid Address"
 893      6C69 6420 
 893      4164 6472 
 893      6573 73
 894 80c5f 0D0A 00   		dc.b 	CR,LF,EOT
 895               	msgInvalidValue:
 896 80c62 496E 7661 	    .ascii	"Invalid Value"
 896      6C69 6420 
 896      5661 6C75 
 896      65
 897 80c6f 0D0A 00   		dc.b	CR,LF,EOT
 898               	msgPrompt:
 899 80c72 3E20      		.ascii "> "
 900 80c74 00        	    dc.b EOT
 901               	msgColonSpace:
 902 80c75 3A20      	    .ascii ": "
 903 80c77 00        	    dc.b EOT
68K GAS  S68K_002.s 			page 19


 904               	msgNewline:
 905 80c78 0D0A 00   	    dc.b CR,LF,EOT
 906               	debug_Srec_Typ_Msg:
 907 80c7b 5320 5265 		.ascii	"S Record Type="
 907      636F 7264 
 907      2054 7970 
 907      653D 
 908 80c89 00        	    dc.b EOT
 909               	debug_Srec_BytCt_Msg:
 910 80c8a 5320 5265 		.ascii	"S Record Byte Count="
 910      636F 7264 
 910      2042 7974 
 910      6520 436F 
 910      756E 743D 
 911 80c9e 00        	    dc.b EOT
 912               	debug_Srec_CSum_Msg:
 913 80c9f 5320 5265 		.ascii	"S Record Checksum="
 913      636F 7264 
 913      2043 6865 
 913      636B 7375 
 913      6D3D 
 914 80cb1 00        	    dc.b EOT
 915               	debug_S2rec_Addr_Msg:
 916 80cb2 5332 2052 		.ascii	"S2 Record Address="
 916      6563 6F72 
 916      6420 4164 
 916      6472 6573 
 916      733D 
 917 80cc4 00        	    dc.b EOT
 918               	debug_SXrec_Addr_Msg:
 919 80cc5 5320 286E 		.ascii	"S (not 2) Record Address="
 919      6F74 2032 
 919      2920 5265 
 919      636F 7264 
 919      2041 6464 
 920 80cde 00        	    dc.b EOT
 921               	debug_Srec_LDData_Msg:
 922 80cdf 4C6F 6164 	    .ascii	"Load Data Loop start"
 922      2044 6174 
 922      6120 4C6F 
 922      6F70 2073 
 922      7461 7274 
 923 80cf3 0D0A 00   		dc.b 	CR,LF,EOT
 924               	
 925               	
 926               	MAX_LINE_LENGTH = 80
 927               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 928               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 20


DEFINED SYMBOLS
          S68K_002.s:6      *ABS*:0000000000000000 RAM_START
          S68K_002.s:7      *ABS*:000000000007fffc STACK_END
          S68K_002.s:8      *ABS*:000000000007ffff RAM_END
          S68K_002.s:9      *ABS*:0000000000080000 ROM_START
          S68K_002.s:10     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:12     *ABS*:000000000008ffff ROM_END
          S68K_002.s:17     *ABS*:00000000000f0000 DUART
          S68K_002.s:18     *ABS*:00000000000f0000 MRA
          S68K_002.s:19     *ABS*:00000000000f0002 SRA
          S68K_002.s:20     *ABS*:00000000000f0002 CSRA
          S68K_002.s:21     *ABS*:00000000000f0004 CRA
          S68K_002.s:22     *ABS*:00000000000f0006 RBA
          S68K_002.s:23     *ABS*:00000000000f0006 TBA
          S68K_002.s:24     *ABS*:00000000000f0008 ACR
          S68K_002.s:25     *ABS*:00000000000f000a ISR
          S68K_002.s:26     *ABS*:00000000000f000a IMR
          S68K_002.s:27     *ABS*:00000000000f0010 MRB
          S68K_002.s:28     *ABS*:00000000000f0012 SRB
          S68K_002.s:29     *ABS*:00000000000f0012 CSRB
          S68K_002.s:30     *ABS*:00000000000f0014 CRB
          S68K_002.s:31     *ABS*:00000000000f0016 RBB
          S68K_002.s:32     *ABS*:00000000000f0016 TBB
          S68K_002.s:33     *ABS*:00000000000f0018 IVR
          S68K_002.s:34     *ABS*:00000000000f001a OPC
          S68K_002.s:35     *ABS*:00000000000f001a INU
          S68K_002.s:36     *ABS*:00000000000f001c OPS
          S68K_002.s:37     *ABS*:00000000000f001e OPR
          S68K_002.s:42     *ABS*:0000000000000007 BEL
          S68K_002.s:43     *ABS*:0000000000000008 BKSP
          S68K_002.s:44     *ABS*:0000000000000009 TAB
          S68K_002.s:45     *ABS*:000000000000000a LF
          S68K_002.s:46     *ABS*:000000000000000d CR
          S68K_002.s:47     *ABS*:000000000000001b ESC
          S68K_002.s:48     *ABS*:0000000000000000 EOT
          S68K_002.s:50     *ABS*:0000000000000003 CTRLC
          S68K_002.s:51     *ABS*:0000000000000018 CTRLX
          S68K_002.s:54     .text:0000000000000400 srecType
          S68K_002.s:55     .text:0000000000000401 srecByCt
          S68K_002.s:56     .text:0000000000000402 srecData
          S68K_002.s:57     .text:0000000000000403 srecCSum
          S68K_002.s:58     .text:0000000000000404 srecAddr
          S68K_002.s:169    .text:0000000000080502 FERVR2
          S68K_002.s:94     .text:000000000008045c loop1stLoc
          S68K_002.s:167    .text:0000000000080502 failBitTest
          S68K_002.s:109    .text:000000000008047c loopAdrFill
          S68K_002.s:121    .text:000000000008049a loopAdrCk
          S68K_002.s:168    .text:0000000000080502 failAdrTest
          S68K_002.s:136    .text:00000000000804b4 fillSRAM
          S68K_002.s:140    .text:00000000000804c0 fillSRAMLoop
          S68K_002.s:828    .text:0000000000080ada initDuart
          S68K_002.s:149    .text:00000000000804cc monitorStart
          S68K_002.s:876    .text:0000000000080bc9 BANNER_MSG
          S68K_002.s:194    .text:0000000000080530 printString1
          S68K_002.s:870    .text:0000000000080bb4 RAM_PASS_MSG
          S68K_002.s:157    .text:00000000000804dc interpLoop
          S68K_002.s:898    .text:0000000000080c72 msgPrompt
68K GAS  S68K_002.s 			page 21


          S68K_002.s:195    .text:0000000000080530 printString
          S68K_002.s:224    .text:0000000000080562 readLine
          S68K_002.s:281    .text:00000000000805f4 lineToUpper
          S68K_002.s:298    .text:0000000000080612 parseLine
          S68K_002.s:176    .text:0000000000080508 outChar1
          S68K_002.s:177    .text:0000000000080508 outChar
          S68K_002.s:185    .text:000000000008051c outChar2
          S68K_002.s:196    .text:0000000000080530 PSloop
          S68K_002.s:202    .text:0000000000080538 PSend
          S68K_002.s:210    .text:000000000008053a inChar1
          S68K_002.s:211    .text:000000000008053a inChar
          S68K_002.s:217    .text:000000000008054e inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:228    .text:000000000008056e RLloop
          S68K_002.s:245    .text:000000000008059a RLBS
          S68K_002.s:256    .text:00000000000805b8 RLlineClr
          S68K_002.s:270    .text:00000000000805dc RLEndLn
          S68K_002.s:238    .text:000000000008058a .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:260    .text:00000000000805be RLlineClrloop
          S68K_002.s:283    .text:00000000000805fa LUloop
          S68K_002.s:290    .text:000000000008060c LUnext
          S68K_002.s:301    .text:000000000008061c PLfindCommand
          S68K_002.s:347    .text:0000000000080686 .examine
          S68K_002.s:702    .text:00000000000809fc .deposit
          S68K_002.s:745    .text:0000000000080a60 .run
          S68K_002.s:326    .text:0000000000080662 .help
          S68K_002.s:415    .text:0000000000080710 loadSRec
          S68K_002.s:320    .text:000000000008065c .exit
          S68K_002.s:317    .text:0000000000080654 .invalid
          S68K_002.s:879    .text:0000000000080bdc msgInvalidCommand
          S68K_002.s:884    .text:0000000000080bf1 msgHelp
          S68K_002.s:330    .text:000000000008066e .invalidAddr
          S68K_002.s:892    .text:0000000000080c50 msgInvalidAddress
          S68K_002.s:334    .text:000000000008067a .invalidVal
          S68K_002.s:895    .text:0000000000080c62 msgInvalidValue
          S68K_002.s:577    .text:0000000000080900 parseNumber
          S68K_002.s:352    .text:0000000000080692 .exloop
          S68K_002.s:366    .text:00000000000806b6 .exrange
          S68K_002.s:375    .text:00000000000806c8 .exlength
          S68K_002.s:383    .text:00000000000806da .exinter
          S68K_002.s:372    .text:00000000000806c4 .exquick
          S68K_002.s:379    .text:00000000000806d2 .exend
          S68K_002.s:630    .text:0000000000080962 dumpRAM
          S68K_002.s:388    .text:00000000000806e8 .exinterend
          S68K_002.s:395    .text:00000000000806fc .exinterpage
          S68K_002.s:889    .text:0000000000080c40 ldSRecMsg
          S68K_002.s:457    .text:00000000000807a2 getRecType
          S68K_002.s:475    .text:00000000000807dc getBytCt
          S68K_002.s:511    .text:0000000000080842 getAddr
          S68K_002.s:921    .text:0000000000080cdf debug_Srec_LDData_Msg
          S68K_002.s:424    .text:0000000000080734 loopSData
          S68K_002.s:429    .text:0000000000080748 sRecDataDone
          S68K_002.s:433    .text:0000000000080750 getLdData
          S68K_002.s:445    .text:000000000008077c getChksum
          S68K_002.s:490    .text:000000000008080e getHexPair
          S68K_002.s:440    .text:000000000008076e skipLdData
68K GAS  S68K_002.s 			page 22


          S68K_002.s:912    .text:0000000000080c9f debug_Srec_CSum_Msg
          S68K_002.s:802    .text:0000000000080aa4 printHexByte
          S68K_002.s:882    .text:0000000000080bee CRLF_MSG
          S68K_002.s:454    .text:00000000000807a0 failCSUM
          S68K_002.s:906    .text:0000000000080c7b debug_Srec_Typ_Msg
          S68K_002.s:909    .text:0000000000080c8a debug_Srec_BytCt_Msg
          S68K_002.s:502    .text:000000000008082e toNibble
          S68K_002.s:507    .text:000000000008083c doHexLetter
          S68K_002.s:548    .text:00000000000808c0 adrLen16
          S68K_002.s:915    .text:0000000000080cb2 debug_S2rec_Addr_Msg
          S68K_002.s:777    .text:0000000000080a84 printHexLong
          S68K_002.s:567    .text:00000000000808fa past16
          S68K_002.s:918    .text:0000000000080cc5 debug_SXrec_Addr_Msg
          S68K_002.s:591    .text:0000000000080924 PNinvalid
          S68K_002.s:597    .text:000000000008092e PNfirstdigit1
          S68K_002.s:594    .text:0000000000080928 PNfirstdigit2
          S68K_002.s:599    .text:0000000000080932 PNloop
          S68K_002.s:610    .text:000000000008094c PNend
          S68K_002.s:617    .text:0000000000080958 PNdigit1
          S68K_002.s:614    .text:0000000000080952 PNdigit2
          S68K_002.s:619    .text:000000000008095c PNdigit3
          S68K_002.s:634    .text:000000000008096a .line
          S68K_002.s:769    .text:0000000000080a7c printHexAddr
          S68K_002.s:901    .text:0000000000080c75 msgColonSpace
          S68K_002.s:641    .text:000000000008097c .hexbyte
          S68K_002.s:653    .text:0000000000080998 .endbytesShort
          S68K_002.s:668    .text:00000000000809be .endbytes
          S68K_002.s:656    .text:000000000008099e .endbytesShortLoop
          S68K_002.s:670    .text:00000000000809c0 .endbytesLoop
          S68K_002.s:685    .text:00000000000809e6 .endline
          S68K_002.s:681    .text:00000000000809dc .unprintable
          S68K_002.s:904    .text:0000000000080c78 msgNewline
          S68K_002.s:691    .text:00000000000809f6 .end
          S68K_002.s:727    .text:0000000000080a34 DepCont
          S68K_002.s:711    .text:0000000000080a10 DepLoop
          S68K_002.s:732    .text:0000000000080a3e DepMLine
          S68K_002.s:739    .text:0000000000080a56 DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:873    .text:0000000000080bc6 msgDepositPrompt
          S68K_002.s:760    .text:0000000000080a72 printHexWord
          S68K_002.s:788    .text:0000000000080a94 printHex_wordentry
          S68K_002.s:784    .text:0000000000080a8e printHex_addrentry
          S68K_002.s:812    .text:0000000000080abc PHBsecond
          S68K_002.s:819    .text:0000000000080ad0 PHBend
          S68K_002.s:854    .text:0000000000080b64 delay1Sec
          S68K_002.s:856    .text:0000000000080b6a delay1Loop
          S68K_002.s:861    .text:0000000000080b72 READINLINE
          S68K_002.s:864    .text:0000000000080b84 L_TO_UPPER_MSG
          S68K_002.s:867    .text:0000000000080ba1 WRITEOUTLINE

NO UNDEFINED SYMBOLS
