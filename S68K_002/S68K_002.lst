68K GAS  S68K_002.s 			page 1


   1               	| S68K_002.s - 68K Monitor with extensions
   2               	|	Adds S Record loader
   3               	| Land Boards, LLC
   4               	|	(c) 2024
   5               	| Use it however you want
   6               	| Borrowed init code from 
   7               	|  https://raw.githubusercontent.com/ChartreuseK/68k-Monitor/master/Monitor-Simple.x68
   8               	|
   9               	| Added S-Record load code
  10               	|	Uses SRAM from 0x400-0x407
  11               	
  12               	RAM_START	= 0x00000	| Beginning of the SRAM
  13               	STACK_END	= 0x7FFFC	| Has to be on a word boundary
  14               	RAM_END		= 0x7FFFF	| 512KB SRAM
  15               	ROM_START	= 0x80000	| ROM start
  16               	ROM_CODE	= ROM_START+1024| Skip vector table
  17               	*ROM_END	= 0x87FFF	| End of 32KB EPROM
  18               	ROM_END		= 0x8FFFF	| End of 64KB EPROM
  19               	
  20               	|||||||||||||||||||||||||||||||||
  21               	| 68681 Duart Register Addresses
  22               	|
  23               	DUART = 0x0F0000	  | Base Addr of DUART
  24               	MRA   = DUART+0		  | Mode Register A           (R/W)
  25               	SRA   = DUART+2       | Status Register A         (r)
  26               	CSRA  = DUART+2       | Clock Select Register A   (w)
  27               	CRA   = DUART+4       | Commands Register A       (w)
  28               	RBA   = DUART+6       | Receiver Buffer A         (r)
  29               	TBA   = DUART+6       | Transmitter Buffer A      (w)
  30               	ACR   = DUART+8       | Aux. Control Register     (R/W)
  31               	ISR   = DUART+10      | Interrupt Status Register (R)
  32               	IMR   = DUART+10      | Interrupt Mask Register   (W)
  33               	MRB   = DUART+16      | Mode Register B           (R/W)
  34               	SRB   = DUART+18      | Status Register B         (R)
  35               	CSRB  = DUART+18      | Clock Select Register B   (W)
  36               	CRB   = DUART+20      | Commands Register B       (W)
  37               	RBB   = DUART+22      | Reciever Buffer B         (R)
  38               	TBB   = DUART+22      | Transmitter Buffer B      (W)
  39               	IVR   = DUART+24      | Interrupt Vector Register (R/W)
  40               	OPC   = DUART+26      | Output port config        (W)
  41               	INU   = DUART+26      | Input port (unlatched)    (R)
  42               	OPS   = DUART+28      | Output port Set           (W)
  43               	OPR   = DUART+30      | Output port Clear         (W)
  44               	
  45               	||||||||||||||||||||||||||||||||||
  46               	| ASCII Control Characters
  47               	|
  48               	BEL   = 0x07
  49               	BKSP  = 0x08       | CTRL-H
  50               	TAB   = 0x09
  51               	LF    = 0x0A
  52               	CR    = 0x0D
  53               	ESC   = 0x1B
  54               	EOT	  = 0x00
  55               	
  56               	CTRLC	=	0x03
  57               	CTRLX	=	0x18     | Line Clear
68K GAS  S68K_002.s 			page 2


  58               	
  59 0000 0000 0000 		.ORG    0x000400
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  59      0000 0000 
  60 0400 00        	_srecType:	ds.b	1		| S1-S9 stored as binary 1-9
  61 0401 00        	_srecByCt:	ds.b	1		| Byte Count
  62 0402 00        	_srecData:	ds.b	1 		| Data
  63 0403 00        	_srecCSum:	ds.b	1 		| S-Record Checksum
  64 0404 0000 0000 	_srecAddr:	ds.l	1		| S Record current byte address
  65               	
  66               	srecType	=		0x000400	| S1-S9 stored as binary 1-9
  67               	srecByCt	=		0x000401	| Byte Count
  68               	srecData	=		0x000402	| Data
  69               	srecCSum	=		0x000403	| S-Record Checksum
  70               	srecAddr	=		0x000404	| S Record current byte address
  71               	
  72 0408 0000 0000 		.ORG	ROM_START
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  72      0000 0000 
  73               	
  74               	| FIRST 8 bytes loaded after reset |
  75 80000 0007 FFFC 	    DC.l    STACK_END | Supervisor stack pointer
  76 80004 0008 0400 	    DC.l    ROM_CODE	| Initial PC
  77               	
  78 80008 0000 0000 	        .ORG ROM_CODE
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  78      0000 0000 
  79 80400 4E71      		nop
  80 80402 4FF9 0007 		lea			STACK_END,%sp
  80      FFFC 
  81 80408 13FC 00FF 		move.b	#0xFF, 0x080000		| Set swap bit so SRAM works
  81      0008 0000 
  82 80410 4E71      		nop
  83               	| LEDs
  84 80412 13FC 0000 		move.b	#0x00, OPC		| Output port configuration (all bit are outs)
  84      000F 001A 
  85 8041a 13FC 00FC 		move.b	#0xFC, OPR		| Clear all outputs
  85      000F 001E 
  86 80422 13FC 0004 		move.b	#0x04, OPS		| Turn off LED on DUART O2
  86      000F 001C 
  87               	|
  88               	| Test the first two SRAM location
  89               	|
  90 8042a 203C DEAD 		move.l	#0xDEADBEEF, %d0		| Test Pattern #1
  90      BEEF 
  91 80430 307C 0000 		move		#0x00000000, %a0	| First address of SRAM
  92 80434 2080      		move.l	%d0, (%a0)				| Write out test pattern to SRAM
  93 80436 2410      		move.l	(%a0), %d2				| Read first SRAM pattern into d2
  94 80438 B042      		cmp			%d2, %d0
  95 8043a 6600 00C6 		bne			FERVR2						
  96 8043e 223C 5555 		move.l	#0x5555AAAA, %d1	| Test Pattern #2
68K GAS  S68K_002.s 			page 3


  96      AAAA 
  97 80444 327C 0004 		move		#0x00000004, %a1	| Second long address of SRAM
  98 80448 2281      		move.l	%d1, (%a1)				| Write out test pattern to SRAM
  99 8044a 2611      		move.l	(%a1), %d3				| Read back
 100 8044c B243      		cmp			%d3, %d1
 101 8044e 6600 00B2 		bne			FERVR2
 102 80452 4E71      		nop
 103               	| Test bits of first location (as bytes)
 104 80454 7001      		move.l	#1, %d0
 105 80456 207C 0000 		move.l	#0, %a0
 105      0000 
 106               	loop1stLoc:
 107 8045c 1080      		move.b	%d0, (%a0)
 108 8045e 1210      		move.b	(%a0), %d1
 109 80460 B200      		cmp.b		%d0, %d1
 110 80462 6600 009E 		bne			failBitTest
 111 80466 E348      		lsl			#1, %d0
 112 80468 0C80 0000 		cmp.l		#0x00000100, %d0
 112      0100 
 113 8046e 6600 FFEC 		bne			loop1stLoc
 114               	|
 115               	| Test all address lines, 512KB SRAM
 116               	| Write incrementing pattern to data bits
 117               	|
 118 80472 7001      		move.l	#1, %d0		| Fill pattern
 119 80474 7401      		move.l	#1, %d2
 120 80476 207C 0000 		move.l	#1, %a0		| Start address 1 (already tested addr 0)
 120      0001 
 121               	loopAdrFill:
 122 8047c 1080      		move.b	%d0,(%a0)	| Do the write
 123 8047e 5240      		addq		#1, %d0		| Increment the pattern
 124 80480 2408      		move.l	%a0, %d2	| Copy a0 to d2 for shift
 125 80482 E38A      		lsl.l		#1, %d2		| Shift temp addr
 126 80484 2042      		move.l	%d2, %a0	| Put back into addr reg
 127 80486 0C82 0008 		cmp.l		#0x00080000,%d2
 127      0000 
 128 8048c 6600 FFEE 		bne			loopAdrFill
 129               	| Check
 130 80490 7001      		move.l	#1, %d0
 131 80492 7401      		move.l	#1, %d2
 132 80494 207C 0000 		move.l	#1, %a0
 132      0001 
 133               	loopAdrCk:
 134 8049a 1210      		move.b	(%a0), %d1	| Do the read (as a byte)
 135 8049c B200      		cmp.b		%d0, %d1
 136 8049e 6600 0062 		bne			failAdrTest
 137 804a2 5240      		addq		#1, %d0
 138 804a4 2408      		move.l	%a0, %d2 
 139 804a6 E38A      		lsl.l		#1, %d2
 140 804a8 2042      		move.l	%d2, %a0
 141 804aa 0C82 0008 		cmp.l		#0x00080000,%d2
 141      0000 
 142 804b0 6600 FFE8 		bne			loopAdrCk
 143               		
 144               	|
 145               	| Fill SRAM with 0x00 values
 146               	| 512KB fill takes about 2.5 seconds at 10 MHz CPU speed
68K GAS  S68K_002.s 			page 4


 147               	|
 148               	fillSRAM:
 149 804b4 41F8 0000 		lea		RAM_START, %a0		| Start at base RAM address
 150 804b8 43F9 0007 		lea		RAM_END, %a1		| End when reach end RAM space
 150      FFFF 
 151 804be 7000      		move.l	#0x00, %d0			| Fill with zeros
 152               	fillSRAMLoop:
 153 804c0 20C0      		move.l	%d0, (%a0)+			| Long fills are faster
 154 804c2 B3C8      		cmpa.l	%a0, %a1
 155 804c4 6E00 FFFA 		bgt		fillSRAMLoop
 156               	
 157               	|
 158               	| Done with address test of SRAM
 159               	|
 160 804c8 4EBA 05A0 		jsr     initDuart       	| Setup the serial port
 161               	monitorStart:					| Warm start
 162 804cc 41FA 068B 		lea		BANNER_MSG, %a0
 163 804d0 4EBA 005E 		jsr		printString1
 164 804d4 41FA 066E 		lea		RAM_PASS_MSG, %a0
 165 804d8 4EBA 0056 		jsr		printString1
 166               	|
 167               	| Interpreter Loop
 168               	|
 169               	interpLoop:
 170 804dc 41FA 0724 	    lea     msgPrompt, %a0	| Prompt
 171 804e0 6100 004E 	    bsr.w   printString
 172 804e4 13FC 0004 		move.b	#0x04, OPR		| Turn on LED
 172      000F 001E 
 173 804ec 4EBA 0074 		jsr		readLine		| Blocking read of line
 174 804f0 13FC 0004 		move.b	#0x04, OPS		| Turn off LED
 174      000F 001C 
 175 804f8 4EBA 00FA 		jsr		lineToUpper
 176 804fc 4EBA 0114 		jsr		parseLine
 177 80500 60DA      		bra.s	interpLoop
 178               		
 179               	failBitTest:
 180               	failAdrTest:
 181               	FERVR2:
 182 80502 4E71      		nop
 183 80504 4EFA FFFC 		jmp	FERVR2
 184               	
 185               	|||||
 186               	| Writes a character to Port A, blocking if not ready (Full buffer)
 187               	|  - Takes a character in D0
 188               	outChar1:
 189               	outChar:
 190 80508 0839 0002 	    btst    #2, SRA      | Check if transmitter ready bit is set
 190      000F 0002 
 191 80510 6700 FFF6 	    beq     outChar1     
 192 80514 13C0 000F 	    move.b  %d0, TBA      | Transmit Character
 192      0006 
 193 8051a 4E75      	    rts
 194               	
 195               	| Writes a character to Port A, blocking if not ready (Full buffer)
 196               	|  - Takes a character in D0
 197               	outChar2:
 198 8051c 0839 0002 	    btst    #2, SRB      | Check if transmitter ready bit is set
68K GAS  S68K_002.s 			page 5


 198      000F 0012 
 199 80524 6700 FFF6 	    beq     outChar2     
 200 80528 13C0 000F 	    move.b  %d0, TBB      | Transmit Character
 200      0016 
 201 8052e 4E75      	    rts
 202               	
 203               	******
 204               	* Print a null terminated string
 205               	*
 206               	printString1:
 207               	printString:
 208               	PSloop:
 209 80530 1018      	    move.b  (%a0)+, %d0  | Read in character
 210 80532 6704      	    beq.s   PSend         | Check for the null
 211               	    
 212 80534 61D2      	    bsr.s   outChar      | Otherwise write the character
 213 80536 60F8      	    bra.s   PSloop        | And continue
 214               	PSend:
 215 80538 4E75      	    rts
 216               	
 217               	
 218               	|||||
 219               	| Reads in a character from Port A, blocking if none available
 220               	|  - Returns character in D0
 221               	|    
 222               	inChar1:
 223               	inChar:
 224 8053a 0839 0000 	    btst    #0,  SRA	| Check if receiver ready bit is set
 224      000F 0002 
 225 80542 6700 FFF6 	    beq     inChar1
 226 80546 1039 000F 	    move.b  RBA, %d0	| Read Character into D0
 226      0006 
 227 8054c 4E75      	    rts
 228               	
 229               	inChar2:
 230 8054e 0839 0000 	    btst    #0,  SRB	| Check if receiver ready bit is set
 230      000F 0012 
 231 80556 6700 FFF6 	    beq     inChar2
 232 8055a 1039 000F 	    move.b  RBB, %d0	| Read Character into D0
 232      0016 
 233 80560 4E75      	    rts
 234               	
 235               	| Read in a line into the line buffer
 236               	readLine:
 237 80562 48E7 2020 	    movem.l %d2/%a2, -(%SP)     | Save changed registers
 238 80566 45F9 0007 	    lea     varLineBuf, %a2   	| Start of the lineBuffer
 238      FBAE 
 239 8056c B542      	    eor.w   %d2, %d2           	| Clear the character counter
 240               	 RLloop:
 241 8056e 6100 FFCA 	    bsr.w   inChar           	| Read a character from the serial port
 242 80572 0C00 0008 	    cmp.b   #BKSP, %d0        	| Is it a backspace?
 243 80576 6722      	    beq.s   RLBS
 244 80578 0C00 0018 	    cmp.b   #CTRLX, %d0       	| Is it Ctrl-H (Line Clear)?
 245 8057c 673A      	    beq.s   RLlineClr
 246 8057e 0C00 000D 	    cmp.b   #CR, %d0          	| Is it a carriage return?
 247 80582 6758      	    beq.s   RLEndLn
 248 80584 0C00 000A 	    cmp.b   #LF, %d0          	| Is it anything else but a LF?
68K GAS  S68K_002.s 			page 6


 249 80588 67E4      	    beq.s   RLloop            	| Ignore LFs and get the next character
 250               	 .char:                      	| Normal character to be inserted into the buffer
 251 8058a 0C42 0050 	    cmp.w   #MAX_LINE_LENGTH, %d2
 252 8058e 6CDE      	    bge.s   RLloop            	| If the buffer is full ignore the character
 253 80590 14C0      	    move.b  %d0, (%a2)+        	| Otherwise store the character
 254 80592 5242      	    addq.w  #1, %d2           	| Increment character count
 255 80594 6100 FF72 	    bsr.w   outChar          	| Echo the character
 256 80598 60D4      	    bra.s   RLloop            	| And get the next one
 257               	 RLBS:
 258 8059a 4A42      	    tst.w   %d2               	| Are we at the beginning of the line?
 259 8059c 67D0      	    beq.s   RLloop            	| Then ignore it
 260 8059e 6100 FF68 	    bsr.w   outChar          	| Backspace
 261 805a2 103C 0020 	    move.b  #' ', %d0
 262 805a6 6100 FF60 	    bsr.w   outChar          	| Space
 263 805aa 103C 0008 	    move.b  #BKSP, %d0
 264 805ae 6100 FF58 	    bsr.w   outChar          	| Backspace
 265 805b2 538A      	    subq.l  #1, %a2           	| Move back in the buffer
 266 805b4 5382      	    subq.l  #1, %d2           	| And current character count
 267 805b6 60B6      	    bra.s   RLloop            	| And goto the next character
 268               	 RLlineClr:
 269 805b8 4A42      	    tst     %d2               	| Anything to clear?
 270 805ba 67B2      	    beq.s   RLloop            	| If not, fetch the next character
 271 805bc 95C2      	    suba.l  %d2, %a2           	| Return to the start of the buffer
 272               	 RLlineClrloop:
 273 805be 103C 0008 	    move.b  #BKSP, %d0
 274 805c2 6100 FF44 	    bsr.w   outChar          	| Backspace
 275 805c6 103C 0020 	    move.b  #' ', %d0
 276 805ca 6100 FF3C 	    bsr.w   outChar          	| Space
 277 805ce 103C 0008 	    move.b  #BKSP, %d0
 278 805d2 6100 FF34 	    bsr.w   outChar          	| Backspace
 279 805d6 5342      	    subq.w  #1, %d2          
 280 805d8 66E4      	    bne.s   RLlineClrloop   	| Go till the start of the line
 281 805da 6092      	    bra.s   RLloop   
 282               	 RLEndLn:
 283 805dc 6100 FF2A 	    bsr.w   outChar          	| Echo the CR
 284 805e0 103C 000A 	    move.b  #LF, %d0
 285 805e4 6100 FF22 	    bsr.w   outChar          	| Line feed to be safe
 286 805e8 14BC 0000 	    move.b  #0, (%a2)         	| Terminate the line (Buffer is longer than max to allow this at ful
 287 805ec 204A      	    movea.l %a2, %a0           	| Ready the pointer to return (if needed)
 288 805ee 4CDF 0404 	    movem.l (%SP)+, %d2/%a2     | Restore registers
 289 805f2 4E75      	    rts                      	| And return
 290               	
 291               	
 292               	| Convert line buffer to upper case
 293               	lineToUpper:
 294 805f4 41F9 0007 	    lea     varLineBuf, %a0   | Get the start of the line buffer
 294      FBAE 
 295               	 LUloop:
 296 805fa 1010      	    move.b  (%a0), %d0        | Read in a character
 297 805fc 0C00 0061 	    cmp.b   #'a', %d0         
 298 80600 6D0A      	    blt.s   LUnext            | Is it less than lower-case 'a', then move on
 299 80602 0C00 007A 	    cmp.b   #'z', %d0
 300 80606 6E04      	    bgt.s   LUnext            | Is it greater than lower-case 'z', then move on
 301 80608 0400 0020 	    sub.b   #0x20, %d0         | Then convert a to A, b to B, etc.
 302               	 LUnext:
 303 8060c 10C0      	    move.b  %d0, (%a0)+       | Store the character back into a0, and move to the next
 304 8060e 66EA      	    bne.s   LUloop             | Keep going till we hit a null terminator
68K GAS  S68K_002.s 			page 7


 305 80610 4E75      	    rts
 306               	
 307               	|
 308               	| Parse Line
 309               	|
 310               	parseLine:
 311 80612 48E7 0030 	    movem.l %a2-%a3, -(%SP)     | Save registers
 312 80616 41F9 0007 	    lea     varLineBuf, %a0
 312      FBAE 
 313               	 PLfindCommand:
 314 8061c 1018      	    move.b  (%a0)+, %d0
 315 8061e 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 316 80622 6700 FFF8 	    beq.w   PLfindCommand    
 317 80626 0C00 0045 	    cmp.b   #'E', %d0           | Examine command
 318 8062a 6700 005A 	    beq.w   .examine
 319 8062e 0C00 0044 	    cmp.b   #'D', %d0           | Deposit command
 320 80632 6700 0358 	    beq.w   .deposit
 321 80636 0C00 0052 	    cmp.b   #'R', %d0           | Run command
 322 8063a 6700 03B4 	    beq.w   .run
 323 8063e 0C00 0048 	    cmp.b   #'H', %d0           | Help command
 324 80642 6700 001E 	    beq.w   .help
 325 80646 0C00 004C 	    cmp.b   #'L', %d0           | Help command
 326 8064a 6700 00C4 	    beq.w   loadSRec
 327 8064e 0C00 0000 	    cmp.b   #0, %d0             | Ignore blank lines
 328 80652 6708      	    beq.s   .exit               
 329               	 .invalid:   
 330 80654 41FA 0516 	    lea     msgInvalidCommand, %a0
 331 80658 6100 FED6 	    bsr.w   printString
 332               	 .exit:
 333 8065c 4CDF 0C00 	    movem.l (%SP)+, %a2-%a3     | Restore registers
 334 80660 4E75      	    rts
 335               	
 336               	|||||||||||||||||||||||||||||||
 337               	|| HELP command
 338               	 .help:
 339 80662 41FA 051D 	    lea     msgHelp, %a0
 340 80666 6100 FEC8 	    bsr.w   printString
 341 8066a 6000 FFF0 	    bra.w   .exit
 342               	 .invalidAddr:
 343 8066e 41FA 0570 	    lea     msgInvalidAddress, %a0
 344 80672 6100 FEBC 	    bsr.w   printString
 345 80676 6000 FFE4 	    bra.w   .exit
 346               	 .invalidVal:
 347 8067a 41FA 0576 	    lea     msgInvalidValue, %a0
 348 8067e 6100 FEB0 	    bsr.w   printString
 349 80682 6000 FFD8 	    bra.w   .exit
 350               		
 351               	|||||||||||||||||||||||||||||||
 352               	| Examines memory addresses
 353               	| Valid modes:
 354               	|   e ADDR                  Displays a single byte
 355               	|   e ADDR-ADDR             Dispalys all bytes between the two addresses
 356               	|   e ADDR+LEN              Dispays LEN bytes after ADDR
 357               	|   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
 358               	|   e ADDR.                 Quick line, displays one line 
 359               	.examine:
 360 80686 6100 0208 	    bsr.w   parseNumber         | Read in the start address
68K GAS  S68K_002.s 			page 8


 361 8068a 4A01      	    tst.b   %d1                 | Make sure it's valid (parseNumber returns non-zero in d1 for fail
 362 8068c 6600 FFE0 	    bne.w   .invalidAddr        
 363 80690 2640      	    move.l  %d0, %a3            | Save the start address
 364               	 .exloop:
 365 80692 1018      	    move.b  (%a0)+, %d0
 366 80694 0C00 0020 	    cmp.b   #' ', %d0           | Ignore spaces
 367 80698 67F8      	    beq.s   .exloop
 368 8069a 0C00 002D 	    cmp.b   #'-', %d0           | Check if it's a range specifier
 369 8069e 6716      	    beq.s   .exrange
 370 806a0 0C00 002B 	    cmp.b   #'+', %d0           | Check if it's a length specifier
 371 806a4 6722      	    beq.s   .exlength
 372 806a6 0C00 003B 	    cmp.b   #';', %d0           | Check if we're going interactive
 373 806aa 672E      	    beq.s   .exinter
 374 806ac 0C00 002E 	    cmp.b   #'.', %d0           | Check if quick 16 
 375 806b0 6712      	    beq.s   .exquick
 376 806b2 7001      	    move.l  #1, %d0             | Otherwise read in a single byte
 377 806b4 601C      	    bra.s   .exend              
 378               	 .exrange:
 379 806b6 6100 01D8 	    bsr.w   parseNumber         | Find the end address
 380 806ba 4A01      	    tst.b   %d1                 | Check if we found a valid address
 381 806bc 6600 FFB0 	    bne.w   .invalidAddr
 382 806c0 908B      	    sub.l   %a3, %d0            | Get the length
 383 806c2 600E      	    bra.s   .exend
 384               	 .exquick:                      | Quick mode means show one line of 16 bytes
 385 806c4 7010      	    move.l  #0x10, %d0
 386 806c6 600A      	    bra.s   .exend
 387               	 .exlength:                     | Length mode means a length is specified
 388 806c8 6100 01C6 	    bsr.w   parseNumber         | Find the length
 389 806cc 4A01      	    tst.b   %d1
 390 806ce 6600 FF9E 	    bne.w   .invalidAddr
 391               	 .exend:                        | Done parsing, give the parameters to dumpRAM and exit
 392 806d2 204B      	    move.l  %a3, %a0
 393 806d4 6100 021C 	    bsr.w   dumpRAM
 394 806d8 6082      	    bra.s   .exit
 395               	 .exinter:                      | Interactive mode, Space shows 16 lines, enter shows 1.
 396 806da 204B      	    move.l  %a3, %a0            | Current Address
 397 806dc 7010      	    move.l  #0x10, %d0          | 16 bytes
 398 806de 6100 0212 	    bsr.w   dumpRAM             | Dump this line
 399 806e2 D7FC 0000 	    add.l   #0x10, %a3          | Move up the current address 16 bytes
 399      0010 
 400               	 .exinterend:
 401 806e8 6100 FE50 	    bsr.w   inChar
 402 806ec 0C00 000D 	    cmp.b   #CR, %d0            | Display another line
 403 806f0 67E8      	    beq.s   .exinter
 404 806f2 0C00 0020 	    cmp.b   #' ', %d0           | Display a page (256 bytes at a time)
 405 806f6 6704      	    beq.s   .exinterpage
 406 806f8 6000 FF62 	    bra	   .exit               | Otherwise exit
 407               	 .exinterpage:
 408 806fc 204B      	    move.l  %a3, %a0
 409 806fe 203C 0000 	    move.l  #0x100, %d0         | 256 bytes
 409      0100 
 410 80704 6100 01EC 	    bsr.w   dumpRAM             | Dump 16 lines of RAM
 411 80708 D7FC 0000 	    add.l   #0x100, %a3         | Move up the current address by 256
 411      0100 
 412 8070e 60D8      	    bra.s   .exinterend
 413               	
 414               	|||||||||||||||||||||||||||||
68K GAS  S68K_002.s 			page 9


 415               	|| Load S Record
 416               	|	srecType:	ds.b	1		| S1-S9 stored as binary 1-9
 417               	|	srecByCt:	ds.b	1		| Byte Count
 418               	|	srecData:	ds.b	1 		| Data
 419               	|	srecCSum:	ds.b	1 		| S-Record Checksum
 420               	|	srecAddr:	ds.l	1		| S Record current byte address
 421               	|
 422               	| Supports S record types (matches gcc m68k output)
 423               	|	S00F00005336384B5F3030322E746D7074
 424               	|	S2240800000007FFFC00080400000000000000000000000000000000000000000000000000C5
 425               	|	S503005BA1
 426               	|
 427               	| Also supports S1 records
 428               	|	S00F00005336384B5F3030332E746D7073
 429               	|	S123100013FC0000000F001A13FC00FC000F001E13FC0004000F001C13FC0004000F001EDE
 430               	|	S1231020203C000186A053806600FFFC13FC0004000F001C203C000186A053806600FFFC00
 431               	|	S10710406000FFD673
 432               	|	S5030003F9
 433               	|
 434               	
 435               	loadSRec:
 436 80710 41FA 04BE 	    lea     ldSRecMsg, %a0					| "Load S-Record"
 437 80714 6100 FE1A 	    bsr.w   printString
 438               	loadSRecLoop:
 439 80718 6100 0096 		bsr		setRecType
 440 8071c 6100 00AC 		bsr		setBytCt
 441 80720 11FC 0000 		move.b 	#0, srecCSum
 441      0403 
 442 80726 6100 00EC 		bsr		setAddr
 443               	|	lea		debug_Srec_LDData_Msg, %a0		| "Load Data Loop start"
 444               	|	bsr		printString
 445 8072a 0C38 0001 		cmp.b	#1, srecType			| 16-bit Address
 445      0400 
 446 80730 6700 0010 		beq		loopSData
 447 80734 0C38 0002 		cmp.b	#2, srecType			| 24-bit Address
 447      0400 
 448 8073a 6700 0006 		beq		loopSData
 449 8073e 6000 0014 		bra		sRecDataDone
 450               	loopSData:
 451 80742 0C38 0000 		cmp.b 	#0, srecByCt
 451      0401 
 452 80748 6700 000A 		beq		sRecDataDone
 453 8074c 6100 003E 		bsr		getSetLdData
 454 80750 6000 FFF0 		bra		loopSData
 455               	sRecDataDone:
 456 80754 6100 0050 		bsr		getChksum
 457 80758 103C 002B 		move.b	#'+', %d0
 458 8075c 6100 FDAA 		bsr		outChar
 459 80760 0C38 0000 		cmp.b	#0, srecType
 459      0400 
 460 80766 6700 FFB0 		beq		loadSRecLoop
 461 8076a 0C38 0001 		cmp.b	#1, srecType
 461      0400 
 462 80770 6700 FFA6 		beq		loadSRecLoop
 463 80774 0C38 0002 		cmp.b	#2, srecType
 463      0400 
 464 8077a 6700 FF9C 		beq		loadSRecLoop
68K GAS  S68K_002.s 			page 10


 465 8077e 0C38 0003 		cmp.b	#3, srecType
 465      0400 
 466 80784 6700 FF92 		beq		loadSRecLoop
 467 80788 6000 FED2 		bra.w   .exit
 468               	
 469               	|||||||||||||||||||||||||||||
 470               	getSetLdData:
 471 8078c 4EBA 004E 		jsr		getHexPair
 472 80790 41F8 0404 		lea 	srecAddr, %a0
 473 80794 2250      		move.l	(%a0), %a1
 474 80796 12C0      		move.b	%d0, (%a1)+
 475 80798 21C9 0404 		move.l	%a1, srecAddr
 476 8079c D138 0403 		add.b	%d0, srecCSum
 477 807a0 5338 0401 		sub.b	#1, srecByCt
 478               	skipLdData:
 479 807a4 4E75      		rts
 480               	
 481               	|||||||||||||||||||||||||||||
 482               	getChksum:
 483               	|	lea		debug_Srec_CSum_Msg, %a0	| "S Record Checksum="
 484               	|	bsr.w   printString
 485 807a6 4EBA 0034 		jsr		getHexPair
 486 807aa D138 0403 		add.b	%d0, srecCSum
 487               	|	move.b	srecCSum, %d0
 488               	|	jsr		printHexByte
 489               	|	lea		CRLF_MSG, %a0
 490               	|	bsr.w   printString
 491               	failCSUM:
 492 807ae 4E75      		rts
 493               	
 494               	|||||||||||||||||||||||||||||
 495               	setRecType:
 496 807b0 4EBA FD88 		jsr		inChar
 497 807b4 0C00 0053 		cmp.b	#'S', %d0
 498 807b8 6600 FFF6 		bne		setRecType					| Toss extra chars
 499 807bc 4EBA FD7C 		jsr		inChar
 500 807c0 0200 000F 		andi.b	#0x0f, %d0
 501 807c4 11C0 0400 		move.b	%d0, srecType
 502               	| Debug messages follow
 503               	|	lea		debug_Srec_Typ_Msg, %a0		| "S Record Type="
 504               	|	bsr.w   printString
 505               	|	move.b	srecType, %d0
 506               	|	add.b	#'0', %d0
 507               	|	jsr		outChar
 508               	|	lea		CRLF_MSG, %a0
 509               	|	bsr.w   printString
 510               	| Debug messages end
 511 807c8 4E75      		rts
 512               		
 513               	|||||||||||||||||||||||||||||
 514               	setBytCt:
 515 807ca 4EBA 0010 		jsr		getHexPair
 516 807ce 11C0 0403 		move.b 	%d0, srecCSum				| Initialize checksum
 517 807d2 11C0 0401 		move.b	%d0, srecByCt				| Byte count
 518               	| Debug messages follow
 519               	|	lea		debug_Srec_BytCt_Msg, %a0	| "S Record Byte Count=0x"
 520               	|	bsr.w   printString
68K GAS  S68K_002.s 			page 11


 521               	|	move.b	srecByCt, %d0
 522               	|	jsr		printHexByte
 523               	|	lea		CRLF_MSG, %a0
 524               	|	bsr		printString
 525               	| Debug messages end
 526 807d6 5338 0401 		sub.b	#1, srecByCt
 527 807da 4E75      		rts
 528               	
 529               	|||||||||||||||||||||||||||||
 530               	getHexPair:
 531 807dc 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 532 807e0 4EBA FD58 		jsr		inChar
 533 807e4 4EBA 0016 		jsr		toNibble
 534 807e8 E900      		asl.b	#4, %d0
 535 807ea 1400      		move.b	%d0, %d2
 536 807ec 4EBA FD4C 		jsr		inChar
 537 807f0 4EBA 000A 		jsr		toNibble
 538 807f4 8002      		or.b	%d2, %d0
 539 807f6 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 540 807fa 4E75      		rts
 541               	
 542               	|||||||||||||||||||||||||||||
 543               	toNibble:
 544 807fc 0C00 0041 		cmp.b	#'A', %d0
 545 80800 6C00 0008 		bge		doHexLetter
 546 80804 0400 0030 		sub.b	#'0', %d0
 547 80808 4E75      		rts
 548               	doHexLetter:
 549 8080a 0400 0041 		sub.b	#'A', %d0
 550 8080e 0600 000A 		add.b	#10, %d0
 551 80812 4E75      		rts
 552               	
 553               	|||||||||||||||||||||||||||||
 554               	setAddr:
 555 80814 48E7 2000 		movem.l %d2, -(%SP)		| Save registers
 556 80818 0C38 0002 		cmp.b	#2, srecType
 556      0400 
 557 8081e 6600 0052 		bne		adrLen16
 558 80822 21FC 0000 		move.l	#0, srecAddr
 558      0000 0404 
 559               	|	lea		debug_S2rec_Addr_Msg, %a0
 560               	|	bsr		printString
 561 8082a 7400      		move.l	#0, %d2			| d2 stores address for accumulation of bytes
 562               		| Get the upper 8-bits of 24-bits
 563 8082c 4EBA FFAE 		jsr		getHexPair
 564 80830 0280 0000 		and.l	#0xff, %d0
 564      00FF 
 565 80836 D138 0403 		add.b 	%d0, srecCSum
 566 8083a 8480      		or.l	%d0, %d2
 567 8083c E182      		asl.l	#8, %d2
 568               	|	move.l	%d2, %d0
 569               	|	bsr		printHexLong
 570               	|	lea		CRLF_MSG, %a0
 571               	|   bsr.w   printString
 572               		| Get the middle 8-bits of 24-bits
 573 8083e 4EBA FF9C 		jsr		getHexPair
 574 80842 0280 0000 		and.l	#0xff, %d0
68K GAS  S68K_002.s 			page 12


 574      00FF 
 575 80848 D138 0403 		add.b 	%d0, srecCSum
 576 8084c 8480      		or.l	%d0, %d2
 577 8084e E182      		asl.l	#8, %d2
 578               	|	move.l	%d2, %d0
 579               	|	bsr		printHexLong
 580               	|	lea		CRLF_MSG, %a0
 581               	|   bsr.w   printString
 582               		| Get the lower 8-bits of 24-bits
 583 80850 4EBA FF8A 		jsr		getHexPair
 584 80854 0280 0000 		and.l	#0xff, %d0
 584      00FF 
 585 8085a D138 0403 		add.b 	%d0, srecCSum
 586 8085e 8480      		or.l	%d0, %d2
 587 80860 0282 00FF 		andi.l	#0x00ffffff, %d2
 587      FFFF 
 588 80866 21C2 0404 		move.l	%d2, srecAddr		| Save the S record address
 589               	|	move.l	%d2, %d0
 590               	|	bsr		printHexLong
 591               	|	lea		CRLF_MSG, %a0
 592               	|	bsr.w   printString
 593 8086a 5738 0401 		sub.b	#3, srecByCt
 594 8086e 6000 001A 		bra		past16
 595               	adrLen16:
 596               	|	lea		debug_SXrec_Addr_Msg, %a0	| "S (not 2) Record Address=0x"
 597               	|	bsr		printString
 598 80872 7400      		move.l	#0, %d2
 599 80874 4EBA FF66 		jsr		getHexPair
 600               	|	bsr		printHexLong
 601               	|	lea		CRLF_MSG, %a0
 602               	|   bsr.w   printString
 603 80878 8480      		or.l	%d0, %d2
 604 8087a E182      		asl.l	#8, %d2
 605 8087c 4EBA FF5E 		jsr		getHexPair
 606               	|	bsr		printHexLong
 607               	|	lea		CRLF_MSG, %a0
 608               	|	bsr.w   printString
 609 80880 8480      		or.l	%d0, %d2
 610 80882 21C2 0404 		move.l	%d2, srecAddr
 611 80886 5538 0401 		sub.b	#2, srecByCt
 612               	past16:
 613 8088a 4CDF 0004 		movem.l (%SP)+, %d2		| Restore registers
 614 8088e 4E75      		rts
 615               			
 616               	|||||||||||||||||||||||||||||
 617               	| Find and parse a hex number
 618               	|  Starting address in A0
 619               	|  Number returned in D0
 620               	|  Status in D1   (0 success, 1 fail)
 621               	|  TODO: Try and merge first digit code with remaining digit code
 622               	parseNumber:
 623 80890 B180      	    eor.l   %d0, %d0		| Zero out d0
 624 80892 1018      	    move.b  (%a0)+, %d0
 625 80894 0C00 0020 	    cmp.b   #' ', %d0		|  Ignore all leading spaces
 626 80898 67F6      	    beq.s   parseNumber
 627 8089a 0C00 0030 	    cmp.b   #'0', %d0       | Look for hex digits 0-9
 628 8089e 6D14      	    blt.s	PNinvalid
68K GAS  S68K_002.s 			page 13


 629 808a0 0C00 0039 	    cmp.b   #'9', %d0
 630 808a4 6F18      	    ble.s   PNfirstdigit1
 631               	
 632 808a6 0C00 0041 	    cmp.b   #'A', %d0      	| Look for hex digits A-F
 633 808aa 6D00 FDA8 	    blt   .invalid    
 634 808ae 0C00 0046 	    cmp.b   #'F', %d0
 635 808b2 6F04      	    ble.s   PNfirstdigit2
 636               	PNinvalid:
 637 808b4 7201      	    move.l  #1, %d1			| Invalid character, mark failure and return
 638 808b6 4E75      	    rts
 639               	PNfirstdigit2:
 640 808b8 0400 0037 	    sub.b   #'7', %d0       | Turn 'A' to 10
 641 808bc 6004      	    bra.s   PNloop
 642               	PNfirstdigit1:
 643 808be 0400 0030 	    sub.b   #'0', %d0       | Turn '0' to 0
 644               	 PNloop:
 645 808c2 1218      	    move.b  (%a0)+, %d1      | Read in a digit
 646 808c4 0C01 0030 	    cmp.b   #'0', %d1       | Look for hex digits 0-9
 647 808c8 6D12      	    blt.s   PNend         	| Any other characters mean we're done reading
 648 808ca 0C01 0039 	    cmp.b   #'9', %d1
 649 808ce 6F18      	    ble.s   PNdigit1
 650 808d0 0C01 0041 	    cmp.b   #'A', %d1      	| Look for hex digits A-F
 651 808d4 6D06      	    blt.s   PNend
 652 808d6 0C01 0046 	    cmp.b   #'F', %d1
 653 808da 6F06      	    ble.s   PNdigit2
 654               	
 655               	PNend:                       | We hit a non-hex digit character, we're done parsing
 656 808dc 5388      	    subq.l  #1, %a0         | Move the pointer back before the end character we read
 657 808de 7200      	    move.l  #0, %d1
 658 808e0 4E75      	    rts
 659               	PNdigit2:
 660 808e2 0401 0037 	    sub.b   #'7', %d1		| Turn 'A' to 10
 661 808e6 6004      	    bra.s   PNdigit3
 662               	PNdigit1:
 663 808e8 0401 0030 	    sub.b   #'0', %d1       | Turn '0' to 0
 664               	PNdigit3:
 665 808ec E988      	    lsl.l   #4, %d0        	| Shift over to the next nybble
 666 808ee D001      	    add.b   %d1, %d0       	| Place in our current nybble (could be or.b instead)
 667 808f0 60D0      	    bra.s   PNloop
 668               	    
 669               	
 670               	|||||||||||||||||||||||||||||
 671               	| Dumps a section of RAM to the screen
 672               	| Displays both hex values and ASCII characters
 673               	| d0 - Number of bytes to dump
 674               	| a0 - Start Address
 675               	dumpRAM:
 676 808f2 48E7 3820 	    movem.l %d2-%d4/%a2, -(%SP) | Save registers
 677 808f6 2448      	    move.l  %a0, %a2           	| Save the start address
 678 808f8 2400      	    move.l  %d0, %d2           	| And the number of bytes
 679               	 .line:
 680 808fa 200A      	    move.l  %a2, %d0          
 681 808fc 6100 010E 	    bsr.w   printHexAddr     	| Starting address of this line
 682 80900 41FA 0303 	    lea     msgColonSpace, %a0
 683 80904 6100 FC2A 	    bsr.w   printString
 684 80908 7610      	    move.l  #16, %d3         	| 16 Bytes can be printed on a line
 685 8090a 2803      	    move.l  %d3, %d4       		| Save number of bytes on this line
68K GAS  S68K_002.s 			page 14


 686               	 .hexbyte:
 687 8090c 4A82      	    tst.l   %d2               	| Check if we're out of bytes
 688 8090e 6718      	    beq.s   .endbytesShort
 689 80910 4A03      	    tst.b   %d3               	| Check if we're done this line
 690 80912 673A      	    beq.s   .endbytes    
 691 80914 101A      	    move.b  (%a2)+, %d0        	| Read a byte in from RAM
 692 80916 6100 011C 	    bsr.w   printHexByte     	| Display it
 693 8091a 103C 0020 	    move.b  #' ', %d0
 694 8091e 6100 FBE8 	    bsr.w   outChar          	| Space out bytes
 695 80922 5383      	    subq.l  #1, %d3    
 696 80924 5382      	    subq.l  #1, %d2        
 697 80926 60E4      	    bra.s   .hexbyte
 698               	 .endbytesShort:
 699 80928 9803      	    sub.b   %d3, %d4           	| Make d4 the actual number of bytes on this line
 700 8092a 103C 0020 	    move.b  #' ', %d0
 701               	 .endbytesShortLoop:
 702 8092e 4A03      	    tst.b   %d3               	| Check if we ended the line
 703 80930 671C      	    beq.s   .endbytes
 704 80932 103C 0020 	    move.b  #' ', %d0
 705 80936 6100 FBD0 	    bsr.w   outChar          	| Three spaces to pad out
 706 8093a 103C 0020 	    move.b  #' ', %d0
 707 8093e 6100 FBC8 	    bsr.w   outChar
 708 80942 103C 0020 	    move.b  #' ', %d0
 709 80946 6100 FBC0 	    bsr.w   outChar
 710               	    
 711 8094a 5303      	    subq.b  #1, %d3
 712 8094c 60E0      	    bra.s   .endbytesShortLoop
 713               	 .endbytes:
 714 8094e 95C4      	    suba.l  %d4, %a2        	| Return to the start address of this line
 715               	 .endbytesLoop:
 716 80950 4A04      	    tst.b   %d4               	| Check if we are done printing ascii
 717 80952 6700 0022 	    beq     .endline    
 718 80956 5304      	    subq.b  #1, %d4
 719 80958 101A      	    move.b  (%a2)+, %d0        	| Read the byte again
 720 8095a 0C00 0020 	    cmp.b   #' ', %d0         	| Lowest printable character
 721 8095e 6D0C      	    blt.s   .unprintable
 722 80960 0C00 007E 	    cmp.b   #'~', %d0         	| Highest printable character
 723 80964 6E06      	    bgt.s   .unprintable
 724 80966 6100 FBA0 	    bsr.w   outChar
 725 8096a 60E4      	    bra.s   .endbytesLoop
 726               	 .unprintable:
 727 8096c 103C 002E 	    move.b  #'.', %d0
 728 80970 6100 FB96 	    bsr.w   outChar
 729 80974 60DA      	    bra.s   .endbytesLoop
 730               	 .endline:
 731 80976 41FA 0290 	    lea     msgNewline, %a0
 732 8097a 6100 FBB4 	    bsr.w   printString
 733 8097e 4A82      	    tst.l   %d2
 734 80980 6F04      	    ble.s   .end
 735 80982 6000 FF76 	    bra.w   .line
 736               	 .end:
 737 80986 4CDF 041C 	    movem.l (%SP)+, %d2-%d4/%a2		| Restore registers
 738 8098a 4E75      	    rts
 739               	
 740               	|||||||||||||||||||||||
 741               	| Deposit values into RAM
 742               	| d ADDR VAL VAL            Deposit value(s) into RAM
68K GAS  S68K_002.s 			page 15


 743               	| d ADDR VAL VAL;           Deposit values, continue with values on next line
 744               	|  VAL VAL VAL;              - Continuing with further continue
 745               	| d: VAL VAL                Continue depositing values after the last address written to
 746               	|||||||||||||||||||||||
 747               	.deposit:
 748 8098c 1010      	    move.b  (%a0), %d0
 749 8098e 0C00 003A 	    cmp.b   #':', %d0       	| Check if we want to continue from last
 750 80992 6730      	    beq.s   DepCont
 751               	    
 752 80994 6100 FEFA 	    bsr.w   parseNumber         | Otherwise read the address
 753 80998 4A01      	    tst.b   %d1
 754 8099a 6600 FCD2 	    bne		.invalidAddr
 755 8099e 2640      	    move.l  %d0, %a3           	| Save the start address
 756               	 DepLoop:
 757 809a0 1010      	    move.b  (%a0), %d0            
 758 809a2 0C00 003B 	    cmp.b   #';', %d0          	| Check for continue
 759 809a6 6726      	    beq.s   DepMLine
 760 809a8 4A40      	    tst     %d0              	| Check for the end of line
 761 809aa 6700 003A 	    beq     DepEnd
 762               	    
 763 809ae 6100 FEE0 	    bsr		parseNumber         | Otherwise read a value
 764 809b2 4A01      	    tst.b   %d1
 765 809b4 6600 FCC4 	    bne		.invalidVal
 766 809b8 0C40 00FF 	    cmp.w   #255, %d0          	| Make sure it's a byte
 767 809bc 6E00 FCBC 	    bgt		.invalidVal
 768               	    
 769 809c0 16C0      	    move.b  %d0, (%a3)+        	| Store the value into memory
 770 809c2 60DC      	    bra.s   DepLoop
 771               	    
 772               	 DepCont:
 773 809c4 2679 0007 	    move.l  varCurAddr, %a3   	| Read in the last address 
 773      FBAA 
 774 809ca 5288      	    addq.l  #1, %a0           	| Skip over the ':'
 775 809cc 60D2      	    bra.s   DepLoop
 776               	    
 777               	 DepMLine:
 778 809ce 41FA 0186 	    lea     msgDepositPrompt, %a0
 779 809d2 6100 FB5C 	    bsr.w   printString
 780 809d6 6100 FB8A 	    bsr.w   readLine          	| Read in the next line to be parsed
 781 809da 6100 FC18 	    bsr.w   lineToUpper         | Convert to uppercase
 782 809de 41F9 0007 	    lea     varLineBuf, %a0    	| Reset our buffer pointer
 782      FBAE 
 783 809e4 60BA      	    bra.s   DepLoop            	| And jump back to decoding
 784               	 DepEnd:
 785 809e6 23CB 0007 	    move.l  %a3, varCurAddr
 785      FBAA 
 786 809ec 6000 FC6E 	    bra.w   .exit
 787               	
 788               	|||||||||||||||||||||||
 789               	| run code
 790               	 .run:
 791 809f0 6100 FE9E 	    bsr.w   parseNumber        	| Otherwise read the address
 792 809f4 4A01      	    tst.b   %d1
 793 809f6 6600 FC76 	    bne		.invalidAddr
 794 809fa 2040      	    move.l  %d0, %a0
 795 809fc 4E90      	    jsr     (%a0)             	| Jump to the code! 
 796               	                                | Go as subroutine to allow code to return to us
68K GAS  S68K_002.s 			page 16


 797 809fe 4EBA FACC 	    jsr     monitorStart        | Warm start after returning so everything is in
 798               	                                | a known state.
 799               	
 800               	
 801               	|||||||||||||||||||||||
 802               	|| KEEP All printHex functions together ||
 803               	|||||||||||||||||||||||
 804               	| Print a hex word
 805               	printHexWord:
 806 80a02 2F02      	    move.l  %d2, -(%SP)		| Save D2
 807 80a04 2400      	    move.l  %d0, %d2		| Save the address in d2
 808               	    
 809 80a06 E19A      	    rol.l   #0x8, %d2       | 4321 -> 3214
 810 80a08 E19A      	    rol.l   #0x8, %d2       | 3214 -> 2143 
 811 80a0a 6018      	    bra.s   printHex_wordentry  | Print out the last 16 bits
 812               	|||||||||||||||||||||||
 813               	| Print a hex 24-bit address
 814               	printHexAddr:
 815 80a0c 2F02      	    move.l %d2, -(%SP)   	| Save D2
 816 80a0e 2400      	    move.l %d0, %d2      	| Save the address in d2
 817               	    
 818 80a10 E19A      	    rol.l   #0x8, %d2     	| 4321 -> 3214
 819 80a12 600A      	    bra.s   printHex_addrentry  | Print out the last 24 bits
 820               	|||||||||||||||||||||||
 821               	* Print a hex long
 822               	printHexLong:
 823 80a14 2F02      	    move.l  %d2, -(%SP)     | Save D2
 824 80a16 2400      	    move.l  %d0, %d2        | Save the address in d2
 825               	    
 826 80a18 E19A      	    rol.l   #0x8, %d2        | 4321 -> 3214 high byte in low
 827 80a1a 2002      	    move.l  %d2, %d0
 828 80a1c 6116      	    bsr.s   printHexByte  	| Print the high byte (24-31)
 829               	printHex_addrentry:     
 830 80a1e E19A      	    rol.l   #0x8, %d2        	| 3214 -> 2143 middle-high byte in low
 831 80a20 2002      	    move.l  %d2, %d0              
 832 80a22 6110      	    bsr.s   printHexByte  	| Print the high-middle byte (16-23)
 833               	printHex_wordentry:    
 834 80a24 E19A      	    rol.l   #0x8, %d2        	| 2143 -> 1432 Middle byte in low
 835 80a26 2002      	    move.l  %d2, %d0
 836 80a28 610A      	    bsr.s   printHexByte  	| Print the middle byte (8-15)
 837 80a2a E19A      	    rol.l   #0x8, %d2
 838 80a2c 2002      	    move.l  %d2, %d0
 839 80a2e 6104      	    bsr.s   printHexByte  	| Print the low byte (0-7)
 840               	    
 841 80a30 241F      	    move.l (%SP)+, %d2      | Restore D2
 842 80a32 4E75      	    RTS
 843               	    
 844               	|||||||||||||||||||||||
 845               	| Print a hex byte
 846               	|  - Takes byte in D0
 847               	printHexByte:
 848 80a34 2F02      	    move.l  %D2, -(%SP)
 849 80a36 7400      		move.l	#0, %d2
 850 80a38 1400      	    move.b  %d0, %d2
 851 80a3a E808      	    lsr.b   #0x4, %d0		| Shift down upper nibble
 852 80a3c 0200 000F 		andi.b	#0xf, %d0
 853 80a40 0600 0030 	    add.b   #'0', %d0
68K GAS  S68K_002.s 			page 17


 854 80a44 0C00 0039 	    cmp.b   #'9', %d0		| Check if the hex number was from 0-9
 855 80a48 6F02      	    ble.s   PHBsecond
 856 80a4a 5E00      	    add.b   #0x7, %d0			| Shift 0xA-0xF from ':' to 'A'
 857               	PHBsecond:
 858 80a4c 6100 FABA 	    bsr   outChar			| Print the digit
 859 80a50 0202 000F 	    andi.b  #0x0F, %d2		| Now we want the lower digit Mask only the lower digit
 860 80a54 0602 0030 	    add.b   #'0', %d2
 861 80a58 0C02 0039 	    cmp.b   #'9', %d2     	| Same as before    
 862 80a5c 6F02      	    ble.s   PHBend
 863 80a5e 5E02      	    add.b   #0x7, %D2
 864               	PHBend:
 865 80a60 1002      	    move.b  %D2, %D0
 866 80a62 6100 FAA4 	    bsr	   outChar      	| Print the lower digit
 867 80a66 241F      	    move.l  (%SP)+, %D2
 868 80a68 4E75      	    rts
 869               		
 870               	
 871               	|||||
 872               	| Initializes the 68681 DUART port A as 9600 8N1 
 873               	initDuart:
 874 80a6a 13FC 0030 	    move.b  #0x30, CRA       | Reset Transmitter
 874      000F 0004 
 875 80a72 13FC 0020 	    move.b  #0x20, CRA       | Reset Receiver
 875      000F 0004 
 876 80a7a 13FC 0010 	    move.b  #0x10, CRA       | Reset Mode Register Pointer
 876      000F 0004 
 877               	    
 878 80a82 13FC 0080 	    move.b  #0x80, ACR       | Baud Rate Set #2
 878      000F 0008 
 879 80a8a 13FC 00BB 	    move.b  #0xBB, CSRA      | Set Tx and Rx rates to 9600
 879      000F 0002 
 880 80a92 13FC 0093 	    move.b  #0x93, MRA       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 880      000F 0000 
 881 80a9a 13FC 0007 	    move.b  #0x07, MRA       | Normal Mode, Not CTS/RTS, 1 stop bit
 881      000F 0000 
 882               	    
 883 80aa2 13FC 0005 	    move.b  #0x05, CRA       | Enable Transmit/Recieve
 883      000F 0004 
 884               	
 885 80aaa 13FC 0030 	    move.b  #0x30, CRB       | Reset Transmitter
 885      000F 0014 
 886 80ab2 13FC 0020 	    move.b  #0x20, CRB       | Reset Receiver
 886      000F 0014 
 887 80aba 13FC 0010 	    move.b  #0x10, CRB       | Reset Mode Register Pointer
 887      000F 0014 
 888               	    
 889 80ac2 13FC 00BB 	    move.b  #0xBB, CSRB      | Set Tx and Rx rates to 9600
 889      000F 0012 
 890 80aca 13FC 0093 	    move.b  #0x93, MRB       | 7-bit, No Parity (0x93 for 8-bit, 0x92 for 7-bit)
 890      000F 0010 
 891 80ad2 13FC 0007 	    move.b  #0x07, MRB       | Normal Mode, Not CTS/RTS, 1 stop bit
 891      000F 0010 
 892               	    
 893 80ada 13FC 0005 	    move.b  #0x05, CRB       | Enable Transmit/Recieve
 893      000F 0014 
 894               		
 895 80ae2 13FC 0000 		move.b	#0x00, OPC		 | Output port configuration (all bit are outs)
68K GAS  S68K_002.s 			page 18


 895      000F 001A 
 896 80aea 13FC 00FC 		move.b	#0xFC, OPR		 | Clear all outputs
 896      000F 001E 
 897 80af2 4E75      	    rts    
 898               	
 899               	delay1Sec:
 900 80af4 203C 0003 		move.l	#200000, %d0	| rough count
 900      0D40 
 901               	delay1Loop:
 902 80afa 5380      		sub.l	#1, %d0			
 903 80afc 6600 FFFC 		bne		delay1Loop
 904 80b00 4E75      		rts
 905               	
 906               	READINLINE:	  
 907 80b02 5265 6164 		.ascii  "Reading in line"
 907      696E 6720 
 907      696E 206C 
 907      696E 65
 908 80b11 0D0A 00   		dc.b CR,LF,EOT
 909               	L_TO_UPPER_MSG:  
 910 80b14 436F 6E76 		.ascii  "Convert line to upper case"
 910      6572 7420 
 910      6C69 6E65 
 910      2074 6F20 
 910      7570 7065 
 911 80b2e 0D0A 00   		dc.b CR,LF,EOT
 912               	WRITEOUTLINE:	  
 913 80b31 5772 6974 		.ascii  "Writing out line"
 913      696E 6720 
 913      6F75 7420 
 913      6C69 6E65 
 914 80b41 0D0A 00   		dc.b CR,LF,EOT
 915               	RAM_PASS_MSG:  
 916 80b44 5241 4D20 		.ascii  "RAM Test Passed"
 916      5465 7374 
 916      2050 6173 
 916      7365 64
 917 80b53 0D0A 00   		dc.b CR,LF,EOT
 918               	msgDepositPrompt:
 919 80b56 3A20      	    .ascii	": "
 920 80b58 00        		dc.b 	EOT
 921               	BANNER_MSG:	
 922 80b59 5349 4D50 		.ascii  "SIMPLE-68008 CPU"
 922      4C45 2D36 
 922      3830 3038 
 922      2043 5055 
 923 80b69 0D0A 00   		dc.b CR,LF,EOT
 924               	msgInvalidCommand:
 925 80b6c 496E 7661 	    .ascii "Invalid Command"
 925      6C69 6420 
 925      436F 6D6D 
 925      616E 64
 926 80b7b 0D0A 00   		dc.b CR,LF,EOT
 927               	CRLF_MSG:	
 928 80b7e 0D0A 00   		dc.b CR,LF,EOT
 929               	msgHelp:
 930 80b81 4176 6169 	    .ascii	"Available Commands: "
68K GAS  S68K_002.s 			page 19


 930      6C61 626C 
 930      6520 436F 
 930      6D6D 616E 
 930      6473 3A20 
 931 80b95 0D0A      		dc.b	CR,LF
 932 80b97 2028 4529 	    .ascii	" (E)xamine    (D)eposit    (R)un     (L)oad     (H)elp"
 932      7861 6D69 
 932      6E65 2020 
 932      2020 2844 
 932      2965 706F 
 933 80bcd 0D0A 00   		dc.b	CR,LF,EOT
 934               	ldSRecMsg:
 935 80bd0 4C6F 6164 	    .ascii	"Load S-Record"
 935      2053 2D52 
 935      6563 6F72 
 935      64
 936 80bdd 0D0A 00   		dc.b	CR,LF,EOT
 937               	msgInvalidAddress:
 938 80be0 496E 7661 	    .ascii	"Invalid Address"
 938      6C69 6420 
 938      4164 6472 
 938      6573 73
 939 80bef 0D0A 00   		dc.b 	CR,LF,EOT
 940               	msgInvalidValue:
 941 80bf2 496E 7661 	    .ascii	"Invalid Value"
 941      6C69 6420 
 941      5661 6C75 
 941      65
 942 80bff 0D0A 00   		dc.b	CR,LF,EOT
 943               	msgPrompt:
 944 80c02 3E20      		.ascii "> "
 945 80c04 00        	    dc.b EOT
 946               	msgColonSpace:
 947 80c05 3A20      	    .ascii ": "
 948 80c07 00        	    dc.b EOT
 949               	msgNewline:
 950 80c08 0D0A 00   	    dc.b CR,LF,EOT
 951               	debug_Srec_Typ_Msg:
 952 80c0b 5320 5265 		.ascii	"S Record Type="
 952      636F 7264 
 952      2054 7970 
 952      653D 
 953 80c19 00        	    dc.b EOT
 954               	debug_Srec_BytCt_Msg:
 955 80c1a 5320 5265 		.ascii	"S Record Byte Count=0x"
 955      636F 7264 
 955      2042 7974 
 955      6520 436F 
 955      756E 743D 
 956 80c30 00        	    dc.b EOT
 957               	debug_Srec_CSum_Msg:
 958 80c31 5320 5265 		.ascii	"S Record Checksum="
 958      636F 7264 
 958      2043 6865 
 958      636B 7375 
 958      6D3D 
 959 80c43 00        	    dc.b EOT
68K GAS  S68K_002.s 			page 20


 960               	debug_S2rec_Addr_Msg:
 961 80c44 5332 2052 		.ascii	"S2 Record Address=0x"
 961      6563 6F72 
 961      6420 4164 
 961      6472 6573 
 961      733D 3078 
 962 80c58 00        	    dc.b EOT
 963               	debug_SXrec_Addr_Msg:
 964 80c59 5320 286E 		.ascii	"S (not 2) Record Address=0x"
 964      6F74 2032 
 964      2920 5265 
 964      636F 7264 
 964      2041 6464 
 965 80c74 00        	    dc.b EOT
 966               	debug_Srec_LDData_Msg:
 967 80c75 4C6F 6164 	    .ascii	"Load Data Loop start"
 967      2044 6174 
 967      6120 4C6F 
 967      6F70 2073 
 967      7461 7274 
 968 80c89 0D0A 00   		dc.b 	CR,LF,EOT
 969               	
 970               	
 971               	MAX_LINE_LENGTH = 80
 972               	varLineBuf = RAM_END+1-1024-MAX_LINE_LENGTH-2
 973               	varCurAddr = varLineBuf-4
68K GAS  S68K_002.s 			page 21


DEFINED SYMBOLS
          S68K_002.s:12     *ABS*:0000000000000000 RAM_START
          S68K_002.s:13     *ABS*:000000000007fffc STACK_END
          S68K_002.s:14     *ABS*:000000000007ffff RAM_END
          S68K_002.s:15     *ABS*:0000000000080000 ROM_START
          S68K_002.s:16     *ABS*:0000000000080400 ROM_CODE
          S68K_002.s:18     *ABS*:000000000008ffff ROM_END
          S68K_002.s:23     *ABS*:00000000000f0000 DUART
          S68K_002.s:24     *ABS*:00000000000f0000 MRA
          S68K_002.s:25     *ABS*:00000000000f0002 SRA
          S68K_002.s:26     *ABS*:00000000000f0002 CSRA
          S68K_002.s:27     *ABS*:00000000000f0004 CRA
          S68K_002.s:28     *ABS*:00000000000f0006 RBA
          S68K_002.s:29     *ABS*:00000000000f0006 TBA
          S68K_002.s:30     *ABS*:00000000000f0008 ACR
          S68K_002.s:31     *ABS*:00000000000f000a ISR
          S68K_002.s:32     *ABS*:00000000000f000a IMR
          S68K_002.s:33     *ABS*:00000000000f0010 MRB
          S68K_002.s:34     *ABS*:00000000000f0012 SRB
          S68K_002.s:35     *ABS*:00000000000f0012 CSRB
          S68K_002.s:36     *ABS*:00000000000f0014 CRB
          S68K_002.s:37     *ABS*:00000000000f0016 RBB
          S68K_002.s:38     *ABS*:00000000000f0016 TBB
          S68K_002.s:39     *ABS*:00000000000f0018 IVR
          S68K_002.s:40     *ABS*:00000000000f001a OPC
          S68K_002.s:41     *ABS*:00000000000f001a INU
          S68K_002.s:42     *ABS*:00000000000f001c OPS
          S68K_002.s:43     *ABS*:00000000000f001e OPR
          S68K_002.s:48     *ABS*:0000000000000007 BEL
          S68K_002.s:49     *ABS*:0000000000000008 BKSP
          S68K_002.s:50     *ABS*:0000000000000009 TAB
          S68K_002.s:51     *ABS*:000000000000000a LF
          S68K_002.s:52     *ABS*:000000000000000d CR
          S68K_002.s:53     *ABS*:000000000000001b ESC
          S68K_002.s:54     *ABS*:0000000000000000 EOT
          S68K_002.s:56     *ABS*:0000000000000003 CTRLC
          S68K_002.s:57     *ABS*:0000000000000018 CTRLX
          S68K_002.s:60     .text:0000000000000400 _srecType
          S68K_002.s:61     .text:0000000000000401 _srecByCt
          S68K_002.s:62     .text:0000000000000402 _srecData
          S68K_002.s:63     .text:0000000000000403 _srecCSum
          S68K_002.s:64     .text:0000000000000404 _srecAddr
          S68K_002.s:66     *ABS*:0000000000000400 srecType
          S68K_002.s:67     *ABS*:0000000000000401 srecByCt
          S68K_002.s:68     *ABS*:0000000000000402 srecData
          S68K_002.s:69     *ABS*:0000000000000403 srecCSum
          S68K_002.s:70     *ABS*:0000000000000404 srecAddr
          S68K_002.s:181    .text:0000000000080502 FERVR2
          S68K_002.s:106    .text:000000000008045c loop1stLoc
          S68K_002.s:179    .text:0000000000080502 failBitTest
          S68K_002.s:121    .text:000000000008047c loopAdrFill
          S68K_002.s:133    .text:000000000008049a loopAdrCk
          S68K_002.s:180    .text:0000000000080502 failAdrTest
          S68K_002.s:148    .text:00000000000804b4 fillSRAM
          S68K_002.s:152    .text:00000000000804c0 fillSRAMLoop
          S68K_002.s:873    .text:0000000000080a6a initDuart
          S68K_002.s:161    .text:00000000000804cc monitorStart
68K GAS  S68K_002.s 			page 22


          S68K_002.s:921    .text:0000000000080b59 BANNER_MSG
          S68K_002.s:206    .text:0000000000080530 printString1
          S68K_002.s:915    .text:0000000000080b44 RAM_PASS_MSG
          S68K_002.s:169    .text:00000000000804dc interpLoop
          S68K_002.s:943    .text:0000000000080c02 msgPrompt
          S68K_002.s:207    .text:0000000000080530 printString
          S68K_002.s:236    .text:0000000000080562 readLine
          S68K_002.s:293    .text:00000000000805f4 lineToUpper
          S68K_002.s:310    .text:0000000000080612 parseLine
          S68K_002.s:188    .text:0000000000080508 outChar1
          S68K_002.s:189    .text:0000000000080508 outChar
          S68K_002.s:197    .text:000000000008051c outChar2
          S68K_002.s:208    .text:0000000000080530 PSloop
          S68K_002.s:214    .text:0000000000080538 PSend
          S68K_002.s:222    .text:000000000008053a inChar1
          S68K_002.s:223    .text:000000000008053a inChar
          S68K_002.s:229    .text:000000000008054e inChar2
                            *ABS*:000000000007fbae varLineBuf
          S68K_002.s:240    .text:000000000008056e RLloop
          S68K_002.s:257    .text:000000000008059a RLBS
          S68K_002.s:268    .text:00000000000805b8 RLlineClr
          S68K_002.s:282    .text:00000000000805dc RLEndLn
          S68K_002.s:250    .text:000000000008058a .char
                            *ABS*:0000000000000050 MAX_LINE_LENGTH
          S68K_002.s:272    .text:00000000000805be RLlineClrloop
          S68K_002.s:295    .text:00000000000805fa LUloop
          S68K_002.s:302    .text:000000000008060c LUnext
          S68K_002.s:313    .text:000000000008061c PLfindCommand
          S68K_002.s:359    .text:0000000000080686 .examine
          S68K_002.s:747    .text:000000000008098c .deposit
          S68K_002.s:790    .text:00000000000809f0 .run
          S68K_002.s:338    .text:0000000000080662 .help
          S68K_002.s:435    .text:0000000000080710 loadSRec
          S68K_002.s:332    .text:000000000008065c .exit
          S68K_002.s:329    .text:0000000000080654 .invalid
          S68K_002.s:924    .text:0000000000080b6c msgInvalidCommand
          S68K_002.s:929    .text:0000000000080b81 msgHelp
          S68K_002.s:342    .text:000000000008066e .invalidAddr
          S68K_002.s:937    .text:0000000000080be0 msgInvalidAddress
          S68K_002.s:346    .text:000000000008067a .invalidVal
          S68K_002.s:940    .text:0000000000080bf2 msgInvalidValue
          S68K_002.s:622    .text:0000000000080890 parseNumber
          S68K_002.s:364    .text:0000000000080692 .exloop
          S68K_002.s:378    .text:00000000000806b6 .exrange
          S68K_002.s:387    .text:00000000000806c8 .exlength
          S68K_002.s:395    .text:00000000000806da .exinter
          S68K_002.s:384    .text:00000000000806c4 .exquick
          S68K_002.s:391    .text:00000000000806d2 .exend
          S68K_002.s:675    .text:00000000000808f2 dumpRAM
          S68K_002.s:400    .text:00000000000806e8 .exinterend
          S68K_002.s:407    .text:00000000000806fc .exinterpage
          S68K_002.s:934    .text:0000000000080bd0 ldSRecMsg
          S68K_002.s:438    .text:0000000000080718 loadSRecLoop
          S68K_002.s:495    .text:00000000000807b0 setRecType
          S68K_002.s:514    .text:00000000000807ca setBytCt
          S68K_002.s:554    .text:0000000000080814 setAddr
          S68K_002.s:450    .text:0000000000080742 loopSData
68K GAS  S68K_002.s 			page 23


          S68K_002.s:455    .text:0000000000080754 sRecDataDone
          S68K_002.s:470    .text:000000000008078c getSetLdData
          S68K_002.s:482    .text:00000000000807a6 getChksum
          S68K_002.s:530    .text:00000000000807dc getHexPair
          S68K_002.s:478    .text:00000000000807a4 skipLdData
          S68K_002.s:491    .text:00000000000807ae failCSUM
          S68K_002.s:543    .text:00000000000807fc toNibble
          S68K_002.s:548    .text:000000000008080a doHexLetter
          S68K_002.s:595    .text:0000000000080872 adrLen16
          S68K_002.s:612    .text:000000000008088a past16
          S68K_002.s:636    .text:00000000000808b4 PNinvalid
          S68K_002.s:642    .text:00000000000808be PNfirstdigit1
          S68K_002.s:639    .text:00000000000808b8 PNfirstdigit2
          S68K_002.s:644    .text:00000000000808c2 PNloop
          S68K_002.s:655    .text:00000000000808dc PNend
          S68K_002.s:662    .text:00000000000808e8 PNdigit1
          S68K_002.s:659    .text:00000000000808e2 PNdigit2
          S68K_002.s:664    .text:00000000000808ec PNdigit3
          S68K_002.s:679    .text:00000000000808fa .line
          S68K_002.s:814    .text:0000000000080a0c printHexAddr
          S68K_002.s:946    .text:0000000000080c05 msgColonSpace
          S68K_002.s:686    .text:000000000008090c .hexbyte
          S68K_002.s:698    .text:0000000000080928 .endbytesShort
          S68K_002.s:713    .text:000000000008094e .endbytes
          S68K_002.s:847    .text:0000000000080a34 printHexByte
          S68K_002.s:701    .text:000000000008092e .endbytesShortLoop
          S68K_002.s:715    .text:0000000000080950 .endbytesLoop
          S68K_002.s:730    .text:0000000000080976 .endline
          S68K_002.s:726    .text:000000000008096c .unprintable
          S68K_002.s:949    .text:0000000000080c08 msgNewline
          S68K_002.s:736    .text:0000000000080986 .end
          S68K_002.s:772    .text:00000000000809c4 DepCont
          S68K_002.s:756    .text:00000000000809a0 DepLoop
          S68K_002.s:777    .text:00000000000809ce DepMLine
          S68K_002.s:784    .text:00000000000809e6 DepEnd
                            *ABS*:000000000007fbaa varCurAddr
          S68K_002.s:918    .text:0000000000080b56 msgDepositPrompt
          S68K_002.s:805    .text:0000000000080a02 printHexWord
          S68K_002.s:833    .text:0000000000080a24 printHex_wordentry
          S68K_002.s:829    .text:0000000000080a1e printHex_addrentry
          S68K_002.s:822    .text:0000000000080a14 printHexLong
          S68K_002.s:857    .text:0000000000080a4c PHBsecond
          S68K_002.s:864    .text:0000000000080a60 PHBend
          S68K_002.s:899    .text:0000000000080af4 delay1Sec
          S68K_002.s:901    .text:0000000000080afa delay1Loop
          S68K_002.s:906    .text:0000000000080b02 READINLINE
          S68K_002.s:909    .text:0000000000080b14 L_TO_UPPER_MSG
          S68K_002.s:912    .text:0000000000080b31 WRITEOUTLINE
          S68K_002.s:927    .text:0000000000080b7e CRLF_MSG
          S68K_002.s:951    .text:0000000000080c0b debug_Srec_Typ_Msg
          S68K_002.s:954    .text:0000000000080c1a debug_Srec_BytCt_Msg
          S68K_002.s:957    .text:0000000000080c31 debug_Srec_CSum_Msg
          S68K_002.s:960    .text:0000000000080c44 debug_S2rec_Addr_Msg
          S68K_002.s:963    .text:0000000000080c59 debug_SXrec_Addr_Msg
          S68K_002.s:966    .text:0000000000080c75 debug_Srec_LDData_Msg

NO UNDEFINED SYMBOLS
68K GAS  S68K_002.s 			page 24


